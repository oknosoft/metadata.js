/*
Product Name: dhtmlxSuite 
Version: 4.1.3 
Edition: Professional 
License: content of this file is covered by DHTMLX Commercial or Enterprise license. Usage without proper license is prohibited. To obtain it contact sales@dhtmlx.com
Copyright UAB Dinamenta http://www.dhtmlx.com
*/

/* dhtmlx.com */

if (typeof(window.dhx4) == "undefined") {
	
	window.dhx4 = {
		
		version: "4.1.3",
		
		skin: null, // allow to be set by user
		
		skinDetect: function(comp) {
			return {10:"dhx_skyblue",20:"dhx_web",30:"dhx_terrace"}[this.readFromCss(comp+"_skin_detect")]||null;
		},
		
		// read value from css
		readFromCss: function(className, property) {
			var t = document.createElement("DIV");
			t.className = className;
			if (document.body.firstChild != null) document.body.insertBefore(t, document.body.firstChild); else document.body.appendChild(t);
			var w = t[property||"offsetWidth"];
			t.parentNode.removeChild(t);
			t = null;
			return w;
		},
		
		// id manager
		lastId: 1,
		newId: function() {
			return this.lastId++;
		},
		
		// z-index manager
		zim: {
			data: {},
			step: 5,
			first: function() {
				return 100;
			},
			last: function() {
				var t = this.first();
				for (var a in this.data) t = Math.max(t, this.data[a]);
				return t;
			},
			reserve: function(id) {
				this.data[id] = this.last()+this.step;
				return this.data[id];
			},
			clear: function(id) {
				if (this.data[id] != null) {
					this.data[id] = null;
					delete this.data[id];
				}
			}
		},
		
		// string to boolean
		s2b: function(r) {
			if (typeof(r) == "string") r = r.toLowerCase();
			return (r == true || r == 1 || r == "true" || r == "1" || r == "yes" || r == "y");
		},
		
		// string to json
		s2j: function(s) {
			var obj = null;
			dhx4.temp = null;
			try { eval("dhx4.temp="+s); } catch(e) { dhx4.temp = null; }
			obj = dhx4.temp;
			dhx4.temp = null;
			return obj;
		},
		
		// absolute top/left position on screen
		absLeft: function(obj) {
			if (typeof(obj) == "string") obj = document.getElementById(obj);
			return this.getOffset(obj).left;
		},
		absTop: function(obj) {
			if (typeof(obj) == "string") obj = document.getElementById(obj);
			return this.getOffset(obj).top;
		},
		_aOfs: function(elem) {
			var top = 0, left = 0;
			while (elem) {
				top = top + parseInt(elem.offsetTop);
				left = left + parseInt(elem.offsetLeft);
				elem = elem.offsetParent;
			}
			return {top: top, left: left};
		},
		_aOfsRect: function(elem) {
			var box = elem.getBoundingClientRect();
			var body = document.body;
			var docElem = document.documentElement;
			var scrollTop = window.pageYOffset || docElem.scrollTop || body.scrollTop;
			var scrollLeft = window.pageXOffset || docElem.scrollLeft || body.scrollLeft;
			var clientTop = docElem.clientTop || body.clientTop || 0;
			var clientLeft = docElem.clientLeft || body.clientLeft || 0;
			var top  = box.top +  scrollTop - clientTop;
			var left = box.left + scrollLeft - clientLeft;
			return { top: Math.round(top), left: Math.round(left) };
		},
		getOffset: function(elem) {
			if (elem.getBoundingClientRect) {
				return this._aOfsRect(elem);
			} else {
				return this._aOfs(elem);
			}
		},
		
		// copy obj
		_isObj: function(k) {
			return (k != null && typeof(k) == "object" && typeof(k.length) == "undefined");
		},
		_copyObj: function(r) {
			if (this._isObj(r)) {
				var t = {};
				for (var a in r) {
					if (typeof(r[a]) == "object" && r[a] != null) t[a] = this._copyObj(r[a]); else t[a] = r[a];
				}
			} else {
				var t = [];
				for (var a=0; a<r.length; a++) {
					if (typeof(r[a]) == "object" && r[a] != null) t[a] = this._copyObj(r[a]); else t[a] = r[a];
				}
			}
			return t;
		},
		
		// screen dim
		screenDim: function() {
			var isIE = (navigator.userAgent.indexOf("MSIE") >= 0);
			var dim = {};
			dim.left = document.body.scrollLeft;
			dim.right = dim.left+(window.innerWidth||document.body.clientWidth);
			dim.top = Math.max((isIE?document.documentElement:document.getElementsByTagName("html")[0]).scrollTop, document.body.scrollTop);
			dim.bottom = dim.top+(isIE?Math.max(document.documentElement.clientHeight||0,document.documentElement.offsetHeight||0):window.innerHeight);
			return dim;
		},
		
		// input/textarea range selection
		selectTextRange: function(inp, start, end) {
			
			inp = (typeof(inp)=="string"?document.getElementById(inp):inp);
			
			var len = inp.value.length;
			start = Math.max(Math.min(start, len), 0);
			end = Math.min(end, len);
			
			if (inp.setSelectionRange) {
				try {inp.setSelectionRange(start, end);} catch(e){}; // combo in grid under IE requires try/catch
			} else if (inp.createTextRange) {
				var range = inp.createTextRange();
				range.moveStart("character", start);
				range.moveEnd("character", end-len);
				try {range.select();} catch(e){};
			}
		},
		// transition
		transData: null,
		transDetect: function() {
			
			if (this.transData == null) {
				
				this.transData = {transProp: false, transEv: null};
				
				// transition, MozTransition, WebkitTransition, msTransition, OTransition
				var k = {
					"MozTransition": "transitionend",
					"WebkitTransition": "webkitTransitionEnd",
					"OTransition": "oTransitionEnd",
					"msTransition": "transitionend",
					"transition": "transitionend"
				};
				
				for (var a in k) {
					if (this.transData.transProp == false && document.documentElement.style[a] != null) {
						this.transData.transProp = a;
						this.transData.transEv = k[a];
					}
				}
				k = null;
			}
			
			return this.transData;
			
		},
		
		// xml parser
		_xmlNodeValue: function(node) {
			var value = "";
			for (var q=0; q<node.childNodes.length; q++) {
				value += (node.childNodes[q].nodeValue!=null?node.childNodes[q].nodeValue.toString().replace(/^[\n\r\s]{0,}/,"").replace(/[\n\r\s]{0,}$/,""):"");
			}
			return value;
		}
		
	};
	
	// browser
	window.dhx4.isIE = (navigator.userAgent.indexOf("MSIE") >= 0 || navigator.userAgent.indexOf("Trident") >= 0);
	window.dhx4.isIE6 = (window.XMLHttpRequest == null && navigator.userAgent.indexOf("MSIE") >= 0);
	window.dhx4.isIE7 = (navigator.userAgent.indexOf("MSIE 7.0") >= 0 && navigator.userAgent.indexOf("Trident") < 0);
	window.dhx4.isIE8 = (navigator.userAgent.indexOf("MSIE 8.0") >= 0 && navigator.userAgent.indexOf("Trident") >= 0);
	window.dhx4.isOpera = (navigator.userAgent.indexOf("Opera") >= 0);
	window.dhx4.isChrome = (navigator.userAgent.indexOf("Chrome") >= 0);
	window.dhx4.isKHTML = (navigator.userAgent.indexOf("Safari") >= 0 || navigator.userAgent.indexOf("Konqueror") >= 0);
	window.dhx4.isFF = (navigator.userAgent.indexOf("Firefox") >= 0);
	window.dhx4.isIPad = (navigator.userAgent.search(/iPad/gi) >= 0);
};


if (typeof(window.dhx4.template) == "undefined") {
	
	// trim
	window.dhx4.trim = function(t) {
		return String(t).replace(/^\s{1,}/,"").replace(/\s{1,}$/,"");
	};
	
	// template parsing
	window.dhx4.template = function(tpl, data, trim) {
		
		// tpl - template text, #value|func:param0:param1:paramX#
		// data - object with key-value
		// trim - true/false, trim values
		return tpl.replace(/#([a-z0-9_-]{1,})(\|([^#]*))?#/gi, function(){
			
			var key = arguments[1];
			
			var t = window.dhx4.trim(arguments[3]);
			var func = null;
			var args = [data[key]];
			
			if (t.length > 0) {
				
				t = t.split(":");
				var k = [];
				
				// check escaped colon
				for (var q=0; q<t.length; q++) {
					if (q > 0 && k[k.length-1].match(/\\$/) != null) {
						k[k.length-1] = k[k.length-1].replace(/\\$/,"")+":"+t[q];
					} else {
						k.push(t[q]);
					}
				}
				
				func = k[0];
				for (var q=1; q<k.length; q++) args.push(k[q]);
				
			}
			
			// via inner function
			if (typeof(func) == "string" && typeof(window.dhx4.template[func]) == "function") {
				return window.dhx4.template[func].apply(window.dhx4.template, args);
			}
			
			// value only
			if (key.length > 0 && typeof(data[key]) != "undefined") {
				if (trim == true) return window.dhx4.trim(data[key]);
				return String(data[key]);
			}
			
			// key not found
			return "";
			
		});
		
	};
	
	window.dhx4.template.date = function(value, format) {
		// Date obj + format	=> convert to string
		// timestamp + format	=> convert to string
		// string		=> no convert
		// any other value	=> empty string
		if (value != null) {
			if (value instanceof Date) {
				return window.dhx4.date2str(value, format);
			} else {
				value = value.toString();
				if (value.match(/^\d*$/) != null) return window.dhx4.date2str(new Date(parseInt(value)), format);
				return value;
			}
		}
		return "";
	};
	
	window.dhx4.template.maxlength = function(value, limit) {
		return String(value).substr(0, limit);
	};
	
	window.dhx4.template.number_format = function(value, format, group_sep, dec_sep) {
		var fmt = window.dhx4.template._parseFmt(format, group_sep, dec_sep);
		if (fmt == false) return value;
		return window.dhx4.template._getFmtValue(value, fmt);
	};
	
	window.dhx4.template.lowercase = function(value) {
		if (typeof(value) == "undefined" || value == null) value = "";
		return String(value).toLowerCase();
	};
	window.dhx4.template.uppercase = function(value) {
		if (typeof(value) == "undefined" || value == null) value = "";
		return String(value).toUpperCase();
	};
	
	// number format helpers
	window.dhx4.template._parseFmt = function(format, group_sep, dec_sep) {
		
		var t = format.match(/^([^\.\,0-9]*)([0\.\,]*)([^\.\,0-9]*)/);
		if (t == null || t.length != 4) return false; // invalid format
		
		var fmt = {
			// int group
			i_len: false,
			i_sep: (typeof(group_sep)=="string"?group_sep:","),
			// decimal
			d_len: false,
			d_sep: (typeof(dec_sep)=="string"?dec_sep:"."),
			// chars before and after
			s_bef: (typeof(t[1])=="string"?t[1]:""),
			s_aft: (typeof(t[3])=="string"?t[3]:"")
		};
		
		var f = t[2].split(".");
		if (f[1] != null) fmt.d_len = f[1].length;
		
		var r = f[0].split(",");
		if (r.length > 1) fmt.i_len = r[r.length-1].length;
		
		return fmt;
		
	};
	
	window.dhx4.template._getFmtValue = function(value, fmt) {
		
		var r = String(value).match(/^(-)?([0-9]{1,})(\.([0-9]{1,}))?$/); // r = [complete value, minus sign, integer, full decimal, decimal]
		
		if (r != null && r.length == 5) {
			var v0 = "";
			// minus sign
			if (r[1] != null) v0 += r[1];
			// chars before
			v0 += fmt.s_bef;
			// int part
			if (fmt.i_len !== false) {
				var i = 0; var v1 = "";
				for (var q=r[2].length-1; q>=0; q--) {
					v1 = ""+r[2].charAt(q)+v1;
					if (++i == fmt.i_len && q > 0) { v1=fmt.i_sep+v1; i=0; }
				}
				v0 += v1;
			} else {
				v0 += r[2];
			}
			// dec part
			if (fmt.d_len !== false) {
				if (r[4] == null) r[4] = "";
				while (r[4].length < fmt.d_len) r[4] += "0";
				eval("dhx4.temp = new RegExp(/\\d{"+fmt.d_len+"}/);");
				var t1 = (r[4]).match(dhx4.temp);
				if (t1 != null) v0 += fmt.d_sep+t1;
				dhx4.temp = t1 = null;
			}
			// chars after
			v0 += fmt.s_aft;
			
			return v0;
		}
		
		return value;
	};
	
};

if (typeof(window.dhx4.dateLang) == "undefined") {
	
	window.dhx4.dateLang = "en";
	window.dhx4.dateStrings = {
		en: {
			monthFullName:	["January","February","March","April","May","June","July","August","September","October","November","December"],
			monthShortName:	["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"],
			dayFullName:	["Sunday","Monday","Tuesday","Wednesday","Thursday","Friday","Saturday"],
			dayShortName:	["Su","Mo","Tu","We","Th","Fr","Sa"]
		}
	};
	window.dhx4.dateFormat = {
		en: "%Y-%m-%d"
	};
	
	window.dhx4.date2str = function(val, format, strings) {
		
		if (format == null || typeof(format) == "undefnied") format = window.dhx4.dateFormat[window.dhx4.dateLang];
		if (strings == null || typeof(strings) == "undefnied") strings = window.dhx4.dateStrings[window.dhx4.dateLang];
		
		if (val instanceof Date) {
			var z = function(t) {
				return (String(t).length==1?"0"+String(t):t);
			}
			var k = function(t) {
				switch(t) {
					case "%d": return z(val.getDate());
					case "%j": return val.getDate();
					case "%D": return strings.dayShortName[val.getDay()];
					case "%l": return strings.dayFullName[val.getDay()];
					case "%m": return z(val.getMonth()+1);
					case "%n": return val.getMonth()+1;
					case "%M": return strings.monthShortName[val.getMonth()];
					case "%F": return strings.monthFullName[val.getMonth()];
					case "%y": return z(val.getYear()%100);
					case "%Y": return val.getFullYear();
					case "%g": return (val.getHours()+11)%12+1;
					case "%h": return z((val.getHours()+11)%12+1);
					case "%G": return val.getHours();
					case "%H": return z(val.getHours());
					case "%i": return z(val.getMinutes());
					case "%s": return z(val.getSeconds());
					case "%a": return (val.getHours()>11?"pm":"am");
					case "%A": return (val.getHours()>11?"PM":"AM");
					case "%%": return "%";
					case "%u": return val.getMilliseconds();
					case "%P":
						if (window.dhx4.temp_calendar != null && window.dhx4.temp_calendar.tz != null) return window.dhx4.temp_calendar.tz;
						var ofs = val.getTimezoneOffset();
						var h = Math.abs(Math.floor(ofs/60));
						var m = Math.abs(ofs)-h*60;
						return (ofs>0?"-":"+")+z(h)+":"+z(m);
					default: return t;
				}
			}
			var t = String(format||window.dhx4.dateFormat).replace(/%[a-zA-Z]/g, k);
		}
		
		return (t||String(val));
		
	};
	
	window.dhx4.str2date = function(val, format, strings) {
		
		if (format == null || typeof(format) == "undefnied") format = window.dhx4.dateFormat[window.dhx4.dateLang];
		if (strings == null || typeof(strings) == "undefnied") strings = window.dhx4.dateStrings[window.dhx4.dateLang];
		
		// escape custom chars
		format = format.replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\\:|]/g, "\\$&");
		
		var v = [];
		var f = [];
		
		// escape required chars
		format = format.replace(/%[a-z]/gi, function(t){
			switch (t) {
				case "%d": case "%m": case "%y": case "%h": case "%H": case "%i": case "%s": f.push(t); return "(\\d{2})"; // 2 digits
				case "%D": case "%l": case "%M": case "%F": f.push(t); return "([a-zéûä\u0430-\u044F\u0451]{1,})"; // chars
				case "%j": case "%n": case "%g": case "%G": f.push(t); return "(\\d{1,2})"; // 1-2 digits
				case "%Y": f.push(t); return "(\\d{4})"; // 4 digits
				case "%a": f.push(t); return "([am|pm])"; // am/pm
				case "%A": f.push(t); return "([AM|PM])"; // AM/PM
				case "%u": f.push(t); return "(\\d{1,6})"; // 1-6 digits, micro/milliseconds
				case "%P": f.push(t); return "([+-]\\d{1,2}:\\d{1,2})"; // zone offset
			}
			return t;
		});
		
		var re = new RegExp(format, "i");
		var e = val.match(re);
		
		if (e == null || e.length-1 != f.length) return "Invalid Date";
		
		// sorting
		/*
		Year	y,Y	1
		Month	n,m,M,F	2
		Day	d,j	3
		AM/PM	a,A	4
		Hours	H,G,h,g	5
		Minutes	i	6
		Seconds	s	7
		MSec	u	7
		Zone 	P	7
		*/
		
		for (var q=1; q<e.length; q++) v.push(e[q]);
		
		var p = {"%y":1,"%Y":1,"%n":2,"%m":2,"%M":2,"%F":2,"%d":3,"%j":3,"%a":4,"%A":4,"%H":5,"%G":5,"%h":5,"%g":5,"%i":6,"%s":7,"%u":7,"%P":7};
		var v2 = {};
		var f2 = {};
		for (var q=0; q<f.length; q++) {
			if (typeof(p[f[q]]) != "undefined") {
				var ind = p[f[q]];
				if (!v2[ind]){v2[ind]=[];f2[ind]=[];}
				v2[ind].push(v[q]);
				f2[ind].push(f[q]);
			}
		}
		v = [];
		f = [];
		for (var q=1; q<=7; q++) {
			if (v2[q] != null) {
				for (var w=0; w<v2[q].length; w++) {
					v.push(v2[q][w]);
					f.push(f2[q][w]);
				}
			}
		}
		
		// parsing date
		var r = new Date();
		r.setDate(1); // fix for 31th
		r.setHours(0);
		r.setMinutes(0);
		r.setSeconds(0);
		r.setMilliseconds(0);
		
		// get index by value
		var getInd = function(val, ar) {
			for (var q=0; q<ar.length; q++) if (ar[q].toLowerCase() == val) return q;
			return -1;
		}
		
		for (var q=0; q<v.length; q++) {
			switch (f[q]) {
				case "%d": case "%j": case "%n": case "%m": case "%Y": case "%H": case "%G": case "%i": case "%s": case "%u":
					if (!isNaN(v[q])) r[{"%d":"setDate","%j":"setDate","%n":"setMonth","%m":"setMonth","%Y":"setFullYear","%H":"setHours","%G":"setHours","%i":"setMinutes","%s":"setSeconds","%u":"setMilliseconds"}[f[q]]](Number(v[q])+(f[q]=="%m"||f[q]=="%n"?-1:0));
					break;
				//
				case "%M": case "%F":
					var k = getInd(v[q].toLowerCase(),strings[{"%M":"monthShortName","%F":"monthFullName"}[f[q]]]);
					if (k >= 0) r.setMonth(k);
					break;
				//
				case "%y":
					if (!isNaN(v[q])) {
						var v0 = Number(v[q]);
						r.setFullYear(v0+(v0>50?1900:2000));
					}
					break;
				//
				case "%g": case "%h":
					if (!isNaN(v[q])) {
						var v0 = Number(v[q]);
						if (v0 <= 12 && v0 >= 0) r.setHours(v0+(getInd("pm",v)>=0?(v0==12?0:12):(v0==12?-12:0))); // 12:00 AM -> midnight, 12:00 PM -> noon
					}
					break;
				//
				case "%P":
					if (window.dhx4.temp_calendar != null) {
						window.dhx4.temp_calendar.tz = v[q];
					}
					break;
			}
		}
		return r;
	};
	
};

if (typeof(window.dhx4.ajax) == "undefined") {
	
	window.dhx4.ajax = {
		
		// if false - dhxr param will added to prevent caching on client side (default),
		// if true - do not add extra params
		cache: false,
		
		// default method for load/loadStruct, post/get allowed
		// get - since 4.1.1, this should fix 412 error for macos safari
		method: "get",
		
		parse: function(data) {
			if (typeof data !== "string") return data;
			
			data = data.replace(/^[\s]+/,"");
			if (window.DOMParser && !dhx4.isIE) { // ff,ie9
				var obj = (new window.DOMParser()).parseFromString(data, "text/xml");
			} else if (window.ActiveXObject !== window.undefined) {
				var obj = new window.ActiveXObject("Microsoft.XMLDOM");
				obj.async = "false";
				obj.loadXML(data);
			}
			return obj;
		},
		xmltop: function(tagname, xhr, obj) {
			if (typeof xhr.status == "undefined" || xhr.status < 400) {
				xml = (!xhr.responseXML) ? dhx4.ajax.parse(xhr.responseText || xhr) : (xhr.responseXML || xhr);
				if (xml && xml.documentElement !== null && !xml.getElementsByTagName("parsererror").length) {
					return xml.getElementsByTagName(tagname)[0];
				}
			}
			if (obj !== -1) dhx4.callEvent("onLoadXMLError",["Incorrect XML", arguments[1], obj]);
			return document.createElement("DIV");
		},
		xpath: function(xpathExp, docObj) {
			if (!docObj.nodeName) docObj = docObj.responseXML || docObj;
			if (dhx4.isIE) {
				return docObj.selectNodes(xpathExp)||[];
			} else {
				var rows = [];
				var first;
				var col = (docObj.ownerDocument||docObj).evaluate(xpathExp, docObj, null, XPathResult.ANY_TYPE, null);
				while (first = col.iterateNext()) rows.push(first);
				return rows;
			}
		},
		query: function(config) {
			dhx4.ajax._call(
				(config.method || "GET"),
				config.url,
				config.data || "",
				(config.async || true),
				config.callback,
				null,
				config.headers
			);
		},
		get: function(url, onLoad) {
			this._call("GET", url, null, true, onLoad);
		},
		getSync: function(url) {
			return this._call("GET", url, null, false);
		},
		put: function(url, postData, onLoad) {
			this._call("PUT", url, postData, true, onLoad);
		},
		del: function(url, postData, onLoad) {
			this._call("DELETE", url, postData, true, onLoad);
		},
		post: function(url, postData, onLoad) {
			if (arguments.length == 1) {
				postData = "";
			} else if (arguments.length == 2 && (typeof(postData) == "function" || typeof(window[postData]) == "function")) {
				onLoad = postData;
				postData = "";
			} else {
				postData = String(postData);
			}
			this._call("POST", url, postData, true, onLoad);
		},
		postSync: function(url, postData) {
			postData = (postData == null ? "" : String(postData));
			return this._call("POST", url, postData, false);
		},
		getLong: function(url, onLoad) {
			this._call("GET", url, null, true, onLoad, {url:url});
		},
		postLong: function(url, postData, onLoad) {
			if (arguments.length == 2 && (typeof(postData) == "function" || typeof(window[postData]))) {
				onLoad = postData;
				postData = "";
			}
			this._call("POST", url, postData, true, onLoad, {url:url, postData:postData});
		},
		_call: function(method, url, postData, async, onLoad, longParams, headers) {
			
			var t = (window.XMLHttpRequest && !dhx4.isIE ? new XMLHttpRequest() : new ActiveXObject("Microsoft.XMLHTTP"));
			var isQt = (navigator.userAgent.match(/AppleWebKit/) != null && navigator.userAgent.match(/Qt/) != null && navigator.userAgent.match(/Safari/) != null);
			
			if (async == true) {
				t.onreadystatechange = function() {
					if ((t.readyState == 4) || (isQt == true && t.readyState == 3)) { // what for long response and status 404?
						if (t.status != 200 || t.responseText == "")
							if (!dhx4.callEvent("onAjaxError", [t])) return;

						window.setTimeout(function(){
							if (typeof(onLoad) == "function") {
								onLoad.apply(window, [{xmlDoc:t}]); // dhtmlx-compat, response.xmlDoc.responseXML/responseText
							}
							if (longParams != null) {
								if (typeof(longParams.postData) != "undefined") {
									dhx4.ajax.postLong(longParams.url, longParams.postData, onLoad);
								} else {
									dhx4.ajax.getLong(longParams.url, onLoad);
								}
							}
							onLoad = null;
							t = null;
						},1);
					}
				}
			}
			
			if (method == "GET" && this.cache != true) {
				url += (url.indexOf("?")>=0?"&":"?")+"dhxr"+new Date().getTime()+"=1";
			}
			
			t.open(method, url, async);
			
			if (headers){
				for (var key in headers)
					t.setRequestHeader(key, headers[key]);
			} else if (method == "POST" || method == "PUT" || method == "DELETE") {
				t.setRequestHeader("Content-Type", "application/x-www-form-urlencoded");
			} else if (method == "GET") {
				postData = null;
			}
			
			t.setRequestHeader("X-Requested-With", "XMLHttpRequest");
			
			t.send(postData);
			
			if (!async) return {xmlDoc:t}; // dhtmlx-compat, response.xmlDoc.responseXML/responseText
			
		}
	};
	
};

if (typeof(window.dhx4._enableDataLoading) == "undefined") {

	window.dhx4._enableDataLoading = function(obj, initObj, xmlToJson, xmlRootTag, mode) {
		
		if (mode == "clear") {
			
			// clear attached functionality
			
			for (var a in obj._dhxdataload) {
				obj._dhxdataload[a] = null;
				delete obj._dhxdataload[a];
			};
			
			obj._loadData = null;
			obj._dhxdataload = null;
			obj.load = null;
			obj.loadStruct = null;
			
			obj = null;
			
			return;
			
		}
		
		obj._dhxdataload = { // move to obj.conf?
			initObj: initObj,
			xmlToJson: xmlToJson,
			xmlRootTag: xmlRootTag,
			onBeforeXLS: null
		};
		
		obj._loadData = function(data, loadParams, onLoad) {
			
			if (arguments.length == 2) {
				onLoad = loadParams;
				loadParams = null;
			}
			
			var obj = null;
			
			// deprecated from 4.0, compatability with version (url, type[json|xml], onLoad)
			if (arguments.length == 3) onLoad = arguments[2];
			
			if (typeof(data) == "string") {
				
				var k = data.replace(/^\s{1,}/,"").replace(/\s{1,}$/,"");
				
				var tag = new RegExp("^<"+this._dhxdataload.xmlRootTag);
				
				// xml
				if (tag.test(k.replace(/^<\?xml[^\?]*\?>\s*/, ""))) { // remove leading <?xml ...?> if any, \n can be also presenе
					obj = dhx4.ajax.parse(data);
					if (obj != null) obj = this[this._dhxdataload.xmlToJson].apply(this, [obj]); // xml to json
				}
				
				if (obj == null && (k.match(/^\{.*\}$/) != null || k.match(/^\[.*\]$/) != null)) {
					obj = dhx4.s2j(k);
				}
				
				if (obj == null) {
					
					this.callEvent("onXLS",[]);
					
					var params = [];
					
					// allow to modify url and add params
					if (typeof(this._dhxdataload.onBeforeXLS) == "function") {
						var k = this._dhxdataload.onBeforeXLS.apply(this,[data]);
						if (k != null && typeof(k) == "object") {
							if (k.url != null) data = k.url;
							if (k.params != null) { for (var a in k.params) params.push(a+"="+encodeURIComponent(k.params[a])); }
						}
					}
					
					var t = this;
					var callBack = function(r) {
						
						var obj = null;
						
						if ((r.xmlDoc.getResponseHeader("Content-Type")||"").search(/xml/gi) >= 0 || (r.xmlDoc.responseText.replace(/^\s{1,}/,"")).match(/^</) != null) {
							obj = t[t._dhxdataload.xmlToJson].apply(t,[r.xmlDoc.responseXML]);
						} else {
							obj = dhx4.s2j(r.xmlDoc.responseText);
						}
						
						// init
						if (obj != null) t[t._dhxdataload.initObj].apply(t,[obj,data]); // data => url
						
						t.callEvent("onXLE",[]);
						
						if (onLoad != null) {
							if (typeof(onLoad) == "function") {
								onLoad.apply(t,[]);
							} else if (typeof(window[onLoad]) == "function") {
								window[onLoad].apply(t,[]);
							}
						}
						
						callBack = onLoad = null;
						obj = r = t = null;
						
					};
					
					params = params.join("&")+(typeof(loadParams)=="string"?"&"+loadParams:"");
					
					if (dhx4.ajax.method == "post") {
						dhx4.ajax.post(data, params, callBack);
					} else if (dhx4.ajax.method == "get") {
						dhx4.ajax.get(data+(data.indexOf("?")>0?"&":"?")+params, callBack);
					}
					
					return;
				}
				
			} else {
				if (typeof(data.documentElement) == "object" || (typeof(data.tagName) != "undefined" && typeof(data.getElementsByTagName) != "undefined" && data.getElementsByTagName(this._dhxdataload.xmlRootTag).length > 0)) { // xml
					obj = this[this._dhxdataload.xmlToJson].apply(this, [data]);
				} else { // json
					obj = window.dhx4._copyObj(data);
				}
				
			}
			
			// init
			if (obj != null) this[this._dhxdataload.initObj].apply(this,[obj]);
			
			if (onLoad != null) {
				if (typeof(onLoad) == "function") {
					onLoad.apply(this, []);
				} else if (typeof(window[onLoad]) == "function") {
					window[onLoad].apply(this, []);
				}
				onLoad = null;
			}
			
		};
		
		// loadStruct for hdr/conf
		// load for data
		if (mode != null) {
			var k = {struct: "loadStruct", data: "load"};
			for (var a in mode) {
				if (mode[a] == true) obj[k[a]] = function() {return this._loadData.apply(this, arguments);}
			}
		}
		
		obj = null;
		
	};
};

if (typeof(window.dhx4._eventable) == "undefined") {
	
	window.dhx4._eventable = function(obj, mode) {
		
		if (mode == "clear") {
			
			obj.detachAllEvents();
			
			obj.dhxevs = null;
			
			obj.attachEvent = null;
			obj.detachEvent = null;
			obj.checkEvent = null;
			obj.callEvent = null;
			obj.detachAllEvents = null;
			
			obj = null;
			
			return;
			
		}
		
		obj.dhxevs = { data: {} };
		
		obj.attachEvent = function(name, func) {
			name = String(name).toLowerCase();
			if (!this.dhxevs.data[name]) this.dhxevs.data[name] = {};
			var eventId = window.dhx4.newId();
			this.dhxevs.data[name][eventId] = func;
			return eventId;
		}
		
		obj.detachEvent = function(eventId) {
			for (var a in this.dhxevs.data) {
				var k = 0;
				for (var b in this.dhxevs.data[a]) {
					if (b == eventId) {
						this.dhxevs.data[a][b] = null;
						delete this.dhxevs.data[a][b];
					} else {
						k++;
					}
				}
				if (k == 0) {
					this.dhxevs.data[a] = null;
					delete this.dhxevs.data[a];
				}
			}
		}
		
		obj.checkEvent = function(name) {
			name = String(name).toLowerCase();
			return (this.dhxevs.data[name] != null);
		}
		
		obj.callEvent = function(name, params) {
			name = String(name).toLowerCase();
			if (this.dhxevs.data[name] == null) return true;
			var r = true;
			for (var a in this.dhxevs.data[name]) {
				r = this.dhxevs.data[name][a].apply(this, params) && r;
			}
			return r;
		}
		
		obj.detachAllEvents = function() {
			for (var a in this.dhxevs.data) {
				for (var b in this.dhxevs.data[a]) {
					this.dhxevs.data[a][b] = null;
					delete this.dhxevs.data[a][b];
				}
				this.dhxevs.data[a] = null;
				delete this.dhxevs.data[a];
			}
		}
		
		obj = null;
	};
	
	dhx4._eventable(dhx4);
	
};

if (typeof(window.dhtmlx) == "undefined") {
	window.dhtmlx={
		extend:function(a, b){
			for (var key in b)
				if (!a[key])
					a[key]=b[key];
			return a;
		},
		extend_api:function(name,map,ext){
			var t = window[name];
			if (!t) return; //component not defined
			window[name]=function(obj){
				if (obj && typeof obj == "object" && !obj.tagName){
					var that = t.apply(this,(map._init?map._init(obj):arguments));
					//global settings
					for (var a in dhtmlx)
						if (map[a]) this[map[a]](dhtmlx[a]);			
					//local settings
					for (var a in obj){
						if (map[a]) this[map[a]](obj[a]);
						else if (a.indexOf("on")===0){
							this.attachEvent(a,obj[a]);
						}
					}
				} else
					var that = t.apply(this,arguments);
				if (map._patch) map._patch(this);
				return that||this;
			};
			window[name].prototype=t.prototype;
			if (ext)
				dhtmlx.extend(window[name].prototype,ext);
		},
		url:function(str){
			if (str.indexOf("?") != -1)
				return "&";
			else
				return "?";
		}
	};
};

/**  
*     @desc: find out what symbol to use as url param delimiters in further params
*     @type: private
*     @param: str - current url string
*     @topic: 0  
*/


function dhtmlDragAndDropObject(){
	if (window.dhtmlDragAndDrop)
		return window.dhtmlDragAndDrop;

	this.lastLanding=0;
	this.dragNode=0;
	this.dragStartNode=0;
	this.dragStartObject=0;
	this.tempDOMU=null;
	this.tempDOMM=null;
	this.waitDrag=0;
	window.dhtmlDragAndDrop=this;

	return this;
};

dhtmlDragAndDropObject.prototype.removeDraggableItem=function(htmlNode){
	htmlNode.onmousedown=null;
	htmlNode.dragStarter=null;
	htmlNode.dragLanding=null;
}
dhtmlDragAndDropObject.prototype.addDraggableItem=function(htmlNode, dhtmlObject){
	htmlNode.onmousedown=this.preCreateDragCopy;
	htmlNode.dragStarter=dhtmlObject;
	this.addDragLanding(htmlNode, dhtmlObject);
}
dhtmlDragAndDropObject.prototype.addDragLanding=function(htmlNode, dhtmlObject){
	htmlNode.dragLanding=dhtmlObject;
}
dhtmlDragAndDropObject.prototype.preCreateDragCopy=function(e){
	if ((e||window.event) && (e||event).button == 2)
		return;

	if (window.dhtmlDragAndDrop.waitDrag){
		window.dhtmlDragAndDrop.waitDrag=0;
		document.body.onmouseup=window.dhtmlDragAndDrop.tempDOMU;
		document.body.onmousemove=window.dhtmlDragAndDrop.tempDOMM;
		return false;
	}
	
	if (window.dhtmlDragAndDrop.dragNode)
		window.dhtmlDragAndDrop.stopDrag(e);	

	window.dhtmlDragAndDrop.waitDrag=1;
	window.dhtmlDragAndDrop.tempDOMU=document.body.onmouseup;
	window.dhtmlDragAndDrop.tempDOMM=document.body.onmousemove;
	window.dhtmlDragAndDrop.dragStartNode=this;
	window.dhtmlDragAndDrop.dragStartObject=this.dragStarter;
	document.body.onmouseup=window.dhtmlDragAndDrop.preCreateDragCopy;
	document.body.onmousemove=window.dhtmlDragAndDrop.callDrag;
	window.dhtmlDragAndDrop.downtime = new Date().valueOf();
	

	if ((e)&&(e.preventDefault)){
		e.preventDefault();
		return false;
	}
	return false;
};
dhtmlDragAndDropObject.prototype.callDrag=function(e){
	if (!e)
		e=window.event;
	dragger=window.dhtmlDragAndDrop;
	if ((new Date()).valueOf()-dragger.downtime<100) return;

	//if ((e.button == 0)&&(_isIE))
	//	return dragger.stopDrag();

	if (!dragger.dragNode){
		if (dragger.waitDrag){
			dragger.dragNode=dragger.dragStartObject._createDragNode(dragger.dragStartNode, e);
	
			if (!dragger.dragNode)
				return dragger.stopDrag();
	
			dragger.dragNode.onselectstart=function(){return false;}
			dragger.gldragNode=dragger.dragNode;
			document.body.appendChild(dragger.dragNode);
			document.body.onmouseup=dragger.stopDrag;
			dragger.waitDrag=0;
			dragger.dragNode.pWindow=window;
			dragger.initFrameRoute();
		} 
		else return dragger.stopDrag(e, true);
	}

	if (dragger.dragNode.parentNode != window.document.body && dragger.gldragNode){
		var grd = dragger.gldragNode;

		if (dragger.gldragNode.old)
			grd=dragger.gldragNode.old;

		//if (!document.all) dragger.calculateFramePosition();
		grd.parentNode.removeChild(grd);
		var oldBody = dragger.dragNode.pWindow;

		if (grd.pWindow &&	grd.pWindow.dhtmlDragAndDrop.lastLanding)
			grd.pWindow.dhtmlDragAndDrop.lastLanding.dragLanding._dragOut(grd.pWindow.dhtmlDragAndDrop.lastLanding);	
			
		//		var oldp=dragger.dragNode.parentObject;
		if (_isIE){
			var div = document.createElement("Div");
			div.innerHTML=dragger.dragNode.outerHTML;
			dragger.dragNode=div.childNodes[0];
		} else
			dragger.dragNode=dragger.dragNode.cloneNode(true);

		dragger.dragNode.pWindow=window;
		//		dragger.dragNode.parentObject=oldp;

		dragger.gldragNode.old=dragger.dragNode;
		document.body.appendChild(dragger.dragNode);
		oldBody.dhtmlDragAndDrop.dragNode=dragger.dragNode;
	}

	dragger.dragNode.style.left=e.clientX+15+(dragger.fx
		? dragger.fx*(-1)
		: 0)
		+(document.body.scrollLeft||document.documentElement.scrollLeft)+"px";
	dragger.dragNode.style.top=e.clientY+3+(dragger.fy
		? dragger.fy*(-1)
		: 0)
		+(document.body.scrollTop||document.documentElement.scrollTop)+"px";

	if (!e.srcElement)
		var z = e.target;
	else
		z=e.srcElement;
	dragger.checkLanding(z, e);
}

dhtmlDragAndDropObject.prototype.calculateFramePosition=function(n){
	//this.fx = 0, this.fy = 0;
	if (window.name){
		var el = parent.frames[window.name].frameElement.offsetParent;
		var fx = 0;
		var fy = 0;

		while (el){
			fx+=el.offsetLeft;
			fy+=el.offsetTop;
			el=el.offsetParent;
		}

		if ((parent.dhtmlDragAndDrop)){
			var ls = parent.dhtmlDragAndDrop.calculateFramePosition(1);
			fx+=ls.split('_')[0]*1;
			fy+=ls.split('_')[1]*1;
		}

		if (n)
			return fx+"_"+fy;
		else
			this.fx=fx;
		this.fy=fy;
	}
	return "0_0";
}
dhtmlDragAndDropObject.prototype.checkLanding=function(htmlObject, e){
	if ((htmlObject)&&(htmlObject.dragLanding)){
		if (this.lastLanding)
			this.lastLanding.dragLanding._dragOut(this.lastLanding);
		this.lastLanding=htmlObject;
		this.lastLanding=this.lastLanding.dragLanding._dragIn(this.lastLanding, this.dragStartNode, e.clientX,
			e.clientY, e);
		this.lastLanding_scr=(_isIE ? e.srcElement : e.target);
	} else {
		if ((htmlObject)&&(htmlObject.tagName != "BODY"))
			this.checkLanding(htmlObject.parentNode, e);
		else {
			if (this.lastLanding)
				this.lastLanding.dragLanding._dragOut(this.lastLanding, e.clientX, e.clientY, e);
			this.lastLanding=0;

			if (this._onNotFound)
				this._onNotFound();
		}
	}
}
dhtmlDragAndDropObject.prototype.stopDrag=function(e, mode){
	dragger=window.dhtmlDragAndDrop;

	if (!mode){
		dragger.stopFrameRoute();
		var temp = dragger.lastLanding;
		dragger.lastLanding=null;

		if (temp)
			temp.dragLanding._drag(dragger.dragStartNode, dragger.dragStartObject, temp, (_isIE
				? event.srcElement
				: e.target));
	}
	dragger.lastLanding=null;

	if ((dragger.dragNode)&&(dragger.dragNode.parentNode == document.body))
		dragger.dragNode.parentNode.removeChild(dragger.dragNode);
	dragger.dragNode=0;
	dragger.gldragNode=0;
	dragger.fx=0;
	dragger.fy=0;
	dragger.dragStartNode=0;
	dragger.dragStartObject=0;
	document.body.onmouseup=dragger.tempDOMU;
	document.body.onmousemove=dragger.tempDOMM;
	dragger.tempDOMU=null;
	dragger.tempDOMM=null;
	dragger.waitDrag=0;
}

dhtmlDragAndDropObject.prototype.stopFrameRoute=function(win){
	if (win)
		window.dhtmlDragAndDrop.stopDrag(1, 1);

	for (var i = 0; i < window.frames.length; i++){
		try{
		if ((window.frames[i] != win)&&(window.frames[i].dhtmlDragAndDrop))
			window.frames[i].dhtmlDragAndDrop.stopFrameRoute(window);
		} catch(e){}
	}

	try{
	if ((parent.dhtmlDragAndDrop)&&(parent != window)&&(parent != win))
		parent.dhtmlDragAndDrop.stopFrameRoute(window);
	} catch(e){}
}
dhtmlDragAndDropObject.prototype.initFrameRoute=function(win, mode){
	if (win){
		window.dhtmlDragAndDrop.preCreateDragCopy();
		window.dhtmlDragAndDrop.dragStartNode=win.dhtmlDragAndDrop.dragStartNode;
		window.dhtmlDragAndDrop.dragStartObject=win.dhtmlDragAndDrop.dragStartObject;
		window.dhtmlDragAndDrop.dragNode=win.dhtmlDragAndDrop.dragNode;
		window.dhtmlDragAndDrop.gldragNode=win.dhtmlDragAndDrop.dragNode;
		window.document.body.onmouseup=window.dhtmlDragAndDrop.stopDrag;
		window.waitDrag=0;

		if (((!_isIE)&&(mode))&&((!_isFF)||(_FFrv < 1.8)))
			window.dhtmlDragAndDrop.calculateFramePosition();
	}
	try{
	if ((parent.dhtmlDragAndDrop)&&(parent != window)&&(parent != win))
		parent.dhtmlDragAndDrop.initFrameRoute(window);
	}catch(e){}

	for (var i = 0; i < window.frames.length; i++){
		try{
		if ((window.frames[i] != win)&&(window.frames[i].dhtmlDragAndDrop))
			window.frames[i].dhtmlDragAndDrop.initFrameRoute(window, ((!win||mode) ? 1 : 0));
		} catch(e){}
	}
}

 _isFF = false;
 _isIE = false;
 _isOpera = false;
 _isKHTML = false;
 _isMacOS = false;
 _isChrome = false;
 _FFrv = false;
 _KHTMLrv = false;
 _OperaRv = false;

if (navigator.userAgent.indexOf('Macintosh') != -1)
	_isMacOS=true;


if (navigator.userAgent.toLowerCase().indexOf('chrome')>-1)
	_isChrome=true;

if ((navigator.userAgent.indexOf('Safari') != -1)||(navigator.userAgent.indexOf('Konqueror') != -1)){
	 _KHTMLrv = parseFloat(navigator.userAgent.substr(navigator.userAgent.indexOf('Safari')+7, 5));

	if (_KHTMLrv > 525){ //mimic FF behavior for Safari 3.1+
		_isFF=true;
		 _FFrv = 1.9;
	} else
		_isKHTML=true;
} else if (navigator.userAgent.indexOf('Opera') != -1){
	_isOpera=true;
	_OperaRv=parseFloat(navigator.userAgent.substr(navigator.userAgent.indexOf('Opera')+6, 3));
}


else if (navigator.appName.indexOf("Microsoft") != -1){
	_isIE=true;
	if ((navigator.appVersion.indexOf("MSIE 8.0")!= -1 || 
		 navigator.appVersion.indexOf("MSIE 9.0")!= -1 || 
		 navigator.appVersion.indexOf("MSIE 10.0")!= -1 ||
		 document.documentMode > 7) && 
			document.compatMode != "BackCompat"){
		_isIE=8;
	}
} else if (navigator.appName  == 'Netscape' && navigator.userAgent.indexOf("Trident") != -1){
	//ie11
	_isIE=8;
} else {
	_isFF=true;
	 _FFrv = parseFloat(navigator.userAgent.split("rv:")[1])
}

if (typeof(window.dhtmlxEvent) == "undefined") {
	
	function dhtmlxEvent(el, event, handler){
		if (el.addEventListener)
			el.addEventListener(event, handler, false);
	
		else if (el.attachEvent)
			el.attachEvent("on"+event, handler);
	}
};

if (dhtmlxEvent.touchDelay == null) {
	dhtmlxEvent.touchDelay = 2000;
};

if (typeof(dhtmlxEvent.initTouch) == "undefined") {
	
	dhtmlxEvent.initTouch = function(){
		var longtouch;
		var target;
		var tx, ty;
	
		dhtmlxEvent(document.body, "touchstart", function(ev){
			target = ev.touches[0].target;
			tx = ev.touches[0].clientX;
			ty = ev.touches[0].clientY;
			longtouch = window.setTimeout(touch_event, dhtmlxEvent.touchDelay);
		});
		function touch_event(){
			if (target){
				var ev = document.createEvent("HTMLEvents"); // for chrome and firefox
				ev.initEvent("dblclick", true, true);
				target.dispatchEvent(ev);
				longtouch = target = null;
			}
		};
		dhtmlxEvent(document.body, "touchmove", function(ev){
			if (longtouch){
				if (Math.abs(ev.touches[0].clientX - tx) > 50 || Math.abs(ev.touches[0].clientY - ty) > 50 ){
					window.clearTimeout(longtouch);
					longtouch = target = false;
				}
			}
		});
		dhtmlxEvent(document.body, "touchend", function(ev){
			if (longtouch){
				window.clearTimeout(longtouch);
				longtouch = target = false;
			}
		});
	
		dhtmlxEvent.initTouch = function(){};
	};
};

/*
Product Name: dhtmlxSuite 
Version: 4.1.3 
Edition: Professional 
License: content of this file is covered by DHTMLX Commercial or Enterprise license. Usage without proper license is prohibited. To obtain it contact sales@dhtmlx.com
Copyright UAB Dinamenta http://www.dhtmlx.com
*/

/*
Copyright DHTMLX LTD. http://www.dhtmlx.com
You allowed to use this component or parts of it under GPL terms
To use it on other terms or get Professional edition of the component please contact us at sales@dhtmlx.com
*/
/*
2014 March 19
*/



/* DHX DEPEND FROM FILE 'assert.js'*/


if (!window.dhtmlx) 
	dhtmlx={};

//check some rule, show message as error if rule is not correct
dhtmlx.assert = function(test, message){
	if (!test)	dhtmlx.error(message);
};
dhtmlx.assert_enabled=function(){ return false; };

//register names of event, which can be triggered by the object
dhtmlx.assert_event = function(obj, evs){
	if (!obj._event_check){
		obj._event_check = {};
		obj._event_check_size = {};
	}
		
	for (var a in evs){
		obj._event_check[a.toLowerCase()]=evs[a];
		var count=-1; for (var t in evs[a]) count++;
		obj._event_check_size[a.toLowerCase()]=count;
	}
};
dhtmlx.assert_method_info=function(obj, name, descr, rules){
	var args = [];
	for (var i=0; i < rules.length; i++) {
		args.push(rules[i][0]+" : "+rules[i][1]+"\n   "+rules[i][2].describe()+(rules[i][3]?"; optional":""));
	}
	return obj.name+"."+name+"\n"+descr+"\n Arguments:\n - "+args.join("\n - ");
};
dhtmlx.assert_method = function(obj, config){
	for (var key in config)
		dhtmlx.assert_method_process(obj, key, config[key].descr, config[key].args, (config[key].min||99), config[key].skip);
};
dhtmlx.assert_method_process = function (obj, name, descr, rules, min, skip){
	var old = obj[name];
	if (!skip)
		obj[name] = function(){
			if (arguments.length !=	rules.length && arguments.length < min) 
				dhtmlx.log("warn","Incorrect count of parameters\n"+obj[name].describe()+"\n\nExpecting "+rules.length+" but have only "+arguments.length);
			else
				for (var i=0; i<rules.length; i++)
					if (!rules[i][3] && !rules[i][2](arguments[i]))
						dhtmlx.log("warn","Incorrect method call\n"+obj[name].describe()+"\n\nActual value of "+(i+1)+" parameter: {"+(typeof arguments[i])+"} "+arguments[i]);
			
			return old.apply(this, arguments);
		};
	obj[name].describe = function(){	return dhtmlx.assert_method_info(obj, name, descr, rules);	};
};
dhtmlx.assert_event_call = function(obj, name, args){
	if (obj._event_check){
		if (!obj._event_check[name])
			dhtmlx.log("warn","Not expected event call :"+name);
		else if (dhtmlx.isNotDefined(args))
			dhtmlx.log("warn","Event without parameters :"+name);
		else if (obj._event_check_size[name] != args.length)
			dhtmlx.log("warn","Incorrect event call, expected "+obj._event_check_size[name]+" parameter(s), but have "+args.length +" parameter(s), for "+name+" event");
	}		
};
dhtmlx.assert_event_attach = function(obj, name){
	if (obj._event_check && !obj._event_check[name]) 
			dhtmlx.log("warn","Unknown event name: "+name);
};
//register names of properties, which can be used in object's configuration
dhtmlx.assert_property = function(obj, evs){
	if (!obj._settings_check)
		obj._settings_check={};
	dhtmlx.extend(obj._settings_check, evs);		
};
//check all options in collection, against list of allowed properties
dhtmlx.assert_check = function(data,coll){
	if (typeof data == "object"){
		for (var key in data){
			dhtmlx.assert_settings(key,data[key],coll);
		}
	}
};
//check if type and value of property is the same as in scheme
dhtmlx.assert_settings = function(mode,value,coll){
	coll = coll || this._settings_check;

	//if value is not in collection of defined ones
	if (coll){
		if (!coll[mode])	//not registered property
			return dhtmlx.log("warn","Unknown propery: "+mode);
			
		var descr = "";
		var error = "";
		var check = false;
		for (var i=0; i<coll[mode].length; i++){
			var rule = coll[mode][i];
			if (typeof rule == "string")
				continue;
			if (typeof rule == "function")
				check = check || rule(value);
			else if (typeof rule == "object" && typeof rule[1] == "function"){
				check = check || rule[1](value);
				if (check && rule[2])
					dhtmlx["assert_check"](value, rule[2]); //temporary fix , for sources generator
			}
			if (check) break;
		}
		if (!check )
			dhtmlx.log("warn","Invalid configuration\n"+dhtmlx.assert_info(mode,coll)+"\nActual value: {"+(typeof value)+"} "+value);
	}
};

dhtmlx.assert_info=function(name, set){ 
	var ruleset = set[name];
	var descr = "";
	var expected = [];
	for (var i=0; i<ruleset.length; i++){
		if (typeof rule == "string")
			descr = ruleset[i];
		else if (ruleset[i].describe)
			expected.push(ruleset[i].describe());
		else if (ruleset[i][1] && ruleset[i][1].describe)
			expected.push(ruleset[i][1].describe());
	}
	return "Property: "+name+", "+descr+" \nExpected value: \n - "+expected.join("\n - ");
};


if (dhtmlx.assert_enabled()){
	
	dhtmlx.assert_rule_color=function(check){
		if (typeof check != "string") return false;
		if (check.indexOf("#")!==0) return false;
		if (check.substr(1).replace(/[0-9A-F]/gi,"")!=="") return false;
		return true;
	};
	dhtmlx.assert_rule_color.describe = function(){
		return "{String} Value must start from # and contain hexadecimal code of color";
	};
	
	dhtmlx.assert_rule_template=function(check){
		if (typeof check == "function") return true;
		if (typeof check == "string") return true;
		return false;
	};
	dhtmlx.assert_rule_template.describe = function(){
		return "{Function},{String} Value must be a function which accepts data object and return text string, or a sting with optional template markers";
	};
	
	dhtmlx.assert_rule_boolean=function(check){
		if (typeof check == "boolean") return true;
		return false;
	};
	dhtmlx.assert_rule_boolean.describe = function(){
		return "{Boolean} true or false";
	};
	
	dhtmlx.assert_rule_object=function(check, sub){
		if (typeof check == "object") return true;
		return false;
	};
	dhtmlx.assert_rule_object.describe = function(){
		return "{Object} Configuration object";
	};
	
	
	dhtmlx.assert_rule_string=function(check){
		if (typeof check == "string") return true;
		return false;
	};
	dhtmlx.assert_rule_string.describe = function(){
		return "{String} Plain string";
	};
	
	
	dhtmlx.assert_rule_htmlpt=function(check){
		return !!dhtmlx.toNode(check);
	};
	dhtmlx.assert_rule_htmlpt.describe = function(){
		return "{Object},{String} HTML node or ID of HTML Node";
	};
	
	dhtmlx.assert_rule_notdocumented=function(check){
		return false;
	};
	dhtmlx.assert_rule_notdocumented.describe = function(){
		return "This options wasn't documented";
	};
	
	dhtmlx.assert_rule_key=function(obj){
		var t = function (check){
			return obj[check];
		};
		t.describe=function(){
			var opts = [];
			for(var key in obj)
				opts.push(key);
			return  "{String} can take one of next values: "+opts.join(", ");
		};
		return t;
	};
	
	dhtmlx.assert_rule_dimension=function(check){
		if (check*1 == check && !isNaN(check) && check >= 0) return true;
		return false;
	};
	dhtmlx.assert_rule_dimension.describe=function(){
		return "{Integer} value must be a positive number";
	};
	
	dhtmlx.assert_rule_number=function(check){
		if (typeof check == "number") return true;
		return false;
	};
	dhtmlx.assert_rule_number.describe=function(){
		return "{Integer} value must be a number";
	};
	
	dhtmlx.assert_rule_function=function(check){
		if (typeof check == "function") return true;
		return false;
	};
	dhtmlx.assert_rule_function.describe=function(){
		return "{Function} value must be a custom function";
	};
	
	dhtmlx.assert_rule_any=function(check){
		return true;
	};
	dhtmlx.assert_rule_any.describe=function(){
		return "Any value";
	};
	
	dhtmlx.assert_rule_mix=function(a,b){
		var t = function(check){
			if (a(check)||b(check)) return true;
			return false;
		};
		t.describe = function(){
			return a.describe();
		};
		return t;
	};

}


/* DHX DEPEND FROM FILE 'dhtmlx.js'*/


/*DHX:Depend assert.js*/

/*
	Common helpers
*/
dhtmlx.version="3.0";
dhtmlx.codebase="./";

//coding helpers

dhtmlx.copy = function(source){
	var f = dhtmlx.copy._function;
	f.prototype = source;
	return new f();
};
dhtmlx.copy._function = function(){};

//copies methods and properties from source to the target
dhtmlx.extend = function(target, source){
	for (var method in source)
		target[method] = source[method];
		
	//applying asserts
	if (dhtmlx.assert_enabled() && source._assert){
		target._assert();
		target._assert=null;
	}
	
	dhtmlx.assert(target,"Invalid nesting target");
	dhtmlx.assert(source,"Invalid nesting source");
	//if source object has init code - call init against target
	if (source._init)	
		target._init();
				
	return target;	
};
dhtmlx.proto_extend = function(){
	var origins = arguments;
	var compilation = origins[0];
	var construct = [];
	
	for (var i=origins.length-1; i>0; i--) {
		if (typeof origins[i]== "function")
			origins[i]=origins[i].prototype;
		for (var key in origins[i]){
			if (key == "_init") 
				construct.push(origins[i][key]);
			else if (!compilation[key])
				compilation[key] = origins[i][key];
		}
	};
	
	if (origins[0]._init)
		construct.push(origins[0]._init);
	
	compilation._init = function(){
		for (var i=0; i<construct.length; i++)
			construct[i].apply(this, arguments);
	};
	compilation.base = origins[1];
	var result = function(config){
		this._init(config);
		if (this._parseSettings)
			this._parseSettings(config, this.defaults);
	};
	result.prototype = compilation;
	
	compilation = origins = null;
	return result;
};
//creates function with specified "this" pointer
dhtmlx.bind=function(functor, object){ 
	return function(){ return functor.apply(object,arguments); };  
};

//loads module from external js file
dhtmlx.require=function(module){
	if (!dhtmlx._modules[module]){
		dhtmlx.assert(dhtmlx.ajax,"load module is required");
		
		//load and exec the required module
		dhtmlx.exec( dhtmlx.ajax().sync().get(dhtmlx.codebase+module).responseText );
		dhtmlx._modules[module]=true;	
	}
};
dhtmlx._modules = {};	//hash of already loaded modules

//evaluate javascript code in the global scoope
dhtmlx.exec=function(code){
	if (window.execScript)	//special handling for IE
		window.execScript(code);
	else window.eval(code);
};

/*
	creates method in the target object which will transfer call to the source object
	if event parameter was provided , each call of method will generate onBefore and onAfter events
*/
dhtmlx.methodPush=function(object,method,event){
	return function(){
		var res = false;
		//if (!event || this.callEvent("onBefore"+event,arguments)){ //not used anymore, probably can be removed
			res=object[method].apply(object,arguments);
		//	if (event) this.callEvent("onAfter"+event,arguments);
		//}
		return res;	//result of wrapped method
	};
};
//check === undefined
dhtmlx.isNotDefined=function(a){
	return typeof a == "undefined";
};
//delay call to after-render time
dhtmlx.delay=function(method, obj, params, delay){
	setTimeout(function(){
		var ret = method.apply(obj,params);
		method = obj = params = null;
		return ret;
	},delay||1);
};

//common helpers

//generates unique ID (unique per window, nog GUID)
dhtmlx.uid = function(){
	if (!this._seed) this._seed=(new Date).valueOf();	//init seed with timestemp
	this._seed++;
	return this._seed;
};
//resolve ID as html object
dhtmlx.toNode = function(node){
	if (typeof node == "string") return document.getElementById(node);
	return node;
};
//adds extra methods for the array
dhtmlx.toArray = function(array){ 
	return dhtmlx.extend((array||[]),dhtmlx.PowerArray);
};
//resolve function name
dhtmlx.toFunctor=function(str){ 
	return (typeof(str)=="string") ? eval(str) : str; 
};

//dom helpers

//hash of attached events
dhtmlx._events = {};
//attach event to the DOM element
dhtmlx.event=function(node,event,handler,master){
	node = dhtmlx.toNode(node);
	
	var id = dhtmlx.uid();
	dhtmlx._events[id]=[node,event,handler];	//store event info, for detaching
	
	if (master) 
		handler=dhtmlx.bind(handler,master);	
		
	//use IE's of FF's way of event's attaching
	if (node.addEventListener)
		node.addEventListener(event, handler, false);
	else if (node.attachEvent)
		node.attachEvent("on"+event, handler);

	return id;	//return id of newly created event, can be used in eventRemove
};

//remove previously attached event
dhtmlx.eventRemove=function(id){
	
	if (!id) return;
	dhtmlx.assert(this._events[id],"Removing non-existing event");
		
	var ev = dhtmlx._events[id];
	//browser specific event removing
	if (ev[0].removeEventListener)
		ev[0].removeEventListener(ev[1],ev[2],false);
	else if (ev[0].detachEvent)
		ev[0].detachEvent("on"+ev[1],ev[2]);
		
	delete this._events[id];	//delete all traces
};


//debugger helpers
//anything starting from error or log will be removed during code compression

//add message in the log
dhtmlx.log = function(type,message,details){
	if (window.console && console.log){
		type=type.toLowerCase();
		if (window.console[type])
			window.console[type](message||"unknown error");
		else
			window.console.log(type +": "+message);
		if (details) 
			window.console.log(details);
	}	
};
//register rendering time from call point 
dhtmlx.log_full_time = function(name){
	dhtmlx._start_time_log = new Date();
	dhtmlx.log("Info","Timing start ["+name+"]");
	window.setTimeout(function(){
		var time = new Date();
		dhtmlx.log("Info","Timing end ["+name+"]:"+(time.valueOf()-dhtmlx._start_time_log.valueOf())/1000+"s");
	},1);
};
//register execution time from call point
dhtmlx.log_time = function(name){
	var fname = "_start_time_log"+name;
	if (!dhtmlx[fname]){
		dhtmlx[fname] = new Date();
		dhtmlx.log("Info","Timing start ["+name+"]");
	} else {
		var time = new Date();
		dhtmlx.log("Info","Timing end ["+name+"]:"+(time.valueOf()-dhtmlx[fname].valueOf())/1000+"s");
		dhtmlx[fname] = null;
	}
};
//log message with type=error
dhtmlx.error = function(message,details){
	dhtmlx.log("error",message,details);
};
//event system
dhtmlx.EventSystem={
	_init:function(){
		this._events = {};		//hash of event handlers, name => handler
		this._handlers = {};	//hash of event handlers, ID => handler
		this._map = {};
	},
	//temporary block event triggering
	block : function(){
		this._events._block = true;
	},
	//re-enable event triggering
	unblock : function(){
		this._events._block = false;
	},
	mapEvent:function(map){
		dhtmlx.extend(this._map, map);
	},
	//trigger event
	callEvent:function(type,params){
		if (this._events._block) return true;
		
		type = type.toLowerCase();
		dhtmlx.assert_event_call(this, type, params);
		
		var event_stack =this._events[type.toLowerCase()];	//all events for provided name
		var return_value = true;

		if (dhtmlx.debug)	//can slowdown a lot
			dhtmlx.log("info","["+this.name+"] event:"+type,params);
		
		if (event_stack)
			for(var i=0; i<event_stack.length; i++)
				/*
					Call events one by one
					If any event return false - result of whole event will be false
					Handlers which are not returning anything - counted as positive
				*/
				if (event_stack[i].apply(this,(params||[]))===false) return_value=false;
				
		if (this._map[type] && !this._map[type].callEvent(type,params))
			return_value =	false;
			
		return return_value;
	},
	//assign handler for some named event
	attachEvent:function(type,functor,id){
		type=type.toLowerCase();
		dhtmlx.assert_event_attach(this, type);
		
		id=id||dhtmlx.uid(); //ID can be used for detachEvent
		functor = dhtmlx.toFunctor(functor);	//functor can be a name of method

		var event_stack=this._events[type]||dhtmlx.toArray();
		//save new event handler
		event_stack.push(functor);
		this._events[type]=event_stack;
		this._handlers[id]={ f:functor,t:type };
		
		return id;
	},
	//remove event handler
	detachEvent:function(id){
		if(this._handlers[id]){
			var type=this._handlers[id].t;
			var functor=this._handlers[id].f;
			
			//remove from all collections
			var event_stack=this._events[type];
			event_stack.remove(functor);
			delete this._handlers[id];
		}
	} 
};

//array helper
//can be used by dhtmlx.toArray()
dhtmlx.PowerArray={
	//remove element at specified position
	removeAt:function(pos,len){
		if (pos>=0) this.splice(pos,(len||1));
	},
	//find element in collection and remove it 
	remove:function(value){
		this.removeAt(this.find(value));
	},	
	//add element to collection at specific position
	insertAt:function(data,pos){
		if (!pos && pos!==0) 	//add to the end by default
			this.push(data);
		else {	
			var b = this.splice(pos,(this.length-pos));
  			this[pos] = data;
  			this.push.apply(this,b); //reconstruct array without loosing this pointer
  		}
  	},  	
  	//return index of element, -1 if it doesn't exists
  	find:function(data){ 
  		for (i=0; i<this.length; i++) 
  			if (data==this[i]) return i; 	
  		return -1; 
  	},
  	//execute some method for each element of array
  	each:function(functor,master){
		for (var i=0; i < this.length; i++)
			functor.call((master||this),this[i]);
	},
	//create new array from source, by using results of functor 
	map:function(functor,master){
		for (var i=0; i < this.length; i++)
			this[i]=functor.call((master||this),this[i]);
		return this;
	}
};

dhtmlx.env = {};

//environment detection
if (navigator.userAgent.indexOf('Opera') != -1)
	dhtmlx._isOpera=true;
else{
	//very rough detection, but it is enough for current goals
	dhtmlx._isIE=!!document.all;
	dhtmlx._isFF=!document.all;
	dhtmlx._isWebKit=(navigator.userAgent.indexOf("KHTML")!=-1);
	if (navigator.appVersion.indexOf("MSIE 8.0")!= -1 && document.compatMode != "BackCompat") 
		dhtmlx._isIE=8;
	if (navigator.appVersion.indexOf("MSIE 9.0")!= -1 && document.compatMode != "BackCompat") 
		dhtmlx._isIE=9;
}

dhtmlx.env = {};

// dhtmlx.env.transform 
// dhtmlx.env.transition
(function(){
	dhtmlx.env.transform = false;
	dhtmlx.env.transition = false;
	var options = {};
	options.names = ['transform', 'transition'];
	options.transform = ['transform', 'WebkitTransform', 'MozTransform', 'oTransform','msTransform'];
	options.transition = ['transition', 'WebkitTransition', 'MozTransition', 'oTransition'];
	
	var d = document.createElement("DIV");
	var property;
	for(var i=0; i<options.names.length; i++) {
		while (p = options[options.names[i]].pop()) {
			if(typeof d.style[p] != 'undefined')
				dhtmlx.env[options.names[i]] = true;
		}
	}
})();
dhtmlx.env.transform_prefix = (function(){
		var prefix;
		if(dhtmlx._isOpera)
			prefix = '-o-';
		else {
			prefix = ''; // default option
			if(dhtmlx._isFF) 
				prefix = '-moz-';
			if(dhtmlx._isWebKit) 
					prefix = '-webkit-';
		}
		return prefix;
})();
dhtmlx.env.svg = (function(){
		return document.implementation.hasFeature("http://www.w3.org/TR/SVG11/feature#BasicStructure", "1.1");
})();

//store maximum used z-index
dhtmlx.zIndex={ drag : 10000 };

//html helpers
dhtmlx.html={
	create:function(name,attrs,html){
		attrs = attrs || {};
		var node = document.createElement(name);
		for (var attr_name in attrs)
			node.setAttribute(attr_name, attrs[attr_name]);
		if (attrs.style)
			node.style.cssText = attrs.style;
		if (attrs["class"])
			node.className = attrs["class"];
		if (html)
			node.innerHTML=html;
		return node;
	},
	//return node value, different logic for different html elements
	getValue:function(node){
		node = dhtmlx.toNode(node);
		if (!node) return "";
		return dhtmlx.isNotDefined(node.value)?node.innerHTML:node.value;
	},
	//remove html node, can process an array of nodes at once
	remove:function(node){
		if (node instanceof Array)
			for (var i=0; i < node.length; i++)
				this.remove(node[i]);
		else
			if (node && node.parentNode)
				node.parentNode.removeChild(node);
	},
	//insert new node before sibling, or at the end if sibling doesn't exist
	insertBefore: function(node,before,rescue){
		if (!node) return;
		if (before)
			before.parentNode.insertBefore(node, before);
		else
			rescue.appendChild(node);
	},
	//return custom ID from html element 
	//will check all parents starting from event's target
	locate:function(e,id){
		e=e||event;
		var trg=e.target||e.srcElement;
		while (trg){
			if (trg.getAttribute){	//text nodes has not getAttribute
				var test = trg.getAttribute(id);
				if (test) return test;
			}
			trg=trg.parentNode;
		}	
		return null;
	},
	//returns position of html element on the page
	offset:function(elem) {
		if (elem.getBoundingClientRect) { //HTML5 method
			var box = elem.getBoundingClientRect();
			var body = document.body;
			var docElem = document.documentElement;
			var scrollTop = window.pageYOffset || docElem.scrollTop || body.scrollTop;
			var scrollLeft = window.pageXOffset || docElem.scrollLeft || body.scrollLeft;
			var clientTop = docElem.clientTop || body.clientTop || 0;
			var clientLeft = docElem.clientLeft || body.clientLeft || 0;
			var top  = box.top +  scrollTop - clientTop;
			var left = box.left + scrollLeft - clientLeft;
			return { y: Math.round(top), x: Math.round(left) };
		} else { //fallback to naive approach
			var top=0, left=0;
			while(elem) {
				top = top + parseInt(elem.offsetTop,10);
				left = left + parseInt(elem.offsetLeft,10);
				elem = elem.offsetParent;
			}
			return {y: top, x: left};
		}
	},
	//returns position of event
	pos:function(ev){
		ev = ev || event;
        if(ev.pageX || ev.pageY)	//FF, KHTML
            return {x:ev.pageX, y:ev.pageY};
        //IE
        var d  =  ((dhtmlx._isIE)&&(document.compatMode != "BackCompat"))?document.documentElement:document.body;
        return {
                x:ev.clientX + d.scrollLeft - d.clientLeft,
                y:ev.clientY + d.scrollTop  - d.clientTop
        };
	},
	//prevent event action
	preventEvent:function(e){
		if (e && e.preventDefault) e.preventDefault();
		dhtmlx.html.stopEvent(e);
	},
	//stop event bubbling
	stopEvent:function(e){
		(e||event).cancelBubble=true;
		return false;
	},
	//add css class to the node
	addCss:function(node,name){
        node.className+=" "+name;
    },
    //remove css class from the node
    removeCss:function(node,name){
        node.className=node.className.replace(RegExp(name,"g"),"");
    }
};

//autodetect codebase folder
(function(){
	var temp = document.getElementsByTagName("SCRIPT");	//current script, most probably
	dhtmlx.assert(temp.length,"Can't locate codebase");
	if (temp.length){
		//full path to script
		temp = (temp[temp.length-1].getAttribute("src")||"").split("/");
		//get folder name
		temp.splice(temp.length-1, 1);
		dhtmlx.codebase = temp.slice(0, temp.length).join("/")+"/";
	}
})();

if (!dhtmlx.ui)
	dhtmlx.ui={};


/* DHX DEPEND FROM FILE 'destructor.js'*/


/*
	Behavior:Destruction
	
	@export
		destructor
*/

/*DHX:Depend dhtmlx.js*/

dhtmlx.Destruction = {
	_init:function(){
		//register self in global list of destructors
		dhtmlx.destructors.push(this);
	},
	//will be called automatically on unload, can be called manually
	//simplifies job of GC
	destructor:function(){
		this.destructor=function(){}; //destructor can be called only once
		
		//html collection
		this._htmlmap  = null;
		this._htmlrows = null;
		
		//temp html element, used by toHTML
		if (this._html)
			document.body.appendChild(this._html);	//need to attach, for IE's GC

		this._html = null;
		if (this._obj) {
			this._obj.innerHTML="";
			this._obj._htmlmap = null;
		}
		this._obj = this._dataobj=null;
		this.data = null;
		this._events = this._handlers = {};
		if(this.render)
			this.render = function(){};//need in case of delayed method calls (virtual render case)
	}
};
//global list of destructors
dhtmlx.destructors = [];
dhtmlx.event(window,"unload",function(){
	//call all registered destructors
	if (dhtmlx.destructors){
		for (var i=0; i<dhtmlx.destructors.length; i++)
			dhtmlx.destructors[i].destructor();
		dhtmlx.destructors = [];
	}
	
	//detach all known DOM events
	for (var a in dhtmlx._events){
		var ev = dhtmlx._events[a];
		if (ev[0].removeEventListener)
			ev[0].removeEventListener(ev[1],ev[2],false);
		else if (ev[0].detachEvent)
			ev[0].detachEvent("on"+ev[1],ev[2]);
		delete dhtmlx._events[a];
	}
});





/* DHX DEPEND FROM FILE 'load.js'*/


/* 
	ajax operations 
	
	can be used for direct loading as
		dhtmlx.ajax(ulr, callback)
	or
		dhtmlx.ajax().item(url)
		dhtmlx.ajax().post(url)

*/

/*DHX:Depend dhtmlx.js*/

dhtmlx.ajax = function(url,call,master){
	//if parameters was provided - made fast call
	if (arguments.length!==0){
		var http_request = new dhtmlx.ajax();
		if (master) http_request.master=master;
		http_request.get(url,null,call);
	}
	if (!this.getXHR) return new dhtmlx.ajax(); //allow to create new instance without direct new declaration
	
	return this;
};
dhtmlx.ajax.prototype={
	//creates xmlHTTP object
	getXHR:function(){
		if (dhtmlx._isIE)
		 return new ActiveXObject("Microsoft.xmlHTTP");
		else 
		 return new XMLHttpRequest();
	},
	/*
		send data to the server
		params - hash of properties which will be added to the url
		call - callback, can be an array of functions
	*/
	send:function(url,params,call){
		var x=this.getXHR();
		if (typeof call == "function")
		 call = [call];
		//add extra params to the url
		if (typeof params == "object"){
			var t=[];
			for (var a in params){
				var value = params[a];
				if (value === null || value === dhtmlx.undefined)
					value = "";
				t.push(a+"="+encodeURIComponent(value));// utf-8 escaping
		 	}
			params=t.join("&");
		}
		if (params && !this.post){
			url=url+(url.indexOf("?")!=-1 ? "&" : "?")+params;
			params=null;
		}
		
		x.open(this.post?"POST":"GET",url,!this._sync);
		if (this.post)
		 x.setRequestHeader('Content-type','application/x-www-form-urlencoded');
		 
		//async mode, define loading callback
		//if (!this._sync){
		 var self=this;
		 x.onreadystatechange= function(){
			if (!x.readyState || x.readyState == 4){
				//dhtmlx.log_full_time("data_loading");	//log rendering time
				if (call && self) 
					for (var i=0; i < call.length; i++)	//there can be multiple callbacks
					 if (call[i])
						call[i].call((self.master||self),x.responseText,x.responseXML,x);
				self.master=null;
				call=self=null;	//anti-leak
			}
		 };
		//}
		
		x.send(params||null);
		return x; //return XHR, which can be used in case of sync. mode
	},
	//GET request
	get:function(url,params,call){
		this.post=false;
		return this.send(url,params,call);
	},
	//POST request
	post:function(url,params,call){
		this.post=true;
		return this.send(url,params,call);
	}, 
	sync:function(){
		this._sync = true;
		return this;
	}
};


dhtmlx.AtomDataLoader={
	_init:function(config){
		//prepare data store
		this.data = {}; 
		if (config){
			this._settings.datatype = config.datatype||"json";
			this._after_init.push(this._load_when_ready);
		}
	},
	_load_when_ready:function(){
		this._ready_for_data = true;
		
		if (this._settings.url)
			this.url_setter(this._settings.url);
		if (this._settings.data)
			this.data_setter(this._settings.data);
	},
	url_setter:function(value){
		if (!this._ready_for_data) return value;
		this.load(value, this._settings.datatype);	
		return value;
	},
	data_setter:function(value){
		if (!this._ready_for_data) return value;
		this.parse(value, this._settings.datatype);
		return true;
	},
	//loads data from external URL
	load:function(url,call){
		this.callEvent("onXLS",[]);
		if (typeof call == "string"){	//second parameter can be a loading type or callback
			this.data.driver = dhtmlx.DataDriver[call];
			call = arguments[2];
		}
		else
			this.data.driver = dhtmlx.DataDriver["xml"];
		//load data by async ajax call
		dhtmlx.ajax(url,[this._onLoad,call],this);
	},
	//loads data from object
	parse:function(data,type){
		this.callEvent("onXLS",[]);
		this.data.driver = dhtmlx.DataDriver[type||"xml"];
		this._onLoad(data,null);
	},
	//default after loading callback
	_onLoad:function(text,xml,loader){
		var driver = this.data.driver;
		var top = driver.getRecords(driver.toObject(text,xml))[0];
		this.data=(driver?driver.getDetails(top):text);
		this.callEvent("onXLE",[]);
	},
	_check_data_feed:function(data){
		if (!this._settings.dataFeed || this._ignore_feed || !data) return true;
		var url = this._settings.dataFeed;
		if (typeof url == "function")
			return url.call(this, (data.id||data), data);
		url = url+(url.indexOf("?")==-1?"?":"&")+"action=get&id="+encodeURIComponent(data.id||data);
		this.callEvent("onXLS",[]);
		dhtmlx.ajax(url, function(text,xml){
			this._ignore_feed=true;
			this.setValues(dhtmlx.DataDriver.json.toObject(text)[0]);
			this._ignore_feed=false;
			this.callEvent("onXLE",[]);
		}, this);
		return false;
	}
};

/*
	Abstraction layer for different data types
*/

dhtmlx.DataDriver={};
dhtmlx.DataDriver.json={
	//convert json string to json object if necessary
	toObject:function(data){
		if (!data) data="[]";
		if (typeof data == "string"){
		 eval ("dhtmlx.temp="+data);
		 return dhtmlx.temp;
		}
		return data;
	},
	//get array of records
	getRecords:function(data){
		if (data && !(data instanceof Array))
		 return [data];
		return data;
	},
	//get hash of properties for single record
	getDetails:function(data){
		return data;
	},
	//get count of data and position at which new data need to be inserted
	getInfo:function(data){
		return { 
		 _size:(data.total_count||0),
		 _from:(data.pos||0),
		 _key:(data.dhx_security)
		};
	}
};

dhtmlx.DataDriver.json_ext={
	//convert json string to json object if necessary
	toObject:function(data){
		if (!data) data="[]";
		if (typeof data == "string"){
			var temp;
			eval ("temp="+data);
			dhtmlx.temp = [];
			var header  = temp.header;
			for (var i = 0; i < temp.data.length; i++) {
				var item = {};
				for (var j = 0; j < header.length; j++) {
					if (typeof(temp.data[i][j]) != "undefined")
						item[header[j]] = temp.data[i][j];
				}
				dhtmlx.temp.push(item);
			}
			return dhtmlx.temp;
		}
		return data;
	},
	//get array of records
	getRecords:function(data){
		if (data && !(data instanceof Array))
		 return [data];
		return data;
	},
	//get hash of properties for single record
	getDetails:function(data){
		return data;
	},
	//get count of data and position at which new data need to be inserted
	getInfo:function(data){
		return {
		 _size:(data.total_count||0),
		 _from:(data.pos||0)
		};
	}
};

dhtmlx.DataDriver.html={
	/*
		incoming data can be
		 - collection of nodes
		 - ID of parent container
		 - HTML text
	*/
	toObject:function(data){
		if (typeof data == "string"){
		 var t=null;
		 if (data.indexOf("<")==-1)	//if no tags inside - probably its an ID
			t = dhtmlx.toNode(data);
		 if (!t){
			t=document.createElement("DIV");
			t.innerHTML = data;
		 }
		 
		 return t.getElementsByTagName(this.tag);
		}
		return data;
	},
	//get array of records
	getRecords:function(data){
		if (data.tagName)
		 return data.childNodes;
		return data;
	},
	//get hash of properties for single record
	getDetails:function(data){
		return dhtmlx.DataDriver.xml.tagToObject(data);
	},
	//dyn loading is not supported by HTML data source
	getInfo:function(data){
		return { 
		 _size:0,
		 _from:0
		};
	},
	tag: "LI"
};

dhtmlx.DataDriver.jsarray={
	//eval jsarray string to jsarray object if necessary
	toObject:function(data){
		if (typeof data == "string"){
		 eval ("dhtmlx.temp="+data);
		 return dhtmlx.temp;
		}
		return data;
	},
	//get array of records
	getRecords:function(data){
		return data;
	},
	//get hash of properties for single record, in case of array they will have names as "data{index}"
	getDetails:function(data){
		var result = {};
		for (var i=0; i < data.length; i++) 
		 result["data"+i]=data[i];
		 
		return result;
	},
	//dyn loading is not supported by js-array data source
	getInfo:function(data){
		return { 
		 _size:0,
		 _from:0
		};
	}
};

dhtmlx.DataDriver.csv={
	//incoming data always a string
	toObject:function(data){
		return data;
	},
	//get array of records
	getRecords:function(data){
		return data.split(this.row);
	},
	//get hash of properties for single record, data named as "data{index}"
	getDetails:function(data){
		data = this.stringToArray(data);
		var result = {};
		for (var i=0; i < data.length; i++) 
		 result["data"+i]=data[i];
		 
		return result;
	},
	//dyn loading is not supported by csv data source
	getInfo:function(data){
		return { 
		 _size:0,
		 _from:0
		};
	},
	//split string in array, takes string surrounding quotes in account
	stringToArray:function(data){
		data = data.split(this.cell);
		for (var i=0; i < data.length; i++)
		 data[i] = data[i].replace(/^[ \t\n\r]*(\"|)/g,"").replace(/(\"|)[ \t\n\r]*$/g,"");
		return data;
	},
	row:"\n",	//default row separator
	cell:","	//default cell separator
};

dhtmlx.DataDriver.xml={
	//convert xml string to xml object if necessary
	toObject:function(text,xml){
		if (xml && (xml=this.checkResponse(text,xml)))	//checkResponse - fix incorrect content type and extra whitespaces errors
		 return xml;
		if (typeof text == "string"){
		 return this.fromString(text);
		}
		return text;
	},
	//get array of records
	getRecords:function(data){
		return this.xpath(data,this.records);
	},
	records:"/*/item",
	//get hash of properties for single record
	getDetails:function(data){
		return this.tagToObject(data,{});
	},
	//get count of data and position at which new data_loading need to be inserted
	getInfo:function(data){
		return { 
		 _size:(data.documentElement.getAttribute("total_count")||0),
		 _from:(data.documentElement.getAttribute("pos")||0),
		 _key:(data.documentElement.getAttribute("dhx_security"))
		};
	},
	//xpath helper
	xpath:function(xml,path){
		if (window.XPathResult){	//FF, KHTML, Opera
		 var node=xml;
		 if(xml.nodeName.indexOf("document")==-1)
		 xml=xml.ownerDocument;
		 var res = [];
		 var col = xml.evaluate(path, node, null, XPathResult.ANY_TYPE, null);
		 var temp = col.iterateNext();
		 while (temp){ 
			res.push(temp);
			temp = col.iterateNext();
		}
		return res;
		}	
		else {
			var test = true;
			try {
				if (typeof(xml.selectNodes)=="undefined")
					test = false;
			} catch(e){ /*IE7 and below can't operate with xml object*/ }
			//IE
			if (test)
				return xml.selectNodes(path);
			else {
				//Google hate us, there is no interface to do XPath
				//use naive approach
				var name = path.split("/").pop();
				return xml.getElementsByTagName(name);
			}
		}
	},
	//convert xml tag to js object, all subtags and attributes are mapped to the properties of result object
	tagToObject:function(tag,z){
		z=z||{};
		var flag=false;
		
		//map attributes
		var a=tag.attributes;
		if(a && a.length){
			for (var i=0; i<a.length; i++)
		 		z[a[i].name]=a[i].value;
		 	flag = true;
	 	}
		//map subtags
		
		var b=tag.childNodes;
		var state = {};
		for (var i=0; i<b.length; i++){
			if (b[i].nodeType==1){
				var name = b[i].tagName;
				if (typeof z[name] != "undefined"){
					if (!(z[name] instanceof Array))
						z[name]=[z[name]];
					z[name].push(this.tagToObject(b[i],{}));
				}
				else
					z[b[i].tagName]=this.tagToObject(b[i],{});	//sub-object for complex subtags
				flag=true;
			}
		}
		
		if (!flag)
			return this.nodeValue(tag);
		//each object will have its text content as "value" property
		z.value = this.nodeValue(tag);
		return z;
	},
	//get value of xml node 
	nodeValue:function(node){
		if (node.firstChild)
			return node.firstChild.wholeText||node.firstChild.data;
		return "";
	},
	//convert XML string to XML object
	fromString:function(xmlString){
		if (window.DOMParser && !dhtmlx._isIE)		// FF, KHTML, Opera
		 return (new DOMParser()).parseFromString(xmlString,"text/xml");
		if (window.ActiveXObject){	// IE, utf-8 only 
		 var temp=new ActiveXObject("Microsoft.xmlDOM");
		 temp.loadXML(xmlString);
		 return temp;
		}
		dhtmlx.error("Load from xml string is not supported");
	},
	//check is XML correct and try to reparse it if its invalid
	checkResponse:function(text,xml){ 
		if (xml && ( xml.firstChild && xml.firstChild.tagName != "parsererror") )
			return xml;
		//parsing as string resolves incorrect content type
		//regexp removes whitespaces before xml declaration, which is vital for FF
		var a=this.fromString(text.replace(/^[\s]+/,""));
		if (a) return a;
		
		dhtmlx.error("xml can't be parsed",text);
	}
};




/* DHX DEPEND FROM FILE 'datastore.js'*/


/*DHX:Depend load.js*/
/*DHX:Depend dhtmlx.js*/

/*
	Behavior:DataLoader - load data in the component
	
	@export
		load
		parse
*/
dhtmlx.DataLoader={
	_init:function(config){
		//prepare data store
		config = config || "";
		this.name = "DataStore";
		this.data = (config.datastore)||(new dhtmlx.DataStore());
		this._readyHandler = this.data.attachEvent("onStoreLoad",dhtmlx.bind(this._call_onready,this));
	},
	//loads data from external URL
	load:function(url,call){
		dhtmlx.AtomDataLoader.load.apply(this, arguments);
		//prepare data feed for dyn. loading
		if (!this.data.feed)
		 this.data.feed = function(from,count){
			//allow only single request at same time
			if (this._load_count)
				return this._load_count=[from,count];	//save last ignored request
			else
				this._load_count=true;
				
			this.load(url+((url.indexOf("?")==-1)?"?":"&")+"posStart="+from+"&count="+count,function(){
				//after loading check if we have some ignored requests
				var temp = this._load_count;
				this._load_count = false;
				if (typeof temp =="object")
					this.data.feed.apply(this, temp);	//load last ignored request
			});
		};
	},
	//default after loading callback
	_onLoad:function(text,xml,loader){
		this.data._parse(this.data.driver.toObject(text,xml));
		this.callEvent("onXLE",[]);
		if(this._readyHandler){
			this.data.detachEvent(this._readyHandler);
			this._readyHandler = null;
		}
	},
	dataFeed_setter:function(value){
		this.data.attachEvent("onBeforeFilter", dhtmlx.bind(function(text, value){
			if (this._settings.dataFeed){
				var filter = {};
				if (!text && !filter) return;
				if (typeof text == "function"){
					if (!value) return;
					text(value, filter);
				} else 
					filter = { text:value };

				this.clearAll();
				var url = this._settings.dataFeed;
				if (typeof url == "function")
					return url.call(this, value, filter);
				var urldata = [];
				for (var key in filter)
					urldata.push("dhx_filter["+key+"]="+encodeURIComponent(filter[key]));
				this.load(url+(url.indexOf("?")<0?"?":"&")+urldata.join("&"), this._settings.datatype);
				return false;
			}
		},this));
		return value;
	},
	_call_onready:function(){
		if (this._settings.ready){
			var code = dhtmlx.toFunctor(this._settings.ready);
			if (code && code.call) code.apply(this, arguments);
		}
	}
};


/*
	DataStore is not a behavior, it standalone object, which represents collection of data.
	Call provideAPI to map data API

	@export
		exists
		idByIndex
		indexById
		get
		set
		refresh
		dataCount
		sort
		filter
		next
		previous
		clearAll
		first
		last
*/
dhtmlx.DataStore = function(){
	this.name = "DataStore";
	
	dhtmlx.extend(this, dhtmlx.EventSystem);
	
	this.setDriver("xml");	//default data source is an XML
	this.pull = {};						//hash of IDs
	this.order = dhtmlx.toArray();		//order of IDs
};

dhtmlx.DataStore.prototype={
	//defines type of used data driver
	//data driver is an abstraction other different data formats - xml, json, csv, etc.
	setDriver:function(type){
		dhtmlx.assert(dhtmlx.DataDriver[type],"incorrect DataDriver");
		this.driver = dhtmlx.DataDriver[type];
	},
	//process incoming raw data
	_parse:function(data){
		this.callEvent("onParse", [this.driver, data]);
		if (this._filter_order)
			this.filter();
			
		//get size and position of data
		var info = this.driver.getInfo(data);
		if (info._key)
			dhtmlx.security_key = info._key;
		//get array of records

		var recs = this.driver.getRecords(data);
		var from = (info._from||0)*1;
		
		if (from === 0 && this.order[0]) //update mode
			from = this.order.length;
		
		var j=0;
		for (var i=0; i<recs.length; i++){
			//get has of details for each record
			var temp = this.driver.getDetails(recs[i]);
			var id = this.id(temp); 	//generate ID for the record
			if (!this.pull[id]){		//if such ID already exists - update instead of insert
				this.order[j+from]=id;	
				j++;
			}
			this.pull[id]=temp;
			//if (this._format)	this._format(temp);
			
			if (this.extraParser)
				this.extraParser(temp);
			if (this._scheme){ 
				if (this._scheme.$init)
					this._scheme.$update(temp);
				else if (this._scheme.$update)
					this._scheme.$update(temp);
			}
		}

		//for all not loaded data
		for (var i=0; i < info._size; i++)
			if (!this.order[i]){
				var id = dhtmlx.uid();
				var temp = {id:id, $template:"loading"};	//create fake records
				this.pull[id]=temp;
				this.order[i]=id;
			}

		this.callEvent("onStoreLoad",[this.driver, data]);
		//repaint self after data loading
		this.refresh();
	},
	//generate id for data object
	id:function(data){
		return data.id||(data.id=dhtmlx.uid());
	},
	changeId:function(old, newid){
		dhtmlx.assert(this.pull[old],"Can't change id, for non existing item: "+old);
		this.pull[newid] = this.pull[old];
		this.pull[newid].id = newid;
		this.order[this.order.find(old)]=newid;
		if (this._filter_order)
			this._filter_order[this._filter_order.find(old)]=newid;
		this.callEvent("onIdChange", [old, newid]);
		if (this._render_change_id)
			this._render_change_id(old, newid);
	},
	get:function(id){
		return this.item(id);
	},
	set:function(id, data){
		return this.update(id, data);
	},
	//get data from hash by id
	item:function(id){
		return this.pull[id];
	},
	//assigns data by id
	update:function(id,data){
		if (this._scheme && this._scheme.$update)
			this._scheme.$update(data);
		if (this.callEvent("onBeforeUpdate", [id, data]) === false) return false;
		this.pull[id]=data;
		this.refresh(id);
	},
	//sends repainting signal
	refresh:function(id){
		if (this._skip_refresh) return; 
		
		if (id)
			this.callEvent("onStoreUpdated",[id, this.pull[id], "update"]);
		else
			this.callEvent("onStoreUpdated",[null,null,null]);
	},
	silent:function(code){
		this._skip_refresh = true;
		code.call(this);
		this._skip_refresh = false;
	},
	//converts range IDs to array of all IDs between them
	getRange:function(from,to){		
		//if some point is not defined - use first or last id
		//BEWARE - do not use empty or null ID
		if (from)
			from = this.indexById(from);
		else 
			from = this.startOffset||0;
		if (to)
			to = this.indexById(to);
		else {
			to = Math.min((this.endOffset||Infinity),(this.dataCount()-1));
			if (to<0) to = 0; //we have not data in the store
		}

		if (from>to){ //can be in case of backward shift-selection
			var a=to; to=from; from=a;
		}
				
		return this.getIndexRange(from,to);
	},
	//converts range of indexes to array of all IDs between them
	getIndexRange:function(from,to){
		to=Math.min((to||Infinity),this.dataCount()-1);
		
		var ret=dhtmlx.toArray(); //result of method is rich-array
		for (var i=(from||0); i <= to; i++)
			ret.push(this.item(this.order[i]));
		return ret;
	},
	//returns total count of elements
	dataCount:function(){
		return this.order.length;
	},
	//returns truy if item with such ID exists
	exists:function(id){
		return !!(this.pull[id]);
	},
	//nextmethod is not visible on component level, check DataMove.move
	//moves item from source index to the target index
	move:function(sindex,tindex){
		if (sindex<0 || tindex<0){
			dhtmlx.error("DataStore::move","Incorrect indexes");
			return;
		}
		
		var id = this.idByIndex(sindex);
		var obj = this.item(id);
		
		this.order.removeAt(sindex);	//remove at old position
		//if (sindex<tindex) tindex--;	//correct shift, caused by element removing
		this.order.insertAt(id,Math.min(this.order.length, tindex));	//insert at new position
		
		//repaint signal
		this.callEvent("onStoreUpdated",[id,obj,"move"]);
	},
	scheme:function(config){
		/*
			some.scheme({
				order:1,
				name:"dummy",
				title:""
			})
		*/
		this._scheme = config;
		
	},
	sync:function(source, filter, silent){
		if (typeof filter != "function"){
			silent = filter;
			filter = null;
		}
		
		if (dhtmlx.debug_bind){
			this.debug_sync_master = source; 
			dhtmlx.log("[sync] "+this.debug_bind_master.name+"@"+this.debug_bind_master._settings.id+" <= "+this.debug_sync_master.name+"@"+this.debug_sync_master._settings.id);
		}
		
		var topsource = source;
		if (source.name != "DataStore")
			source = source.data;

		var sync_logic = dhtmlx.bind(function(id, data, mode){
			if (mode != "update" || filter) 
				id = null;

			if (!id){
				this.order = dhtmlx.toArray([].concat(source.order));
				this._filter_order = null;
				this.pull = source.pull;
				
				if (filter)
					this.silent(filter);
				
				if (this._on_sync)
					this._on_sync();
			}

			if (dhtmlx.debug_bind)
				dhtmlx.log("[sync:request] "+this.debug_sync_master.name+"@"+this.debug_sync_master._settings.id + " <= "+this.debug_bind_master.name+"@"+this.debug_bind_master._settings.id);
			if (!silent) 
				this.refresh(id);
			else
				silent = false;
		}, this);
		
		source.attachEvent("onStoreUpdated", sync_logic);
		this.feed = function(from, count){
			topsource.loadNext(count, from);
		};
		sync_logic();
	},
	//adds item to the store
	add:function(obj,index){
		
		if (this._scheme){
			obj = obj||{};
			for (var key in this._scheme)
				obj[key] = obj[key]||this._scheme[key];
			if (this._scheme){ 
				if (this._scheme.$init)
					this._scheme.$update(obj);
				else if (this._scheme.$update)
					this._scheme.$update(obj);
			}
		}
		
		//generate id for the item
		var id = this.id(obj);
		
		//by default item is added to the end of the list
		var data_size = this.dataCount();
		
		if (dhtmlx.isNotDefined(index) || index < 0)
			index = data_size; 
		//check to prevent too big indexes			
		if (index > data_size){
			dhtmlx.log("Warning","DataStore:add","Index of out of bounds");
			index = Math.min(this.order.length,index);
		}
		if (this.callEvent("onBeforeAdd", [id, obj, index]) === false) return false;

		if (this.exists(id)) return dhtmlx.error("Not unique ID");
		
		this.pull[id]=obj;
		this.order.insertAt(id,index);
		if (this._filter_order){	//adding during filtering
			//we can't know the location of new item in full dataset, making suggestion
			//put at end by default
			var original_index = this._filter_order.length;
			//put at start only if adding to the start and some data exists
			if (!index && this.order.length)
				original_index = 0;
			
			this._filter_order.insertAt(id,original_index);
		}
		this.callEvent("onafterAdd",[id,index]);
		//repaint signal
		this.callEvent("onStoreUpdated",[id,obj,"add"]);
		return id;
	},
	
	//removes element from datastore
	remove:function(id){
		//id can be an array of IDs - result of getSelect, for example
		if (id instanceof Array){
			for (var i=0; i < id.length; i++)
				this.remove(id[i]);
			return;
		}
		if (this.callEvent("onBeforeDelete",[id]) === false) return false;
		if (!this.exists(id)) return dhtmlx.error("Not existing ID",id);
		var obj = this.item(id);	//save for later event
		//clear from collections
		this.order.remove(id);
		if (this._filter_order) 
			this._filter_order.remove(id);
			
		delete this.pull[id];
		this.callEvent("onafterdelete",[id]);
		//repaint signal
		this.callEvent("onStoreUpdated",[id,obj,"delete"]);
	},
	//deletes all records in datastore
	clearAll:function(){
		//instead of deleting one by one - just reset inner collections
		this.pull = {};
		this.order = dhtmlx.toArray();
		this.feed = null;
		this._filter_order = null;
		this.callEvent("onClearAll",[]);
		this.refresh();
	},
	//converts id to index
	idByIndex:function(index){
		if (index>=this.order.length || index<0)
			dhtmlx.log("Warning","DataStore::idByIndex Incorrect index");
			
		return this.order[index];
	},
	//converts index to id
	indexById:function(id){
		var res = this.order.find(id);	//slower than idByIndex
		
		//if (!this.pull[id])
		//	dhtmlx.log("Warning","DataStore::indexById Non-existing ID: "+ id);
			
		return res;
	},
	//returns ID of next element
	next:function(id,step){
		return this.order[this.indexById(id)+(step||1)];
	},
	//returns ID of first element
	first:function(){
		return this.order[0];
	},
	//returns ID of last element
	last:function(){
		return this.order[this.order.length-1];
	},
	//returns ID of previous element
	previous:function(id,step){
		return this.order[this.indexById(id)-(step||1)];
	},
	/*
		sort data in collection
			by - settings of sorting
		
		or
		
			by - sorting function
			dir - "asc" or "desc"
			
		or
		
			by - property
			dir - "asc" or "desc"
			as - type of sortings
		
		Sorting function will accept 2 parameters and must return 1,0,-1, based on desired order
	*/
	sort:function(by, dir, as){
		var sort = by;	
		if (typeof by == "function")
			sort = {as:by, dir:dir};
		else if (typeof by == "string")
			sort = {by:by, dir:dir, as:as};		
		
		
		var parameters = [sort.by, sort.dir, sort.as];
		if (!this.callEvent("onbeforesort",parameters)) return;	
		
		if (this.order.length){
			var sorter = dhtmlx.sort.create(sort);
			//get array of IDs
			var neworder = this.getRange(this.first(), this.last());
			neworder.sort(sorter);
			this.order = neworder.map(function(obj){ return this.id(obj); },this);
		}
		
		//repaint self
		this.refresh();
		
		this.callEvent("onaftersort",parameters);
	},
	/*
		Filter datasource
		
		text - property, by which filter
		value - filter mask
		
		or
		
		text  - filter method
		
		Filter method will receive data object and must return true or false
	*/
	filter:function(text,value){
		if (!this.callEvent("onBeforeFilter", [text, value])) return;
		
		//remove previous filtering , if any
		if (this._filter_order){
			this.order = this._filter_order;
			delete this._filter_order;
		}
		
		if (!this.order.length) return;
		
		//if text not define -just unfilter previous state and exit
		if (text){
			var filter = text;
			value = value||"";
			if (typeof text == "string"){
				text = dhtmlx.Template.fromHTML(text);
				value = value.toString().toLowerCase();
				filter = function(obj,value){	//default filter - string start from, case in-sensitive
					return text(obj).toLowerCase().indexOf(value)!=-1;
				};
			}
			
					
			var neworder = dhtmlx.toArray();
			for (var i=0; i < this.order.length; i++){
				var id = this.order[i];
				if (filter(this.item(id),value))
					neworder.push(id);
			}
			//set new order of items, store original
			this._filter_order = this.order;
			this.order = neworder;
		}
		//repaint self
		this.refresh();
		
		this.callEvent("onAfterFilter", []);
	},
	/*
		Iterate through collection
	*/
	each:function(method,master){
		for (var i=0; i<this.order.length; i++)
			method.call((master||this), this.item(this.order[i]));
	},
	/*
		map inner methods to some distant object
	*/
	provideApi:function(target,eventable){
		this.debug_bind_master = target;
			
		if (eventable){
			this.mapEvent({
				onbeforesort:	target,
				onaftersort:	target,
				onbeforeadd:	target,
				onafteradd:		target,
				onbeforedelete:	target,
				onafterdelete:	target,
				onbeforeupdate: target/*,
				onafterfilter:	target,
				onbeforefilter:	target*/
			});
		}
			
		var list = ["get","set","sort","add","remove","exists","idByIndex","indexById","item","update","refresh","dataCount","filter","next","previous","clearAll","first","last","serialize"];
		for (var i=0; i < list.length; i++)
			target[list[i]]=dhtmlx.methodPush(this,list[i]);
			
		if (dhtmlx.assert_enabled())		
			this.assert_event(target);
	},
	/*
		serializes data to a json object
	*/
	serialize: function(){
		var ids = this.order;
		var result = [];
		for(var i=0; i< ids.length;i++)
			result.push(this.pull[ids[i]]); 
		return result;
	}
};

dhtmlx.sort = {
	create:function(config){
		return dhtmlx.sort.dir(config.dir, dhtmlx.sort.by(config.by, config.as));
	},
	as:{
		"int":function(a,b){
			a = a*1; b=b*1;
			return a>b?1:(a<b?-1:0);
		},
		"string_strict":function(a,b){
			a = a.toString(); b=b.toString();
			return a>b?1:(a<b?-1:0);
		},
		"string":function(a,b){
			a = a.toString().toLowerCase(); b=b.toString().toLowerCase();
			return a>b?1:(a<b?-1:0);
		}
	},
	by:function(prop, method){
		if (!prop)
			return method;
		if (typeof method != "function")
			method = dhtmlx.sort.as[method||"string"];
		prop = dhtmlx.Template.fromHTML(prop);
		return function(a,b){
			return method(prop(a),prop(b));
		};
	},
	dir:function(prop, method){
		if (prop == "asc")
			return method;
		return function(a,b){
			return method(a,b)*-1;
		};
	}
};



/* DHX DEPEND FROM FILE 'key.js'*/


/*
	Behavior:KeyEvents - hears keyboard 
*/
dhtmlx.KeyEvents = {
	_init:function(){
		//attach handler to the main container
		dhtmlx.event(this._obj,"keypress",this._onKeyPress,this);
	},
	//called on each key press , when focus is inside of related component
	_onKeyPress:function(e){
		e=e||event;
		var code = e.which||e.keyCode; //FIXME  better solution is required
		this.callEvent((this._edit_id?"onEditKeyPress":"onKeyPress"),[code,e.ctrlKey,e.shiftKey,e]);
	}
};


/* DHX DEPEND FROM FILE 'mouse.js'*/


/*
	Behavior:MouseEvents - provides inner evnets for  mouse actions
*/
dhtmlx.MouseEvents={
	_init: function(){
		//attach dom events if related collection is defined
		if (this.on_click){
			dhtmlx.event(this._obj,"click",this._onClick,this);
			dhtmlx.event(this._obj,"contextmenu",this._onContext,this);
		}
		if (this.on_dblclick)
			dhtmlx.event(this._obj,"dblclick",this._onDblClick,this);
		if (this.on_mouse_move){
			dhtmlx.event(this._obj,"mousemove",this._onMouse,this);
			dhtmlx.event(this._obj,(dhtmlx._isIE?"mouseleave":"mouseout"),this._onMouse,this);
		}

	},
	//inner onclick object handler
	_onClick: function(e) {
		return this._mouseEvent(e,this.on_click,"ItemClick");
	},
	//inner ondblclick object handler
	_onDblClick: function(e) {
		return this._mouseEvent(e,this.on_dblclick,"ItemDblClick");
	},
	//process oncontextmenu events
	_onContext: function(e) {
		var id = dhtmlx.html.locate(e, this._id);
		if (id && !this.callEvent("onBeforeContextMenu", [id,e]))
			return dhtmlx.html.preventEvent(e);
	},
	/*
		event throttler - ignore events which occurs too fast
		during mouse moving there are a lot of event firing - we need no so much
		also, mouseout can fire when moving inside the same html container - we need to ignore such fake calls
	*/
	_onMouse:function(e){
		if (dhtmlx._isIE)	//make a copy of event, will be used in timed call
			e = document.createEventObject(event);
			
		if (this._mouse_move_timer)	//clear old event timer
			window.clearTimeout(this._mouse_move_timer);
				
		//this event just inform about moving operation, we don't care about details
		this.callEvent("onMouseMoving",[e]);
		//set new event timer
		this._mouse_move_timer = window.setTimeout(dhtmlx.bind(function(){
			//called only when we have at least 100ms after previous event
			if (e.type == "mousemove")
				this._onMouseMove(e);
			else
				this._onMouseOut(e);
		},this),500);
	},
	//inner mousemove object handler
	_onMouseMove: function(e) {
		if (!this._mouseEvent(e,this.on_mouse_move,"MouseMove"))
			this.callEvent("onMouseOut",[e||event]);
	},
	//inner mouseout object handler
	_onMouseOut: function(e) {
		this.callEvent("onMouseOut",[e||event]);
	},
	//common logic for click and dbl-click processing
	_mouseEvent:function(e,hash,name){
		e=e||event;
		var trg=e.target||e.srcElement;
		var css = "";
		var id = null;
		var found = false;
		//loop through all parents
		while (trg && trg.parentNode){
			if (!found && trg.getAttribute){													//if element with ID mark is not detected yet
				id = trg.getAttribute(this._id);							//check id of current one
				if (id){
					if (trg.getAttribute("userdata"))
						this.callEvent("onLocateData",[id,trg]);
					if (!this.callEvent("on"+name,[id,e,trg])) return;		//it will be triggered only for first detected ID, in case of nested elements
					found = true;											//set found flag
				}
			}
			css=trg.className;
			if (css){		//check if pre-defined reaction for element's css name exists
				css = css.split(" ");
				css = css[0]||css[1]; //FIXME:bad solution, workaround css classes which are starting from whitespace
				if (hash[css])
					return  hash[css].call(this,e,id||dhtmlx.html.locate(e, this._id),trg);
			}
			trg=trg.parentNode;
		}		
		return found;	//returns true if item was located and event was triggered
	}
};




/* DHX DEPEND FROM FILE 'config.js'*/


/*
	Behavior:Settings
	
	@export
		customize
		config
*/

/*DHX:Depend template.js*/
/*DHX:Depend dhtmlx.js*/

dhtmlx.Settings={
	_init:function(){
		/* 
			property can be accessed as this.config.some
			in same time for inner call it have sense to use _settings
			because it will be minified in final version
		*/
		this._settings = this.config= {}; 
	},
	define:function(property, value){
		if (typeof property == "object")
			return this._parseSeetingColl(property);
		return this._define(property, value);
	},
	_define:function(property,value){
		dhtmlx.assert_settings.call(this,property,value);
		
		//method with name {prop}_setter will be used as property setter
		//setter is optional
		var setter = this[property+"_setter"];
		return this._settings[property]=setter?setter.call(this,value):value;
	},
	//process configuration object
	_parseSeetingColl:function(coll){
		if (coll){
			for (var a in coll)				//for each setting
				this._define(a,coll[a]);		//set value through config
		}
	},
	//helper for object initialization
	_parseSettings:function(obj,initial){
		//initial - set of default values
		var settings = dhtmlx.extend({},initial);
		//code below will copy all properties over default one
		if (typeof obj == "object" && !obj.tagName)
			dhtmlx.extend(settings,obj);	
		//call config for each setting
		this._parseSeetingColl(settings);
	},
	_mergeSettings:function(config, defaults){
		for (var key in defaults)
			switch(typeof config[key]){
				case "object": 
					config[key] = this._mergeSettings((config[key]||{}), defaults[key]);
					break;
				case "undefined":
					config[key] = defaults[key];
					break;
				default:	//do nothing
					break;
			}
		return config;
	},
	//helper for html container init
	_parseContainer:function(obj,name,fallback){
		/*
			parameter can be a config object, in such case real container will be obj.container
			or it can be html object or ID of html object
		*/
		if (typeof obj == "object" && !obj.tagName) 
			obj=obj.container;
		this._obj = this.$view = dhtmlx.toNode(obj);
		if (!this._obj && fallback)
			this._obj = fallback(obj);
			
		dhtmlx.assert(this._obj, "Incorrect html container");
		
		this._obj.className+=" "+name;
		this._obj.onselectstart=function(){return false;};	//block selection by default
		this._dataobj = this._obj;//separate reference for rendering modules
	},
	//apply template-type
	_set_type:function(name){
		//parameter can be a hash of settings
		if (typeof name == "object")
			return this.type_setter(name);
		
		dhtmlx.assert(this.types, "RenderStack :: Types are not defined");
		dhtmlx.assert(this.types[name],"RenderStack :: Inccorect type name",name);
		//or parameter can be a name of existing template-type	
		this.type=dhtmlx.extend({},this.types[name]);
		this.customize();	//init configs
	},
	customize:function(obj){
		//apply new properties
		if (obj) dhtmlx.extend(this.type,obj);
		
		//init tempaltes for item start and item end
		this.type._item_start = dhtmlx.Template.fromHTML(this.template_item_start(this.type));
		this.type._item_end = this.template_item_end(this.type);
		
		//repaint self
		this.render();
	},
	//config.type - creates new template-type, based on configuration object
	type_setter:function(value){
		this._set_type(typeof value == "object"?dhtmlx.Type.add(this,value):value);
		return value;
	},
	//config.template - creates new template-type with defined template string
	template_setter:function(value){
		return this.type_setter({template:value});
	},
	//config.css - css name for top level container
	css_setter:function(value){
		this._obj.className += " "+value;
		return value;
	}
};



/* DHX DEPEND FROM FILE 'template.js'*/


/*
	Template - handles html templates
*/

/*DHX:Depend dhtmlx.js*/

dhtmlx.Template={
	_cache:{
	},
	empty:function(){	
		return "";	
	},
	setter:function(value){
		return dhtmlx.Template.fromHTML(value);
	},
	obj_setter:function(value){
		var f = dhtmlx.Template.setter(value);
		var obj = this;
		return function(){
			return f.apply(obj, arguments);
		};
	},
	fromHTML:function(str){
		if (typeof str == "function") return str;
		if (this._cache[str])
			return this._cache[str];
			
	//supported idioms
	// {obj} => value
	// {obj.attr} => named attribute or value of sub-tag in case of xml
	// {obj.attr?some:other} conditional output
	// {-obj => sub-template
		str=(str||"").toString();		
		str=str.replace(/[\r\n]+/g,"\\n");
		str=str.replace(/\{obj\.([^}?]+)\?([^:]*):([^}]*)\}/g,"\"+(obj.$1?\"$2\":\"$3\")+\"");
		str=str.replace(/\{common\.([^}\(]*)\}/g,"\"+common.$1+\"");
		str=str.replace(/\{common\.([^\}\(]*)\(\)\}/g,"\"+(common.$1?common.$1(obj):\"\")+\"");
		str=str.replace(/\{obj\.([^}]*)\}/g,"\"+obj.$1+\"");
		str=str.replace(/#([a-z0-9_]+)#/gi,"\"+obj.$1+\"");
		str=str.replace(/\{obj\}/g,"\"+obj+\"");
		str=str.replace(/\{-obj/g,"{obj");
		str=str.replace(/\{-common/g,"{common");
		str="return \""+str+"\";";
		return this._cache[str]= Function("obj","common",str);
	}
};

dhtmlx.Type={
	/*
		adds new template-type
		obj - object to which template will be added
		data - properties of template
	*/
	add:function(obj, data){ 
		//auto switch to prototype, if name of class was provided
		if (!obj.types && obj.prototype.types)
			obj = obj.prototype;
		//if (typeof data == "string")
		//	data = { template:data };
			
		if (dhtmlx.assert_enabled())
			this.assert_event(data);
		
		var name = data.name||"default";
		
		//predefined templates - autoprocessing
		this._template(data);
		this._template(data,"edit");
		this._template(data,"loading");
		
		obj.types[name]=dhtmlx.extend(dhtmlx.extend({},(obj.types[name]||this._default)),data);	
		return name;
	},
	//default template value - basically empty box with 5px margin
	_default:{
		css:"default",
		template:function(){ return ""; },
		template_edit:function(){ return ""; },
		template_loading:function(){ return "..."; },
		width:150,
		height:80,
		margin:5,
		padding:0
	},
	//template creation helper
	_template:function(obj,name){ 
		name = "template"+(name?("_"+name):"");
		var data = obj[name];
		//if template is a string - check is it plain string or reference to external content
		if (data && (typeof data == "string")){
			if (data.indexOf("->")!=-1){
				data = data.split("->");
				switch(data[0]){
					case "html": 	//load from some container on the page
						data = dhtmlx.html.getValue(data[1]).replace(/\"/g,"\\\"");
						break;
					case "http": 	//load from external file
						data = new dhtmlx.ajax().sync().get(data[1],{uid:(new Date()).valueOf()}).responseText;
						break;
					default:
						//do nothing, will use template as is
						break;
				}
			}
			obj[name] = dhtmlx.Template.fromHTML(data);
		}
	}
};


/* DHX DEPEND FROM FILE 'single_render.js'*/


/*
	REnders single item. 
	Can be used for elements without datastore, or with complex custom rendering logic
	
	@export
		render
*/

/*DHX:Depend template.js*/

dhtmlx.SingleRender={
	_init:function(){
	},
	//convert item to the HTML text
	_toHTML:function(obj){
			/*
				this one doesn't support per-item-$template
				it has not sense, because we have only single item per object
			*/
			return this.type._item_start(obj,this.type)+this.type.template(obj,this.type)+this.type._item_end;
	},
	//render self, by templating data object
	render:function(){
		if (!this.callEvent || this.callEvent("onBeforeRender",[this.data])){
			if (this.data)
				this._dataobj.innerHTML = this._toHTML(this.data);
			if (this.callEvent) this.callEvent("onAfterRender",[]);
		}
	}
};


/* DHX DEPEND FROM FILE 'tooltip.js'*/


/*
	UI: Tooltip
	
	@export
		show
		hide
*/

/*DHX:Depend tooltip.css*/
/*DHX:Depend template.js*/
/*DHX:Depend single_render.js*/

dhtmlx.ui.Tooltip=function(container){
	this.name = "Tooltip";
	this.version = "3.0";
	
	if (dhtmlx.assert_enabled()) this._assert();

	if (typeof container == "string"){
		container = { template:container };
	}
		
	dhtmlx.extend(this, dhtmlx.Settings);
	dhtmlx.extend(this, dhtmlx.SingleRender);
	this._parseSettings(container,{
		type:"default",
		dy:0,
		dx:20
	});
	
	//create  container for future tooltip
	this._dataobj = this._obj = document.createElement("DIV");
	this._obj.className="dhx_tooltip";
	dhtmlx.html.insertBefore(this._obj,document.body.firstChild);
};
dhtmlx.ui.Tooltip.prototype = {
	//show tooptip
	//pos - object, pos.x - left, pox.y - top
	show:function(data,pos){
		if (this._disabled) return;
		//render sefl only if new data was provided
		if (this.data!=data){
			this.data=data;
			this.render(data);
		}
		//show at specified position
		this._obj.style.top = pos.y+this._settings.dy+"px";
		this._obj.style.left = pos.x+this._settings.dx+"px";
		this._obj.style.display="block";
	},
	//hide tooltip
	hide:function(){
		this.data=null; //nulify, to be sure that on next show it will be fresh-rendered
		this._obj.style.display="none";
	},
	disable:function(){
		this._disabled = true;	
	},
	enable:function(){
		this._disabled = false;
	},
	types:{
		"default":dhtmlx.Template.fromHTML("{obj.id}")
	},
	template_item_start:dhtmlx.Template.empty,
	template_item_end:dhtmlx.Template.empty
};



/* DHX DEPEND FROM FILE 'autotooltip.js'*/


/*
	Behavior: AutoTooltip - links tooltip to data driven item
*/

/*DHX:Depend tooltip.js*/

dhtmlx.AutoTooltip = {
	tooltip_setter:function(value){
		var t = new dhtmlx.ui.Tooltip(value);
		this.attachEvent("onMouseMove",function(id,e){	//show tooltip on mousemove
			t.show(this.get(id),dhtmlx.html.pos(e));
		});
		this.attachEvent("onMouseOut",function(id,e){	//hide tooltip on mouseout
			t.hide();
		});
		this.attachEvent("onMouseMoving",function(id,e){	//hide tooltip just after moving start
			t.hide();
		});
		return t;
	}
};


/* DHX DEPEND FROM FILE 'compatibility.js'*/


/*
	Collection of compatibility hacks
*/

/*DHX:Depend dhtmlx.js*/

dhtmlx.compat=function(name, obj){
	//check if name hash present, and applies it when necessary
	if (dhtmlx.compat[name])
		dhtmlx.compat[name](obj);
};


/* DHX DEPEND FROM FILE 'compatibility_layout.js'*/


/*DHX:Depend dhtmlx.js*/
/*DHX:Depend compatibility.js*/

if (!dhtmlx.attaches)
	dhtmlx.attaches = {};
	
dhtmlx.attaches.attachAbstract=function(name, conf){
	var obj = document.createElement("DIV");
	obj.id = "CustomObject_"+dhtmlx.uid();
	obj.style.width = "100%";
	obj.style.height = "100%";
	obj.cmp = "grid";
	document.body.appendChild(obj);
	this.attachObject(obj.id);
	
	conf.container = obj.id;
	
	var that = this.vs[this.av];
	that.grid = new window[name](conf);
	
	that.gridId = obj.id;
	that.gridObj = obj;
	
		
	that.grid.setSizes = function(){
		if (this.resize) this.resize();
		else this.render();
	};
	
	var method_name="_viewRestore";
	return this.vs[this[method_name]()].grid;
};
dhtmlx.attaches.attachDataView = function(conf){
	return this.attachAbstract("dhtmlXDataView",conf);
};
dhtmlx.attaches.attachChart = function(conf){
	return this.attachAbstract("dhtmlXChart",conf);
};

dhtmlx.compat.layout = function(){};





/*
Product Name: dhtmlxSuite 
Version: 4.1.3 
Edition: Professional 
License: content of this file is covered by DHTMLX Commercial or Enterprise license. Usage without proper license is prohibited. To obtain it contact sales@dhtmlx.com
Copyright UAB Dinamenta http://www.dhtmlx.com
*/

function dhtmlXCellObject(idd, css) {
	
	this.cell = document.createElement("DIV");
	this.cell.className = "dhx_cell"+(css||"");
	
	this._idd = idd;
	this._isCell = true;
	
	this.conf = {
		borders: true,
		idx: {},
		css: css||"",
		idx_data: {
			cont: "dhx_cell_cont",
			pr1: "dhx_cell_progress_bar",
			pr2: "dhx_cell_progress_img",
			menu: "dhx_cell_menu",
			toolbar: "dhx_cell_toolbar",
			ribbon: "dhx_cell_ribbon",
			sb: "dhx_cell_statusbar"
		},
		ofs_nodes: { t:{}, b:{} }	// attached dataNodes (menu/toolbar/status), can be true, false;
						// in case of layout - "func" for header
	}
	
	this.dataNodes = {}; // menu/toolbar/status
	
	this.views = {};
	
	// cont
	var p = document.createElement("DIV");
	p.className = "dhx_cell_cont"+this.conf.css;
	this.cell.appendChild(p);
	p = null;
	
	this._updateIdx = function() {
		for (var a in this.conf.idx) {
			this.conf.idx[a] = null;
			delete this.conf.idx[a];
		}
		for (var q=0; q<this.cell.childNodes.length; q++) {
			var css = this.cell.childNodes[q].className;
			for (var a in this.conf.idx_data) {
				var r = new RegExp(this.conf.idx_data[a]);
				if (css.match(r) != null) this.conf.idx[a] = q;
			}
		}
		
		this.callEvent("_onIdxUpdated",[]);
	}
	
	this._adjustAttached = function() {
		// mtb/ribbon
		for (var a in this.dataNodes) {
			if (this.dataNodes[a] != null && typeof(this.dataNodes[a].setSizes) == "function") {
				this.dataNodes[a].setSizes();
			}
		}
		// attached node
		if (this.dataObj != null && typeof(this.dataObj.setSizes) == "function") {
			// check if dataObj is layuot which was attached separately
			if (this.dataType == "layout" && typeof(window.dhtmlXLayoutCell) != "undefined" && this instanceof window.dhtmlXLayoutCell && this.dataObj._getMainInst() != this.layout._getMainInst()) {
				this.dataObj.setSizes();
				return;
			}
			this.dataObj.setSizes.apply(this.dataObj, arguments);
		}
	}
	
	this._setSize = function(x, y, w, h, parentIdd, noCalcCont, actionType, customProps) {
		
		if (this.conf.size == null) this.conf.size = {};
		if (customProps == null) customProps = {}; // ability to use margin-left instead of left
		
		var styleProps = {left: "x", top: "y", width: "w", height: "h"};
		
		this.conf.size.x = x;
		this.conf.size.y = y;
		this.conf.size.w = Math.max(w,0);
		this.conf.size.h = Math.max(h,0);
		
		for (var a in styleProps) {
			var name = (customProps[a]||a);
			this.cell.style[name] = this.conf.size[styleProps[a]]+"px";
		}
		
		this.callEvent("_onSetSize",[]);
		
		if (noCalcCont !== true) {
			this._adjustCont(parentIdd, actionType);
		} else {
			this._adjustAttached(parentIdd);
		}
		
		this._adjustProgress();
	}
	
	this._adjustCont = function(parentIdd, actionType) {
		
		var t = this.cell.childNodes[this.conf.idx.cont];
		
		// header height, menu, toolbar if any
		var ht = 0;
		for (var a in this.conf.ofs_nodes.t) {
			var k = this.conf.ofs_nodes.t[a];
			ht += (k=="func"?this[a]():(k==true?this.cell.childNodes[this.conf.idx[a]].offsetHeight:0));
		}
		
		// bottom offset (height reduce if status attached)
		var hb = 0;
		for (var a in this.conf.ofs_nodes.b) {
			var k = this.conf.ofs_nodes.b[a];
			hb += (k=="func"?this[a]():(k==true?this.cell.childNodes[this.conf.idx[a]].offsetHeight:0));
		}
		
		t.style.left = "0px";
		t.style.top = ht+"px";
		
		if (!this.conf.cells_cont) {
			this.conf.cells_cont = {};
			t.style.width = this.cell.offsetWidth+"px";
			t.style.height = Math.max(this.cell.offsetHeight-ht-hb,0)+"px";
			this.conf.cells_cont.w = parseInt(t.style.width)-t.offsetWidth;
			this.conf.cells_cont.h = parseInt(t.style.height)-t.offsetHeight;
		}
		
		t.style.left = "0px";
		t.style.top = ht+"px";
		t.style.width = Math.max(this.cell.offsetWidth+this.conf.cells_cont.w,0)+"px";
		t.style.height = Math.max(this.conf.size.h-ht-hb+this.conf.cells_cont.h,0)+"px";
		t = null;
		
		// move out?
		this._adjustAttached(parentIdd); // for layout only 1 arg should be here
		
		// editor adjust cont here, browser check needed ( !!make some tests :)
		if (actionType == "expand" && this.dataType == "editor" && this.dataObj != null) {
			this.dataObj._prepareContent(true);
		}
	}
	
	this._mtbUpdBorder = function() {
		
		var t = ["menu","toolbar"];
		for (var q=0; q<t.length; q++) {
			if (this.conf.idx[t[q]] != null) {
				var p = this.cell.childNodes[this.conf.idx[t[q]]];
				var c1 = "dhx_cell_"+t[q]+"_no_borders";
				var c2 = "dhx_cell_"+t[q]+"_def";
				p.className = p.className.replace(new RegExp(this.conf.borders?c1:c2), this.conf.borders?c2:c1);
				p = null;
			}
		}
	}
	
	this._resetSizeState = function() {
		// delete autosize settings, autocalc for cell_cont borders, paddings, useful on skinchange
		this.conf.cells_cont = null;
	}
	
	/* views */
	
	// test with url and getFrame()
	
	// current view
	this.conf.view = "def";
	
	// views loaded at least once
	this.conf.views_loaded = {};
	this.conf.views_loaded[this.conf.view] = true;
	
	// move current data to archive
	this._viewSave = function(name) {
		
		this.views[name] = {
			borders: this.conf.borders,
			ofs_nodes: {t:{},b:{}},
			dataType: this.dataType,
			dataObj: this.dataObj,
			cellCont: [],
			dataNodes: {},
			dataNodesCont: {}
		};
		
		// attached cont
		var cellCont = this.cell.childNodes[this.conf.idx.cont];
		while (cellCont.childNodes.length > 0) {
			this.views[name].cellCont.push(cellCont.firstChild);
			cellCont.removeChild(cellCont.firstChild);
		}
		
		this.dataType = null;
		this.dataObj = null;
		
		// menu/toolbar/status
		for (var a in this.dataNodes) {
			
			for (var b in this.conf.ofs_nodes) {
				if (typeof(this.conf.ofs_nodes[b][a]) != "undefined") {
					this.views[name].ofs_nodes[b][a] = this.conf.ofs_nodes[b][a];
					this.conf.ofs_nodes[b][a] = null;
					delete this.conf.ofs_nodes[b][a];
				}
			}
			
			this.views[name].dataNodesCont[a] = this.cell.childNodes[this.conf.idx[a]];
			this.cell.removeChild(this.cell.childNodes[this.conf.idx[a]]);
			
			this.views[name].dataNodes[a] = this.dataNodes[a];
			this.dataNodes[a] = null;
			delete this.dataNodes[a];
			
			this._updateIdx();
		}
		
		this.callEvent("_onViewSave", [name]);
		
	}
	
	this._viewRestore = function(name) {
		
		if (this.views[name] == null) return;
		
		// content
		this.dataObj = this.views[name].dataObj;
		this.dataType = this.views[name].dataType;
		for (var q=0; q<this.views[name].cellCont.length; q++) this.cell.childNodes[this.conf.idx.cont].appendChild(this.views[name].cellCont[q]);
		
		// data nodes (menu/toolbar/status)
		for (var a in this.views[name].dataNodes) {
			
			this.dataNodes[a] = this.views[name].dataNodes[a];
			// below is not very universal solution for extending
			if (a == "menu") this.cell.insertBefore(this.views[name].dataNodesCont[a], this.cell.childNodes[this.conf.idx.toolbar||this.conf.idx.cont]);
			if (a == "toolbar") this.cell.insertBefore(this.views[name].dataNodesCont[a], this.cell.childNodes[this.conf.idx.cont]);
			if (a == "sb") this.cell.appendChild(this.views[name].dataNodesCont[a]);
			
			this._updateIdx();
		}
		
		// ofs_nodes
		for (var a in this.views[name].ofs_nodes) {
			for (var b in this.views[name].ofs_nodes[a]) this.conf.ofs_nodes[a][b] = this.views[name].ofs_nodes[a][b];
		}
		
		if (this.conf.borders != this.views[name].borders) {
			this[this.views[name].borders?"_showBorders":"_hideBorders"](true);
		}
		
		this.callEvent("_onViewRestore", [name]);
		
		this._viewDelete(name);
		
	}
	
	this._viewDelete = function(name) {
		
		if (this.views[name] == null) return;
		
		this.views[name].borders = null;
		
		for (var a in this.views[name].ofs_nodes) {
			for (var b in this.views[name].ofs_nodes[a]) this.views[name].ofs_nodes[a][b] = null;
			this.views[name].ofs_nodes[a] = null;
		}
		
		this.views[name].dataType = null;
		this.views[name].dataObj = null;
		
		for (var q=0; q<this.views[name].cellCont.length; q++) this.views[name].cellCont[q] = null;
		this.views[name].cellCont = null;
		
		for (var a in this.views[name].dataNodes) {
			this.views[name].dataNodes[a] = null;
			this.views[name].dataNodesCont[a] = null;
		}
		
		this.views[name].dataNodes = this.views[name].dataNodesCont = null;
		
		this.views[name] = null;
		delete this.views[name];
		
	}
	
	/* views end */
	
	window.dhx4._eventable(this);
	this._updateIdx();
	
	return this;
	
};

// views
dhtmlXCellObject.prototype.showView = function(name) {
	
	if (this.conf.view == name) return false; // alredy visible
	
	// save current view
	this._viewSave(this.conf.view);
	
	// restore requested view if exists
	this._viewRestore(name);
	
	// update cell rendering
	this._updateIdx();
	this._adjustCont();
	
	this.conf.view = name;
	
	var t = (typeof(this.conf.views_loaded[this.conf.view]) == "undefined");
	this.conf.views_loaded[this.conf.view] = true;
	
	return t;
	
};

dhtmlXCellObject.prototype.getViewName = function() {
	return this.conf.view;
};

dhtmlXCellObject.prototype.unloadView = function(name) {
	// hidden view, unload menu/toolbar/status, etc
	
	// unload actve view
	if (name == this.conf.view) {
		
		// set unloading flag to prevent some adjust operations
		var t = this.conf.unloading;
		this.conf.unloading = true;
		
		// remove content
		if (typeof(this.detachMenu) == "function") this.detachMenu();
		if (typeof(this.detachToolbar) == "function") this.detachToolbar();
		if (typeof(this.detachRibbon) == "function") this.detachRibbon();
		this.detachStatusBar();
		this._detachObject(null, true);
		
		// restore unloading flag
		this.conf.unloading = t;
		if (!this.conf.unloading) this._adjustCont(this._idd);
		
		return;
	}
	
	if (this.views[name] == null) return;
	
	var v = this.views[name];
	for (var a in v.dataNodes) {
		if (typeof(v.dataNodes[a].unload) == "function") v.dataNodes[a].unload();
		v.dataNodes[a] = null;
		v.dataNodesCont[a] = null;
	}
	if (v.dataType == "url") {
		if (v.cellCont != null && v.cellCont[0] != "null") {
			this._detachURLEvents(v.cellCont[0]);
		}
	} else if (v.dataObj != null) {
		if (typeof(v.dataObj.unload) == "function") {
			v.dataObj.unload();
		} else if (typeof(v.dataObj.destructor) == "function") {
			v.dataObj.destructor();
		}
		v.dataObj = null;
	}
	v = null;
	
	this._viewDelete(name);
	
	if (typeof(this.conf.views_loaded[name]) != "undefined") {
		delete this.conf.views_loaded[name];
	}
	
};


// id
dhtmlXCellObject.prototype.getId = function() {
	return this._idd;
};

// progress
dhtmlXCellObject.prototype.progressOn = function() {
	
	if (this.conf.progress) return;
	
	this.conf.progress = true;
	
	var t1 = document.createElement("DIV");
	t1.className = "dhx_cell_progress_bar";
	this.cell.appendChild(t1);
	
	var t2 = document.createElement("DIV");
	t2.className = "dhx_cell_progress_img";
	this.cell.appendChild(t2);
	
	t1 = t2 = null;
	
	this._updateIdx();
	this._adjustProgress();
	
};

dhtmlXCellObject.prototype.progressOff = function() {
	
	if (!this.conf.progress) return;
	
	this.cell.childNodes[this.conf.idx.pr2].parentNode.removeChild(this.cell.childNodes[this.conf.idx.pr2]);
	this.cell.childNodes[this.conf.idx.pr1].parentNode.removeChild(this.cell.childNodes[this.conf.idx.pr1]);
	
	this.conf.progress = false;
	
	this._updateIdx();
};

dhtmlXCellObject.prototype._adjustProgress = function() {
	
	if (this.conf.idx.pr1 == null) return;
	
	if (!this.conf.pr) this.conf.pr = {};
	
	var p1 = this.cell.childNodes[this.conf.idx.pr1]; // half-transparent cover
	var p2 = this.cell.childNodes[this.conf.idx.pr2]; // image
	
	if (!this.conf.pr.ofs) {
		p2.style.width = p1.offsetWidth + "px";
		p2.style.height = p1.offsetHeight + "px";
		this.conf.pr.ofs = {
			w: p2.offsetWidth-p2.clientWidth,
			h: p2.offsetHeight-p2.clientHeight
		};
	}
	
	p2.style.width = p1.offsetWidth - this.conf.pr.ofs.w + "px";
	p2.style.height = p1.offsetHeight - this.conf.pr.ofs.h + "px";
	
	p1 = p2 = null;
};

// borders
dhtmlXCellObject.prototype._showBorders = function(noAdjust) {
	
	if (this.conf.borders) return;
	
	this.conf.borders = true;
	
	this.cell.childNodes[this.conf.idx.cont].className = "dhx_cell_cont"+this.conf.css;
	
	this.conf.cells_cont = null;
	this._mtbUpdBorder();
	
	this.callEvent("_onBorderChange",[true]);
	
	if (noAdjust !== true) this._adjustCont(this._idd);
	
};
	
dhtmlXCellObject.prototype._hideBorders = function(noAdjust) {
	
	if (!this.conf.borders) return;
	
	this.conf.borders = false;
	
	this.cell.childNodes[this.conf.idx.cont].className = "dhx_cell_cont"+this.conf.css+" dhx_cell_cont_no_borders";
	this.conf.cells_cont = null;
	this._mtbUpdBorder();
	
	this.callEvent("_onBorderChange",[false]);
	
	if (noAdjust !== true) this._adjustCont(this._idd);
	
};

// basic width/height
dhtmlXCellObject.prototype._getWidth = function() {
	return this.cell.offsetWidth;
};

dhtmlXCellObject.prototype._getHeight = function() {
	return this.cell.offsetHeight;
};


dhtmlXCellObject.prototype.showInnerScroll = function() {
	this.cell.childNodes[this.conf.idx.cont].style.overflow = "auto";
};

/* unload */
dhtmlXCellObject.prototype._unload = function() {
	
	this.conf.unloading = true;
	
	this.callEvent("_onCellUnload",[]);
	
	this.progressOff();
	
	// unload current view (remove attached content)
	this.unloadView(this.conf.view);
	
	this.dataNodes = null;
	
	this.cell.parentNode.removeChild(this.cell);
	this.cell = null;
	
	window.dhx4._eventable(this, "clear");
	
	// views
	for (var a in this.views) this.unloadView(a);
	
	this.conf = null;
	
	// others
	for (var a in this) this[a] = null; // no mercy
	
};


dhtmlXCellObject.prototype.attachObject = function(obj, adjust) {
	
	// adjust - for windows only
	if (window.dhx4.s2b(adjust) && !(typeof(window.dhtmlXWindowsCell) != "undefined" && (this instanceof window.dhtmlXWindowsCell))) {
		adjust = false;
	}
	
	if (typeof(obj) == "string") obj = document.getElementById(obj);
	
	// already attached
	if (obj.parentNode == this.cell.childNodes[this.conf.idx.cont]) {
		obj = null;
		return;
	}
	
	if (adjust) {
		obj.style.display = "";
		var w = obj.offsetWidth;
		var h = obj.offsetHeight;
	}
	
	this._attachObject(obj);
	this.dataType = "obj";
	obj.style.display = "";
	obj = null;
	
	if (adjust) this._adjustByCont(w,h);
	
};

dhtmlXCellObject.prototype.appendObject = function(obj) {
	
	if (typeof(obj) == "string") obj = document.getElementById(obj);
	
	// already attached
	if (obj.parentNode == this.cell.childNodes[this.conf.idx.cont]) {
		obj = null;
		return;
	}
	
	
	if (!this.conf.append_mode) {
		this.cell.childNodes[this.conf.idx.cont].style.overflow = "auto";
		this.conf.append_mode = true;
	}
	
	this._attachObject(obj, null, null, true);
	this.dataType = "obj";
	obj.style.display = "";
	obj = null;
	
};

dhtmlXCellObject.prototype.detachObject = function(remove, moveTo) {
	this._detachObject(null, remove, moveTo);
};

dhtmlXCellObject.prototype.getAttachedStatusBar = function() {
	return this.dataNodes.sb;
};
dhtmlXCellObject.prototype.getAttachedObject = function() {
	return this.dataObj;
};

dhtmlXCellObject.prototype.attachURL = function(url, useAjax, postData) {
	
	// prepare POST if any, postData should be true or {} otherwise GET
	if (postData == true) postData = {};
	var postReq = (typeof(postData) != "undefined" && postData != false && postData != null);
	
	if (!this.conf.url_data) this.conf.url_data = {};
	this.conf.url_data.url = url;
	this.conf.url_data.ajax = (useAjax == true);
	this.conf.url_data.post_data = (postData==true?{}:(postData||null)); // true or object
	
	if (useAjax == true) {
		
		var t = this;
		if (postReq) {
			var params = "";
			for (var a in postData) params += "&"+encodeURIComponent(a)+"="+encodeURIComponent(postData[a]);

			dhx4.ajax.post(url, params, function(r){
				t.attachHTMLString("<div style='position:relative;width:100%;height:100%;overflow:auto;'>"+r.xmlDoc.responseText+"</div>");
				if (typeof(t._doOnFrameContentLoaded) == "function") t._doOnFrameContentLoaded();
				t.dataType = "url-ajax";
				t = r = null;
			});
		} else {
			dhx4.ajax.get(url, function(r){
				t.attachHTMLString("<div style='position:relative;width:100%;height:100%;overflow:auto;'>"+r.xmlDoc.responseText+"</div>");
				if (typeof(t._doOnFrameContentLoaded) == "function") t._doOnFrameContentLoaded();
				t.dataType = "url-ajax";
				t = r = null;
			});
		}
		
	} else {
		if (this.dataType == "url") {
			var fr = this.getFrame();
		} else {
			var fr = document.createElement("IFRAME");
			fr.frameBorder = 0;
			fr.border = 0;
			fr.style.width = "100%";
			fr.style.height = "100%";
			fr.style.position = "relative";
			this._attachObject(fr);
			this.dataType = "url";
			this._attachURLEvents();
		}
		if (postReq) {
			var firstLoad = (typeof(this.conf.url_data.post_ifr) == "undefined");
			this.conf.url_data.post_ifr = true; // load later
			if (firstLoad) this._attachURLEvents();
			fr.src = "about:blank";
		} else {
			fr.src = url+(window.dhx4.ajax.cache!=true?(url.indexOf("?")>=0?"&":"?")+"dhxr"+new Date().getTime():"");
		}
		fr = null;
	}
	
	fr = null;
};

dhtmlXCellObject.prototype.reloadURL = function() {
	if (!(this.dataType == "url" || this.dataType == "url-ajax")) return;
	if (this.conf.url_data == null) return;
	this.attachURL(this.conf.url_data.url, this.conf.url_data.ajax, this.conf.url_data.post_data);
};

dhtmlXCellObject.prototype.attachHTMLString = function(str) {
	this._attachObject(null, null, str);
	// esec script
	var z = str.match(/<script[^>]*>[^\f]*?<\/script>/g)||[];
	for (var i=0; i<z.length; i++) {
		var s = z[i].replace(/<([\/]{0,1})script[^>]*>/gi,"");
		if (s) {
			if (window.execScript) window.execScript(s); else window.eval(s);
		}
	}
};

dhtmlXCellObject.prototype.attachScheduler = function(day, mode, cont_id, scheduler) {
	
	scheduler = scheduler || window.scheduler;
	
	var ready = false;
	if (cont_id) {
		var obj = document.getElementById(cont_id);
		if (obj) ready = true;
	}
	if (!ready) {
		var tabs = cont_id || '<div class="dhx_cal_tab" name="day_tab" style="right:204px;"></div><div class="dhx_cal_tab" name="week_tab" style="right:140px;"></div><div class="dhx_cal_tab" name="month_tab" style="right:76px;"></div>';
		var obj = document.createElement("DIV");
		obj.id = "dhxSchedObj_"+new Date().getTime();
		obj.style.width = "100%";
		obj.style.height = "100%";
		obj.style.position = "relative";
		obj.style.overflow = "hidden";
		obj.className = "dhx_cal_container";
		obj.innerHTML = '<div class="dhx_cal_navline"><div class="dhx_cal_prev_button">&nbsp;</div><div class="dhx_cal_next_button">&nbsp;</div><div class="dhx_cal_today_button"></div><div class="dhx_cal_date"></div>'+tabs+'</div><div class="dhx_cal_header"></div><div class="dhx_cal_data"></div>';
	}
	
	this._attachObject(obj);
	
	this.dataType = "scheduler";
	this.dataObj = scheduler;
	this.dataObj.setSizes = function(){
		this.update_view();
	}
	
	scheduler.init(obj.id, day, mode);
	
	obj = null;
	
	this.callEvent("_onContentAttach",[]);
	
	return this.dataObj;
};

dhtmlXCellObject.prototype.attachMap = function(opts) {
	
	var obj = document.createElement("DIV");
	obj.id = "GMapsObj_"+this._genStr(12);
	obj.style.width = "100%";
	obj.style.height = "100%";
	obj.style.position = "relative";
	obj.style.overflow = "hidden";
	this._attachObject(obj);
	
	if (!opts) opts = {center: new google.maps.LatLng(40.719837,-73.992348), zoom: 11, mapTypeId: google.maps.MapTypeId.ROADMAP};
	
	this.dataType = "maps";
	this.dataObj = new google.maps.Map(obj, opts);
	
	this.dataObj.setSizes = function() {
		google.maps.event.trigger(this, "resize");
	}
	
	obj = null;
	
	this.callEvent("_onContentAttach",[]);
	
	return this.dataObj;
	
};

// status bar
dhtmlXCellObject.prototype._createNode_sb = function(obj, type, htmlString, append, node) {
	// type -> (object) conf={text:string,height:number}
	if (typeof(node) != "undefined") {
		obj = node;
	} else {
		var conf = type||{};
		var text = (typeof(conf.text)=="string" && conf.text.length > 0 ? conf.text : "&nbsp;");
		var h = (typeof(conf.height) == "number" ? conf.height : false);
		var obj = document.createElement("DIV");
		
		obj.className = "dhx_cell_statusbar_def";
		obj.innerHTML = "<div class='"+(conf.paging==true?"dhx_cell_statusbar_paging":"dhx_cell_statusbar_text")+"'>"+text+"</div>";
		
		// height, optional
		if (h != false) obj.firstChild.style.height = obj.firstChild.style.lineHeight = h+"px";
	}
	
	// before progress or last
	if (this.conf.idx.pr1 != null) {
		this.cell.insertBefore(obj, this.cell.childNodes[this.conf.idx.pr1]);
	} else {
		this.cell.appendChild(obj);
	}
	
	this.conf.ofs_nodes.b.sb = true;
	this._updateIdx();
	this._adjustCont(this._idd);
	
	return obj;
};

dhtmlXCellObject.prototype.attachStatusBar = function(conf) { // args-optinal, new in version
	
	if (this.dataNodes.sb) return;  // return this.dataNodes.sb?
	
	if (conf != null && window.dhx4.s2b(conf.paging) == true) conf.height = null; // will set by css
	
	if (this.conf.skin == "dhx_skyblue" && typeof(window.dhtmlXWindowsCell) != "undefined" && (this instanceof dhtmlXWindowsCell)) {
		 this.cell.childNodes[this.conf.idx.cont].className += " dhx_cell_statusbar_attached";
	}
	this.dataNodes.sb = this._attachObject("sb", conf);
	
	this.dataNodes.sb.setText = function(text) { this.childNodes[0].innerHTML = text; }
	this.dataNodes.sb.getText = function() { return this.childNodes[0].innerHTML; }
	this.dataNodes.sb.onselectstart = function(e) { return false; }
	
	return this.dataNodes.sb;
	
};

dhtmlXCellObject.prototype.detachStatusBar = function() {
	
	if (!this.dataNodes.sb) return;
	
	if (this.conf.skin == "dhx_skyblue"  && typeof(window.dhtmlXWindowsCell) != "undefined" && (this instanceof dhtmlXWindowsCell)) {
		 this.cell.childNodes[this.conf.idx.cont].className = this.cell.childNodes[this.conf.idx.cont].className.replace(/\s{0,}dhx_cell_statusbar_attached/,"");
	}
	
	this.dataNodes.sb.setText = this.dataNodes.sb.getText = this.dataNodes.sb.onselectstart = null;
	this.dataNodes.sb = null;
	delete this.dataNodes.sb;
	
	this._detachObject("sb");
	
};

dhtmlXCellObject.prototype.showStatusBar = function() {
	this._mtbShowHide("sb", "");
};

dhtmlXCellObject.prototype.hideStatusBar = function() {
	this._mtbShowHide("sb", "none");
};

dhtmlXCellObject.prototype._mtbShowHide = function(name, disp) {
	if (!this.dataNodes[name]) return;
	this.cell.childNodes[this.conf.idx[name]].style.display = disp;
	this._adjustCont();
};


/* private logic */

// !!! fix
dhtmlXCellObject.prototype.getFrame = dhtmlXCellObject.prototype._getFrame = function() { // _getFrame deprecated, use getFrame
	if (this.dataType != "url") return null;
	return this.cell.childNodes[this.conf.idx.cont].firstChild;
};


dhtmlXCellObject.prototype._genStr = function() {
	if (!this._genStrId) this._genStrId = new Date().getTime();
	return this._genStrId++;
};

dhtmlXCellObject.prototype._attachURLEvents = function() {
	
	if (this.dataType != "url") return;
	
	var t = this;
	var cId = this._idd;
	var fr = this.cell.childNodes[this.conf.idx.cont].firstChild;
	
	if (typeof(this._doOnFrameMouseDown) != "function") {
		this._doOnFrameMouseDown = function(e) {
			// console.log("frame mouse down"); // needed for windows to activate window
			t.callEvent("_onContentMouseDown", [cId,e||event]);
		}
	}
	
	if (typeof(window.addEventListener) == "function") {
		fr.onload = function() {
			try { if (typeof(t._doOnFrameMouseDown) == "function") this.contentWindow.document.body.addEventListener("mousedown", t._doOnFrameMouseDown, false); } catch(e) {};
			try { if (typeof(t._doOnFrameContentLoaded) == "function") t._doOnFrameContentLoaded(); } catch(e) {};
		}
	} else {
		// ie8-
		fr.onreadystatechange = function(a) {
			if (this.readyState == "complete") {
				try { if (typeof(t._doOnFrameMouseDown) == "function") this.contentWindow.document.body.attachEvent("onmousedown", t._doOnFrameMouseDown); } catch(e) {};
				try { if (typeof(t._doOnFrameContentLoaded) == "function") t._doOnFrameContentLoaded(); } catch(e) {};
			}
		}
	}
	//fr = null;
};


dhtmlXCellObject.prototype._doOnFrameContentLoaded = function() {
	if (this.conf.url_data.post_ifr == true) {
		var d = this.getFrame().contentWindow.document;
		var f = d.createElement("FORM");
		f.method = "POST";
		f.action = this.conf.url_data.url;
		d.body.appendChild(f);
		var postData = {};
		if (window.dhx4.ajax.cache != true) postData["dhxr"+new Date().getTime()] = "1";
		for (var a in this.conf.url_data.post_data) postData[a] = this.conf.url_data.post_data[a];
		for (var a in postData) {
			var k = d.createElement("INPUT");
			k.type = "hidden";
			k.name = a;
			k.value = postData[a];
			f.appendChild(k);
			k = null;
		}
		this.conf.url_data.post_ifr = false;
		f.submit();
	} else {
		this.callEvent("_onContentLoaded", [this._idd]);
	}
};

dhtmlXCellObject.prototype._detachURLEvents = function(fr) {
	if (fr == null) {
		if (this.dataType != "url") return;
		fr = this.cell.childNodes[this.conf.idx.cont].firstChild;
	}
	if (typeof(window.addEventListener) == "function") {
		fr.onload = null;
		try { fr.contentWindow.document.body.removeEventListener("mousedown", this._doOnFrameMouseDown, false); } catch(e) {/* console.log("error: url detach mousedown event fail"); */};
	} else {
		fr.onreadystatechange = null;
		try { fr.contentWindow.document.body.detachEvent("onmousedown", this._doOnFrameMouseDown); } catch(e) { };
	}
	fr = null;
};




dhtmlXCellObject.prototype._attachObject = function(obj, type, htmlString, append, node) {
	
	if (typeof(obj) == "string" && {menu:1,toolbar:1,ribbon:1,sb:1}[obj] == 1) {
		return this["_createNode_"+obj].apply(this, arguments);
	}
	
	if (append != true) this._detachObject(null, true, null);
	
	if (typeof(htmlString) == "string") {
		this.cell.childNodes[this.conf.idx.cont].innerHTML = htmlString;
	} else {
		this.cell.childNodes[this.conf.idx.cont].appendChild(obj);
	}
	
	obj = null;
};
	
dhtmlXCellObject.prototype._detachObject = function(obj, remove, moveTo) {
	
	this.callEvent("_onBeforeContentDetach",[]);
	
	if (obj == "menu" || obj == "toolbar" || obj == "ribbon" || obj == "sb") {
		
		var p = this.cell.childNodes[this.conf.idx[obj]];
		p.parentNode.removeChild(p);
		p = null;
		
		this.conf.ofs_nodes[obj=="sb"?"b":"t"][obj] = false;
		
		this._updateIdx();
		if (!this.conf.unloading) this._adjustCont(this._idd);
		
		return;
	}
	
	if (remove == true) {
		moveTo = false;
	} else {
		if (typeof(moveTo) == "undefined") {
			moveTo = document.body;
		} else {
			if (typeof(moveTo) == "string") moveTo = document.getElementById(moveTo);
		}
	}
	
	// clear obj
	
	if (moveTo === false) {
		if (this.dataType == "url") {
			this._detachURLEvents();
		} else if (this.dataObj != null) {
			if (typeof(this.dataObj.unload) == "function") {
				this.dataObj.unload();
			} else if (typeof(this.dataObj.destructor) == "function") {
				this.dataObj.destructor(); // at least for grid
			}
		}
	}
	
	// clear cell cont
	var p = this.cell.childNodes[this.conf.idx.cont];
	while (p.childNodes.length > 0) {
		if (moveTo === false) {
			p.removeChild(p.lastChild);
		} else {
			p.firstChild.style.display = "none"; // replace with/add - visibility:hidden?
			moveTo.appendChild(p.firstChild);
		}
	}
	
	if (this.conf.append_mode) {
		p.style.overflow = "";
		this.conf.append_mode = false;
	}
	
	var resetHdrBrd = (this.dataType == "tabbar");
	
	this.dataObj = null;
	this.dataType = null;
	
	moveTo = p = null;
	
	if (this.conf.unloading != true && resetHdrBrd) {
		this.showHeader(true);
		this._showBorders();
	}
	
};

// for dock/undock
dhtmlXCellObject.prototype._attachFromCell = function(cell) {
	
	// clear existing
	this.detachObject(true);
	
	var mode = "layout";
	if (typeof(window.dhtmlXWindowsCell) != "undefined" && this instanceof window.dhtmlXWindowsCell) {
		mode = "window";
	}
	
	// check opacity:
	// 1) detach from window cell, opacity set to 0.4
	if (typeof(window.dhtmlXWindowsCell) != "undefined" && cell instanceof window.dhtmlXWindowsCell && cell.wins.w[cell._idd].conf.parked) {
		cell.wins._winCellSetOpacity(cell._idd, "open", false);
	}
	// 2) acc-cell collapsed
	if (typeof(window.dhtmlXAccordionCell) != "undefined" && cell instanceof window.dhtmlXAccordionCell && cell.conf.opened == false) {
		cell._cellSetOpacity("open", false);
	}
	
	// menu, toolbar, status
	for (var a in cell.dataNodes) {
		
		this._attachObject(a, null, null, null, cell.cell.childNodes[cell.conf.idx[a]]);
		this.dataNodes[a] = cell.dataNodes[a];
		
		cell.dataNodes[a] = null;
		cell.conf.ofs_nodes[a=="sb"?"b":"t"][a] = false;
		cell._updateIdx();
		
	}
	
	this._mtbUpdBorder();
	
	if (cell.dataType != null && cell.dataObj != null) {
		this.dataType = cell.dataType;
		this.dataObj = cell.dataObj;
		while (cell.cell.childNodes[cell.conf.idx.cont].childNodes.length > 0) {
			this.cell.childNodes[this.conf.idx.cont].appendChild(cell.cell.childNodes[cell.conf.idx.cont].firstChild);
		}
		cell.dataType = null;
		cell.dataObj = null;
		
		// fixes
		if (this.dataType == "grid") {
			if (mode == "window" && this.conf.skin == "dhx_skyblue") {
				this.dataObj.entBox.style.border = "1px solid #a4bed4";
				this.dataObj._sizeFix = 0;
			} else {
				this.dataObj.entBox.style.border = "0px solid white";
				this.dataObj._sizeFix = 2;
			}
		}
	} else {
		// for attached urls and objects simple move them
		while (cell.cell.childNodes[cell.conf.idx.cont].childNodes.length > 0) {
			this.cell.childNodes[this.conf.idx.cont].appendChild(cell.cell.childNodes[cell.conf.idx.cont].firstChild);
		}
	}
	
	this.conf.view = cell.conf.view;
	cell.conf.view = "def";
	for (var a in cell.views) {
		this.views[a] = cell.views[a];
		cell.views[a] = null;
		delete cell.views[a];
	}
	
	cell._updateIdx();
	cell._adjustCont();
	
	this._updateIdx();
	this._adjustCont();
	
	// save progress state
	if (cell.conf.progress == true) {
		cell.progressOff();
		this.progressOn();
	} else {
		this.progressOff();
	}
	
	// check opacity, set opacity to 0.4
	// 1) attach to window cell, window parked
	if (mode == "window" && this.wins.w[this._idd].conf.parked) {
		this.wins._winCellSetOpacity(this._idd, "close", false);
	}
	
};


/*
Product Name: dhtmlxSuite 
Version: 4.1.3 
Edition: Professional 
License: content of this file is covered by DHTMLX Commercial or Enterprise license. Usage without proper license is prohibited. To obtain it contact sales@dhtmlx.com
Copyright UAB Dinamenta http://www.dhtmlx.com
*/

function dhtmlXCalendarObject(inps, skin) {
	
	// parse inputs
	this.i = {};
	
	var p = null;
	if (typeof(inps) == "string") {
		var t0 = document.getElementById(inps);
	} else {
		var t0 = inps;
	}
	if (t0 && typeof(t0) == "object" && t0.tagName && String(t0.tagName).toLowerCase() != "input") p = t0;
	t0 = null;
	
	// single param
	if (typeof(inps) != "object" || !inps.length) inps = [inps];
	for (var q=0; q<inps.length; q++) {
		if (typeof(inps[q]) == "string") inps[q] = (document.getElementById(inps[q])||null);
		if (inps[q] != null && inps[q].tagName && String(inps[q].tagName).toLowerCase() == "input") {
			this.i[window.dhx4.newId()] = {input: inps[q]};
		} else {
			if (!(inps[q] instanceof Array) && inps[q] instanceof Object && (inps[q].input != null || inps[q].button != null)) {
				if (inps[q].input != null && typeof(inps[q].input) == "string") inps[q].input = document.getElementById(inps[q].input);
				if (inps[q].button != null && typeof(inps[q].button) == "string") inps[q].button = document.getElementById(inps[q].button);
				this.i[window.dhx4.newId()] = inps[q];
			}
		}
		inps[q] = null;
	}
	
	this.conf = {
		skin: (skin||window.dhx4.skin||(typeof(dhtmlx)!="undefined"?dhtmlx.skin:null)||window.dhx4.skinDetect("dhtmlxcalendar")||"dhx_skyblue"),
		zi: window.dhx4.newId(),
		touch: !window.dhx4.isIE
	}
	
	this.setSkin = function(skin, force) {
		if (this.conf.skin == skin && !force) return;
		this.conf.skin = skin;
		this.base.className = "dhtmlxcalendar_"+this.conf.skin;
		this._ifrSize();
	}
	
	// create base
	this.base = document.createElement("DIV");
	this.base.style.display = "none";
	this.base.appendChild(document.createElement("DIV"));
	
	if (p != null) {
		this._hasParent = true;
		p.appendChild(this.base);
		p = null;
	} else { 
		document.body.appendChild(this.base);
	}
	
	this.setParent = function(p) {
		if (this._hasParent) {
			if (typeof(p) == "object") {
				p.appendChild(this.base);
			} else if (typeof(p) == "string") {
				document.getElementById(p).appendChild(this.base);
			}
		}
	}
	
	this.setSkin(this.conf.skin, true);
	
	this.base.onclick = function(e) {
		e = e||event;
		if (e.preventDefault) e.preventDefault();
		e.cancelBubble = true;
	}
	this.base.onmousedown = function() {
		return false;
	}
	
	if (this.conf.touch) {
		this.base.ontouchstart = this.base.onclick;
	}
	
	this.loadUserLanguage = function(lang) {
		if (!this.langData[lang]) return;
		this.lang = lang;
		this.setWeekStartDay(this.langData[this.lang].weekstart);
		this.setDateFormat(this.langData[this.lang].dateformat||"%Y-%m-%d");
		// month selector
		if (this.msCont) {
			var e = 0;
			for (var q=0; q<this.msCont.childNodes.length; q++) {
				for (var w=0; w<this.msCont.childNodes[q].childNodes.length; w++) {
					this.msCont.childNodes[q].childNodes[w].innerHTML = this.langData[this.lang].monthesSNames[e++];
				}
			}
		}
	}
	
	// build month and year header
	this.contMonth = document.createElement("DIV");
	this.contMonth.className = "dhtmlxcalendar_month_cont";
	this.contMonth.onselectstart = function(e){
		e = e||event;
		e.cancelBubble = true;
		if (e.preventDefault) e.preventDefault(); else e.returnValue = false;
		return false;
	}
	this.base.firstChild.appendChild(this.contMonth);
	
	var ul = document.createElement("UL");
	ul.className = "dhtmlxcalendar_line";
	this.contMonth.appendChild(ul);
	
	var li = document.createElement("LI");
	li.className = "dhtmlxcalendar_cell dhtmlxcalendar_month_hdr";
	li.innerHTML = "<div class='dhtmlxcalendar_month_arrow dhtmlxcalendar_month_arrow_left' onmouseover='this.className=\"dhtmlxcalendar_month_arrow dhtmlxcalendar_month_arrow_left_hover\";' onmouseout='this.className=\"dhtmlxcalendar_month_arrow dhtmlxcalendar_month_arrow_left\";'></div>"+
			"<span></span>"+ // hdrformat will here
			"<div class='dhtmlxcalendar_month_arrow dhtmlxcalendar_month_arrow_right' onmouseover='this.className=\"dhtmlxcalendar_month_arrow dhtmlxcalendar_month_arrow_right_hover\";' onmouseout='this.className=\"dhtmlxcalendar_month_arrow dhtmlxcalendar_month_arrow_right\";'></div>";
	ul.appendChild(li);
	
	var that = this;
	
	li.onclick = function(e) {
		
		e = e||event;
		if (e.type == "touchstart" && e.preventDefault != null) e.preventDefault();
		
		var t = (e.target||e.srcElement);
		// change month by clicking left-right arrows
		if (t.className && t.className.indexOf("dhtmlxcalendar_month_arrow") === 0) {
			that._hideSelector();
			var ind = (t.parentNode.firstChild==t?-1:1);
			var k0 = new Date(that._activeMonth);
			that._drawMonth(new Date(that._activeMonth.getFullYear(), that._activeMonth.getMonth()+ind, 1, 0, 0, 0, 0));
			that._evOnArrowClick([k0, new Date(that._activeMonth)]);
			return;
		}
		// show month selector
		if (t.className && t.className == "dhtmlxcalendar_month_label_month") {
			e.cancelBubble = true;
			that._showSelector("month", Math.round(t.offsetLeft+t.offsetWidth/2), t.offsetTop+t.offsetHeight+2, "selector_month", true);
			return;
		}
		// show year selector
		if (t.className && t.className == "dhtmlxcalendar_month_label_year") {
			e.cancelBubble = true;
			that._showSelector("year", Math.round(t.offsetLeft+t.offsetWidth/2), t.offsetTop+t.offsetHeight+2, "selector_year", true);
			return;
		}
		// hide selector if it visible
		that._hideSelector();
	}
	if (this.conf.touch == true) {
		li.ontouchstart = li.onclick;
	}
	
	// build days names
	this.contDays = document.createElement("DIV");
	this.contDays.className = "dhtmlxcalendar_days_cont";
	this.base.firstChild.appendChild(this.contDays);
	
	this.setWeekStartDay = function(ind) {
		// 1..7 = Mo-Su, also 0 = Su
		if (ind == 0) ind = 7;
		this._wStart = Math.min(Math.max((isNaN(ind)?1:ind),1),7);
		this._drawDaysOfWeek();
	}
	
	this._drawDaysOfWeek = function() {
		if (this.contDays.childNodes.length == 0) {
			var ul = document.createElement("UL");
			ul.className = "dhtmlxcalendar_line";
			this.contDays.appendChild(ul);
		} else {
			var ul = this.contDays.firstChild;
		}
		
		var w = this._wStart;
		var k = this.langData[this.lang].daysSNames;
		k.push(String(this.langData[this.lang].daysSNames[0]).valueOf());
		
		for (var q=0; q<8; q++) {
			if (ul.childNodes[q] == null) {
				var li = document.createElement("LI");
				ul.appendChild(li);
			} else {
				var li = ul.childNodes[q];
			}
			if (q == 0) {
				li.className = "dhtmlxcalendar_cell_wn";
				li.innerHTML = "<div class='dhtmlxcalendar_label'>"+(this.langData[this.lang].weekname||"w")+"</div>";
			} else {
				li.className = "dhtmlxcalendar_cell"+(w>=6?" dhtmlxcalendar_day_weekday_cell":"")+(q==1?"_first":"");
				li.innerHTML = k[w];
				if (++w > 7) w = 1;
			}
		}
		if (this._activeMonth != null) this._drawMonth(this._activeMonth);
	}
	
	this._wStart = this.langData[this.lang].weekstart;
	this.setWeekStartDay(this._wStart);
	
	// dates container
	this.contDates = document.createElement("DIV");
	this.contDates.className = "dhtmlxcalendar_dates_cont";
	this.base.firstChild.appendChild(this.contDates);
	
	this.contDates.onclick = function(e){
		
		e = e||event;
		if (e.type == "touchstart" && e.preventDefault != null) e.preventDefault();
		
		var t = (e.target||e.srcElement);
		
		if (t.parentNode != null && t.parentNode._date != null) t = t.parentNode;
		if (t._date != null && !t._css_dis) {
			
			var t1 = that._activeDate.getHours();
			var t2 = that._activeDate.getMinutes();
			var d0 = t._date;
			
			// cjeck if allow to modify input
			if (that.checkEvent("onBeforeChange")) {
				if (!that.callEvent("onBeforeChange",[new Date(t._date.getFullYear(),t._date.getMonth(),t._date.getDate(),t1,t2)])) return;
			}
			
			if (that._activeDateCell != null) {
				that._activeDateCell._css_date = false;
				that._updateCellStyle(that._activeDateCell._q, that._activeDateCell._w);
			}
			
			// update month if day from prev/next month clicked
			var refreshView = (that._activeDate.getFullYear()+"_"+that._activeDate.getMonth() != d0.getFullYear()+"_"+d0.getMonth());
			
			that._nullDate = false;
			that._activeDate = new Date(d0.getFullYear(),d0.getMonth(),d0.getDate(),t1,t2);
			
			that._activeDateCell = t;
			that._activeDateCell._css_date = true;
			that._activeDateCell._css_hover = false;
			that._updateCellStyle(that._activeDateCell._q, that._activeDateCell._w);
			
			if (refreshView) that._drawMonth(that._activeDate);
			
			// update date in input if any
			if (that._activeInp && that.i[that._activeInp] && that.i[that._activeInp].input != null) {
				that.i[that._activeInp].input.value = that._dateToStr(new Date(that._activeDate.getTime()));
			}
			// hide
			if (!that._hasParent) {
				if (e.type == "touchstart") {
					window.setTimeout(function(){that._hide();},400);
				} else {
					that._hide();
				}
			}
			//
			that._evOnClick([new Date(that._activeDate.getTime())]);
			
		}
	}
	
	if (this.conf.touch == true) {
		this.contDates.ontouchstart = this.contDates.onclick;
	}
	
	this.contDates.onmouseover = function(e) {
		e = e||event;
		var t = (e.target||e.srcElement);
		if (t.parentNode != null && t.parentNode._date != null) t = t.parentNode;
		if (t._date != null) { // && t != that._activeDateCell) { // skip hover for selected date
			if (that._lastHover == t || t._css_hover) return;
			t._css_hover = true;
			that._updateCellStyle(t._q, t._w);
			that._lastHover = t;
			that._evOnMouseOver([new Date(t._date.getFullYear(),t._date.getMonth(),t._date.getDate(),0,0,0,0),e]);
			t = null;
		}
	}
	this.contDates.onmouseout = function(e) {
		that._clearDayHover(e||event);
	}
	
	this._lastHover = null;
	this._clearDayHover = function(ev) {
		//if (!this._lastHover || !this._lastHover._css_hover) return;
		if (!this._lastHover) return;
		this._lastHover._css_hover = false;
		this._updateCellStyle(this._lastHover._q, this._lastHover._w);
		that._evOnMouseOut([new Date(this._lastHover._date.getFullYear(),this._lastHover._date.getMonth(),this._lastHover._date.getDate(),0,0,0,0),ev]);
		this._lastHover = null;
	}
	
	// build cells
	for (var q=0; q<6; q++) {
		var ul = document.createElement("UL");
		ul.className = "dhtmlxcalendar_line";
		this.contDates.appendChild(ul);
		for (var w=0; w<=7; w++) {
			var li = document.createElement("LI");
			if (w == 0) {
				// week number
				li.className = "dhtmlxcalendar_cell_wn";
			} else {
				li.className = "dhtmlxcalendar_cell";
			}
			ul.appendChild(li);
		}
	}
	
	
	// timepicker
	this.contTime = document.createElement("DIV");
	this.contTime.className = "dhtmlxcalendar_time_cont";
	this.base.firstChild.appendChild(this.contTime);
	
	this.showTime = function() {
		this.contTime.style.display = "";
		this._ifrSize();
	}
	
	this.hideTime = function() {
		this.contTime.style.display = "none";
		this._ifrSize();
	}
	
	var ul = document.createElement("UL");
	ul.className = "dhtmlxcalendar_line";
	this.contTime.appendChild(ul);
	
	var li = document.createElement("LI");
	li.className = "dhtmlxcalendar_cell dhtmlxcalendar_time_hdr";
	li.innerHTML = "<div class='dhtmlxcalendar_time_img'></div>"+
			"<span class='dhtmlxcalendar_label_hours'></span><span class='dhtmlxcalendar_label_colon'> : </span><span class='dhtmlxcalendar_label_minutes'></span>";
	ul.appendChild(li);
	
	li.onclick = function(e) {
		e = e||event;
		if (e.type == "touchstart" && e.preventDefault != null) e.preventDefault();
		
		var t = (e.target||e.srcElement);
		if (t.tagName != null && t.tagName.toLowerCase() == "span" && t._par == true && t.parentNode != null) {
			t = t.parentNode;
		}
		// show hours selector
		if (t.className && t.className == "dhtmlxcalendar_label_hours") {
			e.cancelBubble = true;
			var h = that.contMonth.offsetHeight+that.contDays.offsetHeight+that.contDates.offsetHeight+t.offsetTop;
			that._showSelector("hours", Math.round(t.offsetLeft+t.offsetWidth/2), h-2, "selector_hours", true);
			return;
		}
		// show minutes selector
		if (t.className && t.className == "dhtmlxcalendar_label_minutes") {
			e.cancelBubble = true;
			if (that._minutesInterval == 1) {
				var d = that.getFormatedDate("%i");
				t.innerHTML = "<span class='dhtmlxcalendar_selected_date'>"+d.charAt(0)+"</span>"+d.charAt(1);
				t.firstChild._par = true;
				that._selectorMode = 1; // select hour
			}
			var h = that.contMonth.offsetHeight+that.contDays.offsetHeight+that.contDates.offsetHeight+t.offsetTop;
			that._showSelector("minutes", Math.round(t.offsetLeft+t.offsetWidth/2), h-2, "selector_minutes",true);
			return;
		}
		// hide selector if it visible
		that._hideSelector();
	}
	if (this.conf.touch == true) {
		li.ontouchstart = li.onclick;
	}
	
	this._activeMonth = null;
	
	this._activeDate = new Date();
	this._activeDateCell = null;
	
	this.setDate = function(d) {
		window.dhx4.temp_calendar = {tz:null};
		this._nullDate = (typeof(d) == "undefined" || d === "" || !d);
		
		if (!(d instanceof Date)) {
			d = this._strToDate(String(d||""));
			if (d == "Invalid Date") d = new Date(); else this.conf.tz = window.dhx4.temp_calendar.tz;
			window.dhx4.temp_calendar = null;
		}
		if (this.conf.tz == null) this.conf.tz = window.dhx4.date2str(d,"%P");
		
		var time = d.getTime();
		
		// out of range
		if (this._isOutOfRange(time)) return;
		
		this._activeDate = new Date(time);
		this._drawMonth(this._nullDate?new Date():this._activeDate);
		this._updateVisibleHours();
		this._updateVisibleMinutes();
	}
	
	this.getDate = function(formated) {
		if (this._nullDate) return null;
		var t = new Date(this._activeDate.getTime());
		if (formated) {
			window.dhx4.temp_calendar = {tz:this.conf.tz};
			var d = this._dateToStr(t);
			window.dhx4.temp_calendar = null;
			return d;
		}
		return t;
	}
	
	this._drawMonth = function(d) {
		
		if (!(d instanceof Date)) return;
		if (isNaN(d.getFullYear())) d = new Date(this._activeMonth.getFullYear(), this._activeMonth.getMonth(), 1, 0, 0, 0, 0);
		
		this._activeMonth = new Date(d.getFullYear(), d.getMonth(), 1, 0, 0, 0, 0);
		
		this._activeDateCell = null;
		
		var first = new Date(this._activeMonth.getTime());
		var d0 = first.getDay();
		
		var e0 = d0-this._wStart;
		if (e0 < 0) e0 = e0+7;
		first.setDate(first.getDate()-e0);
		
		var mx = d.getMonth();
		var dx = new Date(this._activeDate.getFullYear(), this._activeDate.getMonth(), this._activeDate.getDate(), 0, 0, 0, 0).getTime();
		var i = 0;
		for (var q=0; q<6; q++) {
			var ws = this._wStart;
			for (var w=0; w<=7; w++) {
				if (w == 0) {
					var wn = this.getWeekNumber(new Date(first.getFullYear(), first.getMonth(), first.getDate()+i, 0, 0, 0, 0));
					this.contDates.childNodes[q].childNodes[w].innerHTML = "<div class='dhtmlxcalendar_label'>"+wn+"</div>";
				} else {
					
					var d2 = new Date(first.getFullYear(), first.getMonth(), first.getDate()+i, 0, 0, 0, 0);
					if (d2.getHours() != 0) {
						var h = (d2.getHours()>12 ? 24-d2.getHours() : d2.getHours()); // yesturday/tomorrow while daylight saving
						d2.setTime(d2.getTime() + 60*60*1000*h);
					}
					
					var day = d2.getDay();
					var time = d2.getTime();
					
					var label_css = "dhtmlxcalendar_label";
					if (this._tipData[time] != null) {
						if (this._tipData[time].usePopup && typeof(window.dhtmlXPopup) == "function") {
							this.contDates.childNodes[q].childNodes[w].removeAttribute("title");
							this._initTooltipPopup();
						} else {
							this.contDates.childNodes[q].childNodes[w].setAttribute("title", this._tipData[time].text);
						}
						if (this._tipData[time].showIcon) label_css += " dhtmlxcalendar_label_title";
					} else {
						this.contDates.childNodes[q].childNodes[w].removeAttribute("title");
						
					}
					
					this.contDates.childNodes[q].childNodes[w].innerHTML = "<div class='"+label_css+"'>"+d2.getDate()+"</div>";
					
					this.contDates.childNodes[q].childNodes[w]._date = new Date(time);
					this.contDates.childNodes[q].childNodes[w]._q = q;
					this.contDates.childNodes[q].childNodes[w]._w = w;
					this.contDates.childNodes[q].childNodes[w]._css_month = (d2.getMonth()==mx);
					this.contDates.childNodes[q].childNodes[w]._css_date = (!this._nullDate&&time==dx);
					this.contDates.childNodes[q].childNodes[w]._css_weekend = (ws>=6);
					this.contDates.childNodes[q].childNodes[w]._css_dis = this._isOutOfRange(time);
					this.contDates.childNodes[q].childNodes[w]._css_holiday = (this._holidays[time] == true);
					
					this._updateCellStyle(q, w);
					
					if (time==dx) this._activeDateCell = this.contDates.childNodes[q].childNodes[w];
					
					if (++ws > 7) ws = 1;
					i++;
				}
				
			}
		}
		
		this.contMonth.firstChild.firstChild.childNodes[1].innerHTML = this._buildMonthHdr(d);
		
	}
	
	this._updateCellStyle = function(q, w) {
		
		var r = this.contDates.childNodes[q].childNodes[w];
		
		var s = "dhtmlxcalendar_cell dhtmlxcalendar_cell";
		
		// this/another month
		s += (r._css_month ? "_month" : "");
		
		// selected date
		s += (r._css_date ? "_date" : "");
		
		// is weekend
		s += (r._css_weekend ? "_weekend" : "");
		
		// is holiday
		s += (r._css_holiday ? "_holiday" : "");
		
		// is cell disabled
		s += (r._css_dis ? "_dis" : "");
		
		// is cell hover (only if not disabled)
		s += (r._css_hover && !r._css_dis ? "_hover" : "");
		
		r.className = s;
		r = null;
		
	}
	
	/* global selector obj */
	
	this._minutesInterval = 5; // default
	
	this._initSelector = function(type,css) {
		
		if (!this._selCover) {
			this._selCover = document.createElement("DIV");
			this._selCover.className = "dhtmlxcalendar_selector_cover";
			this.base.firstChild.appendChild(this._selCover);
		}

		if (!this._sel) {
			
			this._sel = document.createElement("DIV");
			this._sel.className = "dhtmlxcalendar_selector_obj";
			this.base.firstChild.appendChild(this._sel);
			
			this._sel.appendChild(document.createElement("TABLE"));
			this._sel.firstChild.className = "dhtmlxcalendar_selector_table";
			this._sel.firstChild.cellSpacing = 0;
			this._sel.firstChild.cellPadding = 0;
			this._sel.firstChild.border = 0;
			this._sel.firstChild.appendChild(document.createElement("TBODY"));
			this._sel.firstChild.firstChild.appendChild(document.createElement("TR"));
			
			this._sel.firstChild.firstChild.firstChild.appendChild(document.createElement("TD"));
			this._sel.firstChild.firstChild.firstChild.appendChild(document.createElement("TD"));
			this._sel.firstChild.firstChild.firstChild.appendChild(document.createElement("TD"));
			
			this._sel.firstChild.firstChild.firstChild.childNodes[0].className = "dhtmlxcalendar_selector_cell_left";
			this._sel.firstChild.firstChild.firstChild.childNodes[1].className = "dhtmlxcalendar_selector_cell_middle";
			this._sel.firstChild.firstChild.firstChild.childNodes[2].className = "dhtmlxcalendar_selector_cell_right";
			this._sel.firstChild.firstChild.firstChild.childNodes[0].innerHTML = "&nbsp;";
			this._sel.firstChild.firstChild.firstChild.childNodes[2].innerHTML = "&nbsp;";
			
			this._sel.firstChild.firstChild.firstChild.childNodes[0].onmouseover = function(){
				this.className = "dhtmlxcalendar_selector_cell_left dhtmlxcalendar_selector_cell_left_hover";
			}
			this._sel.firstChild.firstChild.firstChild.childNodes[0].onmouseout = function(){
				this.className = "dhtmlxcalendar_selector_cell_left";
			}
			
			this._sel.firstChild.firstChild.firstChild.childNodes[2].onmouseover = function(){
				this.className = "dhtmlxcalendar_selector_cell_right dhtmlxcalendar_selector_cell_right_hover";
			}
			this._sel.firstChild.firstChild.firstChild.childNodes[2].onmouseout = function(){
				this.className = "dhtmlxcalendar_selector_cell_right";
			}
			
			this._sel.onmouseover = function(e) {
				e = e||event;
				var t = (e.target||e.srcElement);
				if (t._cell === true) {
					if (that._selHover != t) that._clearSelHover();
					if (String(t.className).match(/^\s{0,}dhtmlxcalendar_selector_cell\s{0,}$/gi) !=null) {
						t.className += " dhtmlxcalendar_selector_cell_hover";
						that._selHover = t;
					}
				}
			}
			
			this._sel.onmouseout = function() {
				that._clearSelHover();
			}
			
			this._sel.firstChild.firstChild.firstChild.childNodes[0].onclick = function(e){
				e = e||event;
				if (e.type == "touchstart" && e.preventDefault != null) e.preventDefault();
				e.cancelBubble = true;
				that._scrollYears(-1);
			}
			
			this._sel.firstChild.firstChild.firstChild.childNodes[2].onclick = function(e){
				e = e||event;
				if (e.type == "touchstart" && e.preventDefault != null) e.preventDefault();
				e.cancelBubble = true;
				that._scrollYears(1);
			}
			
			if (this.conf.touch == true) {
				this._sel.firstChild.firstChild.firstChild.childNodes[0].ontouchstart = this._sel.firstChild.firstChild.firstChild.childNodes[0].onclick;
				this._sel.firstChild.firstChild.firstChild.childNodes[2].ontouchstart = this._sel.firstChild.firstChild.firstChild.childNodes[2].onclick;
			}
			
			this._sel._ta = {};
			
			this._selHover = null;
			
			this._sel.appendChild(document.createElement("DIV"));
			this._sel.lastChild.className = "dhtmlxcalendar_selector_obj_arrow";
		}
		
		// check if already inited
		if (this._sel._ta[type] == true) return;
		
		// init month
		if (type == "month") {
			
			this._msCells = {};
			
			this.msCont = document.createElement("DIV");
			this.msCont.className = "dhtmlxcalendar_area_"+css;
			this._sel.firstChild.firstChild.firstChild.childNodes[1].appendChild(this.msCont);
			
			var i = 0;
			for (var q=0; q<4; q++) {
				var ul = document.createElement("UL");
				ul.className = "dhtmlxcalendar_selector_line";
				this.msCont.appendChild(ul);
				for (var w=0; w<3; w++) {
					var li = document.createElement("LI");
					li.innerHTML = this.langData[this.lang].monthesSNames[i];
					li.className = "dhtmlxcalendar_selector_cell";
					ul.appendChild(li);
					li._month = i;
					li._cell = true;
					this._msCells[i++] = li;
				}
			}
			
			this.msCont.onclick = function(e) {
				e = e||event;
				if (e.type == "touchstart" && e.preventDefault != null) e.preventDefault();
				e.cancelBubble = true;
				var t = (e.target||e.srcElement);
				if (t._month != null) {
					that._hideSelector();
					that._updateActiveMonth();
					that._drawMonth(new Date(that._activeMonth.getFullYear(), t._month, 1, 0, 0, 0, 0));
					that._doOnSelectorChange();
				}
			}
			if (this.conf.touch == true) {
				this.msCont.ontouchstart = this.msCont.onclick;
			}
		}
		
		// init year
		if (type == "year") {
			
			this._ysCells = {};
			
			this.ysCont = document.createElement("DIV");
			this.ysCont.className = "dhtmlxcalendar_area_"+css;
			this._sel.firstChild.firstChild.firstChild.childNodes[1].appendChild(this.ysCont);
			
			for (var q=0; q<4; q++) {
				var ul = document.createElement("UL");
				ul.className = "dhtmlxcalendar_selector_line";
				this.ysCont.appendChild(ul);
				for (var w=0; w<3; w++) {
					var li = document.createElement("LI");
					li.className = "dhtmlxcalendar_selector_cell";
					li._cell = true;
					ul.appendChild(li);
				}
			}
			
			this.ysCont.onclick = function(e) {
				e = e||event;
				if (e.type == "touchstart" && e.preventDefault != null) e.preventDefault();
				e.cancelBubble = true;
				var t = (e.target||e.srcElement);
				if (t._year != null) {
					that._hideSelector();
					that._drawMonth(new Date(t._year, that._activeMonth.getMonth(), 1, 0, 0, 0, 0));
					that._doOnSelectorChange();
				}
			}
			if (this.conf.touch == true) {
				this.ysCont.ontouchstart = this.ysCont.onclick;
			}
			
		}
		
		// init hours
		if (type == "hours") {
			
			this._hsCells = {};
			
			this.hsCont = document.createElement("DIV");
			this.hsCont.className = "dhtmlxcalendar_area_"+css;
			this._sel.firstChild.firstChild.firstChild.childNodes[1].appendChild(this.hsCont);
			
			var i = 0;
			for (var q=0; q<4; q++) {
				var ul = document.createElement("UL");
				ul.className = "dhtmlxcalendar_selector_line";
				this.hsCont.appendChild(ul);
				for (var w=0; w<6; w++) {
					var li = document.createElement("LI");
					li.innerHTML = this._fixLength(i,2);
					li.className = "dhtmlxcalendar_selector_cell";
					ul.appendChild(li);
					li._hours = i;
					li._cell = true;
					this._hsCells[i++] = li;
				}
			}
			
			this.hsCont.onclick = function(e) {
				e = e||event;
				if (e.type == "touchstart" && e.preventDefault != null) e.preventDefault();
				e.cancelBubble = true;
				var t = (e.target||e.srcElement);
				if (t._hours != null) {
					that._hideSelector();
					that._activeDate.setHours(t._hours);
					that._updateActiveHours();
					that._updateVisibleHours();
					that._doOnSelectorChange();
					//
					that.callEvent("onTimeChange",[new Date(that._activeDate.getTime())]);
				}
			}
			if (this.conf.touch == true) {
				this.hsCont.ontouchstart = this.hsCont.onclick;
			}
		}
		
		// init minutes
		if (type == "minutes") {
			
			// _minutesInterval = 5, def
			
			var q1 = 4;
			var w1 = 3;
			var len = 2; // leading zero
			
			if (this._minutesInterval == 1) {
				if (this._selectorMode == 1) {
					q1 = 2;
					w1 = 3;
					len = 1;
				} else {
					q1 = 2;
					w1 = 5;
					len = 1;
					css += "5";
				}
			}
			if (this._minutesInterval == 10) q1 = 2;
			if (this._minutesInterval == 15) {
				q1 = 1;
				w1 = 4;
				css += "4";
			}
			
			this._rsCells = {};
			
			this.rsCont = document.createElement("DIV");
			this.rsCont.className = "dhtmlxcalendar_area_"+css;
			this._sel.firstChild.firstChild.firstChild.childNodes[1].appendChild(this.rsCont);
			
			var i = 0;
			for (var q=0; q<q1; q++) {
				var ul = document.createElement("UL");
				ul.className = "dhtmlxcalendar_selector_line";
				this.rsCont.appendChild(ul);
				for (var w=0; w<w1; w++) {
					var li = document.createElement("LI");
					li.innerHTML = (len>1?this._fixLength(i,len):i);
					li.className = "dhtmlxcalendar_selector_cell";
					ul.appendChild(li);
					li._minutes = i;
					li._cell = true;
					this._rsCells[i] = li;
					i += this._minutesInterval;
				}
			}
			
			this.rsCont.onclick = function(e) {
				e = e||event;
				if (e.type == "touchstart" && e.preventDefault != null) e.preventDefault();
				e.cancelBubble = true;
				var t = (e.target||e.srcElement);
				if (t._minutes != null) {
					if (that._minutesInterval == 1) {
						
						var m = that.getFormatedDate("%i");
						if (that._selectorMode == 1) {
							m = t._minutes.toString()+m.charAt(1);
						} else {
							m = m.charAt(0)+t._minutes.toString();
						}
						that._activeDate.setMinutes(Number(m));
						//
						that.callEvent("onTimeChange",[new Date(that._activeDate.getTime())]);
						
						that._hideSelector(); // will unload
						
						if (that._selectorMode == 1) {
							// show 2nd
							
							that._updateVisibleMinutes(true);
							that._selectorMode = 2;
							that._showSelector("minutes", that._sel._x, that._sel._y, "selector_minutes", true);
							that._updateActiveMinutes();
							return;
						} else {
							that._selectorMode = 1;
						}
					} else {
						that._hideSelector();
						that._activeDate.setMinutes(t._minutes);
						that._updateActiveMinutes();
						//
						that.callEvent("onTimeChange",[new Date(that._activeDate.getTime())]);
					}
					that._updateVisibleMinutes();
					that._doOnSelectorChange();
				}
			}
			if (this.conf.touch == true) {
				this.rsCont.ontouchstart = this.rsCont.onclick;
			}
		}
		
		// mark that selector of current type is inited
		this._sel._ta[type] = true;
	}
	
	this._showSelector = function(type, x, y, css, autoHide) {
		
		if (autoHide === true && this._sel != null && this._isSelectorVisible() && type == this._sel._t) {
			this._hideSelector();
			return;
		}
		
		if (this.conf.skin == "dhx_terrace") {
			x += 12; // ul's margin
		}
		
		if (!this._sel || !this._sel._ta[type]) this._initSelector(type,css);
		
		// minutes was visible, selector jumps to other type, remove red line
		if (type != this._sel._t && this._sel._t == "minutes" && this._minutesInterval == 1) {
			this.contTime.firstChild.firstChild.childNodes[3].innerHTML = this.getFormatedDate("%i");
		}
		
		this._sel._x = x;
		this._sel._y = y;
		
		// show selector cover
		this._sel.style.visibility = "hidden";
		this._sel.style.display = "";
		
		this._selCover.style.width = this.base.offsetWidth-2+"px";
		this._selCover.style.top = this.contMonth.offsetHeight+"px";
		this._selCover.style.height = this.contDates.offsetHeight+this.contDays.offsetHeight-1+"px";
		
		this._selCover.style.display = "";
		
		// show selector
		this._sel._t = type;
		this._sel.className = "dhtmlxcalendar_selector_obj dhtmlxcalendar_"+css;
		
		// left/right table arrows
		this._sel.childNodes[0].firstChild.firstChild.childNodes[0].style.display = this._sel.childNodes[0].firstChild.firstChild.childNodes[2].style.display = (type=="year"?"":"none");
		
		// coords
		var x0 = Math.max(0, x-Math.round(this._sel.offsetWidth/2));
		if (x0+this._sel.offsetWidth > this._sel.parentNode.offsetWidth) {
			x0 = this._sel.parentNode.offsetWidth - this._sel.offsetWidth;
		}
		
		this._sel.style.left = x0+"px";
		
		if (type == "hours" || type == "minutes") {
			this._sel.style.top = y-this._sel.offsetHeight+"px";
		} else {
			this._sel.style.top = y+"px";
		}
		
		// arrow width
		this._sel.childNodes[1].style.width = this._sel.childNodes[0].offsetWidth+"px";
		
		// final apply
		this._sel.style.visibility = "visible";
		
		// callbacks
		this._doOnSelectorShow(type);
	}
	
	this._doOnSelectorShow = function(type) {
		if (type == "month") this._updateActiveMonth();
		if (type == "year") this._updateYearsList(this._activeMonth);
		if (type == "hours") this._updateActiveHours();
		if (type == "minutes") this._updateActiveMinutes();
	}
	
	this._hideSelector = function(selMode) {
		if (!this._sel) return;
		this._sel.style.display = "none";
		this._sel.style.visible = "hidden";
		this._selCover.style.display = "none";
		//
		if (this._sel._t == "minutes" && this._minutesInterval == 1) {
			this.contTime.firstChild.firstChild.childNodes[3].innerHTML = this.getFormatedDate("%i");
			this._unloadSelector("minutes");
		}
	}
	
	this._isSelectorVisible = function() {
		if (!this._sel) return false;
		return (this._sel.style.display != "none");
	}
	
	this._doOnSelectorChange = function(state) {
		this.callEvent("onChange",[new Date(this._activeMonth.getFullYear(), this._activeMonth.getMonth(), this._activeDate.getDate(), this._activeDate.getHours(), this._activeDate.getMinutes(), this._activeDate.getSeconds()),state===true]);
	}
	
	this._clearSelHover = function() {
		if (!this._selHover) return;
		this._selHover.className = String(this._selHover.className.replace(/dhtmlxcalendar_selector_cell_hover/gi,""));
		this._selHover = null;
	}
	
	this._unloadSelector = function(type) {
		if (!this._sel) return;
		if (!this._sel._ta[type]) return;
		
		// month selector
		if (type == "month") {
			
			this.msCont.onclick = this.msCont.ontouchstart = null;
			this._msActive = null;
			
			// li
			for (var a in this._msCells) {
				this._msCells[a]._cell = null;
				this._msCells[a]._month = null;
				this._msCells[a].parentNode.removeChild(this._msCells[a]);
				this._msCells[a] = null;
			}
			this._msCells = null;
			
			// ul
			while (this.msCont.childNodes.length > 0) this.msCont.removeChild(this.msCont.lastChild);
			
			// div
			this.msCont.parentNode.removeChild(this.msCont);
			this.msCont = null;
			
		}
		
		// years selector
		if (type == "year") {
			
			this.ysCont.onclick = this.ysCont.ontouchstart = null;
			
			// li
			for (var a in this._ysCells) {
				this._ysCells[a]._cell = null;
				this._ysCells[a]._year = null;
				this._ysCells[a].parentNode.removeChild(this._ysCells[a]);
				this._ysCells[a] = null;
			}
			this._ysCells = null;
			
			// ul
			while (this.ysCont.childNodes.length > 0) this.ysCont.removeChild(this.ysCont.lastChild);
			
			// div
			this.ysCont.parentNode.removeChild(this.ysCont);
			this.ysCont = null;
			
		}
		
		// hours selector
		if (type == "hours") {
			
			this.hsCont.onclick = this.hsCont.ontouchstart = null;
			this._hsActive = null;
			
			// li
			for (var a in this._hsCells) {
				this._hsCells[a]._cell = null;
				this._hsCells[a]._hours = null;
				this._hsCells[a].parentNode.removeChild(this._hsCells[a]);
				this._hsCells[a] = null;
			}
			this._hsCells = null;
			
			// ul
			while (this.hsCont.childNodes.length > 0) this.hsCont.removeChild(this.hsCont.lastChild);
			
			// div
			this.hsCont.parentNode.removeChild(this.hsCont);
			this.hsCont = null;
			
		}
		
		// minutes selector
		if (type == "minutes") {
			
			this.rsCont.onclick = this.rsCont.ontouchstart = null;
			this._rsActive = null;
			
			// li
			for (var a in this._rsCells) {
				this._rsCells[a]._cell = null;
				this._rsCells[a]._minutes = null;
				this._rsCells[a].parentNode.removeChild(this._rsCells[a]);
				this._rsCells[a] = null;
			}
			this._rsCells = null;
			
			// ul
			while (this.rsCont.childNodes.length > 0) this.rsCont.removeChild(this.rsCont.lastChild);
			
			// div
			this.rsCont.parentNode.removeChild(this.rsCont);
			this.rsCont = null;
			
		}
		
		
		this._sel._ta[type] = null;
	}
	
	this.setMinutesInterval = function(d) {
		if (!(d == 1 || d == 5 || d == 10 || d == 15)) return;
		this._minutesInterval = d;
		this._unloadSelector("minutes");
	}
	
	
	/* month selector */
	
	this._updateActiveMonth = function() {
		if (typeof(this._msActive) != "undefined" && typeof(this._msCells[this._msActive]) != "undefined") this._msCells[this._msActive].className = "dhtmlxcalendar_selector_cell";
		this._msActive = this._activeMonth.getMonth();
		this._msCells[this._msActive].className = "dhtmlxcalendar_selector_cell dhtmlxcalendar_selector_cell_active";
	}
	
	/* year selector */
	
	this._updateActiveYear = function() {
		var i = this._activeMonth.getFullYear();
		if (this._ysCells[i]) this._ysCells[i].className = "dhtmlxcalendar_selector_cell dhtmlxcalendar_selector_cell_active";
	}
	
	this._updateYearsList = function(d) {
		for (var a in this._ysCells) {
			this._ysCells[a] = null;
			delete this._ysCells[a];
		}
		//
		var i = 12*Math.floor(d.getFullYear()/12);
		for (var q=0; q<4; q++) {
			for (var w=0; w<3; w++) {
				this.ysCont.childNodes[q].childNodes[w].innerHTML = i;
				this.ysCont.childNodes[q].childNodes[w]._year = i;
				this.ysCont.childNodes[q].childNodes[w].className = "dhtmlxcalendar_selector_cell";
				this._ysCells[i++] = this.ysCont.childNodes[q].childNodes[w];
			}
		}
		this._updateActiveYear();
	}
	
	this._scrollYears = function(i) {
		var y = (i<0?this.ysCont.firstChild.firstChild._year:this.ysCont.lastChild.lastChild._year)+i;
		var d = new Date(y, this._activeMonth.getMonth(), 1, 0, 0, 0, 0);
		this._updateYearsList(d);
	}
	
	/* hours selector */
	
	// update hours in selector
	this._updateActiveHours = function() {
		if (typeof(this._hsActive) != "undefined" && typeof(this._hsCells[this._hsActive]) != "undefined") this._hsCells[this._hsActive].className = "dhtmlxcalendar_selector_cell";
		this._hsActive = this._activeDate.getHours();
		this._hsCells[this._hsActive].className = "dhtmlxcalendar_selector_cell dhtmlxcalendar_selector_cell_active";
	}
	
	// update hours in calendar
	this._updateVisibleHours = function() {
		this.contTime.firstChild.firstChild.childNodes[1].innerHTML = this._fixLength(this._activeDate.getHours(),2);
	}
	
	/* minutes selector */
	
	// update minutes in selector
	this._updateActiveMinutes = function() {
		if (this._rsActive != null && typeof(this._rsActive) != "undefined" && typeof(this._rsCells[this._rsActive]) != "undefined") this._rsCells[this._rsActive].className = "dhtmlxcalendar_selector_cell";
		if (this._minutesInterval == 1) {
			this._rsActive = (this.getFormatedDate("%i").toString()).charAt(this._selectorMode==1?0:1);
		} else {
			this._rsActive = this._activeDate.getMinutes();
		}
		if (typeof(this._rsCells[this._rsActive]) != "undefined") this._rsCells[this._rsActive].className = "dhtmlxcalendar_selector_cell dhtmlxcalendar_selector_cell_active";
	}
	
	// update minutes in calendar
	this._updateVisibleMinutes = function(h) {
		var t = this._fixLength(this._activeDate.getMinutes(),2).toString();
		if (h == true) t = t.charAt(0)+"<span class='dhtmlxcalendar_selected_date'>"+t.charAt(1)+"</span>";
		this.contTime.firstChild.firstChild.childNodes[3].innerHTML = t;
		if (h == true) this.contTime.firstChild.firstChild.childNodes[3].lastChild._par = true;
	}
	
	/* some common functionality */
	
	this._fixLength = function(t, r) {
		while (String(t).length < r) t = "0"+String(t);
		return t;
	}
	
	this._dateFormat = "";
	this._dateFormatRE = null;
	
	this.setDateFormat = function(format) {
		
		// check value in inputs
		// for 1st call on init strTodate not defined
		var upd = {};
		if (this._strToDate != null) {
			for (var a in this.i) {
				if (this.i[a].input != null && this.i[a].input.value.length > 0) {
					var d = this._strToDate(this.i[a].input.value, this._dateFormat||this.langData[this.lang].dateformat||"%Y-%m-%d");
					if (d instanceof Date) upd[a] = d;
				}
			}
		}
		
		this._dateFormat = format;
		var k = String(this._dateFormat).replace(/%[a-zA-Z]+/g,function(t){
			var t2 = t.replace(/%/,"");
			switch (t2) {
				case "n": case "h": case "j": case "g": case "G": return "\\d{1,2}";
				case "m": case "d": case "H": case "i": case "s": case "y": return "\\d{2}";
				case "Y": return "\\d{4}";
				case "M": return "("+that.langData[that.lang].monthesSNames.join("|").toLowerCase()+"){1,}";
				case "F": return "("+that.langData[that.lang].monthesFNames.join("|").toLowerCase()+"){1,}";
				case "D": return "[a-z]{2}";
				case "a": case "A": return "AM|PM";
				case "u": return "\\d{1,6}";
				case "P": return "[\\+\\-]\\d{1,2}\\:\\d{1,2}";
			}
			return t;
		});
		
		this._dateFormatRE = new RegExp(k,"i");
		
		// update dates in inputs
		for (var a in upd) {
			this.i[a].input.value = this._dateToStr(upd[a]);
		}
		upd = null;
	}
	
	this.setDateFormat(this.langData[this.lang].dateformat||"%Y-%m-%d");
	
	this._updateDateStr = function(str) {
		// check if valid str
		if (!this._dateFormatRE || !str.match(this._dateFormatRE)) return;
		
		// input was not updated
		if (str == this.getFormatedDate()) return;
		
		var r = this._strToDate(str);
		if (!(r instanceof Date)) return;
		
		// cjeck if allow to modify input
		if (this.checkEvent("onBeforeChange")) {
			if (!this.callEvent("onBeforeChange",[new Date(r.getFullYear(),r.getMonth(),r.getDate(),r.getHours(),r.getMinutes(),r.getSeconds())])) {
				// revert value
				if (this.i != null && this._activeInp != null && this.i[this._activeInp] != null && this.i[this._activeInp].input != null) {
					this.i[this._activeInp].input.value = this.getFormatedDate();
				}
				return;
			}
		}
		
		this._nullDate = false;
		this._activeDate = r;
		this._drawMonth(this._nullDate?new Date():this._activeDate);
		
		this._updateVisibleMinutes();
		this._updateVisibleHours();
		
		if (this._sel && this._isSelectorVisible()) this._doOnSelectorShow(this._sel._t);
		this._doOnSelectorChange(true);
		
	}
	
	this.showMonth = function(d) {
		if (typeof(d) == "string") d = this._strToDate(d);
		if (!(d instanceof Date)) return;
		this._drawMonth(d);
	}
	
	this.setFormatedDate = function(format, str, a, return_only) {
		var date = this._strToDate(str, format);
		if (return_only) return date;
		this.setDate(date);
	}

	this.getFormatedDate = function(format, date){
		if (!(date && date instanceof Date)){
			if (this._nullDate) return ""; 
			date = new Date(this._activeDate);
		}
		return this._dateToStr(date, format);
	}
	
	/* week numbers */
	this.getWeekNumber = function(dateX) {
		
		if (typeof(dateX) == "string") dateX = this._strToDate(dateX);
		if (!(dateX instanceof Date)) return "Invalid Date";
		
		if (typeof(this._ftDay) == "undefined") this._ftDay = 4;
		
		var ws = this._wStart; // 1..7 = Mo-Su
		var we = ws+7;
		
		var ft = 4; // first thursday
		
		
		var x1_date = new Date(dateX.getFullYear(), 0, 1, 0, 0, 0, 0);// day-of-week, jan first
		var x1 = x1_date.getDay();
		if (x1 == 0) x1 = 7;
		
		// offset
		if (ft < ws) {
			ft += 7;
			x1 += 7;
		}
		
		// detect date of 1st week
		
		var i = 0; // week offset
		if (x1 >= ws && x1 <= ft) {
			// x1 belong 1st week
		} else {
			// x1 belong 2nd week
			i = 1;
		}
		var k = x1-ws;
		var w1 = new Date(dateX.getFullYear(), 0, 1-k+i*7, 0, 0, 0, 0);// 1st week start date
		
		// console.log("1st week of "+x.getFullYear()+" year starts from "+this.getFormatedDate("%M %d, %Y",w1));
		
		var d7 = 604800000; // 7 days in ms, 60*60*24*7*1000
		var x2 = new Date(dateX.getFullYear(), dateX.getMonth(), dateX.getDate()+1, 0, 0, 0, 0); // 2nd day to get interval
		
		var wn = Math.ceil((x2.getTime()-w1.getTime())/d7);
		
		return wn;
		
	}
	
	this.showWeekNumbers = function() {
		this.base.firstChild.className = "dhtmlxcalendar_wn";
	}
	
	this.hideWeekNumbers = function() {
		this.base.firstChild.className = "";
	}
	
	/* show/hide calendar */
	
	// public show/hide
	
	this.show = function(id) {
		// if id not set - try show in container
		if (!id && this._hasParent) {
			this._show();
			return;
		}
		// if input id not specified show near first found
		// if nothing found - do not show
		if (typeof(id) == "object" && typeof(id._dhtmlxcalendar_uid) != "undefined" && this.i[id._dhtmlxcalendar_uid] == id) {
			this._show(id._dhtmlxcalendar_uid);
			return;
		}
		if (typeof(id) == "undefined") { for (var a in this.i) if (!id) id = a; }
		if (!id) return;
		this._show(id);
	}
	
	this.hide = function() {
		if (this._isVisible()) this._hide();
	}
	
	this.isVisible = function() {
		return this._isVisible();
	}
	
	
	// private show/hide
	this._activeInp = null;
	
	this.pos = "bottom";
	this.setPosition = function(x, y) {
		this._px = null;
		this._py = null;
		if (x == "right" || x == "bottom") {
			this.pos = x;
		} else {
			this.pos = "int";
			if (typeof(x) != "undefined" && !isNaN(x)) {
				this.base.style.left = x+"px";
				this._px = x;
			}
			if (typeof(y) != "undefined" && !isNaN(y)) {
				this.base.style.top = y+"px";
				this._py = y;
			}
			this._ifrSize();
		}
	}
	
	this._show = function(inpId, autoHide) {
		if (autoHide === true && this._activeInp == inpId && this._isVisible()) {
			this._hide();
			return;
		}
		this.base.style.visibility = "hidden";
		this.base.style.display = "";
		if (!inpId) {
			if (this._px && this._py) {
				this.base.style.left = this._px+"px";
				this.base.style.top = this._py+"px";
			} else {
				this.base.style.left = "0px";
				this.base.style.top = "0px";
			}
		} else {
			if (this.base.className.indexOf("dhtmlxcalendar_in_input") == -1) this.base.className += " dhtmlxcalendar_in_input";
			var i = (this.i[inpId].input||this.i[inpId].button);
			var _isIE = (navigator.appVersion.indexOf("MSIE")!=-1);
			var y1 = Math.max((_isIE?document.documentElement:document.getElementsByTagName("html")[0]).scrollTop, document.body.scrollTop);
			var y2 = y1+(_isIE?Math.max(document.documentElement.clientHeight||0,document.documentElement.offsetHeight||0,document.body.clientHeight||0):window.innerHeight);
			if (this.pos == "right") {
				this.base.style.left = this._getLeft(i)+i.offsetWidth+"px";
				this.base.style.top = Math.min(this._getTop(i),y2-this.base.offsetHeight)+"px";
			} else if (this.pos == "bottom") {
				var y0 = this._getTop(i)+i.offsetHeight+1;
				if (y0+this.base.offsetHeight > y2) y0 = this._getTop(i)-this.base.offsetHeight;
				this.base.style.left = this._getLeft(i)+"px";
				this.base.style.top = y0+"px";
			} else {
				this.base.style.left = (this._px||0)+"px";
				this.base.style.top = (this._py||0)+"px";
			}
			this._activeInp = inpId;
			i = null;
		}
		this._hideSelector();
		this.base.style.visibility = "visible";
		this.base.style.zIndex = window.dhx4.zim.reserve(this.conf.zi);
		this._ifrSize();
		if (this._ifr) this._ifr.style.display = "";
		this.callEvent("onShow",[]);
	}
	
	this._hide = function() {
		this._hideSelector();
		this.base.style.display = "none";
		window.dhx4.zim.clear(this.conf.zi);
		if (this.base.className.indexOf("dhtmlxcalendar_in_input") >= 0) this.base.className = this.base.className.replace(/\s{0,}dhtmlxcalendar_in_input/gi, "");
		this._activeInp = null;
		if (this._ifr) this._ifr.style.display = "none";
		this.callEvent("onHide",[]);
	}
	
	this._isVisible = function() {
		return (this.base.style.display!="none");
	}
		
	this._getLeft = function(obj) {
		return this._posGetOffset(obj).left;
	}
	
	this._getTop = function(obj) {
		return this._posGetOffset(obj).top;
	}
	
	this._posGetOffsetSum = function(elem) {
		var top=0, left=0;
		while(elem) {
			top = top + parseInt(elem.offsetTop);
			left = left + parseInt(elem.offsetLeft);
			elem = elem.offsetParent;
		}
		return {top: top, left: left};
	}
	this._posGetOffsetRect = function(elem) {
		var box = elem.getBoundingClientRect();
		var body = document.body;
		var docElem = document.documentElement;
		var scrollTop = window.pageYOffset || docElem.scrollTop || body.scrollTop;
		var scrollLeft = window.pageXOffset || docElem.scrollLeft || body.scrollLeft;
		var clientTop = docElem.clientTop || body.clientTop || 0;
		var clientLeft = docElem.clientLeft || body.clientLeft || 0;
		var top  = box.top +  scrollTop - clientTop;
		var left = box.left + scrollLeft - clientLeft;
		return { top: Math.round(top), left: Math.round(left) };                                 
	}
	this._posGetOffset = function(elem) {
		return this[elem.getBoundingClientRect?"_posGetOffsetRect":"_posGetOffsetSum"](elem);
	}
	
	this._rangeActive = false;
	this._rangeFrom = null;
	this._rangeTo = null;
	this._rangeSet = {};
	
	this.setInsensitiveDays = function(d) {
		
		// !works in append mode
		var t = this._extractDates(d);
		for (var q=0; q<t.length; q++) this._rangeSet[new Date(t[q].getFullYear(),t[q].getMonth(),t[q].getDate(),0,0,0,0).getTime()] = true;
		
		this._drawMonth(this._activeMonth);
		
	}
	
	this.clearInsensitiveDays = function() {
		this._clearRangeSet();
		this._drawMonth(this._activeMonth);
	}
	
	this._holidays = {};
	this.setHolidays = function(r) {
		if (r == null) {
			this._clearHolidays();
		} else if (r != null) {
			var t = this._extractDates(r);
			for (var q=0; q<t.length; q++) this._holidays[new Date(t[q].getFullYear(),t[q].getMonth(),t[q].getDate(),0,0,0,0).getTime()] = true;
		}
		this._drawMonth(this._activeMonth);
	}
	
	this._extractDates = function(r) {
		// r = array of dates or comma-separated string list
		// return array with dates
		if (typeof(r) == "string" || r instanceof Date) r = [r];
		var t = [];
		for (var q=0; q<r.length; q++) {
			if (typeof(r[q]) == "string") {
				var e = r[q].split(",");
				for (var w=0; w<e.length; w++) t.push(this._strToDate(e[w]));
			} else if (r[q] instanceof Date) {
				t.push(r[q]);
			}
		}
		return t;
	}
	
	this._clearRange = function() {
		this._rangeActive = false;
		this._rangeType = null;
		this._rangeFrom = null;
		this._rangeTo = null;
	}
	
	this._clearRangeSet = function() {
		for (var a in this._rangeSet) {
			this._rangeSet[a] = null;
			delete this._rangeSet[a];
		}
	}
	
	this._clearHolidays = function() {
		for (var a in this._holidays) {
			this._holidays[a] = null;
			delete this._holidays[a];
		}
	}
	
	this._isOutOfRange = function(time) {
		
		if (this._rangeSet[time] == true) return true;
		
		if (this._rangeActive) {
			
			if (this._rangeType == "in" && (time<this._rangeFrom || time>this._rangeTo)) return true;
			if (this._rangeType == "out" && (time>=this._rangeFrom && time<=this._rangeTo)) return true;
			if (this._rangeType == "from" && time<this._rangeFrom)return true;
			if (this._rangeType == "to" && time>this._rangeTo) return true;
		}
		
		var t0 = new Date(time);
		
		if (this._rangeWeek) {
			if (this._rangeWeekData[t0.getDay()] === true) return true;
		}
		
		if (this._rangeMonth) {
			if (this._rangeMonthData[t0.getDate()] === true) return true;
		}
		
		if (this._rangeYear) {
			if (this._rangeYearData[t0.getMonth()+"_"+t0.getDate()] === true) return true;
		}
		
		return false;
		
	}
	
	this.clearSensitiveRange = function() {
		this._clearRange();
		this._drawMonth(this._activeMonth);
	}
	
	this.setSensitiveRange = function(from, to, ins) {
		
		var f = false;
		
		// set range
		if (from != null && to != null) {
			
			if (!(from instanceof Date)) from = this._strToDate(from);
			if (!(to instanceof Date)) to = this._strToDate(to);
			
			if (from.getTime() > to.getTime()) return;
			
			this._rangeFrom = new Date(from.getFullYear(),from.getMonth(),from.getDate(),0,0,0,0).getTime();
			this._rangeTo = new Date(to.getFullYear(),to.getMonth(),to.getDate(),0,0,0,0).getTime();
			this._rangeActive = true;
			this._rangeType = "in";
			
			f = true;
		}
		
		// set range "from date"
		if (!f && from != null && to == null) {
			
			if (!(from instanceof Date)) from = this._strToDate(from);
			this._rangeFrom = new Date(from.getFullYear(),from.getMonth(),from.getDate(),0,0,0,0).getTime();
			this._rangeTo = null;
			
			if (ins === true) this._rangeFrom++;
			
			this._rangeActive = true;
			this._rangeType = "from";
			
			f = true;
			
		}
		
		// set range "to date"
		if (!f && from == null && to != null) {
			
			if (!(to instanceof Date)) to = this._strToDate(to);
			this._rangeFrom = null;
			this._rangeTo = new Date(to.getFullYear(),to.getMonth(),to.getDate(),0,0,0,0).getTime();
			
			if (ins === true) this._rangeTo--;
			
			this._rangeActive = true;
			this._rangeType = "to";
			
			f = true;
			
		}
		
		if (f) this._drawMonth(this._activeMonth);
	}
	
	this.setInsensitiveRange = function(from, to) {
		
		if (from != null && to != null) {
			
			if (!(from instanceof Date)) from = this._strToDate(from);
			if (!(to instanceof Date)) to = this._strToDate(to);
			
			if (from.getTime() > to.getTime()) return;
			
			this._rangeFrom = new Date(from.getFullYear(),from.getMonth(),from.getDate(),0,0,0,0).getTime();
			this._rangeTo = new Date(to.getFullYear(),to.getMonth(),to.getDate(),0,0,0,0).getTime();
			this._rangeActive = true;
			this._rangeType = "out";
			
			this._drawMonth(this._activeMonth);
			return;
		}
		
		if (from != null && to == null) {
			this.setSensitiveRange(null, from, true);
			return;
		}
		
		if (from == null && to != null) {
			this.setSensitiveRange(to, null, true);
			return;
		}
		
	}
	
	//
	this.disableDays = function(mode, d) {
		
		if (mode == "week") {
			
			// !! works in replace mode
			
			if (typeof(d) != "object" && typeof(d.length) == "undefined") d = [d];
			
			if (!this._rangeWeekData) this._rangeWeekData = {};
			for (var a in this._rangeWeekData) {
				this._rangeWeekData[a] = false;
				delete this._rangeWeekData[a];
			}
			
			for (var q=0; q<d.length; q++) {
				this._rangeWeekData[d[q]] = true;
				if (d[q] == 7) this._rangeWeekData[0] = true;
			}
			this._rangeWeek = true;
		}
		
		if (mode == "month") {
			
			// !! works in replace mode
			
			if (typeof(d) != "object" && typeof(d.length) == "undefined") d = [d];
			
			if (!this._rangeMonthData) this._rangeMonthData = {};
			for (var a in this._rangeMonthData) {
				this._rangeMonthData[a] = false;
				delete this._rangeMonthData[a];
			}
			for (var q=0; q<d.length; q++) this._rangeMonthData[d[q]] = true;
			
			this._rangeMonth = true;
		}
		
		if (mode == "year") {
			
			// !! works in replace mode
			
			var t = this._extractDates(d);
			
			if (!this._rangeYearData) this._rangeYearData = {};
			for (var a in this._rangeYearData) {
				this._rangeYearData[a] = false;
				delete this._rangeYearData[a];
			}
			for (var q=0; q<t.length; q++) this._rangeYearData[t[q].getMonth()+"_"+t[q].getDate()] = true;
			
			this._rangeYear = true;
		}
		
		this._drawMonth(this._activeMonth);
	}
	
	this.enableDays = function(mode) {
		
		if (mode == "week") {
			this._rangeWeek = false;
		}
		
		if (mode == "month") {
			this._rangeMonth = false;
		}
		
		if (mode == "year") {
			this._rangeYear = false;
		}
		
		this._drawMonth(this._activeMonth);
	}
	
	
	/* tooltips */
	
	this._tipData = {};
	this._tipTM = null;
	this._tipTMTime = 400;
	this._tipEvs = false;
	this._tipPopup = null;
	this._tipCellDate = null;
	this._tipCellDim = null;
	
	this.setTooltip = function(dateX, text, showIcon, usePopup) {
		
		var t = this._extractDates(dateX);
		for (var q=0; q<t.length; q++) {
			var k = new Date(t[q].getFullYear(),t[q].getMonth(),t[q].getDate(),0,0,0,0).getTime();
			this._tipData[k] = { text: text, showIcon: showIcon, usePopup: usePopup };
		}
		this._drawMonth(this._activeMonth);
	}
	
	this.clearTooltip = function(dateX) {
		
		var t = this._extractDates(dateX);
		for (var q=0; q<t.length; q++) {
			var k = new Date(t[q].getFullYear(),t[q].getMonth(),t[q].getDate(),0,0,0,0).getTime();
			this._tipData[k] = null;
			delete this._tipData[k];
		}
		this._drawMonth(this._activeMonth);
	}
	
	this._initTooltipPopup = function() {
		
		if (this._tipEvs) return;
		
		this.attachEvent("onMouseOver", function(d){
			var k = new Date(d.getFullYear(),d.getMonth(),d.getDate(),0,0,0,0).getTime();
			if (this._tipData[k] != null) {
				if (this._tipTM) window.clearTimeout(this._tipTM);
				this._tipCellDate = d;
				this._tipCellDim = this.getCellDimension(d);
				this._tipText = this._tipData[k].text;
				this._tipTM = window.setTimeout(this._showTooltipPopup,this._tipTMTime);
			}
		});
		
		this.attachEvent("onMouseOut", this._hideTooltipPopup);
		
		this._tipEvs = true;
	}
	this._showTooltipPopup = function(text,x,y,w,h) {
		if (!that._tipPopup) that._tipPopup = new dhtmlXPopup({mode:"top"});
		that._tipPopup.attachHTML(that._tipText);
		that._tipPopup.show(that._tipCellDim.x, that._tipCellDim.y, that._tipCellDim.w, that._tipCellDim.h);
		that.callEvent("onPopupShow",[that._tipCellDate]);
	}
	
	this._hideTooltipPopup = function() {
		if (this._tipTM) window.clearTimeout(this._tipTM);
		if (this._tipPopup != null && this._tipPopup.isVisible()) {
			this._tipPopup.hide();
			this.callEvent("onPopupHide",[this._tipCellDate]);
		}
	}
	
	this.getPopup = function() {
		return this._tipPopup;
	}
	
	this.getCellDimension = function(dateX) {
		
		if (typeof(dateX) == "string") dateX = this._strToDate(dateX);
		if (!(dateX instanceof Date)) return null;
		
		var t = new Date(dateX.getFullYear(),dateX.getMonth(),dateX.getDate(),0,0,0,0).getTime();
		
		var k = null;
		
		for (var q=0; q<this.contDates.childNodes.length; q++) {
			for (var w=0; w<this.contDates.childNodes[q].childNodes.length; w++) {
				var p = this.contDates.childNodes[q].childNodes[w];
				if (p._date != null && p._date.getTime() == t) k = { x: this._getLeft(p), y: this._getTop(p), w: p.offsetWidth, h: p.offsetHeight };
				p = null;
			}
		}
		
		return k;
	}
	
	/* other */
	this._updateFromInput = function(t) {
		if (this._nullInInput && ((t.value).replace(/\s/g,"")).length == 0) {
			if (this.checkEvent("onBeforeChange")) {
				if (!this.callEvent("onBeforeChange",[null])) {
					// revert value
					if (this.i != null && this._activeInp != null && this.i[this._activeInp] != null && this.i[this._activeInp].input != null) {
						this.i[this._activeInp].input.value = this.getFormatedDate();
					}
					return;
				}
			}
			this.setDate(null);
		} else {
			this._updateDateStr(t.value);
		}
		t = null;
	}
	
	// global events
	this._doOnClick = function(e) {
		e = e||event;
		var t = (e.target||e.srcElement);
		// completely close alien calendar (both selector and container) inly if any assigned input clicked
		// otherwise hide selector and container separately
		if (t._dhtmlxcalendar_uid && t._dhtmlxcalendar_uid != that._activeInp && that._isVisible() && that._activeInp) {
			that._hide();
			return;
		}
		if (!t._dhtmlxcalendar_uid || !that.i[t._dhtmlxcalendar_uid]) { // !that.i[t._dhtmlxcalendar_uid] means alien input, for several calendar instances
			if (that._isSelectorVisible()) that._hideSelector(); else if (!that._hasParent && that._isVisible()) that._hide();
		}
	}
	
	this._doOnKeyDown = function(e) {
		e = e||event;
		if (e.keyCode == 27 || e.keyCode == 13) {
			if (that._isSelectorVisible()) that._hideSelector(); else if (that._isVisible() && !that._hasParent) that._hide();
		}
	}
	
	// inputs events
	this._doOnInpClick = function(e) {
		e = e||event;
		if (e.type == "touchstart" && e.preventDefault != null) e.preventDefault();
		var t = (e.target||e.srcElement);
		if (!t._dhtmlxcalendar_uid) return;
		if (!that._listenerEnabled) {
			that._updateFromInput(t);
		}
		that._show(t._dhtmlxcalendar_uid, true);
	}
	
	this._doOnInpKeyUp = function(e) {
		e = e||event;
		var t = (e.target||e.srcElement);
		if (e.keyCode == 13 || !t._dhtmlxcalendar_uid) return;
		// otherwise try to update calendar's date
		if (!that._listenerEnabled) that._updateFromInput(t);
	}
	
	this._doOnBtnClick = function(e) {
		e = e||event;
		if (e.type == "touchstart" && e.preventDefault != null) e.preventDefault();
		var t = (e.target||e.srcElement);
		if (!t._dhtmlxcalendar_uid) return;
		if (that.i[t._dhtmlxcalendar_uid].input != null) that._updateFromInput(that.i[t._dhtmlxcalendar_uid].input);
		that._show(t._dhtmlxcalendar_uid, true);
	}
	
	this._doOnUnload = function() {
		if (that && that.unload) that.unload();
	}
	
	if (typeof(window.addEventListener) == "function") {
		document.body.addEventListener("click", that._doOnClick, false);
		window.addEventListener("keydown", that._doOnKeyDown, false);
		window.addEventListener("unload", that._doOnUnload, false);
		if (this.conf.touch == true) document.body.addEventListener("touchstart", that._doOnClick, false);
	} else {
		document.body.attachEvent("onclick", that._doOnClick);
		document.body.attachEvent("onkeydown", that._doOnKeyDown);
		window.attachEvent("onunload", that._doOnUnload);
	}
	
	this.attachObj = function(obj) {
		var a = window.dhx4.newId();
		if (typeof(obj) == "string") {
			// id
			this.i[a] = {input:document.getElementById(obj)};
		} else if (typeof(obj.tagName) != "undefined") {
			// input dom obj
			this.i[a] = {input:obj};
		} else if (typeof(obj) == "object" && (obj.input != null || obj.button != null)) {
			// object
			this.i[a] = {};
			if (obj.input != null) this.i[a].input = (typeof(obj.input)=="string"?document.getElementById(obj.input):obj.input);
			if (obj.button != null) this.i[a].button = (typeof(obj.button)=="string"?document.getElementById(obj.button):obj.button);
		}
		this._attachEventsToObject(a);
		return a;
	}
	
	this.detachObj = function(obj) {
		var a = null;
		if (this.i[obj] != null) {
			// direct id
			a = obj;
		} else if (typeof(obj) == "string") {
			// id
			obj = document.getElementById(obj);
			a = obj._dhtmlxcalendar_uid;
		} else if (typeof(obj.tagName) != "undefined") {
			// input dom element
			a = obj._dhtmlxcalendar_uid;
		} else if (typeof(obj) == "object" && (obj.input != null || obj.button != null)) {
			if (a == null && obj.input != null) a = (typeof(obj.input)=="string"?document.getElementById(obj.input):obj.input)._dhtmlxcalendar_uid;
			if (a == null && obj.button != null) a = (typeof(obj.button)=="string"?document.getElementById(obj.button):obj.button)._dhtmlxcalendar_uid;
		}
		if (a != null && this.i[a] != null) {
			this._detachEventsFromObject(a);
			for (var b in this.i[b]) {
				this.i[a][b]._dhtmlxcalendar_uid = null;
				this.i[a][b] = null;
				delete this.i[a][b];
			}
			this.i[a] = null;
			delete this.i[a];
			return true;
		}
		return false;
	}
	
	this._attachEventsToObject = function(a) {
		if (this.i[a].button != null) {
			this.i[a].button._dhtmlxcalendar_uid = a;
			if (typeof(window.addEventListener) == "function") {
				this.i[a].button.addEventListener("click", that._doOnBtnClick, false);
				if (this.conf.touch == true) this.i[a].button.addEventListener("touchstart", that._doOnBtnClick, false);
			} else {
				this.i[a].button.attachEvent("onclick", that._doOnBtnClick);
			}
		} else if (this.i[a].input != null) {
			this.i[a].input._dhtmlxcalendar_uid = a;
			if (typeof(window.addEventListener) == "function") {
				this.i[a].input.addEventListener("click", that._doOnInpClick, false);
				this.i[a].input.addEventListener("keyup", that._doOnInpKeyUp, false);
				if (this.conf.touch == true) this.i[a].input.addEventListener("touchstart", that._doOnInpClick, false);
			} else {
				this.i[a].input.attachEvent("onclick", that._doOnInpClick);
				this.i[a].input.attachEvent("onkeyup", that._doOnInpKeyUp);
			}
		}
	}
	
	this._detachEventsFromObject = function(a) {
		if (this.i[a].button != null) {
			if (typeof(window.addEventListener) == "function") {
				this.i[a].button.removeEventListener("click", that._doOnBtnClick, false);
				if (this.conf.touch == true) this.i[a].button.removeEventListener("touchstart", that._doOnBtnClick, false);
				
			} else {
				this.i[a].button.detachEvent("onclick", that._doOnBtnClick);
			}
		} else if (this.i[a].input != null) {
			if (typeof(window.addEventListener) == "function") {
				this.i[a].input.removeEventListener("click", that._doOnInpClick, false);
				this.i[a].input.removeEventListener("keyup", that._doOnInpKeyUp, false);
				if (this.conf.touch == true) this.i[a].input.removeEventListener("touchstart", that._doOnInpClick, false);
			} else {
				this.i[a].input.detachEvent("onclick", that._doOnInpClick);
				this.i[a].input.detachEvent("onkeyup", that._doOnInpKeyUp);
			}
		}
	}
	
	// listener
	this.enableListener = function(t) {
		if (!t) return;
		if (typeof(window.addEventListener) == "function") {
			t.addEventListener("focus", that._listenerEvFocus, false);
			t.addEventListener("blur", that._listenerEvBlur, false);
		} else {
			t.attachEvent("onfocus", that._listenerEvFocus);
			t.attachEvent("onblur", that._listenerEvBlur);
		}
		t = null;
	}
	
	this.disableListener = function(t) {
		if (!t) return;
		t._f0 = false;
		if (this._tmListener) window.clearTimeout(this._tmListener);
		if (typeof(window.addEventListener) == "function") {
			t.removeEventListener("focus", that._listenerEvFocus, false);
			t.removeEventListener("blur", that._listenerEvBlur, false);
		} else {
			t.detachEvent("onfocus", that._listenerEvFocus);
			t.detachEvent("onblur", that._listenerEvBlur);
		}
		t = null;
	}
	
	this._startListener = function(t) {
		if (this._tmListener) window.clearTimeout(this._tmListener);
		if (typeof(t._v1) == "undefined") t._v1 = t.value;
		if (t._v1 != t.value) {
			this._updateFromInput(t);
			t._v1 = t.value;
		}
		if (t._f0) this._tmListener = window.setTimeout(function(){that._startListener(t);},100);
	}
	
	this._listenerEvFocus = function(e) {
		e = e||event;
		var t = e.target||e.srcElement;
		t._f0 = true;
		that._startListener(t)
		t = null;
	}
	this._listenerEvBlur = function(e) {
		e = e||event;
		var t = e.target||e.srcElement;
		t._f0 = false;
		t = null;
	}
	
	
	//
	for (var a in this.i) this._attachEventsToObject(a);
	
	// events
	window.dhx4._eventable(this);
	
	// event wrappers
	this._evOnArrowClick = function(args) {
		return this.callEvent("onArrowClick", args);
	}
	this._evOnClick = function(args) {
		return this.callEvent("onClick", args);
	}
	this._evOnMouseOut = function(args) {
		return this.callEvent("onMouseOut", args);
	}
	this._evOnMouseOver = function(args) {
		return this.callEvent("onMouseOver", args);
	}
	
	
	
	/* unload */
	
	this.unload = function() {
		
		this._activeDate = null;
		this._activeDateCell = null;
		this._activeInp = null;
		this._activeMonth = null;
		this._dateFormat = null;
		this._dateFormatRE = null;
		this._lastHover = null;
		
		if (this._tmListener) window.clearTimeout(this._tmListener);
		this._tmListener = null;
		
		/* main events */
		
		if (typeof(window.addEventListener) == "function") {
			document.body.removeEventListener("click", that._doOnClick, false);
			window.removeEventListener("keydown", that._doOnKeyDown, false);
			window.removeEventListener("unload", that._doOnUnload, false);
			if (this.conf.touch == true) document.body.removeEventListener("touchstart", that._doOnClick, false);
		} else {
			document.body.detachEvent("onclick", that._doOnClick);
			document.body.detachEvent("onkeydown", that._doOnKeyDown);
			window.detachEvent("onunload", that._doOnKeyDown);
		}
		
		this._doOnClick = null;
		this._doOnKeyDown = null;
		this._doOnUnload = null;
		
		/* assigned inputs */
		
		for (var a in this.i) {
			// marker
			this.i[a]._dhtmlxcalendar_uid = null;
			
			// events
			this._detachEventsFromObject(a);
			this.disableListener(this.i[a].input);
			
			this.i[a] = null;
			delete this.i[a];
			
		}
		
		this.i = null;
		
		this._doOnInpClick = null;
		this._doOnInpKeyUp = null;
		
		/* clear events */
		window.dhx4._eventable(this, "clear");
		
		/* months */
		
		this.contMonth.onselectstart = null;
		
		// li
		this.contMonth.firstChild.firstChild.onclick = null;
		this.contMonth.firstChild.firstChild.ontouchstart = null;
		
		// arrows
		this.contMonth.firstChild.firstChild.firstChild.onmouseover = null;
		this.contMonth.firstChild.firstChild.firstChild.onmouseout = null;
		this.contMonth.firstChild.firstChild.lastChild.onmouseover = null;
		this.contMonth.firstChild.firstChild.lastChild.onmouseout = null;
		
		while (this.contMonth.firstChild.firstChild.childNodes.length > 0) this.contMonth.firstChild.firstChild.removeChild(this.contMonth.firstChild.firstChild.lastChild);
		
		// li
		this.contMonth.firstChild.removeChild(this.contMonth.firstChild.firstChild);
		
		// ul
		this.contMonth.removeChild(this.contMonth.firstChild);
		
		// div
		this.contMonth.parentNode.removeChild(this.contMonth);
		this.contMonth = null;
		
		/* days */
		
		// li
		while (this.contDays.firstChild.childNodes.length > 0) this.contDays.firstChild.removeChild(this.contDays.firstChild.lastChild);
		
		// ul
		this.contDays.removeChild(this.contDays.firstChild);
		
		// div
		this.contDays.parentNode.removeChild(this.contDays);
		this.contDays = null;
		
		/* dates */
		
		this.contDates.onclick = null;
		this.contDates.ontouchstart = null;
		this.contDates.onmouseover = null;
		this.contDates.onmouseout = null;
		
		while (this.contDates.childNodes.length > 0) {
			while (this.contDates.lastChild.childNodes.length > 0) {
				// li
				this.contDates.lastChild.lastChild._css_date = null;
				this.contDates.lastChild.lastChild._css_month = null;
				this.contDates.lastChild.lastChild._css_weekend = null;
				this.contDates.lastChild.lastChild._css_hover = null;
				this.contDates.lastChild.lastChild._date = null;
				this.contDates.lastChild.lastChild._q = null;
				this.contDates.lastChild.lastChild._w = null;
				this.contDates.lastChild.removeChild(this.contDates.lastChild.lastChild);
			}
			// ul
			this.contDates.removeChild(this.contDates.lastChild);
		}
		
		// div
		this.contDates.parentNode.removeChild(this.contDates);
		this.contDates = null;
		
		/* time */
		
		this.contTime.firstChild.firstChild.onclick = null;
		this.contTime.firstChild.firstChild.ontouchstart = null;
		
		// labels
		while (this.contTime.firstChild.firstChild.childNodes.length > 0) this.contTime.firstChild.firstChild.removeChild(this.contTime.firstChild.firstChild.lastChild);
		
		// li
		this.contTime.firstChild.removeChild(this.contTime.firstChild.firstChild);
		
		// ul
		this.contTime.removeChild(this.contTime.firstChild);
		
		// div
		this.contTime.parentNode.removeChild(this.contTime);
		this.contTime = null;
		
		
		this._lastHover = null;
		
		/* selector */
		
		this._unloadSelector("month");
		this._unloadSelector("year");
		this._unloadSelector("hours");
		this._unloadSelector("minutes");
		
		// selector cover
		if (this._selCover) {
			this._selCover.parentNode.removeChild(this._selCover);
			this._selCover = null;
		}
		
		// selector object
		if (this._sel) {
			
			for (var a in this._sel._ta) this._sel._ta[a] = null;
			this._sel._ta = null;
			this._sel._t = null;
			
			this._sel.onmouseover = null;
			this._sel.onmouseout = null;
			
			// td
			while (this._sel.firstChild.firstChild.firstChild.childNodes.length > 0) {
				this._sel.firstChild.firstChild.firstChild.lastChild.onclick = null;
				this._sel.firstChild.firstChild.firstChild.lastChild.onmouseover = null;
				this._sel.firstChild.firstChild.firstChild.lastChild.onmouseout = null;
				this._sel.firstChild.firstChild.firstChild.removeChild(this._sel.firstChild.firstChild.firstChild.lastChild);
			}
			
			// tr
			this._sel.firstChild.firstChild.removeChild(this._sel.firstChild.firstChild.firstChild);
			
			// tbody
			this._sel.firstChild.removeChild(this._sel.firstChild.firstChild);
			
			// table and arrow div
			while (this._sel.childNodes.length > 0) this._sel.removeChild(this._sel.lastChild);
			
			// object
			this._sel.parentNode.removeChild(this._sel);
			this._sel = null;
		}
		
		
		/* base */
		
		this.base.onclick = null;
		this.base.onmousedown = null;
		this.base.ontouchstart = null;
		this.base.onmouseout = null;
		this.base.parentNode.removeChild(this.base);
		this.base = null;
		
		/* methods */
		
		this._clearDayHover = null;
		this._clearSelHover = null;
		this._doOnSelectorChange = null;
		this._doOnSelectorShow = null;
		this._drawMonth = null;
		this._fixLength = null;
		this._getLeft = null;
		this._getTop = null;
		this._ifrSize = null;
		this._hide = null;
		this._hideSelector = null;
		this._initSelector = null;
		this._isSelectorVisible = null;
		this._isVisible = null;
		this._posGetOffset = null;
		this._posGetOffsetRect = null;
		this._posGetOffsetSum = null;
		this._scrollYears = null;
		this._show = null;
		this._showSelector = null;
		this._strToDate = null;
		this._updateActiveHours = null;
		this._updateActiveMinutes = null;
		this._updateActiveMonth = null;
		this._updateActiveYear = null;
		this._updateCellStyle = null;
		this._updateDateStr = null;
		this._updateVisibleHours = null;
		this._updateVisibleMinutes = null;
		this._updateYearsList = null;
		this.enableIframe = null;
		this.hide = null;
		this.hideTime = null;
		this.setDate = null;
		this.setDateFormat = null;
		this.setYearsRange = null;
		this.show = null;
		this.showTime = null;
		this.unload = null;
		
		/* popup */
		if (this._tipPopup != null) {
			this._tipPopup.unload();
			this._tipPopup = null;
		}
		
		for (var a in this) delete this[a];
		
		a = that = null;
		
	}
	
	
	// set init date
	this.setDate(this._activeDate);
	
	return this;
};

dhtmlXCalendarObject.prototype.lang = "ru";
dhtmlXCalendarObject.prototype.langData = {
	"en": {
		dateformat: "%Y-%m-%d",
		hdrformat: "%F %Y",
		monthesFNames: ["January","February","March","April","May","June","July","August","September","October","November","December"],
		monthesSNames: ["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"],
		daysFNames: ["Sunday","Monday","Tuesday","Wednesday","Thursday","Friday","Saturday"],
		daysSNames: ["Su","Mo","Tu","We","Th","Fr","Sa"],
		weekstart: 1,
		weekname: "w"
	},
	"ru": {
		dateformat: "%d.%m.%Y",
		monthesFNames: ["Январь","Февраль","Март","Апрель","Maй","Июнь","Июль","Август","Сентябрь","Oктябрь","Ноябрь","Декабрь"],
		monthesSNames: ["Янв","Фев","Maр","Aпр","Maй","Июн","Июл","Aвг","Сен","Окт","Ноя","Дек"],
		daysFNames: ["Воскресенье","Понедельник","Вторник","Среда","Четверг","Пятница","Суббота"],
		daysSNames: ["Вс","Пн","Вт","Ср","Чт","Пт","Сб"],
		weekstart: 1,
		weekname: "Нд"
	}
};

dhtmlXCalendarObject.prototype._buildMonthHdr = function(val) {
	var that = this;
	var z = function(t) {
		return (String(t).length==1?"0"+String(t):t);
	}
	var w = function(type, str) {
		return "<span class='dhtmlxcalendar_month_label_"+type+"'>"+str+"</span>";
	}
	var format = String(this.langData[this.lang].hdrformat||("%F %Y")).replace(/%[a-z]/gi, function(t){
		switch (t) {
			case "%m": return w("month", z(val.getMonth()+1));
			case "%n": return w("month", val.getMonth()+1);
			case "%M": return w("month", that.langData[that.lang].monthesSNames[val.getMonth()]);
			case "%F": return w("month", that.langData[that.lang].monthesFNames[val.getMonth()]);
			case "%y": return w("year", z(val.getYear()%100));
			case "%Y": return w("year", val.getFullYear());
			case "%%": return "%";
			default: return t;
		}
	});
	that = z = w = null;
	return format;
};

dhtmlXCalendarObject.prototype.enableIframe = function(mode) {
	if (mode == true) {
		if (!this._ifr) {
			this._ifr = document.createElement("IFRAME");
			this._ifr.frameBorder = 0;
			this._ifr.border = 0;
			this._ifr.setAttribute("src","javascript:false;");
			this._ifr.className = "dhtmlxcalendar_ifr";
			this._ifr.onload = function(){
				this.onload = null;
				this.contentWindow.document.open("text/html", "replace");
				this.contentWindow.document.write("<html><head><style>html,body{width:100%;height:100%;overflow:hidden;margin:0px;}</style></head><body</body></html>");
			}
			this.base.parentNode.insertBefore(this._ifr, this.base);
			this._ifrSize();
		}
	} else {
		if (this._ifr) {
			this._ifr.parentNode.removeChild(this._ifr);
			this._ifr = null;
		}
	}
};

dhtmlXCalendarObject.prototype._ifrSize = function() {
	if (this._ifr) {
		this._ifr.style.left = this.base.style.left;
		this._ifr.style.top = this.base.style.top;
		this._ifr.style.width = this.base.offsetWidth+"px";
		this._ifr.style.height = this.base.offsetHeight+"px";
	}
};

dhtmlxCalendarObject = dhtmlXCalendarObject;

dhtmlXCalendarObject.prototype._dateStrings = function() {
	var k = this.langData[this.lang];
	return {monthFullName: k.monthesFNames, monthShortName: k.monthesSNames, dayFullName: k.daysFNames, dayShortName: k.daysSNames};
};
dhtmlXCalendarObject.prototype._strToDate = function(val, format) {
	return window.dhx4.str2date(val, format||this._dateFormat, this._dateStrings());
};
dhtmlXCalendarObject.prototype._dateToStr = function(val, format) {
	return window.dhx4.date2str(val, format||this._dateFormat, this._dateStrings());
};


/*
Product Name: dhtmlxSuite 
Version: 4.1.3 
Edition: Professional 
License: content of this file is covered by DHTMLX Commercial or Enterprise license. Usage without proper license is prohibited. To obtain it contact sales@dhtmlx.com
Copyright UAB Dinamenta http://www.dhtmlx.com
*/

window.dhtmlxDblCalendarObject = window.dhtmlXDoubleCalendarObject = window.dhtmlXDoubleCalendar = function(parentId) {
	
	var that = this;
	
	this.leftCalendar = new dhtmlXCalendarObject(parentId);
	this.leftCalendar.hideTime();
	this.rightCalendar = new dhtmlXCalendarObject(parentId);
	this.rightCalendar.hideTime();
	
	this.leftCalendar.attachEvent("onClick", function(d){
		that._updateRange("rightCalendar", d, null);
		that._evOnClick(["left", d]);
	});
	
	this.rightCalendar.attachEvent("onClick", function(d){
		that._updateRange("leftCalendar", null, d);
		that._evOnClick(["right", d]);
	});
	
	this.leftCalendar.attachEvent("onBeforeChange", function(d){
		return that._evOnBeforeChange(["left",d]);
	});
	
	this.rightCalendar.attachEvent("onBeforeChange", function(d){
		return that._evOnBeforeChange(["right",d]);
	});
	
	this.show = function() {
		this.leftCalendar.show();
		this.rightCalendar.base.style.marginLeft=this.leftCalendar.base.offsetWidth-1+"px";
		this.rightCalendar.show();
	}
	
	this.hide = function() {
		this.leftCalendar.hide();
		this.rightCalendar.hide();
	}
	
	this.setDateFormat = function(t) {
		this.leftCalendar.setDateFormat(t);
		this.rightCalendar.setDateFormat(t);
	}
	
	this.setDates = function(d0, d1) {
		if (d0 != null) this.leftCalendar.setDate(d0);
		if (d1 != null) this.rightCalendar.setDate(d1);
		this._updateRange();
	}
	
	this._updateRange = function(obj, from, to) {
		if (arguments.length == 3) {
			(obj=="leftCalendar"?this.leftCalendar:this.rightCalendar).setSensitiveRange(from, to);
		} else {
			this.leftCalendar.setSensitiveRange(null, this.rightCalendar.getDate());
			this.rightCalendar.setSensitiveRange(this.leftCalendar.getDate(), null);
		}
	}
	
	this.getFormatedDate = function() {
		return this.leftCalendar.getFormatedDate.apply(this.leftCalendar, arguments);
	}
	
	this.unload = function() {
		
		window.dhx4._eventable(this, "clear");
		
		this.leftCalendar.unload();
		this.rightCalendar.unload();
		this.leftCalendar = this.rightCalendar = null;
		
		this._updateRange = null;
		this._evOnClick = null;
		this._evOnBeforeChange = null;
		this.show = null;
		this.hide = null;
		this.setDateFormat = null;
		this.setDates = null;
		this.getFormatedDate = null;
		this.unload = null;
		
		that = null;
	}
	
	this._evOnClick = function(args) {
		return this.callEvent("onClick", args);
	}
	this._evOnBeforeChange = function(args) {
		return this.callEvent("onBeforeChange", args);
	}
	
	window.dhx4._eventable(this);
	
	return this;
}


/*
Product Name: dhtmlxSuite 
Version: 4.1.3 
Edition: Professional 
License: content of this file is covered by DHTMLX Commercial or Enterprise license. Usage without proper license is prohibited. To obtain it contact sales@dhtmlx.com
Copyright UAB Dinamenta http://www.dhtmlx.com
*/

function dhtmlXCombo(parentId, formName, width, optionType, tabIndex) {
	
	// console.info("allow html in options?");
	// console.info("add placeholder?");
	// console.info("iframe for IE6");
	
	var that = this;
	var apiObj = null;
	var skin = null;
	if (typeof(parentId) == "object" && !parentId.tagName) {
		apiObj = parentId;
		parentId = apiObj.parent;
		width = apiObj.width;
		formName = apiObj.name;
		optionType = apiObj.mode;
		skin = apiObj.skin;
	}
	
	this.cont = (typeof(parentId)=="string"?document.getElementById(parentId):parentId);
	
	this.conf = {
		skin: null,
		form_name: formName||"dhxcombo",
		combo_width: (parseInt(width)||this.cont.offsetWidth||120)-(dhx4.isFF||dhx4.isIE||dhx4.isChrome||dhx4.isOpera?2:0),
		combo_image: false,
		combo_focus: false,
		opts_type: (typeof(optionType)=="string" && typeof(this.modes[optionType]) !="undefined" ? optionType : "option"),
		opts_count: 8, // count of visible items
		opts_count_min: 3, // min count of visible items (when near screen edge)
		opts_width: null,
		item_h: null,
		list_zi_id: window.dhx4.newId(), // "dhxcombo_list_"+window.dhx4.newId(), // z-index id
		allow_free_text: true,
		allow_empty_value: true, // allow empty value in combo (when free_text not allowed)
		enabled: true,
		// images
		img_path: "",
		img_def: "",
		img_def_dis: true, // if set to true - img_def used for disabled
		// templates
		template: {
			input: "#text#", // template for top-input
			option: "#text#" // template for option text
		},
		// filtering
		f_func: null,
		f_mode: false, // "start", "between"
		f_url: false,
		f_cache: false,
		f_cache_data: {},
		f_dyn: false,
		f_dyn_end: false, // check if last response have opts
		f_mask: "", // last loaded mask from server
		f_ac: true, // autocomplete if f_mode:"start" filtering mode
		f_ac_text: "",
		f_server_tm: null,
		f_server_last: "",
		f_loading: false,
		// scroll tm
		s_tm: null,
		s_time: 200,
		s_mode: "select", // type of subload request calling, 'select' last item or 'scroll' to last item
		// hover-selected
		last_hover: null,
		last_selected: null,
		last_match: null,
		last_text: "",
		last_value: "",
		tm_hover: null,
		tm_confirm_blur: null,
		// nav settings
		clear_click: false,
		clear_blur: false,
		clear_bsp: false,
		clear_key: false,
		// skin params
		sp: {
			dhx_skyblue: {list_ofs: 1, hdr_ofs: 1, scr_ofs: 1},
			dhx_web: {list_ofs: 0, hdr_ofs: 1, scr_ofs: 0},
			dhx_terrace: {list_ofs: 1, hdr_ofs: 1, scr_ofs: 1}
		},
		// autowidth for columns mode
		col_w: null
	};
	
	this.conf.combo_image = (this.modes[this.conf.opts_type].image==true);
	
	this.t = {}; // options will here
	
	this.base = document.createElement("DIV");
	//this.base.className = "dhxcombo_"+this.conf.skin;
	
	this.base.style.width = this.conf.combo_width+"px";
	this.base.innerHTML = "<input type='text' class='dhxcombo_input' style='width:"+(this.conf.combo_width-24-(this.conf.combo_image?23:0))+"px;"+(this.conf.combo_image?"margin-left:23px;":"")+"' autocomplete='off'>"+
				"<input type='hidden' value=''>"+ // value
				"<input type='hidden' value='false'>"+ // new_value
				"<div class='dhxcombo_select_button'><div class='dhxcombo_select_img'></div></div>"+
				(this.conf.combo_image?"<div class='dhxcombo_top_image'>"+this.modes[this.conf.opts_type].getTopImage(null, this.conf.enabled)+"</div>":"");
	this.cont.appendChild(this.base);
	
	this.list = document.createElement("DIV");
	this.list.style.display = "none";
	document.body.insertBefore(this.list, document.body.firstChild);
	
	// auto-subload logic
	this._doOnListScroll = function() {
		if (that.conf.s_tm != null) window.clearTimeout(that.conf.s_tm);
		that.conf.s_tm = window.setTimeout(that._doOnListScrollAction, that.conf.s_time);
	}
	this._doOnListScrollAction = function() {
		that.conf.s_tm = null;
		if (that.conf.s_mode == "scroll" && that.list.scrollHeight - that.list.scrollTop - 10 < that.list.clientHeight) {
			that._subloadRequest();
		}
	}
	if (typeof(window.addEventListener) == "function") {
		this.list.addEventListener("scroll", this._doOnListScroll, false);
	} else {
		this.list.attachEvent("onscroll", this._doOnListScroll);
	}
	
	// apply skin
	this.setSkin(skin||window.dhx4.skin||(typeof(dhtmlx)!="undefined"?dhtmlx.skin:null)||window.dhx4.skinDetect("dhxcombo")||"dhx_skyblue");
	
	this._updateTopImage = function(id) {
		
		if (!this.conf.combo_image) return;
		
		if (id != null) {
			this.base.lastChild.innerHTML = this.t[id].obj.getTopImage(this.t[id].item, this.conf.enabled);
		} else {
			this.base.lastChild.innerHTML = this.modes[this.conf.opts_type].getTopImage(null, this.conf.enabled);
		}
		 
	}
	
	/* filtering */
	
	this._filterOpts = function(hiddenMode) {
		
		if (this.conf.f_server_tm) window.clearTimeout(this.conf.f_server_tm);
		
		var k = String(this.base.firstChild.value).replace(new RegExp(this.conf.f_ac_text+"$","i"),"");
		
		if (this.conf.f_server_last == k.toLowerCase()) {
			this._checkForMatch();
			return;
		}
		
		// check if user-filter specified
		if (this.conf.f_url != null && this.checkEvent("onDynXLS")) {
			this.conf.f_server_last = k.toLowerCase();
			this.callEvent("onDynXLS", [k]);
			return;
		}
		
		if (this.conf.f_url != null) {
			// server
			if (k.length == 0) {
				this.conf.f_server_last = k.toLowerCase();
				this.clearAll();
				return;
			}
			// check cache
			if (this.conf.f_cache == true && this.conf.f_cache_data[k] != null) {
				// load from cache
				this.clearAll();
				this.conf.f_server_last = k.toLowerCase();
				for (var q=0; q<this.conf.f_cache_data[k].data.length; q++) {
					this.load(this.conf.f_cache_data[k].data[q]);
				}
				if (this.conf.f_dyn) {
					this.conf.f_dyn_end = this.conf.f_cache_data[k].dyn_end;
					this.conf.f_mask = this.conf.f_cache_data[k].mask;
				}
				if (hiddenMode !== true) {
					this._showList(true);
					this._checkForMatch();
				}
			} else {
				this.conf.f_server_tm = window.setTimeout(function(){
					that.conf.f_server_last = k.toLowerCase();
					that.conf.f_mask = k;
					var params = "mask="+encodeURIComponent(k);
					if (that.conf.f_dyn) {
						params += "&pos=0";
						that.conf.f_dyn_end = false;
					}
					var callBack = function(r) {
						// cache
						if (that.conf.f_cache) {
							if (!that.conf.f_cache_data[k]) that.conf.f_cache_data[k] = {data:[],dyn_end:false,mask:k};
							that.conf.f_cache_data[k].data.push(r.xmlDoc.responseXML);
						}
						// load opts
						that.clearAll();
						that.load(r.xmlDoc.responseXML);
						
						var v = (that.base.offsetWidth > 0 && that.base.offsetHeight > 0);
						if (v == true && that.conf.enabled == true && that.conf.combo_focus == true && hiddenMode !== true) {
							// autocomplete if any
							if (that.conf.f_ac && that.conf.f_mode == "start" && that.conf.clear_bsp == false && that.list.firstChild != null) {
								// autocomplete
								var sid = that.list.firstChild._optId;
								var text = String(that.t[sid].obj.getText(that.list.firstChild, true));
								if (String(text).toLowerCase().indexOf(String(k).toLowerCase()) === 0) {
									that.base.firstChild.value = text;
									that._selectRange(k.length, text.length);
								}
							}
							that._showList(true);
							that._checkForMatch();
						}
						callBack = null;
					}
					if (window.dhx4.ajax.method == "post") {
						window.dhx4.ajax.post(that.conf.f_url, params, callBack);
					} else if (window.dhx4.ajax.method == "get") {
						window.dhx4.ajax.get(that.conf.f_url+(String(that.conf.f_url).indexOf("?")>=0?"&":"?")+params, callBack);
					}
				},200);
			}
		} else {
			// client
			this.conf.f_server_last = k.toLowerCase();
			
			var r = (k.length==0?true:new RegExp((this.conf.f_mode=="start"?"^":"")+String(k).replace(/[\\\^\$\*\+\?\.\(\)\|\{\}\[\]]/gi, "\\$&"),"i"));
			
			var acText = null;
			
			for (var a in this.t) {
				var t = false;
				if (r !== true) {
					if (this.conf.f_func != null) {
						var option = this._getOption(this.t[a].item._optId, q);
						t = (this.conf.f_func.apply(window, [k, option]) == true);
					} else {
						var text = this.t[a].obj.getText(this.t[a].item, true);
						t = (r.test(text) == true);
					}
				}
				if (r === true || t == true) {
					this.t[a].item.style.display = "";
					if (acText == null && k.length > 0) acText = String(this.t[a].obj.getText(this.t[a].item, true));//.replace(new RegExp("^"+k,"i"),"");
				} else {
					this.t[a].item.style.display = "none";
				}
			}
			
			if (this.conf.f_ac && this.conf.f_mode == "start" && this.conf.clear_bsp == false && acText != null) {
				this.conf.f_ac_text = acText.replace(new RegExp("^"+k,"i"),"");
				this.base.firstChild.value = acText;
				this._selectRange(this.conf.f_server_last.length, this.base.firstChild.value.length);
			}
			
			// if any text selected and backspace pressed - clear highlight
			// usefull for "between" mode
			if (this.conf.f_mode == "between" && this.conf.clear_bsp == true) {
				this._checkForMatch(true);
			}
			
			if (hiddenMode !== true) {
				this._showList(true);
				this._checkForMatch();
			}
		}
	}
	
	// data loading
	this._initObj = function(data) {
		if (typeof(data.template) != "undefined") this.setTemplate(data.template);
		if (data.add != true && this.conf.f_loading != true) this.clearAll(false);
		this.addOption(data.options);
	}
	
	this._xmlToObj = function(data, selectToObj, selectedIndex) {
		
		/*
		xml format:
		<complete add="true">
			<template>
				<input>...</input>
				<option>...</option>
				<columns>
					<column width="..." css="option css optional">
						<header>text in header</header>
						<option>template for text in option cell</option>
					</column>
				</columns>
			</template>
			<option value="xx" selected="1" img_src="icon_url" checked="1" css="some text">option text</option>
		</complete>
		
		img_src - also add the 4th parameter to combobox constructor - "image"
		checked - checkbox state, for combo with "checkbox" type, 0 by default
		*/
		
		var t = {add:false,options:[]};
		
		var root = (selectToObj==true?data:data.getElementsByTagName("complete"));
		
		if (root.length > 0) {
			if (window.dhx4.s2b(root[0].getAttribute("add")) == true) t.add = true;
			var nodes = root[0].childNodes;
			for (var q=0; q<nodes.length; q++) {
				if (typeof(nodes[q].tagName) != "undefined") {
					
					// template
					if (String(nodes[q].tagName).toLowerCase() == "template") {
						
						var template = {};
						
						for (var w=0; w<nodes[q].childNodes.length; w++) {
							
							var n = nodes[q].childNodes[w];
							
							if (n.tagName != null) {
								
								// default values
								var k = n.tagName;
								if (typeof(this.conf.template[k]) != "undefined") {
									template[k] = window.dhx4._xmlNodeValue(n);
								}
								
								// columns if any
								if (k == "columns") {
									for (var e=0; e<n.childNodes.length; e++) {
										
										var col = n.childNodes[e];
										
										if (col.tagName != null && col.tagName == "column") {
											
											var colData = {};
											
											// attrs
											// <column width="xx" css="xx" header="xx" option="xx"/>
											for (var a in {width:1, css:1, header:1, option:1}) {
												if (col.getAttribute(a) != null) colData[a] = col.getAttribute(a);
											}
											
											// extra header and option if any
											// <column><option><header>..</header><option>..</option></column>
											for (var a in {header:1, option:1}) {
												var h = col.getElementsByTagName(a);
												if (h[0] != null && h[0].firstChild != null) colData[a] = window.dhx4._xmlNodeValue(h[0]);
											}
											
											if (template.columns == null) template.columns = [];
											template.columns.push(colData);
											
										}
										
										col = null;
										
									}
									
								}
							}
							n = null;
						}
						this.setTemplate(template);
					}
					// option
					if (String(nodes[q].tagName).toLowerCase() == "option") {
						var optSelected = false;
						if (selectToObj == true) {
							optSelected = (t.options.length==selectedIndex);
						} else {
							optSelected = window.dhx4.s2b(nodes[q].getAttribute("selected"));
						}
						var opt = {
							value: nodes[q].getAttribute("value"),
							text: window.dhx4._xmlNodeValue(nodes[q]),
							selected: optSelected,
							checked: window.dhx4.s2b(nodes[q].getAttribute("checked"))
						};
						// images
						for (var a in {img:1,img_dis:1,img_src:1,img_src_dis:1,css:1}) {
							if (nodes[q].getAttribute(a) != null) opt[a] = nodes[q].getAttribute(a);
						}
						// text
						for (var w=0; w<nodes[q].childNodes.length; w++) {
							if (nodes[q].childNodes[w].tagName != null && String(nodes[q].childNodes[w].tagName).toLowerCase() == "text") {
								opt.text = {};
								var n = nodes[q].childNodes[w];
								for (var e=0; e<n.childNodes.length; e++) {
									if (n.childNodes[e].tagName != null) {
										opt.text[n.childNodes[e].tagName] = window.dhx4._xmlNodeValue(n.childNodes[e]);
									}
								}
							}
						}
						t.options.push(opt);
					}
				}
			}
			root = nodes = null;
		}
		return t;
	}
	
	window.dhx4._enableDataLoading(this, "_initObj", "_xmlToObj", "complete", {data:true});
	window.dhx4._eventable(this);
	
	
	this._getNearItem = function(item, dir) {
		// return nearest next/prev visible item or null
		var sid = null;
		while (item != null) {
			item = item[dir<0?"previousSibling":"nextSibling"];
			if (sid == null && item != null && item.style.display == "" && item._optId != null) {
				sid = item;
				item = null;
			}
		}
		return sid;
	}
	
	this.setName(this.conf.form_name);
	
	// list hightlight/select
	this._doOnListMouseMove = function(e) {
		e = e||event;
		var t = e.target||e.srcElement;
		while (t != null && t != this) {
			if (typeof(t._optId) != "undefined") {
				if (that.conf.tm_hover) window.clearTimeout(that.conf.tm_hover);
				that._setSelected(t._optId);
			}
			t = t.parentNode;
		}
		t = null;
	}
	
	this._doOnListMouseDown = function(e) {
		e = e||event;
		e.cancelBubble = true;
		that.conf.clear_click = true;
		window.setTimeout(function(){that.base.firstChild.focus();},1);
	}
	
	this._doOnListMouseUp = function(e) {
		// select new item
		e = e||event;
		var t = e.target||e.srcElement;
		while (t != null && t != this) {
			if (typeof(t._optId) != "undefined") {
				var r = true;
				if (typeof(that.t[t._optId].obj.optionClick) == "function" && that.t[t._optId].obj.optionClick(t, e, that) !== true) r = false;
				if (r) {
					
					that._setSelected(t._optId, null, true);
					/*
					that._hideList();
					
					that.conf.last_selected = t._optId;
					that.conf.last_text = that.base.firstChild.value = that.t[t._optId].obj.getText(that.t[t._optId].item, true);
					that.conf.f_server_last = that.base.firstChild.value.toLowerCase();
					*/
					that._confirmSelect("click");
				}
			}
			t = t.parentNode;
		}
		t = null;
	}
	
	this._doOnListMouseOut = function(e) {
		// when cursor out of item - clear hover or highlight selected
		if (that.conf.tm_hover) window.clearTimeout(that.conf.tm_hover);
		that.conf.tm_hover = window.setTimeout(function(){
			// select last selected
			var sId = that.conf.last_match||that.conf.last_selected;
			if (that.conf.last_match == null && that.t[sId] != null) {
				// but if no match found, check if entered text is same as in option
				if (that.base.firstChild.value != that.t[sId].obj.getText(that.t[sId].item, true)) sId = null;
			}
			that._setSelected(sId, null, true);
		},1);
	}
	
	this._doOnBaseMouseDown = function(e) {
		
		if (!that.conf.enabled) return;
		
		that.conf.clear_click = true;
		
		e = e||event;
		var t = e.target||e.srcElement;
		if (t != this.firstChild) {
			// focus input if list opened by clicking on arrow
			window.setTimeout(function(){that.base.firstChild.focus();},1);
			
			// top-image click?
			var p = t;
			while (p != this && p != null) {
				if (p == this.lastChild) {
					if (typeof(that.modes[that.conf.opts_type].topImageClick) == "function") {
						var t_id = (that.conf.last_hover||that.conf.last_selected);
						var t_item = (t_id != null?that.t[t_id].item:null);
						if (that.modes[that.conf.opts_type].topImageClick(t_item, that) !== true) {
							t_id = t_item = null;
							return;
						}
					}
					p = null;
				} else {
					p = p.parentNode;
				}
			}
			
		}
		
		if (that._isListVisible()) {
			that._hideList();
		} else {
			if (t != this.firstChild) that.conf.clear_blur = true;
			that._showList();
			that._setSelected(that.conf.last_selected, true, true);
		}
		t = null;
	}
	
	// body click -> hide list if any
	this._doOnBodyMouseDown = function() {
		if (that.conf.clear_click) {
			that.conf.clear_click = false;
			return;
		}
		that._confirmSelect("blur");
	}
	
	// input focus/blur
	this._doOnInputFocus = function() {
		that.conf.clear_blur = false;
		// if forus back to input - cancel confirm (occured when user clicked on arrow while list opened)
		if (that.conf.tm_confirm_blur) window.clearTimeout(that.conf.tm_confirm_blur);
		// ev
		if (that.conf.combo_focus == false) {
			that.conf.combo_focus = true;
			that.callEvent("onFocus",[]);
		}
	}
	this._doOnInputBlur = function() {
		if (that.conf.clear_blur == true) {
			that.conf.clear_blur = false;
			return;
		}
		// start confirm tm
		if (that.conf.tm_confirm_blur) window.clearTimeout(that.conf.tm_confirm_blur);
		that.conf.tm_confirm_blur = window.setTimeout(function(){
			if (that.conf.clear_click == false) {
				// if (that._isListVisible()) that._hideList();
				that._confirmSelect("blur");
				that.conf.combo_focus = false;
				that.callEvent("onBlur",[]);
			}
		},20);
	}
	
	// input events, typing/filtering
	this._doOnInputKeyUp = function(e) {
		
		e = e||event;
		
		if (that.conf.f_mode != false) {
			that.conf.clear_bsp = (e.keyCode==8||e.keyCode==46); // backspace(8) and delete(46)
			that._filterOpts();
			return;
		} else {
			that._checkForMatch();
		}
	}
	
	this._doOnInputKeyDown = function(e) {
		
		e = e||event;
		
		// console.log("onkeypress ", e.keyCode, " ", e.charCode)
		
		// up (38) /down (40)
		if ((e.keyCode == 38 || e.keyCode == 40) && !e.ctrlKey && !e.shiftKey && !e.altKey) {
			if (e.preventDefault) e.preventDefault(); else e.returnValue = false;
			e.cancelBubble = true;
			that._keyOnUpDown(e.keyCode==38?-1:1);
		}
		
		// F2
		if (e.keyCode == 113) {
			if (!that._isListVisible()) {
				that._showList();
				if (that.base.firstChild.value == that.conf.last_text) {
					that._setSelected(that.conf.last_selected, true, true);
					that.base.firstChild.value = that.conf.last_text;
					that.conf.f_server_last = that.base.firstChild.value.toLowerCase();
				} else {
					that.conf.f_server_last = that.base.firstChild.value.toLowerCase();
					if (that.conf.f_mode == false) that._checkForMatch();
				}
			} else {
				
			}
		}
		
		// esc
		if (e.keyCode == 27) {
			// cancel operation, restore last value
			if (e.preventDefault) e.preventDefault(); else e.returnValue = false;
			e.cancelBubble = true;
			that._cancelSelect();
		}
		
		// enter
		if (e.keyCode == 13) {
			if (e.preventDefault) e.preventDefault(); // if combo attached to form
			that._confirmSelect("kbd");
		}
		
		that.conf.clear_key = true;
		that.callEvent("onKeyPressed",[e.keyCode||e.charCode]);
	}
	
	this._doOnInputKeyPress = function(e) {
		if (that.conf.clear_key) {
			that.conf.clear_key = false;
			return;
		}
		e = e||event;
		that.callEvent("onKeyPressed",[e.keyCode||e.charCode]);
	}
	
	this._keyOnUpDown = function(dir) {
		
		// select(just hover) next/prev item in a list
		
		var item = null;
		if (this.conf.last_hover) {
			item = this.t[this.conf.last_hover].item;
		} else if (this.conf.last_selected) {
			item = this.t[this.conf.last_selected].item;
		}
		
		if (!item && this._getListVisibleCount() == 0) return;
		if (item != null && item.style.display != "") item = null;
		
		this._showList();
		
		if (item != null) {
			// check if item highlighted
			if (this.t[item._optId].obj.isSelected(item)) item = this._getNearItem(item, dir);
		} else {
			item = this.list.firstChild;
			if (item.style.display != "") item = this._getNearItem(item, 1);
		}
		
		if (item == null) return; // first/last
		
		this._setSelected(item._optId, true, true);
		
		if (this.conf.f_mode == false) {
			this.base.firstChild.value = this.t[item._optId].obj.getText(item, true);
		} else {
			var text = String(this.t[item._optId].obj.getText(item, true));
			if (this.conf.f_mode == "start" && this.conf.f_ac == true) {
				if (text.toLowerCase().indexOf(this.conf.f_server_last) === 0) {
					// try to find match and select part of text
					this.conf.f_ac_text = text.substring(this.conf.f_server_last.length, text.length);
					this.base.firstChild.value = text;
					this._selectRange(this.conf.f_server_last.length, this.base.firstChild.value.length);
				} else {
					// insert all text and select
					this.base.firstChild.value = text;
					this.conf.f_server_last = this.base.firstChild.value.toLowerCase();
					this._selectRange(0, this.base.firstChild.value.length);
				}
			} else {
				// just insert text into main input
				this.base.firstChild.value = text;
				this.conf.f_server_last = this.base.firstChild.value.toLowerCase();
			}
		}
		
		//
		item = null;
	}
	
	this.conf.evs_nodes = [
		{node: document.body, evs: {mousedown: "_doOnBodyMouseDown"}},
		{node: this.base, evs: {mousedown: "_doOnBaseMouseDown"}},
		{node: this.base.firstChild, evs: {keyup: "_doOnInputKeyUp", keydown: "_doOnInputKeyDown", keypress: "_doOnInputKeyPress", focus: "_doOnInputFocus", blur: "_doOnInputBlur"}},
		{node: this.list, evs: {mousemove: "_doOnListMouseMove", mousedown: "_doOnListMouseDown", mouseup: "_doOnListMouseUp", mouseout: "_doOnListMouseOut"}}
	];
	for (var q=0; q<this.conf.evs_nodes.length; q++) {
		for (var a in this.conf.evs_nodes[q].evs) {
			if (typeof(window.addEventListener) == "function") {
				this.conf.evs_nodes[q].node.addEventListener(a, this[this.conf.evs_nodes[q].evs[a]], false);
			} else {
				this.conf.evs_nodes[q].node.attachEvent("on"+a, this[this.conf.evs_nodes[q].evs[a]]);
			}
		}
	}
	
	
	this.unload = function() {
		
		// remove options
		this.clearAll();
		this.t = null;
		
		// detach dom events
		for (var q=0; q<this.conf.evs_nodes.length; q++) {
			for (var a in this.conf.evs_nodes[q].evs) {
				if (typeof(window.addEventListener) == "function") {
					this.conf.evs_nodes[q].node.removeEventListener(a, this[this.conf.evs_nodes[q].evs[a]], false);
				} else {
					this.conf.evs_nodes[q].node.detachEvent("on"+a, this[this.conf.evs_nodes[q].evs[a]]);
				}
				this.conf.evs_nodes[q].evs[a] = null;
				delete this.conf.evs_nodes[q].evs[a];
			}
			this.conf.evs_nodes[q].node = null;
			this.conf.evs_nodes[q].evs = null;
			delete this.conf.evs_nodes[q].node;
			delete this.conf.evs_nodes[q].evs;
			this.conf.evs_nodes[q] = null;
		}
		
		window.dhx4._eventable(this, "clear");
		window.dhx4._enableDataLoading(this, null, null, null, "clear");
		
		this._mcDetachHeader();
		
		// depr
		this.DOMelem_input = this.DOMelem_button = this.DOMlist = this.DOMelem = this.DOMParent = null;
		
		for (var a in this.conf) {
			this.conf[a] = null;
			delete this.conf[a];
		}
		this.conf = null;
		
		if (typeof(window.addEventListener) == "function") {
			this.list.removeEventListener("scroll", this._doOnListScroll, false);
		} else {
			this.list.detachEvent("onscroll", this._doOnListScroll);
		}
		
		if(this.base.parentNode)
			this.base.parentNode.removeChild(this.base);
		this.list.parentNode.removeChild(this.list);
		this.base = this.list = this.cont = null;
		
		this.modes = null;
		
		for (var a in this) {
			if (typeof(this[a]) == "function") this[a] = null;
		}
		
		that = null;
		
	};
	
	// DEPRECATED props
	this.DOMelem_input = this.base.firstChild; // 3.6 compat, use getInput()
	this.DOMelem_button = this.base.childNodes[this.base.childNodes.length-(this.conf.combo_image?2:1)]; // 3.6 compat, use getButton()
	this.DOMlist = this.list; // 3.6 compat, use getList()
	this.DOMelem = this.base; // 3.6 compat, use getBase()
	this.DOMParent = parentId; // 3.0 compat, use getParent()
	parentId = null;
	
	// check for object api init details
	if (apiObj != null) {
		// filter
		if (apiObj.filter != null) {
			if (typeof(apiObj.filter) == "string") {
				this.enableFilteringMode(true, apiObj.filter, window.dhx4.s2b(apiObj.filter_cache), window.dhx4.s2b(apiObj.filter_sub_load));
			} else {
				this.enableFilteringMode(true);
			}
		}
		// imgs
		if (apiObj.image_path != null) this.setImagePath(apiObj.image_path);
		if (apiObj.default_image != null || apiObj.default_image_dis != null) this.setDefaultImage(apiObj.default_image, apiObj.default_image_dis);
		// opts
		if (apiObj.items || apiObj.options) this.addOption(apiObj.items||apiObj.options);
		if (apiObj.xml || apiObj.json) this.load(apiObj.xml||apiObj.json);
		// misc
		if (typeof(apiObj.readonly) != "undefined") this.readonly(apiObj.readonly);
		//
		apiObj = null;
	}
	
	return this;
	
};

function dhtmlXComboFromSelect(selectId) {
	
	// <select mode="checkbox">
	
	if (typeof(selectId) == "string") selectId = document.getElementById(selectId);
	
	// collect params
	var comboWidth = selectId.offsetWidth;
	var formName = selectId.getAttribute("name")||null;
	
	// add node
	var comboNode = document.createElement("SPAN");
	selectId.parentNode.insertBefore(comboNode, selectId);
	
	// combo mode
	var comboMode = selectId.getAttribute("mode")||selectId.getAttribute("opt_type")||"option";
	
	// init combo
	var combo = new dhtmlXCombo(comboNode, formName, comboWidth, comboMode);
	comboNode = null;
	
	var imagePath = selectId.getAttribute("imagePath");
	if (imagePath) combo.setImagePath(imagePath);
	
	var defImg = selectId.getAttribute("defaultImage");
	var defImgDis = selectId.getAttribute("defaultImageDis");
	if (window.dhx4.s2b(defImgDis) == true) defImgDis = true;
	if (defImg != null || defImgDis != null) combo.setDefaultImage(defImg, defImgDis);
	
	// options
	var opts = combo._xmlToObj([selectId], true, selectId.selectedIndex);
	if (opts.options.length > 0) combo.addOption(opts.options);
	opts = null;
	
	// remove select
	selectId.parentNode.removeChild(selectId);
	selectId = null;
	
	return combo;
};

/* common funcs */
dhtmlXCombo.prototype.setName = function(name) { // change name for form
	this.conf.form_name = name;
	this.base.childNodes[1].name = name;
	this.base.childNodes[2].name = name.replace(/(\[.*)?$/, "_new_value$1");
};

dhtmlXCombo.prototype.readonly = function(mode) { // enable/disable readonly mode
	if (window.dhx4.s2b(mode)) {
		this.base.firstChild.setAttribute("readOnly", "true");
	} else {
		this.base.firstChild.removeAttribute("readOnly");
	}
};

dhtmlXCombo.prototype.setPlaceholder = function(text) { // new in 4.0, limited support
	if (typeof(text) == "undefined" || text == null) text = "";
	this.base.firstChild.setAttribute("placeholder", String(text));
};

dhtmlXCombo.prototype.setTemplate = function(tpl) {
	for (var a in tpl) {
		if (typeof(this.conf.template[a]) != "undefined") {
			this.conf.template[a] = String(tpl[a]);
		}
	};
	
	// columns
	if (tpl.columns != null) {
		this._mcMakeTemplate(tpl.columns);
	} else {
		this._mcDetachHeader();
	}
	
	// template changed, update combo text and update rendered options
	for (var a in this.t) {
		this.t[a].obj.setText(this.t[a].item, this.t[a].item._conf.text);
	};
	this._confirmSelect();
};

dhtmlXCombo.prototype.setSkin = function(skin) {
	if (skin == this.conf.skin) return;
	this.conf.skin = skin;
	this.base.className = "dhxcombo_"+this.conf.skin+(this.conf.enabled?"":" dhxcombo_disabled");
	this.list.className = "dhxcombolist_"+this.conf.skin+(this.hdr!=null?" dhxcombolist_multicolumn":"");
	if (this.hdr != null) this.hdr.className = "dhxcombolist_"+this.conf.skin+" dhxcombolist_hdr";
};

dhtmlXCombo.prototype.getInput = function() { // returns input, new in 4.0
	return this.base.firstChild;
};
dhtmlXCombo.prototype.getButton = function() { // returns button, new in 4.0
	return this.base.childNodes[this.base.childNodes.length-(this.conf.combo_image?2:1)];
};
dhtmlXCombo.prototype.getList = function() { // do we need it?
	return this.list;
};
dhtmlXCombo.prototype.getBase = function() { // do we need it?
	return this.base;
};

dhtmlXCombo.prototype.getParent = function() { // do we need it?
	return this.DOMParent;
};

dhtmlXCombo.prototype.forEachOption = function(handler) { // iterator, new in 4.0
	for (var q=0; q<this.list.childNodes.length; q++) {
		handler.apply(window, [this._getOption(this.list.childNodes[q]._optId, q)]);
	}
};

dhtmlXCombo.prototype.setFocus = function() {
	if (this.conf.enabled) this.base.firstChild.focus();
};
dhtmlXCombo.prototype.setFontSize = function(sizeInp, sizeList) {
	// "11px" or" "0.9em"
	if (sizeInp != null) this.base.firstChild.style.fontSize = sizeInp;
	if (sizeList != null) this.list.style.fontSize = sizeList;
};

/* options */
dhtmlXCombo.prototype.getOption = function(value) { // option by value
	var id = null;
	var index = null;
	for (var q=0; q<this.list.childNodes.length; q++) {
		if (id == null) {
			var a = this.list.childNodes[q]._optId;
			if (this.t[a].obj.getValue(this.t[a].item) == value) { id = a; index = q; }
		}
	}
	return (id==null?null:this._getOption(id, index));
};

dhtmlXCombo.prototype.getOptionByIndex = function(index) { // option by index
	if (index < 0) return null;
	if (this.list.childNodes[index] == null) return null;
	return this._getOption(this.list.childNodes[index]._optId, index);
};

dhtmlXCombo.prototype.getOptionByLabel = function(text) { // rename to getOptionByText ?
	// option by label
	var id = null;
	var index = null;
	for (var q=0; q<this.list.childNodes.length; q++) {
		if (id == null) {
			var a = this.list.childNodes[q]._optId;
			if (this.t[a].obj.getText(this.t[a].item, true) == text) { id = a; index = q; }
		}
	}
	return (id==null?null:this._getOption(id, index));
};

dhtmlXCombo.prototype.getSelectedIndex = function() { // gets index of selected option
	return this._getOptionProp(this.conf.last_selected, "index", -1);
};

dhtmlXCombo.prototype.getSelectedText = function() { // gets text of selected option
	return this._getOptionProp(this.conf.last_selected, "text", "");
};

dhtmlXCombo.prototype.getSelectedValue = function() { // gets value of selected item
	return this._getOptionProp(this.conf.last_selected, "value", null);
};

dhtmlXCombo.prototype.getActualValue = function() { // gets value which will be sent with form
	return this.base.childNodes[1].value;
};
dhtmlXCombo.prototype.getComboText = function() { // gets current text in combobox
	return this.base.childNodes[0].value;
};

dhtmlXCombo.prototype.getIndexByValue = function(value) { // returns index of item by value
	var t = this.getOption(value);
	return (t!=null?t.index:-1);
};

dhtmlXCombo.prototype.setComboText = function(text) {
	// sets text in combobox, reset selected option
	if (this.conf.allow_free_text != true) return;
	
	this.unSelectOption();
	this.conf.last_text = this.base.firstChild.value = text;
	this.conf.f_server_last = this.base.firstChild.value.toLowerCase();
	
};

dhtmlXCombo.prototype.setComboValue = function(value) {
	// sets text in combobox, only text
	var t = this.getOption(value);
	if (t != null) {
		this.selectOption(t.index);
	} else {
		this.conf.last_value = value;
		this.base.childNodes[1].value = this.conf.last_value;
		this.base.childNodes[2].value = "true";
	}
};

dhtmlXCombo.prototype.selectOption = function(index, filter, conf) { // selects option
	if (index < 0 || index >= this.list.childNodes.length) return;
	var id = this.list.childNodes[index]._optId;
	this._setSelected(id, this._isListVisible(), true);
	this._confirmSelect("script");
};

dhtmlXCombo.prototype.unSelectOption = function() { // unselects option
	
	if (this.conf.last_hover != null) {
		this.t[this.conf.last_hover].obj.setSelected(this.t[this.conf.last_hover].item, false);
		this.conf.last_hover = null;
	}
	
	this.base.firstChild.value = "";
	
	if (this.conf.f_mode != false) {
		this._filterOpts(true);
	}
	this._hideList();
	this._updateTopImage(null);
	
	this._confirmSelect("script");
	
};

dhtmlXCombo.prototype.confirmValue = function() {
	this._confirmSelect("script");
};

/* enable/disable */
dhtmlXCombo.prototype.enable = function(mode) {
	
	mode = (typeof(mode)=="undefined"?true:window.dhx4.s2b(mode));
	if (this.conf.enabled == mode) return;
	
	this.conf.enabled = mode;
	
	if (mode) {
		this.base.className = "dhxcombo_"+this.conf.skin;
		this.base.firstChild.removeAttribute("disabled");
	} else {
		this._hideList();
		this.base.className = "dhxcombo_"+this.conf.skin+" dhxcombo_disabled";
		this.base.firstChild.setAttribute("disabled","true");
	}
	
	// update disabled image if any
	this._updateTopImage(this.conf.last_selected);
};

dhtmlXCombo.prototype.disable = function(mode) {
	mode = (typeof(mode)=="undefined"?true:window.dhx4.s2b(mode));
	this.enable(!mode);
};

dhtmlXCombo.prototype.isEnabled = function() {
	return (this.conf.enabled==true);
};

/* visibility */
dhtmlXCombo.prototype.show = function(mode) {
	if (typeof(mode) == "undefined") mode = true; else mode = window.dhx4.s2b(mode);
	this.base.style.display = (mode==true?"":"none");
};

dhtmlXCombo.prototype.hide = function(mode) {
	if (typeof(mode) == "undefined") mode = true;
	this.show(!mode);
};

dhtmlXCombo.prototype.isVisible = function() {
	return (this.base.style.display=="");
};


/* filtering */
dhtmlXCombo.prototype.setFilterHandler = function(f) {
	if (typeof(f) == "function") {
		this.conf.f_func = f;
		this.conf.f_mode = true;
		this.conf.f_dyn = this.conf.f_cache = this.conf.f_url = null;
	} else if (typeof(f) == "string" && typeof(window[f]) == "function") {
		this.conf.f_func = window[f];
		this.conf.f_mode = true;
		this.conf.f_dyn = this.conf.f_cache = this.conf.f_url = null;
	} else {
		this.conf.f_func = null;
	}
};
dhtmlXCombo.prototype.enableFilteringMode = function(mode, url, cache, dyn) {
	if (mode == true || mode == "between") {
		this.conf.f_mode = (mode==true?"start":"between");
		if (url != null) {
			this.conf.f_url = url;
			this.conf.f_cache = window.dhx4.s2b(cache);
			this.conf.f_dyn = window.dhx4.s2b(dyn);
		} else {
			this.conf.f_url = null;
			this.conf.f_cache = false;
			this.conf.f_dyn = false;
		}
	} else {
		this.conf.f_mode = false;
		this.conf.f_url = null;
		this.conf.f_cache = false;
		this.conf.f_dyn = false;
	}
};

dhtmlXCombo.prototype.filter = function(handler, showList) { // new in 4.0
	for (var q=0; q<this.list.childNodes.length; q++) {
		var k = handler.apply(window, [this._getOption(this.list.childNodes[q]._optId,q)]);
		this.list.childNodes[q].style.display = (k===true?"":"none");
	}
	if (typeof(showList) == "undefined" || showList == true) {
		this._showList(true);
	}
};

dhtmlXCombo.prototype.sort = function(mode) { // new in 4.0
	var r = [];
	for (var q=0; q<this.list.childNodes.length; q++) {
		var id = this.list.childNodes[q]._optId;
		r.push([id, this._getOption(id, q)]);
	}
	// sort
	if (mode == "asc" || mode == "desc") {
		k = true;
		r.sort(function(a,b){
			a = a[1].text_option.toLowerCase();
			b = b[1].text_option.toLowerCase();
			var r = (mode=="asc"?1:-1);
			return (a>b?r:-1*r);
		});
	} else if (typeof(mode) == "function" || typeof(window[mode]) == "function") {
		if (typeof(window[mode]) == "function") mode = window[mode];
		r.sort(function(a,b){
			return mode.apply(window, [a[1],b[1]]);
		});
	}
	// reorder
	while (this.list.childNodes.length > 0) this.list.removeChild(this.list.lastChild);
	for (var q=0; q<r.length; q++) this.list.appendChild(this.t[r[q][0]].item);
};

dhtmlXCombo.prototype.enableAutocomplete = function(mode) { // autocomplete for f_mode:start, enabled by default
	if (typeof(mode) == "undefined") mode = true; else mode = window.dhx4.s2b(mode);
	this.conf.f_ac = mode;
};
dhtmlXCombo.prototype.disableAutocomplete = function(mode) {
	if (typeof(mode) == "undefined") mode = true; else mode = window.dhx4.s2b(mode);
	this.enableAutocomplete(!mode);
};

dhtmlXCombo.prototype.allowFreeText = function(mode) { // new in 4.0
	this.conf.allow_free_text = (typeof(mode)=="undefined"?true:window.dhx4.s2b(mode));
};

dhtmlXCombo.prototype._checkForMatch = function(forceClear) {
	// check if text matched to any opt_text for opt_hover while user entered text
	var k = window.dhx4.trim(this.base.firstChild.value).toLowerCase();
	var id = null;
	var item = this.list.firstChild;
	while (item != null) {
		if (item.style.display == "" && item._optId != null) {
			var text = window.dhx4.trim(this.t[item._optId].obj.getText(item, true)).toLowerCase();
			if (k == text) {
				id = item._optId;
				item = null;
			}
		}
		if (item != null) item = item.nextSibling;
	}
	// match found, hover item
	if (this.conf.last_match == null) {
		if (id != null) {
			// 1st match
			this._setSelected(id, true, true);
			this.conf.last_match = id;
		} else {
			// nothing found
			// clear current selection if any
			if (this.conf.f_mode != "between" || forceClear == true) {
				this._setSelected(null, true, true);
				this.conf.last_match = null;
			}
		}
	} else {
		if (id != null) {
			// another match, check if same or new
			if (id != this.conf.last_match) {
				this._setSelected(id, true, true);
				this.conf.last_match = id;
			}
		} else {
			// nothing found clear last match if hovered and selection not changed
			this._setSelected(null, true, true);
			this.conf.last_match = null;
		}
	}
	
};

dhtmlXCombo.prototype._selectRange = function(from, to) {
	if (this.conf.combo_focus == true) window.dhx4.selectTextRange(this.base.firstChild, from, to);
};

/* show/hide select list */
dhtmlXCombo.prototype.openSelect = function() { // opens list of options
	if (!this._isListVisible()) this._showList();
};

dhtmlXCombo.prototype.closeAll = function() {
	this._hideList();
};

dhtmlXCombo.prototype._showList = function(autoHide) {
	
	if (this._getListVisibleCount() == 0) {
		if (autoHide && this._isListVisible()) this._hideList();
		return;
	}
	
	if (this._isListVisible()) {
		this._checkListHeight();
		return;
	}
	
	this.list.style.zIndex = window.dhx4.zim.reserve(this.conf.list_zi_id); // get new z-index
	if (this.hdr != null) this.hdr.style.zIndex = Number(this.list.style.zIndex)+1;
	
	this.list.style.visibility = "hidden";
	this.list.style.display = "";
	if (this.hdr != null) {
		this.hdr.style.visibility = this.list.style.visibility;
		this.hdr.style.display = this.list.style.display;
	}
	
	// position
	var h0 = (this.hdr != null ? this.hdr.offsetHeight : 0);
	
	this.list.style.width = Math.max(this.conf.opts_width||this.conf.col_w||0, this.conf.combo_width)+"px";
	this.list.style.top = window.dhx4.absTop(this.base)+h0+this.base.offsetHeight-1+"px";
	this.list.style.left = window.dhx4.absLeft(this.base)+"px";
	
	if (this.hdr != null) {
		this.hdr.style.width = this.list.style.width;
		this.hdr.style.left = this.list.style.left;
		this.hdr.style.top = parseInt(this.list.style.top)-h0+"px";
	}
	
	// height
	this._checkListHeight();
	
	// check bottom overlay
	this.list.style.visibility = "visible";
	if (this.hdr != null) this.hdr.style.visibility = "visible";
	
	this.callEvent("onOpen",[]);
	
};

dhtmlXCombo.prototype._hideList = function() {
	
	if (!this._isListVisible()) return;
	
	window.dhx4.zim.clear(this.conf.list_zi_id); // clear z-index
	this.list.style.display = "none";
	if (this.hdr != null) this.hdr.style.display = "none";
	
	this.conf.clear_click = false;
	
	this.callEvent("onClose",[]);
	
};

dhtmlXCombo.prototype._isListVisible = function() {
	return (this.list.style.display=="");
};

dhtmlXCombo.prototype._getListVisibleCount = function() {
	var k = 0;
	for (var q=0; q<this.list.childNodes.length; q++) k += (this.list.childNodes[q].style.display==""?1:0);
	return k;
};

dhtmlXCombo.prototype._checkListHeight = function() {
	
	if (!this._isListVisible()) return;
	
	if (this.conf.item_h == null) {
		var item = this.list.firstChild;
		while (item != null) {
			if (item.style.display == "") {
				this.conf.item_h = item.offsetHeight + (this.hdr != null ? -1 : 0); // multicol rows have -1px margin
				item = null;
			} else {
				item = item.nextSibling;
			}
		}
		item = null;
	}
	
	var s = window.dhx4.screenDim();
	var by = window.dhx4.absTop(this.base);
	var bh = this.base.offsetHeight;
	var hh = (this.hdr!=null?this.hdr.offsetHeight:0); // header_height
	
	var onTop = Math.max(0, Math.floor((by+hh-s.top)/this.conf.item_h));
	var onBottom = Math.max(0, Math.floor((s.bottom-(by+bh+hh))/this.conf.item_h));
	
	var itemsCount = this._getListVisibleCount();
	
	// top/bottom detect
	if (onBottom < Math.min(this.conf.opts_count_min, itemsCount) && onTop > onBottom) onBottom = null;
	
	var itemsToShow = Math.min((onBottom==null?onTop:onBottom), this.conf.opts_count, itemsCount);
	var h = (itemsToShow<itemsCount?(itemsToShow*this.conf.item_h)+"px":"");
	
	var ofs = this.conf.sp[this.conf.skin][this.hdr!=null?"hdr_ofs":"list_ofs"];
	
	this.list.style.height = h;
	this.list.style.top = (onBottom==null?by-this.list.offsetHeight+ofs:by+bh+hh-ofs)+"px";
	if (this.hdr != null) this.hdr.style.top = (onBottom==null?by-hh-this.list.offsetHeight+ofs:by+bh-ofs)+"px";
	
};

dhtmlXCombo.prototype._scrollToItem = function(id) {
	
	var y1 = this.t[id].item.offsetTop;
	var y2 = y1+this.t[id].item.offsetHeight;
	var a1 = this.list.scrollTop;
	var a2 = a1+this.list.clientHeight;
	
	if (y1 < a1) {
		// on top
		this.list.scrollTop = y1+(this.hdr!=null?1:0);
	} else if (y2 > a2) {
		// on bottom
		this.list.scrollTop = y2-this.list.clientHeight+(this.hdr!=null?-this.conf.sp[this.conf.skin].scr_ofs:0);
	}
	
};

/* in-list selection/highlighting */
dhtmlXCombo.prototype._setSelected = function(id, scrollToItem, updateImg) {
	
	if (updateImg) this._updateTopImage(id);
	
	if (id != null && this.conf.last_hover == id) {
		if (scrollToItem) this._scrollToItem(id);
		return;
	}
	
	if (this.conf.last_hover != null) {
		this.t[this.conf.last_hover].obj.setSelected(this.t[this.conf.last_hover].item, false);
		this.conf.last_hover = null;
		if (id == null) this.callEvent("onSelectionChange", []);
	}
	
	if (id != null) {
		
		this.t[id].obj.setSelected(this.t[id].item, true);
		this.conf.last_hover = id;
		
		this.callEvent("onSelectionChange", []);
		
		// last item selected, try subload
		if (this.conf.s_mode == "select" && this.t[id].item == this.t[id].item.parentNode.lastChild) this._subloadRequest();
		
		if (scrollToItem) this._scrollToItem(id);
		
	}
	
};

// auto-subload
dhtmlXCombo.prototype._subloadRequest = function() {
	
	if (this.conf.f_url != null && this.conf.f_dyn == true && this.conf.f_dyn_end == false) {
		
		var params = "mask="+encodeURIComponent(this.conf.f_mask)+"&pos="+this.list.childNodes.length;
		var t = this;
		var callBack = function(r){
			
			// cache
			if (t.conf.f_cache) t.conf.f_cache_data[t.conf.f_mask].data.push(r.xmlDoc.responseXML);
			var k = t.list.childNodes.length;
			
			// skip clear opts w/o add='true'
			t.conf.f_loading = true;
			t.load(r.xmlDoc.responseXML);
			t.conf.f_loading = false;
			
			// if no more opts left on server, stop dyn requests
			if (k == t.list.childNodes.length) {
				t.conf.f_dyn_end = true;
				if (t.conf.f_cache) t.conf.f_cache_data[t.conf.f_mask].dyn_end = true;
			}
			callBack = t = null;
		}
		if (window.dhx4.ajax.method == "post") {
			window.dhx4.ajax.post(this.conf.f_url, params, callBack);
		} else if (window.dhx4.ajax.method == "get") {
			window.dhx4.ajax.get(this.conf.f_url+(String(this.conf.f_url).indexOf("?")>=0?"&":"?")+params, callBack);
		}
	}
};

/* add / remove options */
dhtmlXCombo.prototype.addOption = function(value, text, css, img, selected) {
	
	// selected added in 4.0
	
	/*
	
	single option, 4 params
	z.addOption(value, text, css, img_src);
	value, text, css (css string attached to the option, optional), img_src (path to the option icon image, just for "image" combo type)
	
	several options, array of array (in this case you can't use 4th parameter img_src - improve?)
	z.addOption([["a","option A", "color:red;"],[],[],...]);
	
	several options, as an array of objects (you can use 4 parameters)
	z.addOption([{value: "a", text: "option A", img_src: "../images/blue.gif", css:"color:red;"},{},{}...]);
	
	*/
	
	var toSelect = null;
	
	if (!(value instanceof Array)) {
		// single option
		var id = this._renderOption({value:value, text:text, css:css, img:img});
		if (toSelect == null && window.dhx4.s2b(selected) == true) toSelect = id;
		
	} else {
		// array with opts
		for (var q=0; q<value.length; q++) {
			if (typeof(value[q]) == "undefined") continue;
			if (value[q] instanceof Array) {
				id = this._renderOption({value:value[q][0], text:value[q][1], css:value[q][2], img:value[q][3]});
				if (toSelect == null && window.dhx4.s2b(value[q][4]) == true) toSelect = id;
			} else {
				var id = this._renderOption(value[q]);
				if (toSelect == null && window.dhx4.s2b(value[q].selected) == true) toSelect = id;
			}
		}
	}
	
	if (toSelect != null) {
		this._setSelected(toSelect, this._isListVisible(), true);
		this._confirmSelect("onInit");
	}
};

dhtmlXCombo.prototype.updateOption = function(oldValue, newValue, newText, newCss) {
	var id = this._getOptionId(oldValue);
	if (id == null) return;
	this.t[id].obj.update(this.t[id].item, {value: newValue, text: newText, css: newCss});
	if (this.conf.last_selected == id) {
		this.conf.last_text = this.base.firstChild.value = this.t[id].obj.getText(this.t[id].item, true);
		this.conf.f_server_last = this.base.firstChild.value.toLowerCase();
	}
};

dhtmlXCombo.prototype.deleteOption = function(value) { // deletes option by value
	
	for (var a in this.t) {
		var v = this.t[a].obj.getValue(this.t[a].item);
		if (v == value) this._removeOption(a);
	}
	
	if (this._isListVisible()) this._showList(true); // resize if any or hide if no more items left
	
};

dhtmlXCombo.prototype.clearAll = function(hideList) { // remove all options
	
	hideList = (typeof(hideList)=="undefined"?true:window.dhx4.s2b(hideList));
	for (var a in this.t) this._removeOption(a);
	
	// props
	if (this.conf.tm_hover) window.clearTimeout(this.conf.tm_hover);
	this.conf.last_hover = null;
	this.conf.last_selected = null;
	
	this.list.scrollTop = 0;
	if (hideList == true) this._hideList();
	
};

dhtmlXCombo.prototype._renderOption = function(data) {
	
	var id = window.dhx4.newId();
	var item = document.createElement("DIV");
	
	item._optId = id;
	item._tpl = this.conf.template;
	
	// wrapper for img_src/img_src_dis
	if (typeof(data.img) == "undefined" && typeof(data.img_src) != "undefined") {
		data.img = data.img_src;
		delete data.img_src;
	}
	if (typeof(data.img_dis) == "undefined" && typeof(data.img_src_dis) != "undefined") {
		data.img_dis = data.img_src_dis;
		delete data.img_src_dis;
	}
	
	data.img_path = this.conf.img_path;
	data.img_def = this.conf.img_def;
	data.img_def_dis = this.conf.img_def_dis;
	
	this.list.appendChild(item);
	
	var v = (this._isListVisible() && window.dhx4.isFF == true);
	if (v == true) {
		var k = this.list.scrollTop;
		this.list.scrollTop -= 1;
	}
	
	this.t[item._optId] = {
		obj: this.modes[this.conf.opts_type].render(item, data),
		item: item,
		conf: {
			type: this.conf.opts_type
		}
	};
	item = null;
	
	if (v == true) this.list.scrollTop += 1;
	
	return id;
};

dhtmlXCombo.prototype._removeOption = function(id) {
	this.t[id].obj.destruct(this.t[id].item);
	this.t[id].obj = null;
	this.t[id].item.parentNode.removeChild(this.t[id].item);
	this.t[id].item = null;
	this.t[id].conf = null;
	this.t[id] = null;
	delete this.t[id];
	
	if (this.conf.last_hover == id) this.conf.last_hover = null;
	if (this.conf.last_selected == id) {
		this.conf.last_selected = null;
		this._confirmSelect("onDelete");
	}
};

dhtmlXCombo.prototype._confirmSelect = function(mode) {
	
	var wasChanged = false;
	
	if (this.conf.f_server_tm) window.clearTimeout(this.conf.f_server_tm);
	
	// confirm selection
	// if any item hovered - select, if not - just apply entered value
	if (this.conf.last_hover != null) {
		// select value
		wasChanged = wasChanged||(this.conf.last_value != this._getOptionValue(this.conf.last_hover));
		this.conf.last_match = this.conf.last_selected = this.conf.last_hover;
		this.conf.last_value = this._getOptionValue(this.conf.last_selected);
		this.conf.last_text = this.base.firstChild.value = this.t[this.conf.last_selected].obj.getText(this.t[this.conf.last_selected].item, true);
		this.conf.f_server_last = this.base.firstChild.value.toLowerCase();
		// inputs
		this.base.childNodes[1].value = this.conf.last_value;
		this.base.childNodes[2].value = "false";
	} else {
		// just a text,
		// check if free text allowed
		if (this.conf.allow_free_text || (this.base.firstChild.value == "" && this.conf.allow_empty_value)) {
			wasChanged = wasChanged||(this.conf.last_text != this.base.firstChild.value);
			this.conf.last_match = this.conf.last_value = this.conf.last_selected = null;
			this.conf.last_text = this.base.firstChild.value;
			this.conf.f_server_last = this.base.firstChild.value.toLowerCase();
			// inputs
			this.base.childNodes[1].value = this.conf.last_text;
			this.base.childNodes[2].value = "true";
		} else {
			this._cancelSelect();
			this._updateTopImage(this.conf.last_selected);
			return;
		}
	}
	
	if (this.conf.f_ac && this.conf.f_mode == "start") {
		this.conf.f_ac_text = "";
		if (mode != "blur") {
			this._selectRange(this.base.firstChild.value.length, this.base.firstChild.value.length);
		}
	}
	
	this._hideList();
	
	if (wasChanged == true && mode != "onInit" && mode != "onDelete") {
		this.callEvent("onChange", [this.conf.last_value, this.conf.last_text]);
	}
	
};

dhtmlXCombo.prototype._cancelSelect = function() {
	
	this._hideList();
	this.base.firstChild.value = this.conf.last_text;
	//this.conf.f_server_last = this.base.firstChild.value.toLowerCase();
	
	// restore filters if any
	if (this.conf.f_mode != false) {
		this._filterOpts(true);
	}
	
};


/* option object operations */
dhtmlXCombo.prototype._getOption = function(id, index) {
	
	if (!this.t[id]) return null;
	
	// autodetect index if any
	if (typeof(index) == "undefined") index = -1;
	if (index < 0) {
		for (var q=0; q<this.list.childNodes.length; q++) {
			if (index < 0 && this.list.childNodes[q]._optId == id) index = q;
		}
	}
	
	// comon data
	var t = {
		value: this.t[id].obj.getValue(this.t[id].item),
		text: this.t[id].obj.getText(this.t[id].item),
		text_input: this.t[id].obj.getText(this.t[id].item, true),
		text_option: this.t[id].obj.getText(this.t[id].item, null, true),
		css: this.t[id].obj.getCss(this.t[id].item),
		selected: (id==this.conf.last_selected),
		index: index
	};
	
	// extra data if any, for example "checked" for checkbox
	if (typeof(this.t[id].obj.getExtraData) == "function") {
		var k = this.t[id].obj.getExtraData(this.t[id].item);
		for (var a in k) { if (typeof(t[a]) == "undefined") t[a] = k[a]; }
	}
	
	return t;
};

dhtmlXCombo.prototype._getOptionProp = function(id, prop, def) { // get any property of any option
	if (id != null) {
		var t = this._getOption(id);
		if (t != null) return t[prop];
	}
	return def;
};
dhtmlXCombo.prototype._getOptionId = function(value) {
	var id = null;
	for (var q=0; q<this.list.childNodes.length; q++) {
		if (id == null) {
			var p = this.list.childNodes[q]._optId;
			if (value == this.t[p].obj.getValue(this.t[p].item)) id = p;
		}
	}
	return id;
};
dhtmlXCombo.prototype._getOptionValue = function(id) {
	return this._getOptionProp(id, "value", null);
};


dhtmlXCombo.prototype.setSize = function(width) { // changes control size
	this.conf.combo_width = parseInt(width)-(dhx4.isFF||dhx4.isIE||dhx4.isChrome||dhx4.isOpera?2:0);
	this.base.style.width = Math.max(0, this.conf.combo_width)+"px";
	this.base.firstChild.style.width = Math.max(0, (this.conf.combo_width-24-(this.conf.combo_image?23:0)))+"px";
	this.base.firstChild.style.marginLeft = (this.conf.combo_image?"23px":"0px");
};

dhtmlXCombo.prototype.setOptionWidth = function(w) { // sets width of combo list
	this.conf.opts_width = (parseInt(w)||null);
};

dhtmlXCombo.prototype.setOptionIndex = function(value, index) { // added in 4.1
	
	if (isNaN(index) || index < 0) return;
	
	var p = this.getOption(value);
	if (p == null) return;
	
	if (index == p.index) return;
	
	var t = this.list.childNodes[p.index];
	t.parentNode.removeChild(t);
	
	if (this.list.childNodes[index] != null) {
		this.list.insertBefore(t, this.list.childNodes[index]);
	} else {
		this.list.appendChild(t);
	}
	t = null;
	
};

dhtmlXCombo.prototype.getOptionsCount = function() { // added in 4.1
	return this.list.childNodes.length;
};

// multicolumn feature
dhtmlXCombo.prototype._mcMakeTemplate = function(cols) {
	
	var h = "";
	var t = "";
	
	this.conf.col_w = 0;
	
	for (var q=0; q<cols.length; q++) {
		
		var w = Number(parseInt(cols[q].width)||50);
		var css = (cols[q].css||"");
		var cssIE = (q == 0 && window.dhx4.isIE6 == true ? "_first":"");
		
		t += "<div class='dhxcombo_cell"+cssIE+" "+css+"' style='width:"+w+"px;'><div class='dhxcombo_cell_text'>"+(cols[q].option||"&nbsp;")+"</div></div>";
		h += "<div class='dhxcombo_hdrcell"+cssIE+" "+css+"' style='width:"+w+"px;'><div class='dhxcombo_hdrcell_text'>"+(cols[q].header||"&nbsp;")+"</div></div>";
		//
		this.conf.col_w += w+1;
	}
	
	var w = 500;
	var k = document.createElement("DIV");
	k.style.position = "absolute";
	k.style.top = "10px";
	k.style.left = -w*2+"px";
	k.style.width = w+"px";
	k.style.height = "50px";
	k.style.overflowY = "scroll";
	k.innerHTML = "<div>&nbsp;</div>";
	document.body.appendChild(k);
	
	this.conf.col_w += w-k.firstChild.offsetWidth+10;
	
	k.parentNode.removeChild(k);
	k = null;
	
	this.conf.template.option = t;
	this._mcAttachHeader(h);
	
	this.list.className += " dhxcombolist_multicolumn";
};

dhtmlXCombo.prototype._mcAttachHeader = function(text) {
	
	if (this.hdr == null) {
		
		this.hdr = document.createElement("DIV");
		this.hdr.className = "dhxcombolist_"+this.conf.skin+" dhxcombolist_hdr";
		this.hdr.style.display = "none";
		
		this.list.parentNode.insertBefore(this.hdr, this.list);
		
		if (typeof(window.addEventListener) == "function") {
			this.hdr.addEventListener("mousedown", this._doOnListMouseDown, false);
		} else {
			this.hdr.attachEvent("onmousedown", this._doOnListMouseDown);
		}
		
	}
	
	this.hdr.innerHTML = "<div class='dhxcombo_hdrtext'>"+text+"</div>";
	
};

dhtmlXCombo.prototype._mcDetachHeader = function() {
	
	if (this.hdr != null) {
		
		if (typeof(window.addEventListener) == "function") {
			this.hdr.removeEventListener("mousedown", this._doOnListMouseDown, false);
		} else {
			this.hdr.detachEvent("onmousedown", this._doOnListMouseDown);
		}
		
		this.hdr.parentNode.removeChild(this.hdr);
		this.hdr = null;
	}
	
	this.conf.col_w = null;
	this.conf.item_h = null;
	
};


/****************************************************************************************************************************************************************************************************************/

/* options */
dhtmlXCombo.prototype.modes = {}; // option types

dhtmlXCombo.prototype.doWithItem = function(index, method, param1, param2) { // wrapper to perform opts operations from combo
	
	// get option inner id
	var id = (index >= 0 && index < this.list.childNodes.length ? this.list.childNodes[index]._optId : null);
	if (id == null) return null; // opt no found
	if (typeof(this.t[id].obj[method]) != "function") return null; // function not found
	
	// generate params
	var params = [this.t[id].item];
	for (var q=2; q<arguments.length; q++) params.push(arguments[q]);
	
	// call method
	return this.t[id].obj[method].apply(this.t[id].obj, params);
	
};

function dhtmlXComboExtend(to, from) {
	for (var a in dhtmlXCombo.prototype.modes[from]) {
		if (typeof(dhtmlXCombo.prototype.modes[to][a]) == "undefined") {
			dhtmlXCombo.prototype.modes[to][a] = dhtmlXCombo.prototype.modes[from][a];
		}
	};
};
/****************************************************************************************************************************************************************************************************************/

dhtmlXCombo.prototype.modes.option = {
	
	image: false, // top-level image prev-to input
	option_css: "dhxcombo_option_text",
	render: function(item, data) {
		
		item._conf = {value: data.value, css: ""};
		
		item.className = "dhxcombo_option";
		item.innerHTML = "<div class='"+this.option_css+"'>&nbsp;</div>";
		
		if (data.css != null) {
			item.lastChild.style.cssText = data.css;
			item._conf.css = data.css;
		}
		
		this.setText(item, data.text);
		
		return this;
	},
	
	destruct: function(item) {
		item._conf = null;
	},
	
	update: function(item, data) {
		item._conf.value = data.value;
		item._conf.css = data.css;
		item.lastChild.style.cssText = data.css;
		this.setText(item, data.text);
	},
	
	setText: function(item, text) {
		item._conf.text = text;
		var t = (typeof(text) == "object" ? window.dhx4.template(item._tpl.option, item._conf.text, true) : window.dhx4.trim(item._conf.text||""));
		item.lastChild.innerHTML = (t.length==0?"&nbsp;":t);
	},
	
	getText: function(item, asStringInput, asStringOption) {
		if (window.dhx4.s2b(asStringInput) && typeof(item._conf.text) == "object") return window.dhx4.template(item._tpl.input, item._conf.text, true);
		if (window.dhx4.s2b(asStringOption) && typeof(item._conf.text) == "object") return window.dhx4.template(item._tpl.option, item._conf.text, true);
		return item._conf.text;
	},
	
	getValue: function(item) {
		return item._conf.value;
	},
	
	getCss: function(item) {
		return item._conf.css;
	},
	
	setSelected: function(item, state) {
		item.className = "dhxcombo_option"+(state?" dhxcombo_option_selected":"");
	},
	
	isSelected: function(item) {
		return String(item.className).indexOf("dhxcombo_option_selected") >= 0;
	},
	
	getExtraData: function(item) {
		// optional function,
		// adds extra data to option object returned by getOption()
		return {type: "option"};
	}
	
};

/****************************************************************************************************************************************************************************************************************/

dhtmlXCombo.prototype.modes.checkbox = {
	
	image: true,
	
	image_css: "dhxcombo_checkbox dhxcombo_chbx_#state#",
	option_css: "dhxcombo_option_text dhxcombo_option_text_chbx",
	
	render: function(item, data) {
		
		item._conf = {value: data.value, css: "", checked: window.dhx4.s2b(data.checked)};
		
		item.className = "dhxcombo_option";
		item.innerHTML = "<div class='"+String(this.image_css).replace("#state#",(item._conf.checked?"1":"0"))+"'></div>"+
				"<div class='"+this.option_css+"'>&nbsp;</div>";
		
		item.firstChild._optChbxId = item._optId; // mark checkbox
		
		if (data.css != null) {
			item.lastChild.style.cssText += data.css;
			item._conf.css = data.css;
		}
		
		this.setText(item, data.text);
		
		return this;
	},
	
	setChecked: function(item, state) {
		item._conf.checked = window.dhx4.s2b(state);
		item.firstChild.className = String(this.image_css).replace("#state#",(item._conf.checked?"1":"0"));
	},
	
	isChecked: function(item) {
		return (item._conf.checked==true);
	},
	
	getExtraData: function(item) {
		return {type: "checkbox", checked: item._conf.checked};
	},
	
	optionClick: function(item, ev, combo) {
		// called when option clicked, return true allows selection+confirm, return false - not
		var r = true;
		var t = (ev.target||ev.srcElement);
		while (r == true && t != null && t != item) {
			if (t._optChbxId != null) {
				if (combo.callEvent("onCheck", [item._conf.value,!item._conf.checked]) === true) {
					this.setChecked(item, !this.isChecked(item));
				};
				r = false;
			} else {
				t = t.parentNode;
			}
		}
		t = combo = item = null;
		return r;
	},
	
	getTopImage: function(item, enabled) {
		// returns html for top image
		// if item not specified - default image
		// enabled specify if combo enabled
		return "";
	},
	
	topImageClick: function(item, combo) {
		// called when user clicked on top-image,
		// return true/false to allow defailt action (open/close list) ot not
		// for checkbox - perform default action
		return true;
	}
	
};

dhtmlXComboExtend("checkbox", "option");

dhtmlXCombo.prototype.setChecked = function(index, mode) {
	this.doWithItem(index, "setChecked", mode);
};

dhtmlXCombo.prototype.getChecked = function(index, mode) {
	// return checked values
	var t = [];
	for (var q=0; q<this.list.childNodes.length; q++) {
		if (this.isChecked(q)) t.push(this._getOptionProp(this.list.childNodes[q]._optId, "value", ""));
	}
	return t;
};

dhtmlXCombo.prototype.isChecked = function(index) {
	return this.doWithItem(index, "isChecked");
};

/****************************************************************************************************************************************************************************************************************/

dhtmlXCombo.prototype.modes.image = {
	
	image: true,
	
	image_css: "dhxcombo_image",
	option_css: "dhxcombo_option_text dhxcombo_option_text_image",
	
	render: function(item, data) {
		
		item._conf = {value: data.value, css: ""};
		
		item.className = "dhxcombo_option";
		item.innerHTML = "<div class='"+this.image_css+"'></div>"+
				"<div class='"+this.option_css+"'>&nbsp;</div>";
		
		if (data.css != null) {
			item.lastChild.style.cssText += data.css;
			item._conf.css = data.css;
		}
		
		this.setText(item, data.text);
		this.setImage(item, data.img, data.img_dis, data.img_path, data.img_def, data.img_def_dis);
		
		return this;
	},
	
	update: function(item, data) {
		item._conf.value = data.value;
		item._conf.css = data.css;
		item.lastChild.style.cssText = data.css;
		this.setText(item, data.text);
		this.setImage(item, data.img, data.img_dis, data.img_path, data.img_def, data.img_def_dis);
	},
	
	setImage: function(item, img, img_dis, path, def, def_dis) {
		
		// image
		if (img != null && img.length > 0) {
			img = path+img;
		} else if (def != null && def.length > 0) {
			img = path+def;
		} else {
			img = null;
		}
		
		// image
		if (img_dis != null && img_dis.length > 0) {
			img_dis = path+img_dis;
		} else if (def_dis != null && def_dis.length > 0) {
			img_dis = path+def_dis;
		} else if (def_dis == true) {
			img_dis = img;
		} else {
			img_dis = null;
		}
		
		item._conf.img = img;
		item._conf.img_dis = img_dis;
		
		item.firstChild.style.backgroundImage = (img!=null?"url("+img+")":"none");
	},
	
	getExtraData: function(item) {
		return {type: "image"};
	},
	
	getTopImage: function(item, enabled) {
		// returns html for top image
		// if item not specified - default image
		var a = (enabled?"img":"img_dis");
		if (item != null && item._conf[a] != null) return "<div class='"+this.image_css+"' style='background-image:url("+item._conf[a]+");'></div>";
		return "";
	}
	
};

dhtmlXComboExtend("image", "option");

dhtmlXCombo.prototype.setDefaultImage = function(img, imgDis) {
	// sets default image
	// set imgDis to tru to use the same image as for enabled combo, default
	if (img != null) this.conf.img_def = img;
	if (imgDis != null) this.conf.img_def_dis = imgDis;
};
dhtmlXCombo.prototype.setImagePath = function(path) {
	this.conf.img_path = path;
};


/*
Product Name: dhtmlxSuite 
Version: 4.1.3 
Edition: Professional 
License: content of this file is covered by DHTMLX Commercial or Enterprise license. Usage without proper license is prohibited. To obtain it contact sales@dhtmlx.com
Copyright UAB Dinamenta http://www.dhtmlx.com
*/

function dhtmlXSlider(data) {
	
	var that = this;
	
	this.conf = {
		size: null,
		skin: null,
		vertical: false,
		min: 0,
		max: 99,
		value: 0,
		step: 1,
		decimals: 0,
		margin: 2,
		border: 1,
		inverse: false,
		disabled: false,
		tooltip: false,
		visible: true,
		linkTo: undefined
	};
	
	this._attachedNode = {};
	this._movingInitialValues = null;
	
	this.base = null;
	
	if (arguments.length > 1) { // init by arguments
		return new dhtmlXSlider(this._renderArgumets(arguments));
	}else if (typeof(data) == "string" || (typeof(data) == "object" && data.tagName)) { // init by node
		return new dhtmlXSlider({parent: data});
	}
	
	if (typeof(data.parent) == "string") {
		this.base = document.getElementById(data.parent);
	} else {
		this.base = data.parent;
	}
	
	this._mergeConfig(this._readAttFormNode(this.base));
	this._mergeConfig(data);
	
	this._detectDecimals();
	
	if (this.conf.size == null || this.conf.size == undefined) {
		if (this.conf.vertical) {
			this.conf.size = this.base.offsetHeight;
		} else {
			this.conf.size = this.base.offsetWidth;
		}
	}
	
	var skin = this.conf.skin || window.dhx4.skin || (typeof(dhtmlx) != "undefined"? dhtmlx.skin : null) || window.dhx4.skinDetect("dhxslider") || "dhx_skyblue";
	
	this.setSkin(skin);
	
	this.base.innerHTML = "<div class='dhxsl_container'>"+
					"<div class='dhxsl_track'></div>"+
					"<div class='dhxsl_runner'></div>"+
				"</div>";
	
	this._nodes = {
		cont: this.base.firstChild,
		track: this.base.firstChild.firstChild,
		runner: this.base.firstChild.childNodes[1]
	};
	
	this._nodes.cont.onmousedown = 
	this._nodes.track.onmousedown = 
	this._nodes.cont.onselectstart = 
	this._nodes.track.onselectstart = function(e) {
		e = e || event;
		if (typeof(e.preventDefault) == "function") {
			e.preventDefault();
		} else {
			e.returnValue = false;
		}
		return false;
	};
	
	this.conf.value = this._normalize(this.conf.value);
	this._setOrient(this.conf.vertical);
	this.setSize(this.conf.size);
	
	// events start
	
	this._initMover = function(e) {
		
		e = e || event;
		if (typeof(e.preventDefault) == "function") e.preventDefault();
		
		that._nodes.runner.className = "dhxsl_runner dhxsl_runner_actv";
		
		var type = (e.type=="mousedown"?"client":"page")+(that.conf.vertical?"Y":"X");
		
		that._movingInitialValues = {};
		that._movingInitialValues.value = that.conf.value;
		that._movingInitialValues.coord = (typeof(e[type]) != "undefined" ? e[type] : e.touches[0][type]);
		
		if (that.conf.disabled == false) {
			if (typeof(window.addEventListener) == "function") {
				window.addEventListener("mousemove", that._move, false);
				window.addEventListener("mouseup", that._cleanMove, false);
				window.addEventListener("touchmove", that._move, false);
				window.addEventListener("touchend", that._cleanMove, false);
			} else {
				document.body.attachEvent("onmousemove", that._move);
				document.body.attachEvent("onmouseup", that._cleanMove);
			}
		}
		that.callEvent("_onRunnerMouseDown",[]);
		return false;
	};
	
	this._move = function(e) {
		
		e = e || event;
		if (typeof(e.preventDefault) == "function") e.preventDefault();
		var type = (e.type=="mousemove"?"client":"page")+(that.conf.vertical?"Y":"X");
		
		var runner = (that.conf.vertical) ? that._nodes.runner.offsetHeight : that._nodes.runner.offsetWidth;
		var rang = that.conf.max - that.conf.min;
		var n_cord = (typeof(e[type]) != "undefined" ? e[type] : e.touches[0][type]);
		var new_value = that._movingInitialValues.value + (n_cord - that._movingInitialValues.coord)*rang/(that.conf.size - runner)*(that.conf.inverse?-1:1);
		
		that.setValue(new_value, true);
	};
	
	this._cleanMove = function(e) {
		if (typeof(window.addEventListener) == "function") {
			window.removeEventListener("mousemove", that._move, false);
			window.removeEventListener("mouseup", that._cleanMove, false);
			window.removeEventListener("touchmove", that._move, false);
			window.removeEventListener("touchend", that._cleanMove, false);
		} else {
			document.body.detachEvent("onmousemove", that._move);
			document.body.detachEvent("onmouseup", that._cleanMove);
		}
		that._movingInitialValues = null;
		that._nodes.runner.className = that._nodes.runner.className.replace(/\s{0,}dhxsl_runner_actv/gi,"");
		that.callEvent("onSlideEnd", [that.conf.value]);
		that.callEvent("_onRunnerMouseUp", []);
	};
	
	this._doOnSetValue = function(e) {
		
		if (that._movingInitialValues != null) return false;
		
		e = e || event;
		if (typeof(e.preventDefault) == "function") e.preventDefault();
		
		var n_coord = (that.conf.vertical) ? (e.offsetY || e.layerY) : (e.offsetX || e.layerX);
		var runner = (that.conf.vertical) ? that._nodes.runner.offoffsetHeightsetHe : that._nodes.runner.offsetWidth;
		var rang = that.conf.max - that.conf.min;
		
		var new_value = n_coord*rang/(that.conf.size) + that.conf.min;
		
		that.setValue(new_value, true);
		
		if (that._movingInitialValues == null) that._initMover(e);
		
		return false;
	};
	
	this._doOnChangeInput = function(e) {
		e = e || event;
		var target = e.target || e.srcElement;
		that.setValue(target.value);
	};
	
	this._doOnKeyDown = function(e) {
		e = e || event;
		var target = e.target || e.srcElement;
		if (e.keyCode == 13) that.setValue(target.value);
	};
	
	// events end
	
	this._attachEvents(this._nodes);
	
	this.unload = function() {
		
		dhx4._eventable(this, "clear");
		
		this._detachNode();
		this._detachEvents(this._nodes);
		
		this.base.removeChild(this._nodes.cont);
		
		this._nodes.cont.onmousedown = 
		this._nodes.track.onmousedown = 
		this._nodes.cont.onselectstart = 
		this._nodes.track.onselectstart = null;
		
		delete this._nodes.cont;
		delete this._nodes.track;
		delete this._nodes.max;
		delete this._nodes.min;
		delete this._nodes.runner;
		
		if (/\s?dhtmlxslider_\S*/.test(this.base.className)) {
			this.base.className = this.base.className.replace(/\s?dhtmlxslider_\S*/, "");
		}
		
		for (var key in this) this[key] = null;
		
		that = null;
	};
	
	dhx4._eventable(this);
	
	if (this.conf.disabled) {
		this.disable();
	}
	
	if (this.conf.tooltip) {
		this.enableTooltip();
	}
	
	if (!this.conf.visible) {
		this.hide();
	}
	
	if (this.conf.linkTo) {
		this.linkTo(this.conf.linkTo);
	}
	
	return this;
	
};

dhtmlXSlider.prototype._setOrient = function(vertical) {
	vertical = vertical || false;
	
	if (/\s?dhxsl_cont_hr/i.test(this._nodes.cont.className)) {
		this._nodes.cont.className = this._nodes.cont.className.replace(/\s?dhxsl_cont_hr/i, "");
	}
	
	if (/\s?dhxsl_cont_vr/i.test(this._nodes.cont.className)) {
		this._nodes.cont.className = this._nodes.cont.className.replace(/\s?dhxsl_cont_vr/i, "");
	}
	
	if (vertical) {
		this._nodes.cont.className += " dhxsl_cont_vr";
	} else {
		this._nodes.cont.className += " dhxsl_cont_hr";
	}
};

dhtmlXSlider.prototype._attachEvents = function(nodes) {
	if (typeof(window.addEventListener) == "function") {
		nodes.runner.addEventListener("mousedown", this._initMover, false);
		nodes.runner.addEventListener("touchstart", this._initMover, false);
		nodes.cont.addEventListener("mousedown", this._doOnSetValue, false);
		nodes.cont.addEventListener("touchstart", this._doOnSetValue, false);
	} else {
		nodes.runner.attachEvent("onmousedown", this._initMover);
		nodes.cont.attachEvent("onmousedown", this._doOnSetValue);
	}
};

dhtmlXSlider.prototype._detachEvents = function(nodes) {
	if (typeof(window.addEventListener) == "function") {
		nodes.runner.removeEventListener("mousedown", this._initMover, false);
		nodes.runner.removeEventListener("touchstart", this._initMover, false);
		nodes.cont.removeEventListener("mousedown", this._doOnSetValue, false);
		nodes.cont.removeEventListener("touchstart", this._doOnSetValue, false);
	} else {
		nodes.runner.detachEvent("onmousedown", this._initMover);
		nodes.cont.detachEvent("onmousedown", this._doOnSetValue);
	}
};

dhtmlXSlider.prototype._mergeConfig = function(data) {
	for (var key in data) {
		switch (key.toLowerCase()) {
			case "min":
			case "max":
			case "size":
			case "step":
			case "value":
			case "inverse":
				this.conf[key] = data[key];
				break;
			case "tooltip":
			case "visible":
			case "vertical":
			case "disabled":
				this.conf[key] = dhx4.s2b(data[key]);
				break;
			case "parent":
				continue;
				break;
			default:
				this.conf[key] = data[key];
		}
	}
};

dhtmlXSlider.prototype._readAttFormNode = function(node) {
	var atts = node.attributes, l = atts.length, i, answer = {}, att;
	
	for (i=0; i<l; i++) {
		att = atts[i];
		switch (att.name.toLowerCase()) {
			case "size":
			case "min":
			case "max":
			case "value":
			case "step":
				answer[att.name] = att.value;
				break;
			case "skin":
				answer.skin = att.value;
				break;
			case "vertical":
			case "disabled":
			case "visible":
				answer[att.name] = dhx4.s2b(att.value);
				break;
			case "linkto":
				answer.linkTo = att.value;
				break;
			case "tooltip":
				answer.tooltip = dhx4.s2b(att.value);
				break;
		}
	}
	
	return answer;
};

dhtmlXSlider.prototype._renderArgumets = function(arg) {
	var answer = {}, i,l;
	l = arg.length;
	
	for (i=0; i<l; i++) {
		switch (i) {
			case 0:
				answer.parent = arg[i];
				break;
			case 1:
				answer.size = arg[i];
				break;
			case 2:
				answer.skin = arg[i];
				break;
			case 3:
				answer.vertical = arg[i];
				break;
			case 4:
				answer.min = arg[i];
				break;
			case 5:
				answer.max = arg[i];
				break;
			case 6:
				answer.value = arg[i];
				break;
			case 7:
				answer.step = arg[i];
				break;
		}
	}
	
	return answer;
};

dhtmlXSlider.prototype._skinCollection = {
	dhx_skyblue: true,
	dhx_web: true,
	dhx_terrace: true
};

dhtmlXSlider.prototype._indexOf = function(arr, el) {
	var i,l,answer = -1;
	l = arr.length;
	for (i=l; i>=0; i--) {
		if (arr[i] == el) {
			answer = i;
			break;
		}
	}
	
	return answer;
};

dhtmlXSlider.prototype._refreshRunner = function() {
	var cmax, cp;
	
	if (this.conf.vertical) {
		cmax = this._nodes.cont.offsetHeight - this._nodes.runner.offsetHeight;
		cp = this._getCoord(cmax);
		
		this._nodes.runner.style.top = cp + this.conf.border + "px";
		this._nodes.runner.style.left = Math.round((this._nodes.cont.offsetWidth - this._nodes.runner.offsetWidth)/2) + "px";
		
	}else {
		cmax = this._nodes.cont.offsetWidth - this._nodes.runner.offsetWidth;
		cp = this._getCoord(cmax);
		
		this._nodes.runner.style.left = cp + this.conf.border + "px";
		this._nodes.runner.style.top = Math.round((this._nodes.cont.offsetHeight - this._nodes.runner.offsetHeight)/2) + "px";
	}
};

dhtmlXSlider.prototype._setValueByCoord = function(data) {
	var cx = dhx4.absLeft(this._nodes.cont),
	cy = dhx4.absTop(this._nodes.cont),
	value, k;
	
	if (this.conf.vertical) {
		k = (data.y - cy - this._nodes.runner.offsetHeight/2)/(this._nodes.cont.offsetHeight - this._nodes.runner.offsetHeight);
	} else {
		k = (data.x - cx - this._nodes.runner.offsetWidth/2)/(this._nodes.cont.offsetWidth - this._nodes.runner.offsetWidth);
	}
	
	value = (this.conf.max-this.conf.min)*k+this.conf.min;
	
	this.setValue(value, true);
};

dhtmlXSlider.prototype._getCoord = function(max) {
	var v = (this.conf.inverse?this._inverseValue(this.conf.value):this.conf.value);
	var k = (v-this.conf.min)/(this.conf.max - this.conf.min);
	return Math.round(max*k);
};

dhtmlXSlider.prototype._normalize = function(value) {
	value = Number(value); // for decimals
	value = Math.round(value/this.conf.step)*this.conf.step;
	var ten = Math.pow(10, this.conf.decimals);
	value = Math.round(value*ten)/ten;
	value = Math.max(this.conf.min, Math.min(this.conf.max, value));
	return value;
};

dhtmlXSlider.prototype._attachNode = function(node) {
	var tagName = node.tagName.toLowerCase();
	if (!tagName) return;
	
	this._attachedNode.node = node;
	
	switch (tagName) {
		case "input":
		case "select":
			if (typeof(window.addEventListener) == "function") {
				node.addEventListener("change", this._doOnChangeInput, false);
				node.addEventListener("keydown", this._doOnKeyDown, false);
			} else {
				node.attachEvent("onchange", this._doOnChangeInput);
				node.attachEvent("onkeydown", this._doOnKeyDown);
			}
			
			this._attachedNode.setValue = function(value, decimals) {
				value = String(value);
				if (decimals > 0) {
					var k = value.match(/\.\d{1,}$/);
					if (k != null) decimals = Math.max(decimals-k[0].length+1);
					value += (value.indexOf(".")<0?".":"");
					for (var q=0; q<decimals; q++) value += "0";
				}
				this.node.value = value;
			};
			break;
		default:
			this._attachedNode.setValue = function(value) {
				this.node.innerHTML = value;
			};
	}
	
	this._attachedNode.setValue(this.conf.value, this.conf.decimals);
};

dhtmlXSlider.prototype._detachNode = function() {
	var node = this._attachedNode.node;
	
	if (!node) {
		return;
	}
	
	var tagName = node.tagName;
	
	switch (tagName) {
		case "input":
		case "select":
			if (typeof(window.addEventListener) == "function") {
				node.removeEventListener("change", this._doOnChangeInput, false);
				node.removeEventListener("keydown", this._doOnChangeInput, false);
			} else {
				node.detachEvent("change", this._doOnChangeInput);
				node.detachEvent("keydown", this._doOnChangeInput);
			}
			break;
	}
	
	delete this._attachedNode.node;
	delete this._attachedNode.setValue;
};

dhtmlXSlider.prototype._detectDecimals = function() {
	var k = this.conf.step.toString().match(/\.(\d*)$/);
	this.conf.decimals = (k!=null?k[1].length:0);
};

dhtmlXSlider.prototype.setSize = function(value) {
	if (!isNaN(value)) {
		if (this.conf.vertical) {
			if (this._nodes.cont.style.width) delete this._nodes.cont.style.width;
			this._nodes.cont.style.height = value-this.conf.margin + "px";
		} else {
			if (this._nodes.cont.style.height) delete this._nodes.cont.style.height;
			this._nodes.cont.style.width = value-this.conf.margin + "px";
		}
		
		this._refreshRunner();
	} 
};

dhtmlXSlider.prototype.setSkin = function (skin) {
	skin = skin.toLowerCase();
	
	var classes, _int = -1, skinName, className="dhtmlxslider";
	
	classes = this.base.className.match(/\S\w+/ig);
	
	if (classes instanceof  Array) {    
		for (skinName in this._skinCollection) {
			if (_int == -1) {
				_int = this._indexOf(classes, className + "_" + skinName);
			} else {
				break;
			}
		}
		
		_int = (_int == -1) ? classes.length : _int;
	} else {
		classes = [];
		_int = 0;
	}
	
	
	
	classes[_int] = className + "_" + skin;
	
	this.base.className = classes.join(" ");
	this.conf.skin = skin;
	
	if (this._nodes) this._refreshRunner();
};

dhtmlXSlider.prototype.setValue = function(value, callEvent) {
	
	callEvent = callEvent || false;
	
	if (!isNaN(value)) {
		value = this._normalize(value);
		if (this.conf.value != value) {
			
			this.conf.value = value;
			
			this._refreshRunner();
			
			if (this.conf.tooltip) this._nodes.cont.title = value;
			
			if (callEvent) this.callEvent("onChange", [value, this]);
		}
	}
	
	if (typeof(this._attachedNode.setValue) == "function") {
		this._attachedNode.setValue(this.conf.value, this.conf.decimals);
	}
};

dhtmlXSlider.prototype.getValue = function() {
	return this.conf.value;
};

dhtmlXSlider.prototype._inverseValue = function() {
	return this.conf.max+this.conf.min-this.conf.value;
};

dhtmlXSlider.prototype.disable = function(mode) {
	mode = (mode == false) ? false : true; // deprecated
	var reg = null;
	if (mode) {
		for (var nm in this._nodes) {
			if (nm == "cont") continue;
			reg = new RegExp("\\s?dhxsl_"+nm+"_dis","i");
			if (!reg.test(this._nodes[nm].className)) {
				this._nodes[nm].className += " dhxsl_"+nm+"_dis";
			}
		}
		
		this.conf.disabled = true;
	} else {
		this.enable();
	}
};

dhtmlXSlider.prototype.enable = function() {
	var reg;
	for (var nm in this._nodes) {
		if (nm == "cont") continue;
		reg = new RegExp("\\s?dhxsl_"+nm+"_dis","i");
		if (reg.test(this._nodes[nm].className)) {
			this._nodes[nm].className = this._nodes[nm].className.replace(reg,"");
		}
	}
	
	this.conf.disabled = false;
};

dhtmlXSlider.prototype.isEnabled = function() {
	return !this.conf.disabled;
};

dhtmlXSlider.prototype.disableTooltip = function() {
	this._nodes.cont.removeAttribute("title");
	this.conf.tooltip = false;
};

dhtmlXSlider.prototype.enableTooltip = function(mode) {
	if (typeof(mode) == "undefined") mode = true; else mode = dhx4.s2b(mode);
	if (mode) {
		this._nodes.cont.title = this.conf.value;
		this.conf.tooltip = true;
	} else {
		this.disableTooltip();
	}
};

dhtmlXSlider.prototype.setMax = function(value) {
	if (!isNaN(value) && this.conf.min < value) {
		this.conf.max = value;
		this.setValue(this.conf.value);
	}
};

dhtmlXSlider.prototype.getMax = function() {
	return this.conf.max;
};

dhtmlXSlider.prototype.setMin = function(value) {
	if (!isNaN(value) && this.conf.max > value) {
		this.conf.min = value;
		this.setValue(this.conf.value);
	}
};

dhtmlXSlider.prototype.getMin = function() {
	return this.conf.min;
};

dhtmlXSlider.prototype.setStep = function(value) {
	var maxValue = this.conf.max - this.conf.min;
	if (!isNaN(value) && value < maxValue) {
		this.conf.step = value;
		this._detectDecimals();
		this.setValue(this.conf.value);
	}
};

dhtmlXSlider.prototype.getStep = function() {
	return this.conf.step;
};

dhtmlXSlider.prototype.show = function() {
	if (/\s?dhxsl_hidden/i.test(this._nodes.cont.className)) {
		this._nodes.cont.className = this._nodes.cont.className.replace(/\s?dhxsl_hidden/i, "");
	}
	
	this.conf.visible = true;
};

dhtmlXSlider.prototype.hide = function() {
	if (!/\s?dhxsl_hidden/i.test(this._nodes.cont.className)) {
		this._nodes.cont.className += " dhxsl_hidden";
	}
	
	this.conf.visible = false;
};

dhtmlXSlider.prototype.isVisible = function() {
	return this.conf.visible;
};

dhtmlXSlider.prototype.linkTo = function(node) {
	if (typeof(node) == "string") {
		node = document.getElementById(node);
	}
	
	if (this._attachedNode.node) {
		this._detachNode();
	}
	
	this._attachNode(node);
};

/*
Product Name: dhtmlxSuite 
Version: 4.1.3 
Edition: Professional 
License: content of this file is covered by DHTMLX Commercial or Enterprise license. Usage without proper license is prohibited. To obtain it contact sales@dhtmlx.com
Copyright UAB Dinamenta http://www.dhtmlx.com
*/

function dhtmlXPopup(conf) {
	
	var that = this;
	
	this.conf = conf||{};
	conf = null;
	
	this.mode = (this.conf.mode||"bottom"); // popup position related to caller element
	this.conf.zi = window.dhx4.newId();
	
	this.conf.isIE = (navigator.userAgent.indexOf("MSIE")>=0);
	
	// enable/disable native context menu, enabled by default
	this.conf.context = (this.conf.context==null?true:window.dhx4.s2b(this.conf.context));
	
	// enable/disable full-fix for content in IE6 (depending on content fix mey be not required), disabled by default
	this.conf.IE6_display_fix = (this.conf.IE6_display_fix==null?false:window.dhx4.s2b(this.conf.IE6_display_fix));
	
	this.p = document.createElement("DIV");
	this.p.style.display = "none";
	this.p.innerHTML = "<div class='dhx_popup_area"+(this.conf.isIE?" dhx_popup_area_ie":"")+"'>"+
					"<table cellspacing='0' cellpadding='0' border='0' class='dhx_popup_table'><tbody></tbody></table>"+
				"</div>"+
				"<div class='dhx_popup_arrow dhx_popup_arrow_"+this.mode+"'></div>";
	
	document.body.appendChild(this.p);
	
	this.p.oncontextmenu = function(e) {
		if (that.conf.context == false) {
			e = e||event;
			e.returnValue = false;
			return false;
		}
	}
	
	this.skinParams = {
		dhx_terrace: {
			t0: 19, // minimal top offset for polygon, i.e. space between polygon top and arrow top
			t1: 9,  // if no more space at top, and "t0 allowed" - move top polygon position a bit to bottom, t1 = offset for empty space at top
			t2: 19, // same as t0, for width
			t3: 9   // same as t1, for width
		},
		dhx_skyblue: {t0: 12, t1: 9, t2: 12, t3: 9},
		dhx_web: {t0: 12, t1: 9, t2: 12, t3: 9}
	};
	
	this.p.onclick = function(e) {
		e = e||event;
		that._clearClick = true;
		if (that._nodeObj != null) {
			that.callEvent("onContentClick",[]);
			return true;
		}
		var t = (e.target||e.srcElement);
		var id = null;
		while (t != that.p && t != null) {
			if (typeof(t._idd) != "undefined" && !t._isSeparator) {
				id = t._idd;
				t = null;
			} else {
				t = t.parentNode;
			}
		}
		t = null;
		if (id != null) {
			that.callEvent("onClick",[id]);
			if (that != null && that.isVisible != null && that.isVisible() && that.callEvent("onBeforeHide",["select",e,id]) === true) {
				e.cancelBubble = true;
				that.hide();
			}
		}
	}
	
	this.separator = "DHXSEP_"+window.dhx4.newId();
	
	this.tpl = [];
	this._setTemplate = function(t) {
		this.tpl = t.split(",");
	}
	
	this.show = function(id) { // 4 coords for custom object, x, y, width, height
		
		var p = null;
		
		if (arguments.length == 1) {
			
			// if id not specified show on first
			
			if (!id) {
				id = this.conf.id[0];
			} else {
				if (!this._idExists(id)) return;
			}
			if (this.conf.toolbar) {
				p = this.conf.toolbar._getItemDim(id);
			}
			if (this.conf.ribbon) {
				p = this.conf.ribbon._getItemDim(id);
			}
			if (this.conf.form) {
				p = this.conf.form._getItemDim(id);
			}
			
		} else if (arguments.length == 4) {
			
			this._clearClick = true;
			
			// show for custom object, 4 coords
			p = {
				left:   arguments[0],
				top:    arguments[1],
				width:  arguments[2],
				height: arguments[3]
			}
			
			id = null;
		}
		
		if (!p) return;
		
		this.p.style.visibility = "hidden";
		this.p.style.display = "";
		
		this._setPos(p);
		
		this.p.style.zIndex = window.dhx4.zim.reserve(this.conf.zi);
		this.p.style.visibility = "visible";
		
		this._lastId = id;
		
		this.callEvent("onShow",[id]);
		
		
	}
	
	this._setPos = function(p, state) {
		
		var x = p.left;
		var y = p.top;
		var w = p.width;
		var h = p.height;
		
		this._posData = {
			left: x,
			top: y,
			width: w,
			height: h
		};
		
		var d = window.dhx4.screenDim();
		
		var mode = state||this.mode;
		if (typeof(state) == "undefined") state = false;
		
		// avail space form each side, negative value = no-space
		var availSpace = {
			top: (y-this.p.offsetHeight)-d.top,
			bottom: d.bottom-(y+h+this.p.offsetHeight),
			left: x-this.p.offsetWidth-d.left,
			right: d.right-(x+w+this.p.offsetWidth)
		};
		
		if (!state && availSpace[mode] < 0) {
			var k = this._getAvailPos(mode, availSpace);
			if (k !== false) {
				this._setPos(p, k);
				return;
			}
			
		}
		
		if (mode == "top" || mode == "bottom") {
			
			var t0 = this.skinParams[this.conf.skin].t2;
			var t1 = this.skinParams[this.conf.skin].t3;
			
			var pw2 = Math.round(this.p.offsetWidth/2); // 1/2 polygon width
			var aw2 = Math.round(this.p.lastChild.offsetWidth/2); // 1/2 arrow width
			
			// define max left and right position of input including rendering [d.left..d.right] area
			if (x < d.left) { var x1 = Math.min(x+w, d.left); w = x+w-x1; x = x1; } // left
			if (x+w > d.right) w = d.right-x; // right
			
			// arrow position
			var ta = Math.round(x+w/2);
			
			// polygon top
			var left = ta - pw2;
			var maxLeft = ta - t0 - aw2;
			var maxLeftRight = ta+aw2+t0-this.p.offsetWidth;
			
			
			if (left < d.left-t1) { // left
				left = Math.min(d.left-t1, maxLeft);
			} else if (left+this.p.offsetWidth > d.right+t1) { // right
				left = Math.max(maxLeftRight, d.right+t1-this.p.offsetWidth); // -scrollWidth here?
			}
			
			// draw polygon
			this.p.style.left = left+"px";
			this.p.style.top = (mode=="top"?y-this.p.offsetHeight:y+h)+"px";
			
			// fix arrow offset (it inside polygon)
			ta = ta-left-aw2;
			
			// draw arrow
			this.p.lastChild.className = "dhx_popup_arrow dhx_popup_arrow_"+mode;
			this.p.lastChild.style.top = (mode=="top"?this.p.offsetHeight-this.p.lastChild.offsetHeight:0)+"px";
			this.p.lastChild.style.left = ta+"px";
			
			
		}
		
		
		if (mode == "left" || mode == "right") {
			
			var t0 = this.skinParams[this.conf.skin].t0;
			var t1 = this.skinParams[this.conf.skin].t1;
			
			var ph2 = Math.round(this.p.offsetHeight/2); // 1/2 polygon height
			var ah2 = Math.round(this.p.lastChild.offsetHeight/2); // 1/2 arrow height
			
			// define max top and bottom position of input including rendering [d.top..d.bottom] area
			if (y < d.top) { var y1 = Math.min(y+h, d.top); h = y+h-y1; y = y1; } // top
			if (y+h > d.bottom) h = d.bottom-y; // bottom
			
			// arrow position
			var ta = Math.round(y+h/2);
			
			// polygon top
			var top = ta - ph2;
			var maxTop = ta - t0 - ah2;
			var maxTopBottom = ta+ah2+t0-this.p.offsetHeight;
			
			
			if (top < d.top-t1) { // top
				top = Math.min(d.top-t1, maxTop);
			} else if (top+this.p.offsetHeight > d.bottom+t1) { // bottom
				top = Math.max(maxTopBottom, d.bottom+t1-this.p.offsetHeight);
			}
			
			// draw polygon
			this.p.style.left = (mode=="left"?x-this.p.offsetWidth:x+w)+"px";
			this.p.style.top = top+"px";
			
			// fix arrow offset (it inside polygon)
			ta = ta-top-ah2;
			
			// draw arrow
			this.p.lastChild.className = "dhx_popup_arrow dhx_popup_arrow_"+mode;
			this.p.lastChild.style.left = (mode=="left"?this.p.offsetWidth-this.p.lastChild.offsetWidth:0)+"px";
			this.p.lastChild.style.top = ta+"px";
			
		}
		
		if (this._IEDisp && this._nodeId != null) {
			var t = document.getElementById(this._nodeId);
			if (this.conf.IE6_display_fix == true) t.style.visibility = "hidden";
			window.setTimeout(function(){
				t.style.visibility = "visible";
				t = null;
			},1);
		}
	}
	
	this._getAvailPos = function(mode, data) {
		
		var seq = {
			top: ["bottom","right","left"],
			bottom: ["top","right","left"],
			left: ["right", "bottom", "top"],
			right: ["left", "bottom", "top"]
		};
		
		var dir = null;
		
		// check "next" with avail space
		for (var q=0; q<seq[mode].length; q++) {
			if (dir == null && data[seq[mode][q]] > 0) dir = seq[mode][q];
		}
		
		// define which side have more space
		if (dir == null) {
			dir = "bottom";
			for (var a in data) if (data[a] > data[dir]) dir = a;
		}
		
		if (dir == mode) return false;
		
		return dir;
		
	}
	
	this._repaint = function() {
		if (this.isVisible()) this._setPos(this._posData);
	}
	
	this.clear = function() {
		
		if (this._nodeObj) {
			if (this.conf.isIE && typeof(dhtmlXLayoutObject) != "undefined" && this._nodeObj instanceof dhtmlXLayoutObject) {
				this.p.onmousedown = null;
			}
			if (this._nodeObj.unload) {
				this._nodeObj.unload();
			} else if (this._nodeObj.destruct) {
				this._nodeObj.destruct();
			}
			this._nodeObj = this._nodeId = null;
			// events if any
			if (this._nodeObjEv != null) {
				for (var q=0; q<this._nodeObjEv.length; q++) this.detachEvent(this._nodeObjEv[q]);
				this._nodeObjEv = null;
			}
		}
		
		if (this._IEHoverInited) this._IEHoverClear();
		
		var r = this.p.firstChild.firstChild.firstChild; // table->tbody
		while (r.childNodes.length > 0) r.removeChild(r.lastChild);
		
		r = null;
		
		this.itemData = {};
	}
	
	this.hide = function() {
		if (this.p.style.display != "none") {
			this.p.style.display = "none";
			window.dhx4.zim.clear(this.conf.zi);
			var id = this._lastId;
			this._lastId = null;
			this.callEvent("onHide",[id]);
		}
	}
	
	this.isVisible = function() {
		return (this.p.style.display == "");
	}
	
	this.itemData = {};
	
	this.getItemData = function(id) {
		if (!id) return this.itemData;
		if (this.itemData[id]) return this.itemData[id];
		return {};
	}
	
	this.setSkin = function(skin) {
		this.conf.skin = skin;
		this.p.className = "dhx_popup_"+this.conf.skin;
		if (this._nodeObj != null && typeof(this._nodeObj.setSkin) == "function") this._nodeObj.setSkin(this.conf.skin);
		this._repaint();
	}
	
	this.attachList = function(template, data) {
		
		this._setTemplate(template);
		
		this.clear();
		var r = this.p.firstChild.firstChild.firstChild; // table->tbody
		
		for (var q=0; q<data.length; q++) {
			
			var tr = document.createElement("TR");
			if (data[q] != this.separator) {
				if (typeof(data[q].id) == "undefined" || data[q].id == null) {
					tr._idd = window.dhx4.newId();
					while (this.itemData[tr._idd] != null) tr._idd = window.dhx4.newId();
				} else {
					tr._idd = data[q].id;
				}
				this.itemData[tr._idd] = data[q];
			}
			r.appendChild(tr);
			
			if (data[q] == this.separator) {
				tr.className = "dhx_popup_sep";
				tr._isSeparator = true;
				var td = document.createElement("TD");
				td.className = "dhx_popup_sep";
				td.colSpan = this.tpl.length;
				td.innerHTML = "<div class='dhx_popup_sep'>&nbsp;</div>";
				tr.appendChild(td);
				td = null;
			} else {
				for (var w=0; w<this.tpl.length; w++) {
					var css = "dhx_popup_td";
					if (this._IEFirstLast && (this.tpl.length==1||w==0||w==this.tpl.length-1)) {
						if (this.tpl.length==1) css += " dhx_popup_td_single"; else css += (w==0?" dhx_popup_td_first":" dhx_popup_td_last");
					}
					var td = document.createElement("TD");
					td.className = css;
					td.innerHTML = data[q][this.tpl[w]]||"&nbsp;";
					tr.appendChild(td);
					td = null;
				}
				// IE6 hover functionality
				if (this._IEHover) {
					tr._IEHover = true;
					if (!this._IEHoverInited) this._IEHoverInit();
				}
			}
			tr = null;
		}
		r = null;
		
		this._repaint();
		
	}
	
	this._attachNode = function(mode, data) {
		
		this.clear();
		
		this._nodeId = "dhxpopup_node_"+window.dhx4.newId();
		
		var r = this.p.firstChild.firstChild.firstChild; // table->tbody
		
		var tr = document.createElement("TR");
		tr.className = "dhxnode";
		r.appendChild(tr);
		
		var td = document.createElement("TD");
		td.className = "dhx_popup_td";
		td.innerHTML = "<div id='"+this._nodeId+"' style='position:relative;'></div>";
		
		if (data.width) td.firstChild.style.width = data.width+"px";
		if (data.height) td.firstChild.style.height = data.height+"px";
		
		tr.appendChild(td);
		
		td = tr = r = null;
		
		if (typeof(this["_attach_init_"+mode]) == "function") {
			this["_attach_init_"+mode](data);
			this._enableIEVFix();
		}
		
		this._repaint();
		
		return this._nodeObj;
		
	}
	
	this.unload = function() {
		
		if (typeof(window.addEventListener) == "function") {
			window.removeEventListener("click", this._doOnClick, false);
			window.removeEventListener("keyup", this._doOnKeyUp, false);
			window.removeEventListener("unload", this._doOnUnload, false);
		} else {
			document.body.detachEvent("onclick", this._doOnClick, false);
			document.body.detachEvent("onkeyup", this._doOnKeyUp, false);
			document.body.detachEvent("onunload", this._doOnUnload, false);
		}
		
		this.clear();
		
		this._doOnClick = null;
		this._doOnUnload = null;
		this._doOnKeyUp = null;
		
		
		if (this.conf.toolbarEvent != null && this.conf.toolbar != null) {
			if (this.conf.toolbar.detachEvent != null) {
				// make sure toolbar wasn't unloaded
				this.conf.toolbar.detachEvent(this.conf.toolbarEvent);
			} else {
				this.conf.toolbar._getItemDim = null;
			}
		}
		
		if (this.conf.ribbonEvent != null && this.conf.ribbon != null) {
			if (this.conf.ribbon.detachEvent != null) {
				this.conf.ribbon.detachEvent(this.conf.ribbonEvent);
			} else {
				this.conf.ribbon._getItemDim = null;
			}
		}
		
		if (this.conf.slider) {
			for (var q=0; q<this.conf.slider_events.length; q++) {
				this.conf.slider.detachEvent(this.conf.slider_events[q]);
			}
			this.conf.slider_events = null;
			this._sliderShow = this._sliderHide = null;
			this.conf.slider = null;
		}
		
		window.dhx4._eventable(this, "clear");
		
		this.attachList = this.attachAccordion = this.attachCalendar = this.attachForm = this.attachGrid = this.attachLayout = this.attachTabbar = this.attachTree = this.attachHTML = this.attachObject = this._attachNode = null;
		
		this.show = this.hide = this.isVisible = this._setTemplate = this._repaint = this._setPos = this.getItemData = this.clear = this._idExists = this._doOnToolbarClick = this._doOnRibbonClick = this.setSkin = null;
		this.tpl = this.itemData = this.separator = this.mode = null;
		this._clearClick = this._lastId = this._posData = this.skinParams = this.skinParent = null;
		
		this.p.onclick = this.p.oncontextmenu = null;
		this.p.parentNode.removeChild(this.p);
		this.p = null;
		
		this.conf.toolbar = this.conf.toolbarEvent = this.conf.ribbon = this.conf.ribbonEvent = this.conf.form = this.conf.id = null;
		this.conf = null;
		
		this._IEHover = this._IEHoverTM = this._IEHoverInit = this._IEHoverClear = this._IEHoverRender = this._IEHoverInited = null;
		this._IEDisp = null;
		
		this.unload = null;
		that = null;
		
	}
	
	window.dhx4._eventable(this);
	
	this._doOnClick = function(e) {
		e = e||event;
		if (that._clearClick) {
			that._clearClick = false;
			return;
		}
		if (that.conf.form != null) {
			var id;
			var t = (e.target||e.srcElement);
			if ((t.tagName||"").toLowerCase() == "option") t = t.parentNode;
			if (t.className != null && t.className.search("dhxform") >= 0) {
				if (t.parentNode != null && t.parentNode.parentNode != null && t.parentNode.parentNode._idd != null) {
					id = t.parentNode.parentNode._idd;
					if (t.parentNode.parentNode._type == "ra") id = [t.parentNode.parentNode._group, t.parentNode.parentNode._value];
				}
			} else {
				// check if button, editor or combo
				var k = true;
				var f = false;
				while (k && !f) {
					var p = (t.className||"").toLowerCase();
					if (p.length > 0) f = (p == "dhxform_btn" || p.search(/dhxeditor_inside/gi) >= 0 || p == "dhxcombo_input" || p.search(/dhxcombolist/gi) >=0);
					t = t.parentNode;
					k = (t != null);
				}
				if (f) return;
			}
			t = null;
			if (id != null && that._idExists(id)) return;
		}
		if (that.isVisible() && that.callEvent("onBeforeHide",["click",e]) === true) {
			that.hide();
		}
	}
	this._doOnKeyUp = function(e) {
		e = e||event;
		if (e.keyCode == 27) {
			if (that.isVisible() && that.callEvent("onBeforeHide",["esc",e]) === true) {
				that.hide();
			}
		}
	}
	this._doOnUnload = function() {
		that.unload();
	}
	
	if (typeof(window.addEventListener) == "function") {
		window.addEventListener("click", this._doOnClick, false);
		window.addEventListener("keyup", this._doOnKeyUp, false);
		window.addEventListener("unload", this._doOnUnload, false);
	} else {
		document.body.attachEvent("onclick", this._doOnClick, false);
		document.body.attachEvent("onkeyup", this._doOnKeyUp, false);
		document.body.attachEvent("onunload", this._doOnUnload, false);
	}
	
	this._idExists = function(id) {
		var r = false;
		for (var q=0; q<this.conf.id.length; q++) {
			if (this.conf.id[q] instanceof Array) { // radiobutton
				r = r||(this.conf.id[q][0]==id[0]&&this.conf.id[q][1]==id[1]);
			} else {
				r = r||this.conf.id[q]==id;
			}
		}
		return r;
	}
	
	// IE6/Quircks Display fix
	this._IEDisp = (this.conf.isIE && (navigator.userAgent.search("MSIE 6.0")>=0 || document.compatMode != "CSS1Compat"));
	
	// IE6 hover functionality
	this._IEHover = (this.conf.isIE && navigator.userAgent.search("MSIE 6.0")>=0);
	if (this._IEHover) {
		this._IEHoverInit = function() {
			this.p.onmouseover = function() {
				var t = event.srcElement;
				while (t != this && t._IEHover != true) t = t.parentNode;
				if (t._IEHover) {
					if (that._IEHoverTM) window.clearTimeout(that._IEHoverTM);
					if (that._lastIEHover == t) return;
					that._IEHoverRender(t);
					t = null;
				}
			}
			this.p.onmouseout = function() {
				if (that._IEHoverTM) window.clearTimeout(that._IEHoverTM);
				that._IEHoverTM = window.setTimeout(function(){that._IEHoverRender(null);},1);
			}
			this._IEHoverRender = function(t) {
				if (this._lastIEHover != null) {
					if (this._lastIEHover.className.search(/tr_hover/gi) >= 0) {
						this._lastIEHover.className = this._lastIEHover.className.replace(/\s{0,}tr_hover/gi, "");
						this._lastIEHover = null;
					}
				}
				if (t != null && t.className.search(/tr_hover/gi) < 0) {
					t.className += " tr_hover";
					that._lastIEHover = t;
				}
			}
			this._IEHoverInited = true;
		}
		this._IEHoverClear =  function() {
			this.p.onmouseover = null;
			this.p.onmouseout = null;
			this._IEHoverInited = false;
		}
	}
	
	// IE6/7/8 first/last-child
	this._IEFirstLast = (this.conf.isIE && navigator.userAgent.search(/MSIE [6,7,8]\.0/i)>=0);
	
	// IE6 visibility fix
	this._enableIEVFix = function() {
		if (this.conf.isIE && navigator.userAgent.search("MSIE 6.0") >= 0) {
			var e1 = this.attachEvent("onHide", function(){
				document.getElementById(this._nodeId).style.visibility = "hidden";
			});
			var e2 = this.attachEvent("onShow", function(){
				document.getElementById(this._nodeId).style.visibility = "visible";
			});
			if (this._nodeObjEv == null) this._nodeObjEv = [];
			this._nodeObjEv.push(e1,e2);
		}
	}
	
	// auto-init, toolbar mode
	if (typeof(window.dhtmlXToolbarObject) != "undefined" && this.conf.toolbar != null && this.conf.toolbar instanceof window.dhtmlXToolbarObject && this.conf.id != null) {
		
		if (!(this.conf.id instanceof Array)) this.conf.id = [this.conf.id];
		
		this.skinParent = this.conf.toolbar.conf.skin;
		
		this._doOnToolbarClick = function(id) {
			for (var q=0; q<that.conf.id.length; q++) {
				if (id == that.conf.id[q]) {
					if (id != that._lastId) {
						that.show(id);
						that._clearClick = true;
					}
				}
			}
		}
		
		// extension for toolbar, return pos/dim for specified button
		if (typeof(dhtmlXToolbarObject.prototype._getItemDim) == "undefined") {
			
			dhtmlXToolbarObject.prototype._getItemDim = function(id) {
				var t = this.objPull[this.idPrefix+id];
				var p = {
					left: window.dhx4.absLeft(t.obj),
					top: window.dhx4.absTop(t.obj),
					width: t.obj.offsetWidth+(t.arw?t.arw.offsetWidth:0),
					height: t.obj.offsetHeight
				};
				t = null;
				return p;
			}
			
		}
		
		this.conf.toolbarEvent = this.conf.toolbar.attachEvent("onClick", this._doOnToolbarClick);
		
	}
	
	// auto-init, ribbon mode
	if (typeof(window.dhtmlXRibbon) != "undefined" && this.conf.ribbon != null && this.conf.ribbon instanceof window.dhtmlXRibbon && this.conf.id != null) {
		
		if (!(this.conf.id instanceof Array)) this.conf.id = [this.conf.id];
		
		this.skinParent = this.conf.ribbon.conf.skin;
		
		this._doOnRibbonClick = function(id) {
			for (var q=0; q<that.conf.id.length; q++) {
				if (id == that.conf.id[q]) {
					if (id != that._lastId) {
						that.show(id);
						that._clearClick = true;
					}
				}
			}
		}
		
		// extension for toolbar, return pos/dim for specified button
		if (typeof(dhtmlXRibbon.prototype._getItemDim) == "undefined") {
			
			dhtmlXRibbon.prototype._getItemDim = function(id) {
				var t = this._items[id].base;
				var p = {
					left: window.dhx4.absLeft(t),
					top: window.dhx4.absTop(t),
					width: t.offsetWidth,
					height: t.offsetHeight
				};
				t = null;
				return p;
			}
			
		}
		
		this.conf.ribbonEvent = this.conf.ribbon.attachEvent("_showPopup", this._doOnRibbonClick);
		
	}
	
	// auto-init, form mode
	if (typeof(window.dhtmlXForm) != "undefined" && this.conf.form != null && this.conf.form instanceof window.dhtmlXForm && this.conf.id != null) {
		
		if (!(this.conf.id instanceof Array)) this.conf.id = [this.conf.id];
		
		if (!this.conf.mode) this.mode = "right"; // default mode for form
		this.skinParent = this.conf.form.skin;
		
		if (typeof(dhtmlXForm.prototype._getItemDim) == "undefined") {
			
			dhtmlXForm.prototype._getItemDim = function(name, value) {
				return this.doWithItem(name, "_getDim");
			};
			
			// file - ??
			for (var a in {input: 1, password: 1, select: 1, multiselect: 1, checkbox: 1, radio: 1, button: 1, combo: 1, btn2state: 1, calendar: 1, colorpicker: 1, editor: 1}) {
				
				if (dhtmlXForm.prototype.items[a] != null) {
				
					dhtmlXForm.prototype.items[a]._getDim = function(item) {
						
						var t = item;
						//console.log(item._type)
						
						if ({"ta":true,"pw":true,"se":true,"calendar":true,"colorpicker":1,"editor":true}[item._type]) {
							t = item.childNodes[item._ll?1:0].childNodes[0];
						}
						if ({"ch":true,"ra":true,"btn2state":true}[item._type]) {
							t = item.childNodes[item._ll?1:0].childNodes[1];
						}
						if ({"bt":true}[item._type]){
							t = item.firstChild;
						}
						if ({"combo":true}[item._type]){
							t = item._combo.DOMParent.firstChild;
						}
						
						
						var p = {
							left: window.dhx4.absLeft(t),
							top: window.dhx4.absTop(t),
							width: t.offsetWidth,
							height: t.offsetHeight
						};
						t = null;
						return p;
					};
				}
			}
			
		}
		
	}
	
	// auto-init, slider mode
	if (typeof(window.dhtmlXSlider) != "undefined" && this.conf.slider != null && this.conf.slider instanceof window.dhtmlXSlider) {
		
		if (!this.conf.mode) this.mode = "top"; // default mode for slider
		
		this.conf.slider_tm = null;
		
		this._sliderShow = function() {
			if (that.conf.slider_tm) window.clearTimeout(that.conf.slider_tm);
			var t = that.conf.slider._nodes.runner;
			var p = {
				left: window.dhx4.absLeft(t),
				top: window.dhx4.absTop(t),
				width: t.offsetWidth,
				height: t.offsetHeight
			};
			that.show(p.left, p.top, p.width, p.height);
		}
		
		this._sliderHide = function() {
			that.conf.slider_tm = window.setTimeout(function(){
				that.hide();
			}, 200);
			//that.hide();
		}
		
		this.conf.slider_events = [
			this.conf.slider.attachEvent("_onRunnerMouseDown", this._sliderShow),
			this.conf.slider.attachEvent("_onRunnerMouseUp", this._sliderHide),
			this.conf.slider.attachEvent("onChange", this._sliderShow)
		];
		
	}
	
	
	// define skin
	this.setSkin(this.skinParent||this.conf.skin||window.dhx4.skin||(typeof(dhtmlx)!="undefined"?dhtmlx.skin:null)||window.dhx4.skinDetect("dhx_popup")||"dhx_skyblue");
	
	return this;
	
};

// object
dhtmlXPopup.prototype.attachObject = function(obj) {
	return this._attachNode("object", {obj: obj});
};
dhtmlXPopup.prototype._attach_init_object = function(data) {
	this._nodeObj = (typeof(data.obj)=="string"?document.getElementById(data.obj):data.obj);
	data.obj = null;
	document.getElementById(this._nodeId).appendChild(this._nodeObj);
	this._nodeObj.style.display = "";
	this._nodeObj.style.visibility = "visible";
};

// html
dhtmlXPopup.prototype.attachHTML = function(html) {
	return this._attachNode("html", {html: html});
};
dhtmlXPopup.prototype._attach_init_html = function(data) {
	document.getElementById(this._nodeId).innerHTML = data.html;
	this._nodeObj = {text: data.html};
};

// form
dhtmlXPopup.prototype.attachForm = function(struct) {
	return this._attachNode("form", {struct: struct});
};
dhtmlXPopup.prototype._attach_init_form = function(data) {
	var that = this;
	this._nodeObj = new dhtmlXForm(this._nodeId, data.struct);
	this._nodeObj.setSkin(this.conf.skin);
	this._nodeObj.attachEvent("_onBeforeEditorAccess", function(){
		// prevent popup autohide, editor will trigger body/click
		that._clearClick = true;
	});
	// fix editors which were inited in hidden popup
	if (this.conf.editorEv != null && this.checkEvent(this.conf.editorEv) == false) {
		this.conf.editorEv = null;
	}
	// attach event for first popup show
	if (dhtmlXForm.prototype.items.editor != null && this.conf.editorEv == null) {
		this.conf.editorEv = this.attachEvent("onShow", function(){
			var editors = dhtmlXForm.prototype.items.editor.editor;
			for (var a in editors) {
				var base = editors[a].base;
				var fixSize = false;
				while (base != null) {
					if (base == this.p) {
						fixSize = true;
						base = null;
					} else {
						base = base.parentNode;
					}
				}
				base = null;
				if (fixSize == true) {
					editors[a].cell.conf.cells_cont = null;
					editors[a].setSizes();
				}
			}
			editors = null;
			this.detachEvent(this.conf.editorEv);
			this.conf.editorEv = null;
		});
		if (this._nodeObjEv == null) this._nodeObjEv = [];
		this._nodeObjEv.push(this.conf.editorEv);
	}
};

// calendar
dhtmlXPopup.prototype.attachCalendar = function() {
	return this._attachNode("calendar", {});
};
dhtmlXPopup.prototype._attach_init_calendar = function(data) {
	this._nodeObj = new dhtmlXCalendarObject(this._nodeId);
	this._nodeObj.setSkin(this.conf.skin);
	this._nodeObj.show();
};

// grid
dhtmlXPopup.prototype.attachGrid = function(width, height) {
	return this._attachNode("grid", {width: width||400, height: height||200});
};
dhtmlXPopup.prototype._attach_init_grid = function() {
	this._nodeObj = new dhtmlXGridObject(this._nodeId);
	this._nodeObj.setSkin(this.conf.skin);
};

// tree
dhtmlXPopup.prototype.attachTree = function(width, height, rootId) {
	return this._attachNode("tree", {width: width||400, height: height||200, rootId: rootId||0});
};
dhtmlXPopup.prototype._attach_init_tree = function(data) {
	this._nodeObj = new dhtmlXTreeObject(this._nodeId, "100%", "100%", (data.rootId))
};

// layout
dhtmlXPopup.prototype.attachLayout = function(width, height, pattern) {
	return this._attachNode("layout", {width: width||400, height: height||200, pattern: pattern||"3L"});
};
dhtmlXPopup.prototype._attach_init_layout = function(data) {
	this._nodeObj = new dhtmlXLayoutObject(this._nodeId, data.pattern, this.conf.skin)
};

// accordion
dhtmlXPopup.prototype.attachAccordion = function(width, height, conf) {
	return this._attachNode("accordion", {width: width||400, height: height||200, conf:conf||{}});
};
dhtmlXPopup.prototype._attach_init_accordion = function(conf) {
	conf.conf.parent = this._nodeId;
	conf.conf.skin = this.conf.skin;
	this._nodeObj = new dhtmlXAccordion(conf.conf);
};

// tabbar
dhtmlXPopup.prototype.attachTabbar = function(width, height, conf) {
	if (typeof(conf) == "string") {
		conf = {mode:conf}; // 3.6 compat
	} else if (typeof(conf) != "object" || conf == null) {
		conf = {};
	}
	return this._attachNode("tabbar", {width: width||400, height: height||200, conf:conf});
};
dhtmlXPopup.prototype._attach_init_tabbar = function(conf) {
	conf.conf.parent = this._nodeId;
	conf.conf.skin = this.conf.skin;
	this._nodeObj = new dhtmlXTabBar(conf.conf);
};

// editor
dhtmlXPopup.prototype.attachEditor = function(width, height, conf) {
	return this._attachNode("editor", {width: width||400, height: height||200, conf: conf||{}});
};
dhtmlXPopup.prototype._attach_init_editor = function(data) {
	document.getElementById(this._nodeId).className = "dhxeditor_"+this.conf.skin;
	data.conf.parent = this._nodeId;
	if (data.conf.skin == null) data.conf.skin = this.conf.skin;
	this._nodeObj = new dhtmlXEditor(data.conf);
	var evId = this.attachEvent("onShow", function(){
		if (this._nodeObj instanceof window.dhtmlXEditor) this._nodeObj.setSizes();
	});
	if (this._nodeObjEv == null) this._nodeObjEv = [];
	this._nodeObjEv.push(evId);
};

// color picker
dhtmlXPopup.prototype.attachColorPicker = function(conf) {
	if (typeof(conf) != "object" || conf == null) conf = {};
	return this._attachNode("colorpicker", {conf:conf});
};
dhtmlXPopup.prototype._attach_init_colorpicker = function(conf) {
	conf.conf.skin = this.conf.skin;
	conf.conf.parent = this._nodeId;
	this._nodeObj = new dhtmlXColorPicker(conf.conf);
};



/*
Product Name: dhtmlxSuite 
Version: 4.1.3 
Edition: Professional 
License: content of this file is covered by DHTMLX Commercial or Enterprise license. Usage without proper license is prohibited. To obtain it contact sales@dhtmlx.com
Copyright UAB Dinamenta http://www.dhtmlx.com
*/

function dhtmlXMenuObject(base, skin) {
	
	var that = this;
	
	// iframe
	this.conf = {
		skin: (skin||window.dhx4.skin||(typeof(dhtmlx)!="undefined"?dhtmlx.skin:null)||window.dhx4.skinDetect("dhxmenu")||"dhx_skyblue"),
		mode: "web",
		align: "left",
		is_touched: false,
		selected: -1,
		last_click: -1,
		fixed_pos: false, // should be used for frameset in IE
		rtl: false,
		icons_path: "",
		arrow_ff_fix: (navigator.userAgent.indexOf("MSIE") >= 0 && document.compatMode=="BackCompat"), // border fixer for FF for arrows polygons
		live_id: window.dhx4.newId(),
		tags: {
			root: "menu",
			item: "item",
			text_ext: "itemtext",
			userdata: "userdata",
			tooltip: "tooltip",
			hotkey: "hotkey",
			href: "href"
		},
		autoload: {},
		hide_tm: {},
		// shows sublevel polygons from toplevel items with delay
		top_mode: true,
		top_tmtime: 200,
		// visible area
		v_enabled: false,
		v: {x1: null, x2: null, y1: null, y2: null},
		// open direction
		dir_toplv: "bottom",
		dir_sublv: "right",
		// overflow
		auto_overflow: false,
		overflow_limit: 0,
		of_utm: null, // scroll up - tm
		of_utime: 20, // scroll up - time
		of_ustep: 3, // scroll up - step
		of_dtm: null,
		of_dtime: 20,
		of_dstep: 3,
		// hide
		tm_sec: 400,
		tm_handler: null,
		// dyn load
		dload: false,
		dload_url: "",
		dload_icon: false, // show loading icon
		dload_params: {action: "loadMenu"}, // extra params
		dload_pid: "parentId", // parentId param name
		// skinbased offsets
		tl_botmarg: 1, // top level bottom margin
		tl_rmarg: 0, // right margin
		tl_ofsleft: 1, // offset left
		// context menu
		context: false,
		ctx_zoneid: false,
		ctx_autoshow: true, // default open action
		ctx_autohide: true, // default close action
		ctx_hideall: true, // true will hide all opened contextual menu polygons on mouseout, false - all except topleft
		ctx_zones: {},
		ctx_baseid: null, // add baseId as context zone
		// selected subitems
		selected_sub: [],
		opened_poly: []
	}
	
	if (typeof(base) == "object" && base != null && typeof(base.tagName) == "undefined") {
		
		// object-api init
		if (base.icons_path != null || base.icon_path != null) this.conf.icons_path = (base.icons_path||base.icon_path);
		if (base.skin != null) this.conf.skin = base.skin;
		if (base.visible_area) {
			this.conf.v_enabled = true;
			this.conf.v = {
				x1: base.visible_area.x1,
				x2: base.visible_area.x2,
				y1: base.visible_area.y1,
				y2: base.visible_area.y2
			};
		}
			
		for (var a in {json:1,xml:1,items:1,top_text:1,align:1,open_mode:1,overflow:1,dynamic:1,dynamic_icon:1,context:1,onload:1,onclick:1,oncheckboxclick:1,onradioclick:1}) {
			if (base[a] != null) this.conf.autoload[a] = base[a];
		}
		
		base = base.parent;
	}
	
	if (base == null) {
		this.base = document.body;
	} else {
		var baseObj = (typeof(base)=="string"?document.getElementById(base):base);
		if (baseObj != null) {
			this.base = baseObj;
			if (!this.base.id) this.base.id = (new Date()).valueOf();
			this.base.className += " dhtmlxMenu_"+this.conf.skin+"_Middle dir_left";
			this.base._autoSkinUpdate = true;
			 // preserv default oncontextmenu for future restorin in case of context menu
			if (this.base.oncontextmenu) this.base._oldContextMenuHandler = this.base.oncontextmenu;
			//
			this.conf.ctx_baseid = this.base.id;
			this.base.onselectstart = function(e) { e = e || event; if (e.preventDefault) e.preventDefault(); else e.returnValue = false; return false; }
			this.base.oncontextmenu = function(e) { e = e || event; if (e.preventDefault) e.preventDefault(); else e.returnValue = false; return false; }
		} else {
			this.base = document.body;
		}
	}
	
	this.idPrefix = "";
	this.topId = "dhxWebMenuTopId";
	
	this.idPull = {};
	this.itemPull = {};
	this.userData = {};
	this.radio = {};
	//
	this.setSkin = function(skin) {
		var oldSkin = this.conf.skin;
		this.conf.skin = skin;
		switch (this.conf.skin){
			case "dhx_skyblue":
			case "dhx_web":
				this.conf.tl_botmarg = 2;
				this.conf.tl_rmarg = 1;
				this.conf.tl_ofsleft = 1;
				break;
			case "dhx_terrace":
				this.conf.tl_botmarg = 0;
				this.conf.tl_rmarg = 0;
				this.conf.tl_ofsleft = 0;
				break;
		}
		if (this.base._autoSkinUpdate) {
			this.base.className = this.base.className.replace("dhtmlxMenu_"+oldSkin+"_Middle", "")+" dhtmlxMenu_"+this.conf.skin+"_Middle";
		}
		
		for (var a in this.idPull) {
			this.idPull[a].className = String(this.idPull[a].className).replace(oldSkin, this.conf.skin);
			
		}
	}
	this.setSkin(this.conf.skin);
	//
	
	this._addSubItemToSelected = function(item, polygon) {
		var t = true;
		for (var q=0; q<this.conf.selected_sub.length; q++) { if ((this.conf.selected_sub[q][0] == item) && (this.conf.selected_sub[q][1] == polygon)) { t = false; } }
		if (t == true) { this.conf.selected_sub.push(new Array(item, polygon)); }
		return t;
	}
	this._removeSubItemFromSelected = function(item, polygon) {
		var m = new Array();
		var t = false;
		for (var q=0; q<this.conf.selected_sub.length; q++) { if ((this.conf.selected_sub[q][0] == item) && (this.conf.selected_sub[q][1] == polygon)) { t = true; } else { m[m.length] = this.conf.selected_sub[q]; } }
		if (t == true) { this.conf.selected_sub = m; }
		return t;
	}
	this._getSubItemToDeselectByPolygon = function(polygon) {
		var m = new Array();
		for (var q=0; q<this.conf.selected_sub.length; q++) {
			if (this.conf.selected_sub[q][1] == polygon) {
				m[m.length] = this.conf.selected_sub[q][0];
				m = m.concat(this._getSubItemToDeselectByPolygon(this.conf.selected_sub[q][0]));
				var t = true;
				for (var w=0; w<this.conf.opened_poly.length; w++) { if (this.conf.opened_poly[w] == this.conf.selected_sub[q][0]) { t = false; } }
				if (t == true) { this.conf.opened_poly[this.conf.opened_poly.length] = this.conf.selected_sub[q][0]; }
				this.conf.selected_sub[q][0] = -1;
				this.conf.selected_sub[q][1] = -1;
			}
		}
		return m;
	}
	
	this._hidePolygon = function(id) {
		if (this.idPull["polygon_" + id] != null) {
			// clear z-index
			if (this.idPull["polygon_"+id]._zId != null) {
				window.dhx4.zim.clear(this.idPull["polygon_"+id]._zId);
			}
			//
			if (typeof(this._menuEffect) != "undefined" && this._menuEffect !== false) {
				this._hidePolygonEffect("polygon_"+id);
			} else {
				// already hidden
				if (this.idPull["polygon_"+id].style.display == "none") return;
				//
				this.idPull["polygon_"+id].style.display = "none";
				if (this.idPull["arrowup_"+id] != null) this.idPull["arrowup_"+id].style.display = "none";
				if (this.idPull["arrowdown_"+id] != null) this.idPull["arrowdown_"+id].style.display = "none";
				this._updateItemComplexState(id, true, false);
				// hide ie6 cover
				if (window.dhx4.isIE6 && this.idPull["polygon_"+id+"_ie6cover"] != null) this.idPull["polygon_"+id+"_ie6cover"].style.display = "none";
			}
			// call event
			id = String(id).replace(this.idPrefix, "");
			if (id == this.topId) id = null;
			this.callEvent("onHide", [id]);
			
			// corners
			if (id != null && this.conf.skin == "dhx_terrace" && this.itemPull[this.idPrefix+id].parent == this.idPrefix+this.topId) {
				this._improveTerraceButton(this.idPrefix+id, true);
			}
			
		}
	}
	
	this._showPolygon = function(id, openType) {
		
		var itemCount = this._countVisiblePolygonItems(id);
		if (itemCount == 0) return;
		var pId = "polygon_"+id;
		if ((this.idPull[pId] != null) && (this.idPull[id] != null)) {
			
			if (this.conf.top_mode && this.conf.mode == "web" && !this.conf.context) {
				if (!this.idPull[id]._mouseOver && openType == this.conf.dir_toplv) return;
			}
			
			// detect visible area
			if (!this.conf.fixed_pos) this._autoDetectVisibleArea();
			
			// show arrows
			var arrUpH = 0;
			var arrDownH = 0;
			//
			var arrowUp = null;
			var arrowDown = null;
			
			// show polygon
			if (this.idPull[pId]._zId == null) {
				this.idPull[pId]._zId = window.dhx4.newId();
			}
			this.idPull[pId]._zInd = window.dhx4.zim.reserve(this.idPull[pId]._zId);
			
			this.idPull[pId].style.visibility = "hidden";
			this.idPull[pId].style.left = "0px";
			this.idPull[pId].style.top = "0px";
			this.idPull[pId].style.display = "";
			this.idPull[pId].style.zIndex = this.idPull[pId]._zInd;
			
			//
			if (this.conf.auto_overflow) {
				if (this.idPull[pId].childNodes[1].childNodes[0].offsetHeight > this.conf.v.y1+this.conf.v.y2) {
					var t0 = Math.floor((this.conf.v.y2-this.conf.v.y1-35)/24);
					this.conf.overflow_limit = t0;
				} else {
					this.conf.overflow_limit = 0;
					
					if (this.idPull["arrowup_"+id] != null) this._removeUpArrow(String(id).replace(this.idPrefix,""));
					if (this.idPull["arrowdown_"+id] != null) this._removeDownArrow(String(id).replace(this.idPrefix,""));
				}
			}
			
			if (this.conf.overflow_limit > 0 && this.conf.overflow_limit < itemCount)  {
				
				// add overflow arrows if they not exists
				if (this.idPull["arrowup_"+id] == null) this._addUpArrow(String(id).replace(this.idPrefix,""));
				if (this.idPull["arrowdown_"+id] == null) this._addDownArrow(String(id).replace(this.idPrefix,""));
				
				// configure up arrow
				arrowUp = this.idPull["arrowup_"+id];
				arrowUp.style.display = "none";
				//arrUpH = arrowUp.offsetHeight;
				
				// configure bottom arrow
				arrowDown = this.idPull["arrowdown_"+id];
				arrowDown.style.display = "none";
				//arrDownH = arrowDown.offsetHeight;
				
			}
			
			if (this.conf.overflow_limit > 0) {
				if (this.conf.overflow_limit < itemCount)  {
					// set fixed size
					this.idPull[pId].childNodes[1].style.height = 24*this.conf.overflow_limit+"px";
					arrowUp.style.width = arrowDown.style.width = this.idPull[pId].childNodes[1].style.width = this.idPull[pId].childNodes[1].childNodes[0].offsetWidth+"px";
					this.idPull[pId].childNodes[1].scrollTop = 0;
					
					arrowUp.style.display = "";
					arrUpH = arrowUp.offsetHeight;
					
					arrowDown.style.display = "";
					arrDownH = arrowDown.offsetHeight;
					
				} else {
					// remove fixed size
					this.idPull[pId].childNodes[1].style.height = "";
					this.idPull[pId].childNodes[1].style.width = "";
				}
			}
			
			if (this.itemPull[id] != null) {
				var parPoly = "polygon_"+this.itemPull[id]["parent"];
			} else if (this.conf.context) {
				var parPoly = this.idPull[this.idPrefix+this.topId];
			}
			
			// define position
			var srcX = (this.idPull[id].tagName != null ? window.dhx4.absLeft(this.idPull[id]) : this.idPull[id][0]);
			var srcY = (this.idPull[id].tagName != null ? window.dhx4.absTop(this.idPull[id]) : this.idPull[id][1]);
			var srcW = (this.idPull[id].tagName != null ? this.idPull[id].offsetWidth : 0);
			var srcH = (this.idPull[id].tagName != null ? this.idPull[id].offsetHeight : 0);
			
			var x = 0;
			var y = 0;
			var w = this.idPull[pId].offsetWidth;
			var h = this.idPull[pId].childNodes[1].offsetHeight + arrUpH + arrDownH;
			
			// pos
			if (openType == "bottom") {
				if (this.conf.rtl) {
					x = srcX + (srcW!=null?srcW:0) - w;
				} else {
					if (this.conf.align == "right") {
						x = srcX + srcW - w;
					} else {
						x = srcX - 1 + (openType==this.conf.dir_toplv?this.conf.tl_rmarg:0);
					}
				}
				y = srcY - 1 + srcH + this.conf.tl_botmarg;
			}
			if (openType == "right") { x = srcX + srcW - 1; y = srcY + 2; }
			if (openType == "left") { x = srcX - this.idPull[pId].offsetWidth + 2; y = srcY + 2; }
			if (openType == "top") { x = srcX - 1; y = srcY - h + 2; }
			
			// overflow check
			if (this.conf.fixed_pos) {
				// use fixed document.body/window dimension if required
				var mx = 65536;
				var my = 65536;
			} else {
				var mx = (this.conf.v.x2!=null?this.conf.v.x2:0);
				var my = (this.conf.v.y2!=null?this.conf.v.y2:0);
				
				if (mx == 0) {
					if (window.innerWidth) {
						mx = window.innerWidth;
						my = window.innerHeight;
					} else {
						mx = document.body.offsetWidth;
						my = document.body.scrollHeight;
					}
				}
			}
			if (x+w > mx && !this.conf.rtl) {
				// no space on right, open to left
				x = srcX - w + 2;
			}
			if (x < this.conf.v.x1 && this.conf.rtl) {
				// no space on left, open to right
				x = srcX + srcW - 2;
			}
			if (x < 0) {
				// menu floats left
				x = 0;
			}
			if (y+h > my && this.conf.v.y2 != null) {
				y = Math.max(srcY + srcH - h + 2, (this.conf.v_enabled?this.conf.v.y1+2:2));
				// open from top level
				if (this.conf.context && this.idPrefix+this.topId == id && arrowDown != null) {
					// autoscroll prevent because menu mouse pointer will right over downarrow
					y = y-2;
				}
				if (this.itemPull[id] != null && !this.conf.context) {
					if (this.itemPull[id]["parent"] == this.idPrefix+this.topId) y = y - this.base.offsetHeight;
				}
			}
			//
			this.idPull[pId].style.left = x+"px";
			//this.idPull[pId].style.top = y+arrUpH+"px";
			this.idPull[pId].style.top = y+"px";
			//
			if (typeof(this._menuEffect) != "undefined" && this._menuEffect !== false) {
				this._showPolygonEffect(pId);
			} else {
				this.idPull[pId].style.visibility = "";
				
				if (this.conf.overflow_limit > 0 && this.conf.overflow_limit < itemCount)  {
					this.idPull[pId].childNodes[1].scrollTop = 0;
					this._checkArrowsState(id);
				}
				
				// show ie6 cover
				if (window.dhx4.isIE6) {
					var pIdIE6 = pId+"_ie6cover";
					if (this.idPull[pIdIE6] == null) {
						var ifr = document.createElement("IFRAME");
						ifr.className = "dhtmlxMenu_IE6CoverFix_"+this.conf.skin;
						ifr.frameBorder = 0;
						ifr.setAttribute("src", "javascript:false;");
						document.body.insertBefore(ifr, document.body.firstChild);
						this.idPull[pIdIE6] = ifr;
					}
					this.idPull[pIdIE6].style.left = x+"px";
					this.idPull[pIdIE6].style.top = y+"px";
					this.idPull[pIdIE6].style.width = this.idPull[pId].offsetWidth+"px";
					this.idPull[pIdIE6].style.height = this.idPull[pId].offsetHeight+"px";
					this.idPull[pIdIE6].style.zIndex = this.idPull[pId].style.zIndex-1;
					this.idPull[pIdIE6].style.display = "";
				}
			}
			
			id = String(id).replace(this.idPrefix, "");
			if (id == this.topId) id = null;
			this.callEvent("onShow", [id]);
			
			// corners
			if (id != null && this.conf.skin == "dhx_terrace" && this.itemPull[this.idPrefix+id].parent == this.idPrefix+this.topId) {
				this._improveTerraceButton(this.idPrefix+id, false);
			}
			
		}
	}
	
	this._redistribSubLevelSelection = function(id, parentId) {
		// clear previosly selected items
		while (this.conf.opened_poly.length > 0) this.conf.opened_poly.pop();
		// this.conf.opened_poly = new Array();
		var i = this._getSubItemToDeselectByPolygon(parentId);
		this._removeSubItemFromSelected(-1, -1);
		for (var q=0; q<i.length; q++) { if ((this.idPull[i[q]] != null) && (i[q] != id)) { if (this.itemPull[i[q]]["state"] == "enabled") { this.idPull[i[q]].className = "sub_item"; } } }
		// hide polygons
		for (var q=0; q<this.conf.opened_poly.length; q++) { if (this.conf.opened_poly[q] != parentId) { this._hidePolygon(this.conf.opened_poly[q]); } }
		// add new selection into list new
		if (this.itemPull[id]["state"] == "enabled") {
			this.idPull[id].className = "sub_item_selected";
			if (this.itemPull[id]["complex"] && this.conf.dload && (this.itemPull[id]["loaded"]=="no")) {
				if (this.conf.dload_icon == true) { this._updateLoaderIcon(id, true); }
				this.itemPull[id].loaded = "get";
				var xmlParentId = id.replace(this.idPrefix,"");
				this._dhxdataload.onBeforeXLS = function() {
					var p = {params:{}};
					p.params[this.conf.dload_pid] = xmlParentId;
					for (var a in this.conf.dload_params) p.params[a] = this.conf.dload_params[a];
					return p;
				};
				this.loadStruct(this.conf.dload_url);
			}
			// show
			if (this.itemPull[id]["complex"] || (this.conf.dload && (this.itemPull[id]["loaded"] == "yes"))) {
				// make arrow over
				if ((this.itemPull[id]["complex"]) && (this.idPull["polygon_" + id] != null))  {
					this._updateItemComplexState(id, true, true);
					this._showPolygon(id, this.conf.dir_sublv);
				}
			}
			this._addSubItemToSelected(id, parentId);
			this.conf.selected = id;
		}
	}
	
	this._doOnClick = function(id, type, casState) {
		this.conf.last_click = id;
		// href
		if (this.itemPull[this.idPrefix+id]["href_link"] != null && this.itemPull[this.idPrefix+id].state == "enabled") {
			var form = document.createElement("FORM");
			var k = String(this.itemPull[this.idPrefix+id]["href_link"]).split("?");
			form.action = k[0];
			if (k[1] != null) {
				var p = String(k[1]).split("&");
				for (var q=0; q<p.length; q++) {
					var j = String(p[q]).split("=");
					var m = document.createElement("INPUT");
					m.type = "hidden";
					m.name = (j[0]||"");
					m.value = (j[1]||"");
					form.appendChild(m);
				}
			}
			if (this.itemPull[this.idPrefix+id]["href_target"] != null) { form.target = this.itemPull[this.idPrefix+id]["href_target"]; }
			form.style.display = "none";
			document.body.appendChild(form);
			form.submit();
			if (form != null) {
				document.body.removeChild(form);
				form = null;
			}
			return;
		}
		//
		// some fixes
		if (type.charAt(0)=="c") return; // can't click on complex item
		if (type.charAt(1)=="d") return; // can't click on disabled item
		if (type.charAt(2)=="s") return; // can't click on separator
		//
		if (this.checkEvent("onClick")) {
			this.callEvent("onClick", [id, this.conf.ctx_zoneid, casState]);
		} else {
			if ((type.charAt(1) == "d") || (this.conf.mode == "win" && type.charAt(2) == "t")) return;
		}
		if (this.conf.context && this._isContextMenuVisible() && this.conf.ctx_autohide) {
			this._hideContextMenu();
		} else {
			// if menu unloaded from click event
			if (this._clearAndHide) this._clearAndHide();
		}
	}
	// onTouchMenu action - select topLevel item
	this._doOnTouchMenu = function(id) {
		if (this.conf.is_touched == false) {
			this.conf.is_touched = true;
			if (this.checkEvent("onTouch")) {
				this.callEvent("onTouch", [id]);
			}
		}
	}
	
	// return menu array of all nested objects
	this._searchMenuNode = function(node, menu) {
		var m = new Array();
		for (var q=0; q<menu.length; q++) {
			if (typeof(menu[q]) == "object") {
				if (menu[q].length == 5) { if (typeof(menu[q][0]) != "object") { if ((menu[q][0].replace(this.idPrefix, "") == node) && (q == 0)) { m = menu; } } }
				var j = this._searchMenuNode(node, menu[q]);
				if (j.length > 0) { m = j; }
			}
		}
		return m;
	}
	// return array of subitems for single menu object
	this._getMenuNodes = function(node) {
		var m = new Array;
		for (var a in this.itemPull) { if (this.itemPull[a]["parent"] == node) { m[m.length] = a; } }
		return m;
	}
	// generate random string with specified length
	this._genStr = function(w) {
		var s = ""; var z = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";
		for (var q=0; q<w; q++) s += z.charAt(Math.round(Math.random() * (z.length-1)));
		return s;
	}
	
	this.getItemType = function(id) {
		id = this.idPrefix+id;
		if (this.itemPull[id] == null) { return null; }
		return this.itemPull[id]["type"];
	}
	
	this.forEachItem = function(handler) {
		for (var a in this.itemPull) { handler(String(a).replace(this.idPrefix, "")); }
	}
	
	// clear selection and hide menu on onbody click event
	this._clearAndHide = function() {
		that.conf.selected = -1;
		that.conf.last_click = -1;
		while (that.conf.opened_poly.length > 0) { that.conf.opened_poly.pop(); }
		for (var q=0; q<that.conf.selected_sub.length; q++) {
			var id = that.conf.selected_sub[q][0];
			// clear all selection
			if (that.idPull[id] != null) {
				if (that.itemPull[id]["state"] == "enabled") {
					if (that.idPull[id].className == "sub_item_selected") that.idPull[id].className = "sub_item";
					if (that.idPull[id].className == "dhtmlxMenu_"+that.conf.skin+"_TopLevel_Item_Selected") {
						// custom css
						if (that.itemPull[id]["cssNormal"] != null) {
							that.idPull[id].className = that.itemPull[id]["cssNormal"];
						} else {
							// default css
							that.idPull[id].className = "dhtmlxMenu_"+that.conf.skin+"_TopLevel_Item_Normal";
						}
					}
				}
			}
			that._hidePolygon(id);
		}
		
		that.conf.is_touched = false;
		
		// hide all contextmenu polygons on mouseout
		if (that.conf.context && that.conf.ctx_hideall) that._hidePolygon(that.idPrefix+that.topId);
		
	}
	
	/* show sublevel item */
	this._showSubLevelItem = function(id,back) {
		if (document.getElementById("arrow_" + this.idPrefix + id) != null) { document.getElementById("arrow_" + this.idPrefix + id).style.display = (back?"none":""); }
		if (document.getElementById("image_" + this.idPrefix + id) != null) { document.getElementById("image_" + this.idPrefix + id).style.display = (back?"none":""); }
		if (document.getElementById(this.idPrefix + id) != null) { document.getElementById(this.idPrefix + id).style.display = (back?"":"none"); }
	}
	/* hide sublevel item */
	this._hideSubLevelItem = function(id) {
		this._showSubLevelItem(id,true)
	}
	// generating id prefix
	this.idPrefix = this._genStr(12)+"_";
	
	/* attach body events */
	this._bodyClick = function(e) {
		e = e||event;
		if (e.button == 2 || (window.dhx4.isOpera && e.ctrlKey == true)) return;
		if (that.conf.context) {
			if (that.conf.ctx_autohide && (!window.dhx4.isOpera || (that._isContextMenuVisible() && window.dhx4.isOpera))) that._hideContextMenu();
		} else {
			if (that._clearAndHide) that._clearAndHide();
		}
	}
	this._bodyContext = function(e) {
		e = e||event;
		var t = String((e.srcElement||e.target).className);
		if (t.search("dhtmlxMenu") != -1 && t.search("SubLevelArea") != -1) return;
		var toHide = true;
		var testZone = e.target || e.srcElement;
		while (testZone != null) {
			if (testZone.id != null) if (that.isContextZone(testZone.id)) toHide = false;
			if (testZone == document.body) toHide = false;
			testZone = testZone.parentNode;
		}
		if (toHide) that.hideContextMenu();
	}
	
	if (typeof(window.addEventListener) != "undefined") {
		window.addEventListener("click", this._bodyClick, false);
		window.addEventListener("contextmenu", this._bodyContext, false);
	} else {
		document.body.attachEvent("onclick", this._bodyClick);
		document.body.attachEvent("oncontextmenu", this._bodyContext);
	}
	
	this.unload = function() {
		
		window.dhx4._eventable(this, "clear");
		
		// remove menu from global store
		dhtmlXMenuObject.prototype.liveInst[this.conf.live_id] = null;
		try { delete dhtmlXMenuObject.prototype.liveInst[this.conf.live_id]; } catch(e) {}
		this.conf.live_id = null;
		
		if (typeof(window.addEventListener) == "function") {
			window.removeEventListener("click", this._bodyClick, false);
			window.removeEventListener("contextmenu", this._bodyContext, false);
		} else {
			document.body.detachEvent("onclick", this._bodyClick);
			document.body.detachEvent("oncontextmenu", this._bodyContext);
		}
		this._bodyClick = null;
		this._bodyContext = null;
		
		// will recursively remove all items
		this.removeItem(this.idPrefix+this.topId, true);
		
		this.itemPull = null;
		this.idPull = null;
		
		// clear context zones
		if (this.conf.context) for (var a in this.conf.ctx_zones) this.removeContextZone(a);
		
		if (this.cont != null) {
			this.cont.className = "";
			this.cont.parentNode.removeChild(this.cont);
			this.cont = null;
		}
		
		if (this.base != null) {
			if (!this.conf.context) this.base.className = "";
			if (!this.conf.context) this.base.oncontextmenu = (this.base._oldContextMenuHandler||null);
			this.base.onselectstart = null;
			this.base = null;
		}
		
		for (var a in this) this[a] = null;
		that = null;
		
	}
	
	// register instance
	dhtmlXMenuObject.prototype.liveInst[this.conf.live_id] = this;
	
	window.dhx4._enableDataLoading(this, "_initObj", "_xmlToJson", this.conf.tags.root, {struct:true});
	window.dhx4._eventable(this);
	
	// autoload
	if (window.dhx4.s2b(this.conf.autoload.context) == true) this.renderAsContextMenu();
	
	if (this.conf.autoload.dynamic != null) {
		this.enableDynamicLoading(this.conf.autoload.dynamic, window.dhx4.s2b(this.conf.autoload.dynamic_icon));
	} else if (this.conf.autoload.items != null) {
		this.loadStruct(this.conf.autoload.items, this.conf.autoload.onload);
	} else if (this.conf.autoload.json != null) {
		this.loadStruct(this.conf.autoload.json, this.conf.autoload.onload);
	} else if (this.conf.autoload.xml != null) {
		this.loadStruct(this.conf.autoload.xml, this.conf.autoload.onload);
	}
	
	for (var a in {onclick:1,oncheckboxclick:1,onradioclick:1}) {
		if (this.conf.autoload[a] != null) {
			if (typeof(this.conf.autoload[a]) == "function") {
				this.attachEvent(a, this.conf.autoload[a]);
			} else if (typeof(window[this.conf.autoload[a]]) == "function") {
				this.attachEvent(a, window[this.conf.autoload[a]]);
			}
		}
	}
	
	if (this.conf.autoload.top_text != null) this.setTopText(this.conf.autoload.top_text);
	if (this.conf.autoload.align != null) this.setAlign(this.conf.autoload.align);
	if (this.conf.autoload.open_mode != null) this.setOpenMode(this.conf.autoload.open_mode);
	if (this.conf.autoload.overflow != null) this.setOverflowHeight(this.conf.autoload.overflow);
	//
	for (var a in this.conf.autoload) {
		this.conf.autoload[a] = null;
		delete this.conf.autoload[a];
	}
	this.conf.autoload = null;
	
	//
	return this;
	
};

dhtmlXMenuObject.prototype._init = function() {
	if (this._isInited == true) return;
	if (this.conf.dload) {
		this._dhxdataload.onBeforeXLS = function() {
			var p = {params:{}};
			for (var a in this.conf.dload_params) p.params[a] = this.conf.dload_params[a];
			return p;
		};
		this.loadStruct(this.conf.dload_url);
	} else {
		this._initTopLevelMenu();
		this._isInited = true;
	}
};

dhtmlXMenuObject.prototype._countVisiblePolygonItems = function(id) {
	
	var count = 0;
	
	for (var a in this.itemPull) {
		
		var par = this.itemPull[a]["parent"];
		var tp = this.itemPull[a]["type"];
		if (this.idPull[a] != null) {
			if (par == id && (tp == "item" || tp == "radio" || tp == "checkbox") && this.idPull[a].style.display != "none") {
				count++;
			}
		}
	}
	return count;
};

dhtmlXMenuObject.prototype._redefineComplexState = function(id) {
	// alert(id)
	if (this.idPrefix+this.topId == id) { return; }
	if ((this.idPull["polygon_"+id] != null) && (this.idPull[id] != null)) {
		var u = this._countVisiblePolygonItems(id);
		if ((u > 0) && (!this.itemPull[id]["complex"])) { this._updateItemComplexState(id, true, false); }
		if ((u == 0) && (this.itemPull[id]["complex"])) { this._updateItemComplexState(id, false, false); }
	}
};

dhtmlXMenuObject.prototype._updateItemComplexState = function(id, state, over) {
	// 0.2 FIX :: topLevel's items can have complex items with arrow
	if ((!this.conf.context) && (this._getItemLevelType(id.replace(this.idPrefix,"")) == "TopLevel")) {
		// 30.06.2008 fix > complex state for top level item, state only, no arrow
		this.itemPull[id]["complex"] = state;
		return;
	}
	if ((this.idPull[id] == null) || (this.itemPull[id] == null)) { return; }
	// 0.2 FIX :: end
	this.itemPull[id]["complex"] = state;
	// fixed in 0.4 for context
	if (id == this.idPrefix+this.topId) return;
	// end fix
	// try to retrieve arrow img object
	var arrowObj = null;
	
	
	var item = this.idPull[id].childNodes[this.conf.rtl?0:2];
	if (item.childNodes[0]) if (String(item.childNodes[0].className).search("complex_arrow") === 0) arrowObj = item.childNodes[0];
	
	if (this.itemPull[id]["complex"]) {
		// create arrow
		if (arrowObj == null) {
			arrowObj = document.createElement("DIV");
			arrowObj.className = "complex_arrow";
			arrowObj.id = "arrow_"+id;
			while (item.childNodes.length > 0) item.removeChild(item.childNodes[0]);
			item.appendChild(arrowObj);
		}
		// over state added in 0.4
		
		if (this.conf.dload && (this.itemPull[id].loaded == "get") && this.conf.dload_icon) {
			// change arrow to loader
			if (arrowObj.className != "complex_arrow_loading") arrowObj.className = "complex_arrow_loading";
		} else {
			arrowObj.className = "complex_arrow";
		}
		
		return;
	}
	
	if ((!this.itemPull[id]["complex"]) && (arrowObj!=null)) {
		item.removeChild(arrowObj);
		if (this.itemPull[id]["hotkey_backup"] != null && this.setHotKey) { this.setHotKey(id.replace(this.idPrefix, ""), this.itemPull[id]["hotkey_backup"]); }
	}
	
};

dhtmlXMenuObject.prototype._getItemLevelType = function(id) {
	return (this.itemPull[this.idPrefix+id]["parent"]==this.idPrefix+this.topId?"TopLevel":"SubLevelArea");
};

dhtmlXMenuObject.prototype.setIconsPath = function(path) {
	this.conf.icons_path = path;
};

/* real-time update icon in menu */
dhtmlXMenuObject.prototype._updateItemImage = function(id, levelType) {
	// search existsing image
	
	id = this.idPrefix+id;
	
	var tp = this.itemPull[id]["type"];
	if (tp == "checkbox" || tp == "radio") return;
	
	var isTopLevel = (this.itemPull[id]["parent"] == this.idPrefix+this.topId && !this.conf.context);
	
	// search existing image
	var imgObj = null;
	if (isTopLevel) {
		for (var q=0; q<this.idPull[id].childNodes.length; q++) {
			try { if (this.idPull[id].childNodes[q].className == "dhtmlxMenu_TopLevel_Item_Icon") imgObj = this.idPull[id].childNodes[q]; } catch(e) {}
		}
	} else {
		try { var imgObj = this.idPull[id].childNodes[this.conf.rtl?2:0].childNodes[0]; } catch(e) { }
		if (!(imgObj != null && typeof(imgObj.className) != "undefined" && imgObj.className == "sub_icon")) imgObj = null;
	}
	
	var imgSrc = this.itemPull[id][(this.itemPull[id]["state"]=="enabled"?"imgen":"imgdis")];
	
	if (imgSrc.length > 0) {
		if (imgObj != null) {
			imgObj.src = this.conf.icons_path+imgSrc;
		} else {
			if (isTopLevel) {
				var imgObj = document.createElement("IMG");
				imgObj.className = "dhtmlxMenu_TopLevel_Item_Icon";
				imgObj.src = this.conf.icons_path+imgSrc;
				imgObj.border = "0";
				imgObj.id = "image_"+id;
				if (!this.conf.rtl && this.idPull[id].childNodes.length > 0) this.idPull[id].insertBefore(imgObj,this.idPull[id].childNodes[0]); else this.idPull[id].appendChild(imgObj);
				
			} else {
				
				var imgObj = document.createElement("IMG");
				imgObj.className = "sub_icon";
				imgObj.src = this.conf.icons_path+imgSrc;
				imgObj.border = "0";
				imgObj.id = "image_"+id;
				var item = this.idPull[id].childNodes[this.conf.rtl?2:0];
				while (item.childNodes.length > 0) item.removeChild(item.childNodes[0]);
				item.appendChild(imgObj);
				
			}
		}
	} else {
		if (imgObj != null) {
			var p = imgObj.parentNode;
			p.removeChild(imgObj);
			p.innerHTML = "&nbsp;";
			p = imgObj = null;
		}
	}
};

// collect parents for remove complex item
dhtmlXMenuObject.prototype._getAllParents = function(id) {
	var parents = new Array();
	for (var a in this.itemPull) {
		if (this.itemPull[a]["parent"] == id) {
			parents[parents.length] = this.itemPull[a]["id"];
			if (this.itemPull[a]["complex"]) {
				var t = this._getAllParents(this.itemPull[a]["id"]);
				for (var q=0; q<t.length; q++) { parents[parents.length] = t[q]; }
			}
		}
	}
	return parents;
};

// visible area
dhtmlXMenuObject.prototype._autoDetectVisibleArea = function() {
	if (this.conf.v_enabled) return;
	var d = window.dhx4.screenDim();
	this.conf.v.x1 = d.left;
	this.conf.v.x2 = d.right;
	this.conf.v.y1 = d.top;
	this.conf.v.y2 = d.bottom;
};

dhtmlXMenuObject.prototype.getItemPosition = function(id) {
	id = this.idPrefix+id;
	var pos = -1;
	if (this.itemPull[id] == null) return pos;
	var parent = this.itemPull[id]["parent"];
	// var obj = (this.idPull["polygon_"+parent]!=null?this.idPull["polygon_"+parent].tbd:this.base);
	var obj = (this.idPull["polygon_"+parent]!=null?this.idPull["polygon_"+parent].tbd:this.cont);
	for (var q=0; q<obj.childNodes.length; q++) { if (obj.childNodes[q]==this.idPull["separator_"+id]||obj.childNodes[q]==this.idPull[id]) { pos = q; } }
	return pos;
};

dhtmlXMenuObject.prototype.setItemPosition = function(id, pos) {
	id = this.idPrefix+id;
	if (this.idPull[id] == null) { return; }
	// added in 0.4
	var isOnTopLevel = (this.itemPull[id]["parent"] == this.idPrefix+this.topId);
	//
	var itemData = this.idPull[id];
	var itemPos = this.getItemPosition(id.replace(this.idPrefix,""));
	var parent = this.itemPull[id]["parent"];
	// var obj = (this.idPull["polygon_"+parent]!=null?this.idPull["polygon_"+parent].tbd:this.base);
	var obj = (this.idPull["polygon_"+parent]!=null?this.idPull["polygon_"+parent].tbd:this.cont);
	obj.removeChild(obj.childNodes[itemPos]);
	if (pos < 0) pos = 0;
	// added in 0.4
	if (isOnTopLevel && pos < 1) { pos = 1; }
	//
	if (pos < obj.childNodes.length) { obj.insertBefore(itemData, obj.childNodes[pos]); } else { obj.appendChild(itemData); }
};

dhtmlXMenuObject.prototype.getParentId = function(id) {
	id = this.idPrefix+id;
	if (this.itemPull[id] == null) { return null; }
	return ((this.itemPull[id]["parent"]!=null?this.itemPull[id]["parent"]:this.topId).replace(this.idPrefix,""));
};


// hide any opened polygons
dhtmlXMenuObject.prototype.hide = function() {
	this._clearAndHide();
};
dhtmlXMenuObject.prototype.clearAll = function() {
	this.removeItem(this.idPrefix+this.topId, true);
	this._isInited = false;
	this.idPrefix = this._genStr(12)+"_";
	this.itemPull = {};
};

// dhtmlxmenu global store
if (typeof(dhtmlXMenuObject.prototype.liveInst) == "undefined") {
	dhtmlXMenuObject.prototype.liveInst = {};
};


// redistrib selection in case of top node in real-time mode
dhtmlXMenuObject.prototype._redistribTopLevelSelection = function(id, parent) {
	// kick polygons and decelect before selected menues
	var i = this._getSubItemToDeselectByPolygon("parent");
	this._removeSubItemFromSelected(-1, -1);
	for (var q=0; q<i.length; q++) {
		if (i[q] != id) { this._hidePolygon(i[q]); }
		if ((this.idPull[i[q]] != null) && (i[q] != id)) { this.idPull[i[q]].className = this.idPull[i[q]].className.replace(/Selected/g, "Normal"); }
	}
	// check if enabled
	if (this.itemPull[this.idPrefix+id]["state"] == "enabled") {
		this.idPull[this.idPrefix+id].className = "dhtmlxMenu_"+this.conf.skin+"_TopLevel_Item_Selected";
		//
		this._addSubItemToSelected(this.idPrefix+id, "parent");
		this.conf.selected = (this.conf.mode=="win"?(this.conf.selected!=-1?id:this.conf.selected):id);
		if ((this.itemPull[this.idPrefix+id]["complex"]) && (this.conf.selected != -1)) { this._showPolygon(this.idPrefix+id, this.conf.dir_toplv); }
	}
};

dhtmlXMenuObject.prototype._initTopLevelMenu = function() {
	
	this.conf.dir_toplv = "bottom";
	this.conf.dir_sublv = (this.conf.rtl?"left":"right");
	if (this.conf.context) {
		this.idPull[this.idPrefix+this.topId] = new Array(0,0);
		this._addSubMenuPolygon(this.idPrefix+this.topId, this.idPrefix+this.topId);
	} else {
		var m = this._getMenuNodes(this.idPrefix + this.topId);
		for (var q=0; q<m.length; q++) {
			if (this.itemPull[m[q]]["type"] == "item") this._renderToplevelItem(m[q], null);
			if (this.itemPull[m[q]]["type"] == "separator") this._renderSeparator(m[q], null);
		}
	}
};

// add top menu item, complex define that submenues are in presence
dhtmlXMenuObject.prototype._renderToplevelItem = function(id, pos) {
	var that = this;
	var m = document.createElement("DIV");
	m.id = id;
	// custom css
	if (this.itemPull[id]["state"] == "enabled" && this.itemPull[id]["cssNormal"] != null) {
		m.className = this.itemPull[id]["cssNormal"];
	} else {
		m.className = "dhtmlxMenu_"+this.conf.skin+"_TopLevel_Item_"+(this.itemPull[id]["state"]=="enabled"?"Normal":"Disabled");
	}
	
	// text
	if (this.itemPull[id]["title"] != "") {
		var t1 = document.createElement("DIV");
		t1.className = "top_level_text";
		t1.innerHTML = this.itemPull[id]["title"];
		m.appendChild(t1);
	}
	// tooltip
	if (this.itemPull[id]["tip"].length > 0) m.title = this.itemPull[id]["tip"];
	//
	// image in top level
	if ((this.itemPull[id]["imgen"]!="")||(this.itemPull[id]["imgdis"]!="")) {
		var imgTop=this.itemPull[id][(this.itemPull[id]["state"]=="enabled")?"imgen":"imgdis"];
		if (imgTop) {
			var img = document.createElement("IMG");
			img.border = "0";
			img.id = "image_"+id;
			img.src= this.conf.icons_path+imgTop;
			img.className = "dhtmlxMenu_TopLevel_Item_Icon";
			if (m.childNodes.length > 0 && !this.conf.rtl) m.insertBefore(img, m.childNodes[0]); else m.appendChild(img);
		}
	}
	m.onselectstart = function(e) { e = e || event; if (e.preventDefault) e.preventDefault(); else e.returnValue = false; return false; }
	m.oncontextmenu = function(e) { e = e || event; if (e.preventDefault) e.preventDefault(); else e.returnValue = false; return false; }
	// add container for top-level items if not exists yet
	if (!this.cont) {
		this.cont = document.createElement("DIV");
		this.cont.dir = "ltr";
		this.cont.className = (this.conf.align=="right"?"align_right":"align_left");
		this.base.appendChild(this.cont);
	}
	// insert
	
	if (pos != null) { pos++; if (pos < 0) pos = 0; if (pos > this.cont.childNodes.length - 1) pos = null; }
	if (pos != null) this.cont.insertBefore(m, this.cont.childNodes[pos]); else this.cont.appendChild(m);
	
	this.idPull[m.id] = m;
	// create submenues
	if (this.itemPull[id]["complex"] && (!this.conf.dload)) this._addSubMenuPolygon(this.itemPull[id]["id"], this.itemPull[id]["id"]);
	// events
	m.onmouseover = function() {
		if (that.conf.mode == "web") { window.clearTimeout(that.conf.tm_handler); }
		// kick polygons and decelect before selected menues
		var i = that._getSubItemToDeselectByPolygon("parent");
		that._removeSubItemFromSelected(-1, -1);
		for (var q=0; q<i.length; q++) {
			if (i[q] != this.id) { that._hidePolygon(i[q]); }
			if ((that.idPull[i[q]] != null) && (i[q] != this.id)) {
				// custom css
				if (that.itemPull[i[q]]["cssNormal"] != null) {
					that.idPull[i[q]].className = that.itemPull[i[q]]["cssNormal"];
				} else {
					if (that.idPull[i[q]].className == "sub_item_selected") that.idPull[i[q]].className = "sub_item";
					that.idPull[i[q]].className = that.idPull[i[q]].className.replace(/Selected/g, "Normal");
				}
			}
		}
		// check if enabled
		if (that.itemPull[this.id]["state"] == "enabled") {
			this.className = "dhtmlxMenu_"+that.conf.skin+"_TopLevel_Item_Selected";
			//
			that._addSubItemToSelected(this.id, "parent");
			that.conf.selected = (that.conf.mode=="win"?(that.conf.selected!=-1?this.id:that.conf.selected):this.id);
			if (that.conf.dload) {
				if (that.itemPull[this.id].loaded == "no") {
					this._dynLoadTM = new Date().getTime();
					that.itemPull[this.id].loaded = "get";
					var xmlParentId = this.id.replace(that.idPrefix,"");
					that._dhxdataload.onBeforeXLS = function() {
						var p = {params:{}};
						p.params[this.conf.dload_pid] = xmlParentId;
						for (var a in this.conf.dload_params) p.params[a] = this.conf.dload_params[a];
						return p;
					};
					that.loadStruct(that.conf.dload_url);
				}
				if (that.conf.top_mode && that.conf.mode == "web" && !that.conf.context) {
					this._mouseOver = true;
				}
			}
			if ((!that.conf.dload) || (that.conf.dload && (!that.itemPull[this.id]["loaded"] || that.itemPull[this.id]["loaded"]=="yes"))) {
				if ((that.itemPull[this.id]["complex"]) && (that.conf.selected != -1)) {
					if (that.conf.top_mode && that.conf.mode == "web" && !that.conf.context) {
						this._mouseOver = true;
						var showItemId = this.id;
						this._menuOpenTM = window.setTimeout(function(){that._showPolygon(showItemId, that.conf.dir_toplv);}, that.conf.top_tmtime);
					} else {
						that._showPolygon(this.id, that.conf.dir_toplv);
					}
				}
			}
		}
		that._doOnTouchMenu(this.id.replace(that.idPrefix, ""));
	}
	m.onmouseout = function() {
		if (!((that.itemPull[this.id]["complex"]) && (that.conf.selected != -1)) && (that.itemPull[this.id]["state"]=="enabled")) {
			// custom css
			
			if (that.itemPull[this.id]["cssNormal"] != null) {
				// alert(1)
				m.className = that.itemPull[this.id]["cssNormal"];
			} else {
				// default css
				m.className = "dhtmlxMenu_"+that.conf.skin+"_TopLevel_Item_Normal";
			}
		}
		if (that.conf.mode == "web") {
			window.clearTimeout(that.conf.tm_handler);
			that.conf.tm_handler = window.setTimeout(function(){that._clearAndHide();}, that.conf.tm_sec, "JavaScript");
		}
		if (that.conf.top_mode && that.conf.mode == "web" && !that.conf.context) {
			this._mouseOver = false;
			window.clearTimeout(this._menuOpenTM);
		}
	}
	m.onclick = function(e) {
		if (that.conf.mode == "web") { window.clearTimeout(that.conf.tm_handler); }
		// fix, added in 0.4
		if (that.conf.mode != "web" && that.itemPull[this.id]["state"] == "disabled") { return; }
		//
		e = e || event;
		e.cancelBubble = true;
		if (e.preventDefault) e.preventDefault(); else e.returnValue = false;
		
		if (that.conf.mode == "win") {
			if (that.itemPull[this.id]["complex"]) {
				if (that.conf.selected == this.id) { that.conf.selected = -1; var s = false; } else { that.conf.selected = this.id; var s = true; }
				if (s) { that._showPolygon(this.id, that.conf.dir_toplv); } else { that._hidePolygon(this.id); }
			}
		}
		var tc = (that.itemPull[this.id]["complex"]?"c":"-");
		var td = (that.itemPull[this.id]["state"]!="enabled"?"d":"-");
		var cas = {"ctrl": e.ctrlKey, "alt": e.altKey, "shift": e.shiftKey};
		that._doOnClick(this.id.replace(that.idPrefix, ""), tc+td+"t", cas);
		return false;
	}
	
	if (this.conf.skin == "dhx_terrace") {
		this._improveTerraceSkin();
	}
};

// recursively creates and adds submenu polygon
dhtmlXMenuObject.prototype._addSubMenuPolygon = function(id, parentId) {
	var s = this._renderSublevelPolygon(id, parentId);
	var j = this._getMenuNodes(parentId);
	for (q=0; q<j.length; q++) { if (this.itemPull[j[q]]["type"] == "separator") { this._renderSeparator(j[q], null); } else { this._renderSublevelItem(j[q], null); } }
	if (id == parentId) { var level = "topLevel"; } else { var level = "subLevel"; }
	for (var q=0; q<j.length; q++) { if (this.itemPull[j[q]]["complex"]) { this._addSubMenuPolygon(id, this.itemPull[j[q]]["id"]); } }
};

// inner: add single subpolygon/item/separator
dhtmlXMenuObject.prototype._renderSublevelPolygon = function(id, parentId) {
	var s = document.createElement("DIV");
	s.className = "dhtmlxMenu_"+this.conf.skin+"_SubLevelArea_Polygon "+(this.conf.rtl?"dir_right":"");
	s.dir = "ltr";
	s.oncontextmenu = function(e) { e = e||event; if (e.preventDefault) e.preventDefault(); else e.returnValue = false; e.cancelBubble = true; return false; }
	s.id = "polygon_" + parentId;
	s.onclick = function(e) { e = e || event; e.cancelBubble = true; }
	s.style.display = "none";
	document.body.insertBefore(s, document.body.firstChild);
	//
	
	s.innerHTML = '<div style="position:relative;"></div>'+'<div style="position: relative; overflow:hidden;"></div>'+'<div style="position:relative;"></div>';
	
	var tbl = document.createElement("TABLE");
	tbl.className = "dhtmlxMebu_SubLevelArea_Tbl";
	tbl.cellSpacing = 0;
	tbl.cellPadding = 0;
	tbl.border = 0;
	var tbd = document.createElement("TBODY");
	tbl.appendChild(tbd);
	
	s.childNodes[1].appendChild(tbl);
	
	s.tbl = tbl;
	s.tbd = tbd;
	// polygon
	this.idPull[s.id] = s;
	if (this.sxDacProc != null) {
		this.idPull["sxDac_" + parentId] = new this.sxDacProc(s, s.className);
		if (window.dhx4.isIE) {
			this.idPull["sxDac_" + parentId]._setSpeed(this.dacSpeedIE);
			this.idPull["sxDac_" + parentId]._setCustomCycle(this.dacCyclesIE);
		} else {
			this.idPull["sxDac_" + parentId]._setSpeed(this.dacSpeed);
			this.idPull["sxDac_" + parentId]._setCustomCycle(this.dacCycles);
		}
	}
	return s;
};

dhtmlXMenuObject.prototype._renderSublevelItem = function(id, pos) {
	var that = this;
	
	var tr = document.createElement("TR");
	tr.className = (this.itemPull[id]["state"]=="enabled"?"sub_item":"sub_item_dis");
	
	// icon
	var t1 = document.createElement("TD");
	t1.className = "sub_item_icon";
	var icon = this.itemPull[id][(this.itemPull[id]["state"]=="enabled"?"imgen":"imgdis")];
	if (icon != "") {
		var tp = this.itemPull[id]["type"];
		if (tp=="checkbox"||tp=="radio") {
			var img = document.createElement("DIV");
			img.id = "image_"+this.itemPull[id]["id"];
			img.className = "sub_icon "+icon;
			t1.appendChild(img);
		}
		if (!(tp=="checkbox"||tp=="radio")) {
			var img = document.createElement("IMG");
			img.id = "image_"+this.itemPull[id]["id"];
			img.className = "sub_icon";
			img.src = this.conf.icons_path+icon;
			t1.appendChild(img);
		}
	} else {
		t1.innerHTML = "&nbsp;";
	}
	
	// text
	var t2 = document.createElement("TD");
	t2.className = "sub_item_text";
	if (this.itemPull[id]["title"] != "") {
		var t2t = document.createElement("DIV");
		t2t.className = "sub_item_text";
		t2t.innerHTML = this.itemPull[id]["title"];
		t2.appendChild(t2t);
	} else {
		t2.innerHTML = "&nbsp;";
	}
	
	// hotkey/sublevel arrow
	var t3 = document.createElement("TD");
	t3.className = "sub_item_hk";
	if (this.itemPull[id]["complex"]) {
		
		var arw = document.createElement("DIV");
		arw.className = "complex_arrow";
		arw.id = "arrow_"+this.itemPull[id]["id"];
		t3.appendChild(arw);
		
	} else {
		if (this.itemPull[id]["hotkey"].length > 0 && !this.itemPull[id]["complex"]) {
			var t3t = document.createElement("DIV");
			t3t.className = "sub_item_hk";
			t3t.innerHTML = this.itemPull[id]["hotkey"];
			t3.appendChild(t3t);
		} else {
			t3.innerHTML = "&nbsp;";
		}
	}
	tr.appendChild(this.conf.rtl?t3:t1);
	tr.appendChild(t2);
	tr.appendChild(this.conf.rtl?t1:t3);
	
	
	//
	tr.id = this.itemPull[id]["id"];
	tr.parent = this.itemPull[id]["parent"];
	// tooltip, added in 0.4
	if (this.itemPull[id]["tip"].length > 0) tr.title = this.itemPull[id]["tip"];
	//
	tr.onselectstart = function(e) { e = e || event; if (e.preventDefault) e.preventDefault(); else e.returnValue = false; return false; }
	tr.onmouseover = function(e) {
		if (that.conf.hide_tm[this.id]) window.clearTimeout(that.conf.hide_tm[this.id]);
		if (that.conf.mode == "web") window.clearTimeout(that.conf.tm_handler);
		if (!this._visible) that._redistribSubLevelSelection(this.id, this.parent); // if not visible
		this._visible = true;
	}
	tr.onmouseout = function() {
		if (that.conf.mode == "web") {
			if (that.conf.tm_handler) window.clearTimeout(that.conf.tm_handler);
			that.conf.tm_handler = window.setTimeout(function(){if(that&&that._clearAndHide)that._clearAndHide();}, that.conf.tm_sec, "JavaScript");
		}
		var k = this;
		if (that.conf.hide_tm[this.id]) window.clearTimeout(that.conf.hide_tm[this.id]);
		that.conf.hide_tm[this.id] = window.setTimeout(function(){k._visible=false;}, 50);
	}
	tr.onclick = function(e) {
		// added in 0.4, preven complex closing if user event not defined
		if (!that.checkEvent("onClick") && that.itemPull[this.id]["complex"]) return;
		//
		e = e || event; e.cancelBubble = true;
		if (e.preventDefault) e.preventDefault(); else e.returnValue = false;
		tc = (that.itemPull[this.id]["complex"]?"c":"-");
		td = (that.itemPull[this.id]["state"]=="enabled"?"-":"d");
		var cas = {"ctrl": e.ctrlKey, "alt": e.altKey, "shift": e.shiftKey};
		switch (that.itemPull[this.id]["type"]) {
			case "checkbox":
				that._checkboxOnClickHandler(this.id.replace(that.idPrefix, ""), tc+td+"n", cas);
				break;
			case "radio":
				that._radioOnClickHandler(this.id.replace(that.idPrefix, ""), tc+td+"n", cas);
				break;
			case "item":
				that._doOnClick(this.id.replace(that.idPrefix, ""), tc+td+"n", cas);
				break;
		}
		return false;
	}
	// add
	var polygon = this.idPull["polygon_"+this.itemPull[id]["parent"]];
	if (pos != null) { pos++; if (pos < 0) pos = 0; if (pos > polygon.tbd.childNodes.length - 1) pos = null; }
	if (pos != null && polygon.tbd.childNodes[pos] != null) polygon.tbd.insertBefore(tr, polygon.tbd.childNodes[pos]); else polygon.tbd.appendChild(tr);
	this.idPull[tr.id] = tr;
};

dhtmlXMenuObject.prototype._renderSeparator = function(id, pos) {
	var level = (this.conf.context?"SubLevelArea":(this.itemPull[id]["parent"]==this.idPrefix+this.topId?"TopLevel":"SubLevelArea"));
	if (level == "TopLevel" && this.conf.context) return;
	
	var that = this;
	
	if (level != "TopLevel") {
		var tr = document.createElement("TR");
		tr.className = "sub_sep";
		var td = document.createElement("TD");
		td.colSpan = "3";
		tr.appendChild(td);
	}
	
	var k = document.createElement("DIV");
	k.id = "separator_"+id;
	k.className = (level=="TopLevel"?"top_sep":"sub_sep");
	k.onselectstart = function(e) { e = e || event; if (e.preventDefault) e.preventDefault(); else e.returnValue = false; }
	k.onclick = function(e) {
		e = e || event; e.cancelBubble = true;
		var cas = {"ctrl": e.ctrlKey, "alt": e.altKey, "shift": e.shiftKey};
		that._doOnClick(this.id.replace("separator_" + that.idPrefix, ""), "--s", cas);
	}
	if (level == "TopLevel") {
		if (pos != null) {
			pos++; if (pos < 0) { pos = 0; }
			// if (this.base.childNodes[pos] != null) { this.base.insertBefore(k, this.base.childNodes[pos]); } else { this.base.appendChild(k); }
			if (this.cont.childNodes[pos] != null) { this.cont.insertBefore(k, this.cont.childNodes[pos]); } else { this.cont.appendChild(k); }
		} else {
			// add as a last item
			// var last = this.base.childNodes[this.base.childNodes.length-1];
			var last = this.cont.childNodes[this.cont.childNodes.length-1];
			// if (String(last).search("TopLevel_Text") == -1) { this.base.appendChild(k); } else { this.base.insertBefore(k, last); }
			if (String(last).search("TopLevel_Text") == -1) { this.cont.appendChild(k); } else { this.cont.insertBefore(k, last); }
		}
		this.idPull[k.id] = k;
	} else {
		var polygon = this.idPull["polygon_"+this.itemPull[id]["parent"]];
		if (pos != null) { pos++; if (pos < 0) pos = 0; if (pos > polygon.tbd.childNodes.length - 1) pos = null; }
		if (pos != null && polygon.tbd.childNodes[pos] != null) polygon.tbd.insertBefore(tr, polygon.tbd.childNodes[pos]); else polygon.tbd.appendChild(tr);
		td.appendChild(k);
		this.idPull[k.id] = tr;
	}
};

dhtmlXMenuObject.prototype.addNewSeparator = function(nextToId, itemId) {
	itemId = this.idPrefix+(itemId!=null?itemId:this._genStr(24));
	var parentId = this.idPrefix+this.getParentId(nextToId);
	
	this._addItemIntoGlobalStrorage(itemId, parentId, "", "separator", false, "", "");
	this._renderSeparator(itemId, this.getItemPosition(nextToId));
};


dhtmlXMenuObject.prototype._initObj = function(items, nested, parentId) {
	
	if (!(items instanceof Array)) {
		parentId = items.parentId;
		if (parentId != null && String(parentId).indexOf(this.idPrefix) !== 0) parentId = this.idPrefix+String(parentId);
		items = items.items;
	}
	
	for (var q=0; q<items.length; q++) {
		
		// api-init, items w/o id
		if (typeof(items[q].id) == "undefined" || items[q].id == null) {
			items[q].id = this._genStr(24);
		}
		
		// empty text fix
		if (items[q].text == null) items[q].text = "";
		
		// api-init, add idPrefix
		if (String(items[q].id).indexOf(this.idPrefix) !== 0) {
			items[q].id = this.idPrefix+String(items[q].id);
		}
		
		var k = {type: "item", tip: "", hotkey: "", state: "enabled", imgen: "", imgdis: ""};
		for (var a in k) { if (typeof(items[q][a]) == "undefined") items[q][a] = k[a]; }
		
		//
		if (items[q].imgen == "" && items[q].img != null) items[q].imgen = items[q].img;
		if (items[q].imgdis == "" && items[q].img_disabled != null) items[q].imgdis = items[q].img_disabled;
		if (items[q].title == null && items[q].text != null) items[q].title = items[q].text;
		
		// hrefs
		if (items[q].href != null) {
			if (items[q].href.link != null) items[q].href_link = items[q].href.link;
			if (items[q].href.target != null) items[q].href_target = items[q].href.target;
		}
		
		// userdata
		if (items[q].userdata != null) {
			for (var a in items[q].userdata) this.userData[items[q].id+"_"+a] = items[q].userdata[a];
		}

		
		// en/dis
		if (typeof(items[q].enabled) != "undefined" && window.dhx4.s2b(items[q].enabled) == false) {
			items[q].state = "disabled";
		} else if (typeof(items[q].disabled) != "undefined" && window.dhx4.s2b(items[q].disabled) == true) {
			items[q].state = "disabled";
		}
		
		//
		if (typeof(items[q].parent) == "undefined") {
			items[q].parent = (parentId != null ? parentId : this.idPrefix+this.topId);
		}
		
		
		// checkbox
		if (items[q].type == "checkbox") {
			items[q].checked = window.dhx4.s2b(items[q].checked);
			items[q].imgen = items[q].imgdis = "chbx_"+(items[q].checked?"1":"0"); // set classname
		}
		// radio
		if (items[q].type == "radio") {
			items[q].checked = window.dhx4.s2b(items[q].checked);
			items[q].imgen = items[q].imgdis = "rdbt_"+(items[q].checked?"1":"0");
			// group
			if (typeof(items[q].group) == "undefined" || items[q].group == null) items[q].group = this._genStr(24);
			if (this.radio[items[q].group] == null) this.radio[items[q].group] = [];
			this.radio[items[q].group].push(items[q].id);
		}
		
		//
		this.itemPull[items[q].id] = items[q];
		if (items[q].items != null && items[q].items.length > 0) {
			this.itemPull[items[q].id].complex = true;
			this._initObj(items[q].items, true, items[q].id);
		} else if (this.conf.dload && items[q].complex == true) {
			this.itemPull[items[q].id].loaded = "no";
		}
		this.itemPull[items[q].id].items = null;
		
	}
	
	if (nested !== true) {
		if (this.conf.dload == true) {
			if (parentId == null) {
				this._initTopLevelMenu();
			} else {
				this._addSubMenuPolygon(parentId, parentId);
				if (this.conf.selected == parentId) {
					var isTop = (this.itemPull[parentId].parent == this.idPrefix+this.topId);
					var level = (isTop && !this.conf.context ? this.conf.dir_toplv:this.conf.dir_sublv);
					var isShow = false;
					if (isTop && this.conf.top_mode && this.conf.mode == "web" && !this.conf.context) {
						var item = this.idPull[parentId];
						if (item._mouseOver == true) {
							var delay = this.conf.top_tmtime - (new Date().getTime()-item._dynLoadTM);
							if (delay > 1) {
								var pId = parentId;
								var that = this;
								item._menuOpenTM = window.setTimeout(function(){
									that._showPolygon(pId, level);
									that = pId = null;
								}, delay);
								isShow = true;
							}
						}
					}
					if (!isShow) this._showPolygon(parentId, level);
				}
				
				this.itemPull[parentId].loaded = "yes";
				if (this.conf.dload_icon == true) this._updateLoaderIcon(parentId, false);
			}
		} else {
			this._init();
		}
	}
	
};

dhtmlXMenuObject.prototype._xmlToJson = function(xml, parentId) {
	
	var items = [];
	
	if (parentId == null) {
		var root = xml.getElementsByTagName(this.conf.tags.root);
		if (root == null || (root != null && root.length == 0)) return {items:[]};
		root = root[0];
	} else {
		root = xml;
	}
	
	if (root.getAttribute("parentId") != null) {
		parentId = this.idPrefix+root.getAttribute("parentId");
	}
	
	for (var q=0; q<root.childNodes.length; q++) {
		if (typeof(root.childNodes[q].tagName) != "undefined" && String(root.childNodes[q].tagName).toLowerCase() == this.conf.tags.item) {
			var r = root.childNodes[q];
			var item = {
				// basic
				id: this.idPrefix+(r.getAttribute("id")||this._genStr(24)),
				title: r.getAttribute("text")||"",
				// images
				imgen: r.getAttribute("img")||"",
				imgdis: r.getAttribute("imgdis")||"",
				tip: "",
				hotkey: "",
				//
				type: r.getAttribute("type")||"item"
			};
			// custom css
			if (r.getAttribute("cssNormal") != null) {
				item.cssNormal = r.getAttribute("cssNormal");
			}
			// checkbox
			if (item.type == "checkbox") item.checked = r.getAttribute("checked");
			// radio
			if (item.type == "radio") {
				item.checked = r.getAttribute("checked");
				item.group = r.getAttribute("group");
			}
			// en/dis
			item.state = "enabled";
			if (r.getAttribute("enabled") != null && window.dhx4.s2b(r.getAttribute("enabled")) == false) {
				item.state = "disabled";
			} else if (r.getAttribute("disabled") != null && window.dhx4.s2b(r.getAttribute("disabled")) == true) {
				item.state = "disabled";
			}
			
			item.parent = (parentId != null ? parentId : this.idPrefix+this.topId);
			// is complex item
			if (this.conf.dload) {
				item.complex = (r.getAttribute("complex") != null);
				if (item.complex) item.loaded = "no";
			} else {
				var i = this._xmlToJson(r, item.id);
				item.items = i.items;
				item.complex = (item.items.length > 0);
			}
			
			// misc
			for (var w=0; w<r.childNodes.length; w++) {
				if (typeof(r.childNodes[w].tagName) != "undefined") {
					var t = String(r.childNodes[w].tagName||"").toLowerCase();
					// userdata
					if (t == this.conf.tags.userdata) {
						var d = r.childNodes[w];
						if (d.getAttribute("name") != null) {
							this.userData[item.id+"_"+d.getAttribute("name")] = (d.firstChild != null && d.firstChild.nodeValue != null ? d.firstChild.nodeValue : "");
						}
					}
					// extended text
					if (t == this.conf.tags.text_ext) {
						item.title = r.childNodes[w].firstChild.nodeValue;
					}
					// tooltips
					if (t == this.conf.tags.tooltip) {
						item.tip = r.childNodes[w].firstChild.nodeValue;
					}
					// hotkeys
					if (t == this.conf.tags.hotkey) {
						item.hotkey = r.childNodes[w].firstChild.nodeValue;
					}
					// hrefs
					if (t == this.conf.tags.href && item.type == "item") {
						item.href_link = r.childNodes[w].firstChild.nodeValue;
						if (r.childNodes[w].getAttribute("target") != null) {
							item.href_target = r.childNodes[w].getAttribute("target");
						}
					}
				}
			}
			items.push(item);
		}
	}
	
	var r = {
		parentId: parentId,//(root.getAttribute("parentId")||null),
		items: items
	};
	
	return r;
};

// dynload
dhtmlXMenuObject.prototype.enableDynamicLoading = function(url, icon) {
	this.conf.dload = true;
	this.conf.dload_url = url;
	this.conf.dload_sign = (String(this.conf.dload_url).search(/\?/)==-1?"?":"&");
	this.conf.dload_icon = icon;
	this._init();
};

dhtmlXMenuObject.prototype._updateLoaderIcon = function(id, state) {
	
	if (this.idPull[id] == null) return;
	if (String(this.idPull[id].className).search("TopLevel_Item") >= 0) return;
	// get arrow
	var ind = (this.conf.rtl?0:2);
	if (!this.idPull[id].childNodes[ind]) return;
	if (!this.idPull[id].childNodes[ind].childNodes[0]) return;
	var aNode = this.idPull[id].childNodes[ind].childNodes[0];
	if (String(aNode.className).search("complex_arrow") === 0) aNode.className = "complex_arrow"+(state?"_loading":"");

};



// add/remove
dhtmlXMenuObject.prototype.addNewSibling = function(nextToId, itemId, itemText, disabled, imgEnabled, imgDisabled) {
	var id = this.idPrefix+(itemId!=null?itemId:this._genStr(24));
	var parentId = this.idPrefix+(nextToId!=null?this.getParentId(nextToId):this.topId);
	
	this._addItemIntoGlobalStrorage(id, parentId, itemText, "item", disabled, imgEnabled, imgDisabled);
	if ((parentId == this.idPrefix+this.topId) && (!this.conf.context)) {
		this._renderToplevelItem(id, this.getItemPosition(nextToId));
	} else {
		this._renderSublevelItem(id, this.getItemPosition(nextToId));
	}
};

dhtmlXMenuObject.prototype.addNewChild = function(parentId, pos, itemId, itemText, disabled, imgEnabled, imgDisabled) {
	if (parentId == null) {
		if (this.conf.context) {
			parentId = this.topId;
		} else {
			this.addNewSibling(parentId, itemId, itemText, disabled, imgEnabled, imgDisabled);
			if (pos != null) this.setItemPosition(itemId, pos);
			return;
		}
	}
	itemId = this.idPrefix+(itemId!=null?itemId:this._genStr(24));
	// remove hotkey, added in 0.4
	if (this.setHotKey) this.setHotKey(parentId, "");
	//
	parentId = this.idPrefix+parentId;
	this._addItemIntoGlobalStrorage(itemId, parentId, itemText, "item", disabled, imgEnabled, imgDisabled);
	if (this.idPull["polygon_"+parentId] == null) { this._renderSublevelPolygon(parentId, parentId); }
	this._renderSublevelItem(itemId, pos-1);
	
	this._redefineComplexState(parentId);
};

dhtmlXMenuObject.prototype.removeItem = function(id, _isTId, _recCall) {
	if (!_isTId) id = this.idPrefix + id;
	
	var pId = null;
	
	if (id != this.idPrefix+this.topId) {
		
		if (this.itemPull[id] == null) return;
		
		// effects
		if (this.idPull["polygon_"+id] && this.idPull["polygon_"+id]._tmShow) window.clearTimeout(this.idPull["polygon_"+id]._tmShow);
		
		// separator top
		var t = this.itemPull[id]["type"];
		
		if (t == "separator") {
			var item = this.idPull["separator_"+id];
			if (this.itemPull[id]["parent"] == this.idPrefix+this.topId) {
				item.onclick = null;
				item.onselectstart = null;
				item.id = null;
				item.parentNode.removeChild(item);
			} else {
				item.childNodes[0].childNodes[0].onclick = null;
				item.childNodes[0].childNodes[0].onselectstart = null;
				item.childNodes[0].childNodes[0].id = null;
				item.childNodes[0].removeChild(item.childNodes[0].childNodes[0]);
				item.removeChild(item.childNodes[0]);
				item.parentNode.removeChild(item);
			}
			this.idPull["separator_"+id] = null;
			this.itemPull[id] = null;
			delete this.idPull["separator_"+id];
			delete this.itemPull[id];
			item = null;
		} else {
			// item checkbox radio
			pId = this.itemPull[id]["parent"];
			var item = this.idPull[id];
			item.onclick = null;
			item.oncontextmenu = null;
			item.onmouseover = null;
			item.onmouseout = null;
			item.onselectstart = null;
			item.id = null;
			while (item.childNodes.length > 0) item.removeChild(item.childNodes[0]);
			item.parentNode.removeChild(item);
			this.idPull[id] = null;
			this.itemPull[id] = null;
			delete this.idPull[id];
			delete this.itemPull[id];
			item = null;
			
		}
		t = null;
	}
	
	// clear nested items
	for (var a in this.itemPull) if (this.itemPull[a]["parent"] == id) this.removeItem(a, true, true);
	
	// check if empty polygon left
	var p2 = new Array(id);
	if (pId != null && !_recCall) {
		if (this.idPull["polygon_"+pId] != null) {
			if (this.idPull["polygon_"+pId].tbd.childNodes.length == 0) {
				p2.push(pId);
				this._updateItemComplexState(pId, false, false);
			}
		}
	}
	
	// delete nested polygons and parent's if any
	for (var q=0; q<p2.length; q++) {
		if (this.idPull["polygon_"+p2[q]]) {
			var p = this.idPull["polygon_"+p2[q]];
			p.onclick = null;
			p.oncontextmenu = null;
			p.tbl.removeChild(p.tbd);
			p.tbd = null;
			p.childNodes[1].removeChild(p.tbl);
			p.tbl = null;
			p.id = null;
			p.parentNode.removeChild(p);
			p = null;
			if (window.dhx4.isIE6) {
				var pc = "polygon_"+p2[q]+"_ie6cover";
				if (this.idPull[pc] != null) { document.body.removeChild(this.idPull[pc]); delete this.idPull[pc]; }
			}
			if (this.idPull["arrowup_"+id] != null && this._removeArrow) this._removeArrow("arrowup_"+id);
			if (this.idPull["arrowdown_"+id] != null && this._removeArrow) this._removeArrow("arrowdown_"+id);
			//
			this.idPull["polygon_"+p2[q]] = null;
			delete this.idPull["polygon_"+p2[q]];
		}
	}
	p2 = null;
	
	// update corners
	if (this.conf.skin == "dhx_terrace" && arguments.length == 1) this._improveTerraceSkin();
	
};


// add item to storage
dhtmlXMenuObject.prototype._addItemIntoGlobalStrorage = function(itemId, itemParentId, itemText, itemType, disabled, img, imgDis) {
	var item = {
		id:	itemId,
		title:	itemText,
		imgen:	(img!=null?img:""),
		imgdis:	(imgDis!=null?imgDis:""),
		type:	itemType,
		state:	(disabled==true?"disabled":"enabled"),
		parent:	itemParentId,
		complex:false,
		hotkey:	"",
		tip:	""};
	this.itemPull[item.id] = item;
};

dhtmlXMenuObject.prototype.renderAsContextMenu = function() {
	this.conf.context = true;
	if (this.base._autoSkinUpdate == true) {
		this.base.className = this.base.className.replace("dhtmlxMenu_"+this.conf.skin+"_Middle","");
		this.base._autoSkinUpdate = false;
	}
	if (this.conf.ctx_baseid != null) { this.addContextZone(this.conf.ctx_baseid); }
};

dhtmlXMenuObject.prototype.addContextZone = function(zoneId) {
	if (zoneId == document.body) {
		zoneId = "document.body."+this.idPrefix;
		var zone = document.body;
	} else if (typeof(zoneId) == "string") {
		var zone = document.getElementById(zoneId);
	} else {
		var zone = zoneId;
	}
	var zoneExists = false;
	for (var a in this.conf.ctx_zones) { zoneExists = zoneExists || (a == zoneId) || (this.conf.ctx_zones[a] == zone); }
	if (zoneExists == true) return false;
	this.conf.ctx_zones[zoneId] = zone;
	var that = this;
	if (window.dhx4.isOpera) {
		this.operaContext = function(e){ that._doOnContextMenuOpera(e, that); }
		zone.addEventListener("mouseup", this.operaContext, false);
		//
	} else {
		if (zone.oncontextmenu != null && !zone._oldContextMenuHandler) zone._oldContextMenuHandler = zone.oncontextmenu;
		zone.oncontextmenu = function(e) {
			// autoclose any other opened context menues
			for (var q in dhtmlXMenuObject.prototype.liveInst) {
				if (q != that.conf.live_id) {
					if (dhtmlXMenuObject.prototype.liveInst[q].context) {
						dhtmlXMenuObject.prototype.liveInst[q]._hideContextMenu();
					}
				}
			}
			//
			e = e||event;
			e.cancelBubble = true;
			if (e.preventDefault) e.preventDefault(); else e.returnValue = false;
			that._doOnContextBeforeCall(e, this);
			return false;
		}
	}
};
dhtmlXMenuObject.prototype._doOnContextMenuOpera = function(e, that) {
	// autoclose any other opened context menues
	for (var q in dhtmlXMenuObject.prototype.liveInst) {
		if (q != that.conf.live_id) {
			if (dhtmlXMenuObject.prototype.liveInst[q].context) {
				dhtmlXMenuObject.prototype.liveInst[q]._hideContextMenu();
			}
		}
	}
	//
	e.cancelBubble = true;
	if (e.preventDefault) e.preventDefault(); else e.returnValue = false;
	if (e.button == 0 && e.ctrlKey == true) { that._doOnContextBeforeCall(e, this); }
	return false;
};

dhtmlXMenuObject.prototype.removeContextZone = function(zoneId) {
	if (!this.isContextZone(zoneId)) return false;
	if (zoneId == document.body) zoneId = "document.body."+this.idPrefix;
	var zone = this.conf.ctx_zones[zoneId];
	if (window.dhx4.isOpera) {
		zone.removeEventListener("mouseup", this.operaContext, false);
	} else {
		zone.oncontextmenu = (zone._oldContextMenuHandler!=null?zone._oldContextMenuHandler:null);
		zone._oldContextMenuHandler = null;
	}
	try {
		this.conf.ctx_zones[zoneId] = null;
		delete this.conf.ctx_zones[zoneId];
 	} catch(e){}
	return true;
};

dhtmlXMenuObject.prototype.isContextZone = function(zoneId) {
	if (zoneId == document.body && this.conf.ctx_zones["document.body."+this.idPrefix] != null) return true;
	var isZone = false;
	if (this.conf.ctx_zones[zoneId] != null) { if (this.conf.ctx_zones[zoneId] == document.getElementById(zoneId)) isZone = true; }
	return isZone;
};
dhtmlXMenuObject.prototype._isContextMenuVisible = function() {
	if (this.idPull["polygon_"+this.idPrefix+this.topId] == null) return false;
	return (this.idPull["polygon_"+this.idPrefix+this.topId].style.display == "");
};
dhtmlXMenuObject.prototype._showContextMenu = function(x, y, zoneId) {
	// hide any opened context menu/polygons
	this._clearAndHide();
	// open
	if (this.idPull["polygon_"+this.idPrefix+this.topId] == null) return false;
	window.clearTimeout(this.conf.tm_handler);
	this.idPull[this.idPrefix+this.topId] = new Array(x, y);
	this._showPolygon(this.idPrefix+this.topId, "bottom");
	this.callEvent("onContextMenu", [zoneId]);
};
dhtmlXMenuObject.prototype._hideContextMenu = function() {
	if (this.idPull["polygon_"+this.idPrefix+this.topId] == null) return false;
	this._clearAndHide();
	this._hidePolygon(this.idPrefix+this.topId);
};

dhtmlXMenuObject.prototype._doOnContextBeforeCall = function(e, cZone) {
	this.conf.ctx_zoneid = cZone.id;
	this._clearAndHide();
	this._hideContextMenu();
	
	// scroll settings
	var p = (e.srcElement||e.target);
	var px = (window.dhx4.isIE||window.dhx4.isOpera||window.dhx4.isKHTML?e.offsetX:e.layerX);
	var py = (window.dhx4.isIE||window.dhx4.isOpera||window.dhx4.isKHTML?e.offsetY:e.layerY);
	var mx = window.dhx4.absLeft(p)+px;
	var my = window.dhx4.absTop(p)+py;
	
	if (this.checkEvent("onBeforeContextMenu")) {
		if (this.callEvent("onBeforeContextMenu", [cZone.id,e])) {
			if (this.conf.ctx_autoshow) {
				this._showContextMenu(mx, my, cZone.id);
				this.callEvent("onAfterContextMenu", [cZone.id,e]);
			}
		}
	} else {
		if (this.conf.ctx_autoshow) {
			this._showContextMenu(mx, my, cZone.id);
			this.callEvent("onAfterContextMenu", [cZone.id]);
		}
	}
};

dhtmlXMenuObject.prototype.showContextMenu = function(x, y) {
	this._showContextMenu(x, y, false);
};

dhtmlXMenuObject.prototype.hideContextMenu = function() {
	this._hideContextMenu();
};

dhtmlXMenuObject.prototype.setAutoShowMode = function(mode) {
	this.conf.ctx_autoshow = (mode==true?true:false);
};

dhtmlXMenuObject.prototype.setAutoHideMode = function(mode) {
	this.conf.ctx_autohide = (mode==true?true:false);
};

dhtmlXMenuObject.prototype.setContextMenuHideAllMode = function(mode) {
	this.conf.ctx_hideall = (mode==true?true:false);
};

dhtmlXMenuObject.prototype.getContextMenuHideAllMode = function() {
	return this.conf.ctx_hideall;
};

dhtmlXMenuObject.prototype._improveTerraceSkin = function() {
	
	for (var a in this.itemPull) {
		
		if (this.itemPull[a].parent == this.idPrefix+this.topId && this.idPull[a] != null) { // this.idPull[a] will null for separator
			
			var bl = false;
			var br = false;
			
			// left side, first item, not sep
			if (this.idPull[a].parentNode.firstChild == this.idPull[a]) {
				bl = true;
			}
			
			// right side, last item, not sep
			if (this.idPull[a].parentNode.lastChild == this.idPull[a]) {
				br = true;
			}
			
			// check siblings
			for (var b in this.itemPull) {
				if (this.itemPull[b].type == "separator" && this.itemPull[b].parent == this.idPrefix+this.topId) {
					if (this.idPull[a].nextSibling == this.idPull["separator_"+b]) {
						br = true;
					}
					if (this.idPull[a].previousSibling == this.idPull["separator_"+b]) {
						bl = true;
					}
				}
			}
			
			this.idPull[a].style.borderLeftWidth = (bl?"1px":"0px");
			this.idPull[a].style.borderTopLeftRadius = this.idPull[a].style.borderBottomLeftRadius = (bl?"3px":"0px");
			
			this.idPull[a].style.borderTopRightRadius = this.idPull[a].style.borderBottomRightRadius = (br?"3px":"0px");
			
			this.idPull[a]._bl = bl;
			this.idPull[a]._br = br;
			
		}
	}
	
};

dhtmlXMenuObject.prototype._improveTerraceButton = function(id, state) {
	if (state) {
		this.idPull[id].style.borderBottomLeftRadius = (this.idPull[id]._bl ? "3px" : "0px");
		this.idPull[id].style.borderBottomRightRadius = (this.idPull[id]._br ? "3px" : "0px");
	} else {
		this.idPull[id].style.borderBottomLeftRadius = "0px";
		this.idPull[id].style.borderBottomRightRadius = "0px";
	}
};

if (typeof(window.dhtmlXCellObject) != "undefined") {
	
	dhtmlXCellObject.prototype._createNode_menu = function(obj, type, htmlString, append, node) {
		
		if (typeof(node) != "undefined") {
			obj = node;
		} else {
			obj = document.createElement("DIV");
			obj.className = "dhx_cell_menu_"+(this.conf.borders?"def":"no_borders");
			obj.appendChild(document.createElement("DIV"));
		}
		
		this.cell.insertBefore(obj, this.cell.childNodes[this.conf.idx.toolbar||this.conf.idx.cont]); // before toolbar or before cont, 0=hdr
		
		this.conf.ofs_nodes.t.menu = true;
		this._updateIdx();
		// adjust cont will performed after toolbar init
		
		return obj;
		
	};
	
	dhtmlXCellObject.prototype.attachMenu = function(conf) {
		
		if (this.dataNodes.menu) return; // return this.dataNodes.menu?
		
		if (typeof(conf) == "undefined") conf = {};
		if (typeof(conf.skin) == "undefined") conf.skin = this.conf.skin;
		conf.parent = this._attachObject("menu").firstChild;
		
		this.dataNodes.menu = new dhtmlXMenuObject(conf);
		this._adjustCont(this._idd);
		
		conf.parent = null;
		conf = null;
		
		return this.dataNodes.menu;
		
	};
	
	dhtmlXCellObject.prototype.detachMenu = function() {
		
		if (!this.dataNodes.menu) return;
		this.dataNodes.menu.unload();
		this.dataNodes.menu = null;
		delete this.dataNodes.menu;
		
		this._detachObject("menu");
		
	};
	
	dhtmlXCellObject.prototype.showMenu = function() {
		this._mtbShowHide("menu", "");
	};
	
	dhtmlXCellObject.prototype.hideMenu = function() {
		this._mtbShowHide("menu", "none");
	};
	
	dhtmlXCellObject.prototype.getAttachedMenu = function() {
		return this.dataNodes.menu;
	};
	
}


/*
Product Name: dhtmlxSuite 
Version: 4.1.3 
Edition: Professional 
License: content of this file is covered by DHTMLX Commercial or Enterprise license. Usage without proper license is prohibited. To obtain it contact sales@dhtmlx.com
Copyright UAB Dinamenta http://www.dhtmlx.com
*/

// enable/disable

dhtmlXMenuObject.prototype.setItemEnabled = function(id) {
	this._changeItemState(id, "enabled", this._getItemLevelType(id));
};
dhtmlXMenuObject.prototype.setItemDisabled = function(id) {
	this._changeItemState(id, "disabled", this._getItemLevelType(id));
};
dhtmlXMenuObject.prototype.isItemEnabled = function(id) {
	return (this.itemPull[this.idPrefix+id]!=null?(this.itemPull[this.idPrefix+id]["state"]=="enabled"):false);
};

// enable/disable sublevel item
dhtmlXMenuObject.prototype._changeItemState = function(id, newState, levelType) {
	var t = false;
	var j = this.idPrefix + id;
	if ((this.itemPull[j] != null) && (this.idPull[j] != null)) {
		if (this.itemPull[j]["state"] != newState) {
			this.itemPull[j]["state"] = newState;
			if (this.itemPull[j]["parent"] == this.idPrefix+this.topId && !this.conf.context) {
				this.idPull[j].className = "dhtmlxMenu_"+this.conf.skin+"_TopLevel_Item_"+(this.itemPull[j]["state"]=="enabled"?"Normal":"Disabled");
			} else {
				this.idPull[j].className = "sub_item"+(this.itemPull[j]["state"]=="enabled"?"":"_dis");
			}
			
			this._updateItemComplexState(this.idPrefix+id, this.itemPull[this.idPrefix+id]["complex"], false);
			this._updateItemImage(id, levelType);
			// if changeItemState attached to onClick event and changing applies to selected item all selection should be reparsed
			if ((this.idPrefix + this.conf.last_click == j) && (levelType != "TopLevel")) {
				this._redistribSubLevelSelection(j, this.itemPull[j]["parent"]);
			}
			if (levelType == "TopLevel" && !this.conf.context) { // rebuild style.left and show nested polygons
				// this._redistribTopLevelSelection(id, "parent");
			}
		}
	}
	return t;
};


// set-get text
dhtmlXMenuObject.prototype.getItemText = function(id) {
	return (this.itemPull[this.idPrefix+id]!=null?this.itemPull[this.idPrefix+id]["title"]:"");
};

dhtmlXMenuObject.prototype.setItemText = function(id, text) {
	id = this.idPrefix + id;
	if ((this.itemPull[id] != null) && (this.idPull[id] != null)) {
		this._clearAndHide();
		this.itemPull[id]["title"] = text;
		if (this.itemPull[id]["parent"] == this.idPrefix+this.topId && !this.conf.context) {
			// top level
			var tObj = null;
			for (var q=0; q<this.idPull[id].childNodes.length; q++) {
				try { if (this.idPull[id].childNodes[q].className == "top_level_text") tObj = this.idPull[id].childNodes[q]; } catch(e) {}
			}
			if (String(this.itemPull[id]["title"]).length == "" || this.itemPull[id]["title"] == null) {
				if (tObj != null) tObj.parentNode.removeChild(tObj);
			} else {
				if (!tObj) {
					tObj = document.createElement("DIV");
					tObj.className = "top_level_text";
					if (this.conf.rtl && this.idPull[id].childNodes.length > 0) this.idPull[id].insertBefore(tObj,this.idPull[id].childNodes[0]); else this.idPull[id].appendChild(tObj);
				}
				tObj.innerHTML = this.itemPull[id]["title"];
			}
		} else {
			// sub level
			var tObj = null;
			for (var q=0; q<this.idPull[id].childNodes[1].childNodes.length; q++) {
				if (String(this.idPull[id].childNodes[1].childNodes[q].className||"") == "sub_item_text") tObj = this.idPull[id].childNodes[1].childNodes[q];
			}
			if (String(this.itemPull[id]["title"]).length == "" || this.itemPull[id]["title"] == null) {
				if (tObj) {
					tObj.parentNode.removeChild(tObj);
					tObj = null;
					this.idPull[id].childNodes[1].innerHTML = "&nbsp;";
				}
			} else {
				if (!tObj) {
					tObj = document.createElement("DIV");
					tObj.className = "sub_item_text";
					this.idPull[id].childNodes[1].innerHTML = "";
					this.idPull[id].childNodes[1].appendChild(tObj);
				}
				tObj.innerHTML = this.itemPull[id]["title"];
			}
		}
	}
};

// load from html
dhtmlXMenuObject.prototype.loadFromHTML = function(objId, clearAfterAdd, onLoad) {
	
	var t = this.conf.tags.item;
	this.conf.tags.item = "div";
	
	var node = (typeof(objId)=="string"?document.getElementById(objId):objId);
	var items = this._xmlToJson(node, this.idPrefix+this.topId);
	this._initObj(items);
	
	this.conf.tags.item = t;
	
	if (clearAfterAdd) node.parentNode.removeChild(node);
	node = objOd = null;
	
	if (onload != null) {
		if (typeof(onLoad) == "function") {
			onLoad();
		} else if (typeof(window[onLoad]) == "function") {
			window[onLoad]();
		}
	}
};

// show/hide items
dhtmlXMenuObject.prototype.hideItem = function(id) {
	this._changeItemVisible(id, false);
};

dhtmlXMenuObject.prototype.showItem = function(id) {
	this._changeItemVisible(id, true);
};

dhtmlXMenuObject.prototype.isItemHidden = function(id) {
	var isHidden = null;
	if (this.idPull[this.idPrefix+id] != null) { isHidden = (this.idPull[this.idPrefix+id].style.display == "none"); }
	return isHidden;
};

dhtmlXMenuObject.prototype._changeItemVisible = function(id, visible) {
	var itemId = this.idPrefix+id;
	if (this.itemPull[itemId] == null) return;
	if (this.itemPull[itemId]["type"] == "separator") { itemId = "separator_"+itemId; }
	if (this.idPull[itemId] == null) return;
	this.idPull[itemId].style.display = (visible?"":"none");
	this._redefineComplexState(this.itemPull[this.idPrefix+id]["parent"]);
};

// userdata
dhtmlXMenuObject.prototype.setUserData = function(id, name, value) {
	this.userData[this.idPrefix+id+"_"+name] = value;
};

dhtmlXMenuObject.prototype.getUserData = function(id, name) {
	return (this.userData[this.idPrefix+id+"_"+name]!=null?this.userData[this.idPrefix+id+"_"+name]:null);
};

// open-mode (win/web)
dhtmlXMenuObject.prototype.setOpenMode = function(mode) {
	this.conf.mode = (mode=="win"?"win":"web");
};

// web-mode timeout
dhtmlXMenuObject.prototype.setWebModeTimeout = function(tm) {
	this.conf.tm_sec = (!isNaN(tm)?tm:400);
};

// icons
dhtmlXMenuObject.prototype.getItemImage = function(id) {
	var imgs = new Array(null, null);
	id = this.idPrefix+id;
	if (this.itemPull[id]["type"] == "item") {
		imgs[0] = this.itemPull[id]["imgen"];
		imgs[1] = this.itemPull[id]["imgdis"];
	}
	return imgs;
};

dhtmlXMenuObject.prototype.setItemImage = function(id, img, imgDis) {
	if (this.itemPull[this.idPrefix+id]["type"] != "item") return;
	this.itemPull[this.idPrefix+id]["imgen"] = img;
	this.itemPull[this.idPrefix+id]["imgdis"] = imgDis;
	this._updateItemImage(id, this._getItemLevelType(id));
};

dhtmlXMenuObject.prototype.clearItemImage = function(id) {
	this.setItemImage(id, "", "");
};

// visible area
dhtmlXMenuObject.prototype.setVisibleArea = function(x1, x2, y1, y2) {
	this.conf.v_enabled = true;
	this.conf.v.x1 = x1;
	this.conf.v.x2 = x2;
	this.conf.v.y1 = y1;
	this.conf.v.y2 = y2;
};

// tooltips
dhtmlXMenuObject.prototype.setTooltip = function(id, tip) {
	id = this.idPrefix+id;
	if (!(this.itemPull[id] != null && this.idPull[id] != null)) return;
	this.idPull[id].title = (tip.length > 0 ? tip : null);
	this.itemPull[id]["tip"] = tip;
};

dhtmlXMenuObject.prototype.getTooltip = function(id) {
	if (this.itemPull[this.idPrefix+id] == null) return null;
	return this.itemPull[this.idPrefix+id]["tip"];
};



dhtmlXMenuObject.prototype.setTopText = function(text) {
	if (this.conf.context) return;
	if (this._topText == null) {
		this._topText = document.createElement("DIV");
		this._topText.className = "dhtmlxMenu_TopLevel_Text_"+(this.conf.rtl?"left":(this.conf.align=="left"?"right":"left"));
		this.base.appendChild(this._topText);
	}
	this._topText.innerHTML = text;
};

dhtmlXMenuObject.prototype.setAlign = function(align) {
	if (this.conf.align == align) return;
	if (align == "left" || align == "right") {
		// if (this.setRTL) this.setRTL(false);
		this.conf.align = align;
		if (this.cont) this.cont.className = (this.conf.align=="right"?"align_right":"align_left");
		if (this._topText != null) this._topText.className = "dhtmlxMenu_TopLevel_Text_"+(this.conf.align=="left"?"right":"left");
	}
};

dhtmlXMenuObject.prototype.setHref = function(itemId, href, target) {
	if (this.itemPull[this.idPrefix+itemId] == null) return;
	this.itemPull[this.idPrefix+itemId]["href_link"] = href;
	if (target != null) this.itemPull[this.idPrefix+itemId]["href_target"] = target;
};

dhtmlXMenuObject.prototype.clearHref = function(itemId) {
	if (this.itemPull[this.idPrefix+itemId] == null) return;
	delete this.itemPull[this.idPrefix+itemId]["href_link"];
	delete this.itemPull[this.idPrefix+itemId]["href_target"];
};
/*
File [id="file"] -> Open [id="open"] -> Last Save [id="lastsave"]
getCircuit("lastsave") will return Array("file", "open", "lastsave");
*/

dhtmlXMenuObject.prototype.getCircuit = function(id) {
	var parents = new Array(id);
	while (this.getParentId(id) != this.topId) {
		id = this.getParentId(id);
		parents[parents.length] = id;
	}
	return parents.reverse();
};

// checkboxes
dhtmlXMenuObject.prototype._getCheckboxState = function(id) {
	if (this.itemPull[this.idPrefix+id] == null) return null;
	return this.itemPull[this.idPrefix+id]["checked"];
};

dhtmlXMenuObject.prototype._setCheckboxState = function(id, state) {
	if (this.itemPull[this.idPrefix+id] == null) return;
	this.itemPull[this.idPrefix+id]["checked"] = state;
};

dhtmlXMenuObject.prototype._updateCheckboxImage = function(id) {
	if (this.idPull[this.idPrefix+id] == null) return;
	this.itemPull[this.idPrefix+id]["imgen"] = "chbx_"+(this._getCheckboxState(id)?"1":"0");
	this.itemPull[this.idPrefix+id]["imgdis"] = this.itemPull[this.idPrefix+id]["imgen"];
	try { this.idPull[this.idPrefix+id].childNodes[(this.conf.rtl?2:0)].childNodes[0].className = "sub_icon "+this.itemPull[this.idPrefix+id]["imgen"]; } catch(e){}
};

dhtmlXMenuObject.prototype._checkboxOnClickHandler = function(id, type, casState) {
	if (type.charAt(1)=="d") return;
	if (this.itemPull[this.idPrefix+id] == null) return;
	var state = this._getCheckboxState(id);
	if (this.checkEvent("onCheckboxClick")) {
		if (this.callEvent("onCheckboxClick", [id, state, this.conf.ctx_zoneid, casState])) {
			this.setCheckboxState(id, !state);
		}
	} else {
		this.setCheckboxState(id, !state);
	}
	// call onClick if exists
	if (this.checkEvent("onClick")) this.callEvent("onClick", [id]);
};

dhtmlXMenuObject.prototype.setCheckboxState = function(id, state) {
	this._setCheckboxState(id, state);
	this._updateCheckboxImage(id);
};

dhtmlXMenuObject.prototype.getCheckboxState = function(id) {
	return this._getCheckboxState(id);
};

dhtmlXMenuObject.prototype.addCheckbox = function(mode, nextToId, pos, itemId, itemText, state, disabled) {
	// checks
	if (this.conf.context && nextToId == this.topId) {
		// adding checkbox as first element to context menu
		// do nothing
	} else {
		if (this.itemPull[this.idPrefix+nextToId] == null) return;
		if (mode == "child" && this.itemPull[this.idPrefix+nextToId]["type"] != "item") return;
	}
	//
	var img = "chbx_"+(state?"1":"0");
	var imgDis = img;
	//
	
	if (mode == "sibling") {
		
		var id = this.idPrefix+(itemId!=null?itemId:this._genStr(24));
		var parentId = this.idPrefix+this.getParentId(nextToId);
		this._addItemIntoGlobalStrorage(id, parentId, itemText, "checkbox", disabled, img, imgDis);
		this.itemPull[id]["checked"] = state;
		this._renderSublevelItem(id, this.getItemPosition(nextToId));
	} else {
		
		var id = this.idPrefix+(itemId!=null?itemId:this._genStr(24));
		var parentId = this.idPrefix+nextToId;
		this._addItemIntoGlobalStrorage(id, parentId, itemText, "checkbox", disabled, img, imgDis);
		this.itemPull[id]["checked"] = state;
		if (this.idPull["polygon_"+parentId] == null) { this._renderSublevelPolygon(parentId, parentId); }
		this._renderSublevelItem(id, pos-1);
		this._redefineComplexState(parentId);
	}
};


// hot-keys
dhtmlXMenuObject.prototype.setHotKey = function(id, hkey) {
	
	id = this.idPrefix+id;
	
	if (!(this.itemPull[id] != null && this.idPull[id] != null)) return;
	if (this.itemPull[id]["parent"] == this.idPrefix+this.topId && !this.conf.context) return;
	if (this.itemPull[id]["complex"]) return;
	var t = this.itemPull[id]["type"];
	if (!(t == "item" || t == "checkbox" || t == "radio")) return;
	
	// retrieve obj
	var hkObj = null;
	try { if (this.idPull[id].childNodes[this.conf.rtl?0:2].childNodes[0].className == "sub_item_hk") hkObj = this.idPull[id].childNodes[this.conf.rtl?0:2].childNodes[0]; } catch(e){}
	
	if (hkey.length == 0) {
		// remove if exists
		this.itemPull[id]["hotkey_backup"] = this.itemPull[id]["hotkey"];
		this.itemPull[id]["hotkey"] = "";
		if (hkObj != null) hkObj.parentNode.removeChild(hkObj);
		
	} else {
		
		// add if needed or change
		this.itemPull[id]["hotkey"] = hkey;
		this.itemPull[id]["hotkey_backup"] = null;
		//
		if (hkObj == null) {
			hkObj = document.createElement("DIV");
			hkObj.className = "sub_item_hk";
			var item = this.idPull[id].childNodes[this.conf.rtl?0:2];
			while (item.childNodes.length > 0) item.removeChild(item.childNodes[0]);
			item.appendChild(hkObj);
		}
		hkObj.innerHTML = hkey;

	}
};

dhtmlXMenuObject.prototype.getHotKey = function(id) {
	if (this.itemPull[this.idPrefix+id] == null) return null;
	return this.itemPull[this.idPrefix+id]["hotkey"];
};


// overflow control
dhtmlXMenuObject.prototype._clearAllSelectedSubItemsInPolygon = function(polygon) {
	var subIds = this._getSubItemToDeselectByPolygon(polygon);
	// hide opened polygons and selected items
	for (var q=0; q<this.conf.opened_poly.length; q++) {
		if (this.conf.opened_poly[q] != polygon) this._hidePolygon(this.conf.opened_poly[q]);
	}
	for (var q=0; q<subIds.length; q++) {
		if (this.idPull[subIds[q]] != null && this.itemPull[subIds[q]]["state"] == "enabled") {
			this.idPull[subIds[q]].className = "dhtmlxMenu_"+this.conf.skin+"_SubLevelArea_Item_Normal";
		}
	}
};

// define normal/disabled arrows in polygon
dhtmlXMenuObject.prototype._checkArrowsState = function(id) {
	var polygon = this.idPull["polygon_"+id].childNodes[1];
	var arrowUp = this.idPull["arrowup_"+id];
	var arrowDown = this.idPull["arrowdown_"+id];
	if (polygon.scrollTop == 0) {
		arrowUp.className = "dhtmlxMenu_"+this.conf.skin+"_SubLevelArea_ArrowUp_Disabled";
	} else {
		arrowUp.className = "dhtmlxMenu_"+this.conf.skin+"_SubLevelArea_ArrowUp" + (arrowUp.over ? "_Over" : "");
	}
	if (polygon.scrollTop + polygon.offsetHeight < polygon.scrollHeight) {
		arrowDown.className = "dhtmlxMenu_"+this.conf.skin+"_SubLevelArea_ArrowDown" + (arrowDown.over ? "_Over" : "");
	} else {
		arrowDown.className = "dhtmlxMenu_"+this.conf.skin+"_SubLevelArea_ArrowDown_Disabled";
	}
	polygon = arrowUp = arrowDown = null;
};

// add up-limit-arrow
dhtmlXMenuObject.prototype._addUpArrow = function(id) {
	var that = this;
	var arrow = document.createElement("DIV");
	arrow.pId = this.idPrefix+id;
	arrow.id = "arrowup_"+this.idPrefix+id;
	arrow.className = "dhtmlxMenu_"+this.conf.skin+"_SubLevelArea_ArrowUp";
	
	arrow.over = false;
	arrow.onselectstart = function(e) { e = e||event; if (e.preventDefault) e.preventDefault(); else e.returnValue = false; return false; }
	arrow.oncontextmenu = function(e) { e = e||event; if (e.preventDefault) e.preventDefault(); else e.returnValue = false; return false; }
	// actions
	arrow.onmouseover = function() {
		if (that.conf.mode == "web") { window.clearTimeout(that.conf.tm_handler); }
		that._clearAllSelectedSubItemsInPolygon(this.pId);
		if (this.className == "dhtmlxMenu_"+that.conf.skin+"_SubLevelArea_ArrowUp_Disabled") return;
		this.className = "dhtmlxMenu_"+that.conf.skin+"_SubLevelArea_ArrowUp_Over";
		this.over = true;
		that._canScrollUp = true;
		that._doScrollUp(this.pId, true);
	}
	arrow.onmouseout = function() {
		if (that.conf.mode == "web") {
			window.clearTimeout(that.conf.tm_handler);
			that.conf.tm_handler = window.setTimeout(function(){that._clearAndHide();}, that.conf.tm_sec, "JavaScript");
		}
		this.over = false;
		that._canScrollUp = false;
		if (this.className == "dhtmlxMenu_"+that.conf.skin+"_SubLevelArea_ArrowUp_Disabled") return;
		this.className = "dhtmlxMenu_"+that.conf.skin+"_SubLevelArea_ArrowUp";
		window.clearTimeout(that.conf.of_utm);
	}
	arrow.onclick = function(e) {
		e = e||event;
		if (e.preventDefault) e.preventDefault(); else e.returnValue = false;
		e.cancelBubble = true;
		return false;
	}
	
	var polygon = this.idPull["polygon_"+this.idPrefix+id];
	polygon.childNodes[0].appendChild(arrow);
	
	this.idPull[arrow.id] = arrow;
	polygon = arrow = null;
};

dhtmlXMenuObject.prototype._addDownArrow = function(id) {
	
	var that = this;
	var arrow = document.createElement("DIV");
	arrow.pId = this.idPrefix+id;
	arrow.id = "arrowdown_"+this.idPrefix+id;
	arrow.className = "dhtmlxMenu_"+this.conf.skin+"_SubLevelArea_ArrowDown";
	
	arrow.over = false;
	arrow.onselectstart = function(e) { e = e||event; if (e.preventDefault) e.preventDefault(); else e.returnValue = false; return false; }
	arrow.oncontextmenu = function(e) { e = e||event; if (e.preventDefault) e.preventDefault(); else e.returnValue = false; return false; }
	
	// actions
	arrow.onmouseover = function() {
		if (that.conf.mode == "web") { window.clearTimeout(that.conf.tm_handler); }
		that._clearAllSelectedSubItemsInPolygon(this.pId);
		if (this.className == "dhtmlxMenu_"+that.conf.skin+"_SubLevelArea_ArrowDown_Disabled") return;
		this.className = "dhtmlxMenu_"+that.conf.skin+"_SubLevelArea_ArrowDown_Over";
		this.over = true;
		that._canScrollDown = true;
		that._doScrollDown(this.pId, true);
	}
	arrow.onmouseout = function() {
		if (that.conf.mode == "web") {
			window.clearTimeout(that.conf.tm_handler);
			that.conf.tm_handler = window.setTimeout(function(){that._clearAndHide();}, that.conf.tm_sec, "JavaScript");
		}
		this.over = false;
		that._canScrollDown = false;
		if (this.className == "dhtmlxMenu_"+that.conf.skin+"_SubLevelArea_ArrowDown_Disabled") return;
		this.className = "dhtmlxMenu_"+that.conf.skin+"_SubLevelArea_ArrowDown";
		window.clearTimeout(that.conf.of_dtm);
	}
	arrow.onclick = function(e) {
		e = e||event;
		if (e.preventDefault) e.preventDefault(); else e.returnValue = false;
		e.cancelBubble = true;
		return false;
	}
	
	var polygon = this.idPull["polygon_"+this.idPrefix+id];
	polygon.childNodes[2].appendChild(arrow);
	
	this.idPull[arrow.id] = arrow;
	polygon = arrow = null;
};

dhtmlXMenuObject.prototype._removeUpArrow = function(id) {
	var fullId = "arrowup_"+this.idPrefix+id;
	this._removeArrow(fullId);
};

dhtmlXMenuObject.prototype._removeDownArrow = function(id) {
	var fullId = "arrowdown_"+this.idPrefix+id;
	this._removeArrow(fullId);
};

dhtmlXMenuObject.prototype._removeArrow = function(fullId) {
	var arrow = this.idPull[fullId];
	arrow.onselectstart = null;
	arrow.oncontextmenu = null;
	arrow.onmouseover = null;
	arrow.onmouseout = null;
	arrow.onclick = null;
	if (arrow.parentNode) arrow.parentNode.removeChild(arrow);
	arrow = null;
	this.idPull[fullId] = null;
	try { delete this.idPull[fullId]; } catch(e) {}
};

dhtmlXMenuObject.prototype._isArrowExists = function(id) {
	if (this.idPull["arrowup_"+id] != null && this.idPull["arrowdown_"+id] != null) return true;
	return false;
};

// scroll down
dhtmlXMenuObject.prototype._doScrollUp = function(id, checkArrows) {
	var polygon = this.idPull["polygon_"+id].childNodes[1];
	if (this._canScrollUp && polygon.scrollTop > 0) {
		var theEnd = false;
		var nextScrollTop = polygon.scrollTop - this.conf.of_ustep;
		if (nextScrollTop < 0) {
			theEnd = true;
			nextScrollTop = 0;
		}
		polygon.scrollTop = nextScrollTop;
		if (!theEnd) {
			var that = this;
			this.conf.of_utm = window.setTimeout(function() {
				that._doScrollUp(id, false);
				that = null;
			}, this.conf.of_utime);
		} else {
			checkArrows = true;
		}
	} else {
		this._canScrollUp = false;
		this._checkArrowsState(id);
	}
	if (checkArrows) {
		this._checkArrowsState(id);
	}
};

dhtmlXMenuObject.prototype._doScrollDown = function(id, checkArrows) {
	var polygon = this.idPull["polygon_"+id].childNodes[1];
	if (this._canScrollDown && polygon.scrollTop + polygon.offsetHeight <= polygon.scrollHeight) {
		var theEnd = false;
		var nextScrollTop = polygon.scrollTop + this.conf.of_dstep;
		if (nextScrollTop + polygon.offsetHeight >= polygon.scrollHeight) {
			theEnd = true;
			nextScrollTop = polygon.scrollHeight - polygon.offsetHeight;
		}
		polygon.scrollTop = nextScrollTop;
		if (!theEnd) {
			var that = this;
			this.conf.of_dtm = window.setTimeout(function() {
				that._doScrollDown(id, false);
				that = null;
			}, this.conf.of_dtime);
		} else {
			checkArrows = true;
		}
	} else {
		this._canScrollDown = false;
		this._checkArrowsState(id);
	}
	if (checkArrows) {
		this._checkArrowsState(id);
	}
};

dhtmlXMenuObject.prototype._countPolygonItems = function(id) {
	var count = 0;
	for (var a in this.itemPull) {
		var par = this.itemPull[a]["parent"];
		var tp = this.itemPull[a]["type"];
		if (par == this.idPrefix+id && (tp == "item" || tp == "radio" || tp == "checkbox")) { count++; }
	}
	return count;
};

dhtmlXMenuObject.prototype.setOverflowHeight = function(itemsNum) {
	
	// set auto overflow mode
	if (itemsNum === "auto") {
		this.conf.overflow_limit = 0;
		this.conf.auto_overflow = true;
		return;
	}
	
	// no existing limitation, now new limitation
	if (this.conf.overflow_limit == 0 && itemsNum <= 0) return;
	
	// hide menu to prevent visible changes
	this._clearAndHide();
	
	// redefine existing limitation, arrows will added automatically with showPlygon
	if (this.conf.overflow_limit >= 0 && itemsNum > 0) {
		this.conf.overflow_limit = itemsNum;
		return;
	}
	
	// remove existing limitation
	if (this.conf.overflow_limit > 0 && itemsNum <= 0) {
		for (var a in this.itemPull) {
			if (this._isArrowExists(a)) {
				var b = String(a).replace(this.idPrefix, "");
				this._removeUpArrow(b);
				this._removeDownArrow(b);
				// remove polygon's height
				this.idPull["polygon_"+a].childNodes[1].style.height = "";
			}
		}
		this.conf.overflow_limit = 0;
		return;
	}
};


// radiobuttons
dhtmlXMenuObject.prototype._getRadioImgObj = function(id) {
	try { var imgObj = this.idPull[this.idPrefix+id].childNodes[(this.conf.rtl?2:0)].childNodes[0] } catch(e) { var imgObj = null; }
	return imgObj;
};

dhtmlXMenuObject.prototype._setRadioState = function(id, state) {
	// if (this.itemPull[this.idPrefix+id]["state"] != "enabled") return;
	var imgObj = this._getRadioImgObj(id);
	if (imgObj != null) {
		// fix, added in 0.4
		var rObj = this.itemPull[this.idPrefix+id];
		rObj["checked"] = state;
		rObj["imgen"] = "rdbt_"+(rObj["checked"]?"1":"0");
		rObj["imgdis"] = rObj["imgen"];
		imgObj.className = "sub_icon "+rObj["imgen"];
	}
};

dhtmlXMenuObject.prototype._radioOnClickHandler = function(id, type, casState) {
	if (type.charAt(1)=="d" || this.itemPull[this.idPrefix+id]["group"]==null) return;
	// deselect all from the same group
	var group = this.itemPull[this.idPrefix+id]["group"];
	if (this.checkEvent("onRadioClick")) {
		if (this.callEvent("onRadioClick", [group, this.getRadioChecked(group), id, this.conf.ctx_zoneid, casState])) {
			this.setRadioChecked(group, id);
		}
	} else {
		this.setRadioChecked(group, id);
	}
	// call onClick if exists
	if (this.checkEvent("onClick")) this.callEvent("onClick", [id]);
};

dhtmlXMenuObject.prototype.getRadioChecked = function(group) {
	var id = null;
	for (var q=0; q<this.radio[group].length; q++) {
		var itemId = this.radio[group][q].replace(this.idPrefix, "");
		var imgObj = this._getRadioImgObj(itemId);
		if (imgObj != null) {
			var checked = (imgObj.className).match(/rdbt_1$/gi);
			if (checked != null) id = itemId;
		}
	}
	return id;
};

dhtmlXMenuObject.prototype.setRadioChecked = function(group, id) {
	if (this.radio[group] == null) return;
	for (var q=0; q<this.radio[group].length; q++) {
		var itemId = this.radio[group][q].replace(this.idPrefix, "");
		this._setRadioState(itemId, (itemId==id));
	}
}

dhtmlXMenuObject.prototype.addRadioButton = function(mode, nextToId, pos, itemId, itemText, group, state, disabled) {
	// radiobutton
	if (this.conf.context && nextToId == this.topId) {
		// adding radiobutton as first element to context menu
		// do nothing
	} else {
		if (this.itemPull[this.idPrefix+nextToId] == null) return;
		if (mode == "child" && this.itemPull[this.idPrefix+nextToId]["type"] != "item") return;
	}
	
	var id = this.idPrefix+(itemId!=null?itemId:this._genStr(24));
	var img = "rdbt_"+(state?"1":"0");
	var imgDis = img;
	//
	if (mode == "sibling") {
		var parentId = this.idPrefix+this.getParentId(nextToId);
		this._addItemIntoGlobalStrorage(id, parentId, itemText, "radio", disabled, img, imgDis);
		this._renderSublevelItem(id, this.getItemPosition(nextToId));
	} else {
		var parentId = this.idPrefix+nextToId;
		this._addItemIntoGlobalStrorage(id, parentId, itemText, "radio", disabled, img, imgDis);
		if (this.idPull["polygon_"+parentId] == null) { this._renderSublevelPolygon(parentId, parentId); }
		this._renderSublevelItem(id, pos-1);
		this._redefineComplexState(parentId);
	}
	//
	var gr = (group!=null?group:this._genStr(24));
	this.itemPull[id]["group"] = gr;
	//
	if (this.radio[gr]==null) { this.radio[gr] = new Array(); }
	this.radio[gr][this.radio[gr].length] = id;
	//
	if (state == true) this.setRadioChecked(gr, String(id).replace(this.idPrefix, ""));
};


// serialize
dhtmlXMenuObject.prototype.serialize = function() {
	var xml = "<menu>"+this._readLevel(this.idPrefix+this.topId)+"</menu>";
	return xml;
};

dhtmlXMenuObject.prototype._readLevel = function(parentId) {
	var xml = "";
	for (var a in this.itemPull) {
		if (this.itemPull[a]["parent"] == parentId) {
			var imgEn = "";
			var imgDis = "";
			var hotKey = "";
			var itemId = String(this.itemPull[a]["id"]).replace(this.idPrefix,"");
			var itemType = "";
			var itemText = (this.itemPull[a]["title"]!=""?' text="'+this.itemPull[a]["title"]+'"':"");
			var itemState = "";
			if (this.itemPull[a]["type"] == "item") {
				if (this.itemPull[a]["imgen"] != "") imgEn = ' img="'+this.itemPull[a]["imgen"]+'"';
				if (this.itemPull[a]["imgdis"] != "") imgDis = ' imgdis="'+this.itemPull[a]["imgdis"]+'"';
				if (this.itemPull[a]["hotkey"] != "") hotKey = '<hotkey>'+this.itemPull[a]["hotkey"]+'</hotkey>';
			}
			if (this.itemPull[a]["type"] == "separator") {
				itemType = ' type="separator"';
			} else {
				if (this.itemPull[a]["state"] == "disabled") itemState = ' enabled="false"';
			}
			if (this.itemPull[a]["type"] == "checkbox") {
				itemType = ' type="checkbox"'+(this.itemPull[a]["checked"]?' checked="true"':"");
			}
			if (this.itemPull[a]["type"] == "radio") {
				itemType = ' type="radio" group="'+this.itemPull[a]["group"]+'" '+(this.itemPull[a]["checked"]?' checked="true"':"");
			}
			xml += "<item id='"+itemId+"'"+itemText+itemType+imgEn+imgDis+itemState+">";
			xml += hotKey;
			if (this.itemPull[a]["complex"]) xml += this._readLevel(a);
			xml += "</item>";
		}
	}
	return xml;
};


/*
Product Name: dhtmlxSuite 
Version: 4.1.3 
Edition: Professional 
License: content of this file is covered by DHTMLX Commercial or Enterprise license. Usage without proper license is prohibited. To obtain it contact sales@dhtmlx.com
Copyright UAB Dinamenta http://www.dhtmlx.com
*/

// effects: opacity, slide
dhtmlXMenuObject.prototype.enableEffect = function(name, maxOpacity, effectSpeed) {
	
	this._menuEffect = (name=="opacity"||name=="slide"||name=="slide+"?name:false);
	
	this._pOpStyleIE = (navigator.userAgent.search(/MSIE\s[678]\.0/gi)>=0); // opacity was added in IE9
	
	for (var a in this.idPull) {
		if (a.search(/polygon/) === 0) {
			this._pOpacityApply(a,(this._pOpStyleIE?100:1));
			this.idPull[a].style.height = "";
		}
		
	}
	
	// opacity max value
	this._pOpMax = (typeof(maxOpacity)=="undefined"?100:maxOpacity)/(this._pOpStyleIE?1:100);
	
	// opacity css styles
	this._pOpStyleName = (this._pOpStyleIE?"filter":"opacity");
	this._pOpStyleValue = (this._pOpStyleIE?"progid:DXImageTransform.Microsoft.Alpha(Opacity=#)":"#");
	
	
	// count of steps to open full polygon
	this._pSlSteps = (this._pOpStyleIE?10:20);
	
	// timeout to open polygon
	this._pSlTMTimeMax = effectSpeed||50;
	
};

// extended show
dhtmlXMenuObject.prototype._showPolygonEffect = function(pId) {
	this._pShowHide(pId, true);
};

// extended hide
dhtmlXMenuObject.prototype._hidePolygonEffect = function(pId) {
	this._pShowHide(pId, false);
};

// apply opacity css
dhtmlXMenuObject.prototype._pOpacityApply = function(pId, val) {
	this.idPull[pId].style[this._pOpStyleName] = String(this._pOpStyleValue).replace("#", val||this.idPull[pId]._op);
};

dhtmlXMenuObject.prototype._pShowHide = function(pId, mode) {
	
	if (!this.idPull) return;
	
	// check if mode in progress
	if (this.idPull[pId]._tmShow != null) {
		if ((this.idPull[pId]._step_h > 0 && mode == true) || (this.idPull[pId]._step_h < 0 && mode == false)) return;
		window.clearTimeout(this.idPull[pId]._tmShow);
		this.idPull[pId]._tmShow = null;
		this.idPull[pId]._max_h = null;
	}
	
	if (mode == false && (this.idPull[pId].style.visibility == "hidden" || this.idPull[pId].style.display == "none")) return;
	
	if (mode == true && this.idPull[pId].style.display == "none") {
		this.idPull[pId].style.visibility = "hidden";
		this.idPull[pId].style.display = "";
	}
	
	// init values or show-hide revert
	if (this.idPull[pId]._max_h == null) {
		
		this.idPull[pId]._max_h = parseInt(this.idPull[pId].offsetHeight);
		this.idPull[pId]._h = (mode==true?0:this.idPull[pId]._max_h);
		this.idPull[pId]._step_h = Math.round(this.idPull[pId]._max_h/this._pSlSteps)*(mode==true?1:-1);
		if (this.idPull[pId]._step_h == 0) return;
		this.idPull[pId]._step_tm = Math.round(this._pSlTMTimeMax/this._pSlSteps);
		
		if (this._menuEffect == "slide+" || this._menuEffect == "opacity") {
			this.idPull[pId].op_tm = this.idPull[pId]._step_tm;
			this.idPull[pId].op_step = (this._pOpMax/this._pSlSteps)*(mode==true?1:-1);
			if (this._pOpStyleIE) this.idPull[pId].op_step = Math.round(this.idPull[pId].op_step);
			this.idPull[pId]._op = (mode==true?0:this._pOpMax);
			this._pOpacityApply(pId);
		} else {
			this.idPull[pId]._op = (this._pOpStyleIE?100:1);
			this._pOpacityApply(pId);
		}
		
		// show first time
		if (this._menuEffect.search(/slide/) === 0) this.idPull[pId].style.height = "0px";
		this.idPull[pId].style.visibility = "visible";
		
	}
	
	// run cycle
	this._pEffectSet(pId, this.idPull[pId]._h+this.idPull[pId]._step_h);
	
};

dhtmlXMenuObject.prototype._pEffectSet = function(pId, t) {
	
	if (!this.idPull) return;
	
	if (this.idPull[pId]._tmShow) window.clearTimeout(this.idPull[pId]._tmShow);
	
	// check and apply next step
	this.idPull[pId]._h = Math.max(0,Math.min(t,this.idPull[pId]._max_h));
	if (this._menuEffect.search(/slide/) === 0) this.idPull[pId].style.height = this.idPull[pId]._h+"px";
	
	t += this.idPull[pId]._step_h;
	
	if (this._menuEffect == "slide+" || this._menuEffect == "opacity") {
		this.idPull[pId]._op = Math.max(0,Math.min(this._pOpMax,this.idPull[pId]._op+this.idPull[pId].op_step));
		this._pOpacityApply(pId);
	}
	
	if ((this.idPull[pId]._step_h > 0 && t <= this.idPull[pId]._max_h) || (this.idPull[pId]._step_h < 0 && t >= 0)) {
		// continue
		var k = this;
		this.idPull[pId]._tmShow = window.setTimeout(function(){k._pEffectSet(pId,t);}, this.idPull[pId]._step_tm);
	} else {
		
		// clear height
		if (this._menuEffect.search(/slide/) === 0) this.idPull[pId].style.height = "";
		
		// hide completed
		if (this.idPull[pId]._step_h < 0) this.idPull[pId].style.visibility = "hidden";
		
		if (this._menuEffect == "slide+" || this._menuEffect == "opacity") {
			this.idPull[pId]._op = (this.idPull[pId]._step_h<0?(this._pOpStyleIE?100:1):this._pOpMax);
			this._pOpacityApply(pId);
		}
		
		// clear values
		this.idPull[pId]._tmShow = null;
		this.idPull[pId]._h = null;
		this.idPull[pId]._max_h = null;
		///this.idPull[pId]._step_h = null;
		this.idPull[pId]._step_tm = null;
	}
	
};



/*
Product Name: dhtmlxSuite 
Version: 4.1.3 
Edition: Professional 
License: content of this file is covered by DHTMLX Commercial or Enterprise license. Usage without proper license is prohibited. To obtain it contact sales@dhtmlx.com
Copyright UAB Dinamenta http://www.dhtmlx.com
*/

function dhtmlXToolbarObject(base, skin) {
	
	var main_self = this;
	
	this.conf = {
		skin: (skin||window.dhx4.skin||(typeof(dhtmlx)!="undefined"?dhtmlx.skin:null)||window.dhx4.skinDetect("dhxtoolbar")||"dhx_skyblue"),
		align: "left",
		align_autostart: "left",
		icons_path: "",
		iconSize: 18,
		sel_ofs_x: 0,
		sel_ofs_y: 0,
		xml_autoload: null,
		items_autoload: null
	}
	
	if (typeof(base) == "object" && base != null && typeof(base.tagName) == "undefined") {
		// object-api init
		if (base.icons_path != null || base.icon_path != null) this.conf.icons_path = (base.icons_path||base.icon_path);
		if (base.icons_size != null) this.conf.icons_size_autoload = base.icons_size;
		if (base.json != null) this.conf.json_autoload = base.json;
		if (base.xml != null) this.conf.xml_autoload = base.xml;
		if (base.onload != null) this.conf.onload_autoload = base.onload;
		if (base.onclick != null || base.onClick != null) this.conf.auto_onclick = (base.onclick|| base.onClick);
		if (base.items != null) this.conf.items_autoload = base.items;
		if (base.skin != null) this.conf.skin = base.skin;
		if (base.align != null) this.conf.align_autostart = base.align;
		base = base.parent;
	}
	
	this.cont = (typeof(base)!="object")?document.getElementById(base):base;
	while (this.cont.childNodes.length > 0) this.cont.removeChild(this.cont.childNodes[0]);
	
	base = null;
	
	this.cont.dir = "ltr";
	
	this.base = document.createElement("DIV");
	this.base.className = "dhxtoolbar_float_left";
	this.cont.appendChild(this.base);
	
	if (window.dhx4.isIPad) {
		this.cont.ontouchstart = function(e){
			e = e||event;
			if((String(e.target.tagName||"").toLowerCase()=="input"))
				return true;
			if (e.preventDefault) e.preventDefault(); else e.returnValue = false;
			e.cancelBubble = true;
			return false;
		}
	}
	
	this.setSkin(this.conf.skin);
	
	this.objPull = {};
	this.anyUsed = "none";
	
	/* random prefix */
	this._genStr = function(w) {
		var s = ""; var z = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";
		for (var q=0; q<w; q++) s += z.charAt(Math.round(Math.random() * (z.length-1)));
		return s;
	}
	this.rootTypes = new Array("button", "buttonSelect", "buttonTwoState", "separator", "label", "slider", "text", "buttonInput");
	this.idPrefix = this._genStr(12);
	//
	
	window.dhx4._enableDataLoading(this, "_initObj", "_xmlToJson", "toolbar", {struct:true});
	window.dhx4._eventable(this);
	//
	// return obj if exists by tagname
	this._getObj = function(obj, tag) {
		var targ = null;
		for (var q=0; q<obj.childNodes.length; q++) {
			if (obj.childNodes[q].tagName != null) {
				if (String(obj.childNodes[q].tagName).toLowerCase() == String(tag).toLowerCase()) targ = obj.childNodes[q];
			}
		}
		return targ;
	}
	// create and return image object
	this._addImgObj = function(obj) {
		var imgObj = document.createElement("IMG");
		if (obj.childNodes.length > 0) obj.insertBefore(imgObj, obj.childNodes[0]); else obj.appendChild(imgObj);
		return imgObj;
	}
	// set/clear item image/imagedis
	this._setItemImage = function(item, url, dis) {
		if (dis == true) item.imgEn = url; else item.imgDis = url;
		if ((!item.state && dis == true) || (item.state && dis == false)) return;
		var imgObj = this._getObj(item.obj, "img");
		if (imgObj == null) imgObj = this._addImgObj(item.obj);
		imgObj.src = this.conf.icons_path+url;
	}
	this._clearItemImage = function(item, dis) {
		if (dis == true) item.imgEn = ""; else item.imgDis = "";
		if ((!item.state && dis == true) || (item.state && dis == false)) return;
		var imgObj = this._getObj(item.obj, "img");
		if (imgObj != null) imgObj.parentNode.removeChild(imgObj);
	}
	// set/get item text
	this._setItemText = function(item, text) {
		var txtObj = this._getObj(item.obj, "div");
		if (text == null || text.length == 0) {
			if (txtObj != null) txtObj.parentNode.removeChild(txtObj);
			return;
		}
		if (txtObj == null) {
			txtObj = document.createElement("DIV");
			txtObj.className = "dhxtoolbar_text";
			item.obj.appendChild(txtObj);
		}
		txtObj.innerHTML = text;
	}
	this._getItemText = function(item) {
		var txtObj = this._getObj(item.obj, "div");
		if (txtObj != null) return txtObj.innerHTML;
		return "";
	}
	
	// enable/disable btn
	this._enableItem = function(item) {
		if (item.state) return;
		item.state = true;
		if (this.objPull[item.id]["type"] == "buttonTwoState" && this.objPull[item.id]["obj"]["pressed"] == true) {
			item.obj.className = "dhx_toolbar_btn dhxtoolbar_btn_pres";
			item.obj.renderAs = "dhx_toolbar_btn dhxtoolbar_btn_over";
		} else {
			item.obj.className = "dhx_toolbar_btn dhxtoolbar_btn_def";
			item.obj.renderAs = item.obj.className;
		}
		if (item.arw) item.arw.className = String(item.obj.className).replace("btn","arw");
		var imgObj = this._getObj(item.obj, "img");
		if (item.imgEn != "") {
			if (imgObj == null) imgObj = this._addImgObj(item.obj);
			imgObj.src = this.conf.icons_path+item.imgEn;
		} else {
			if (imgObj != null) imgObj.parentNode.removeChild(imgObj);
		}
	}
	this._disableItem = function(item) {
		if (!item.state) return;
		item.state = false;
		item.obj.className = "dhx_toolbar_btn dhxtoolbar_btn_"+(this.objPull[item.id]["type"]=="buttonTwoState"&&item.obj.pressed?"pres_":"")+"dis";
		item.obj.renderAs = "dhx_toolbar_btn dhxtoolbar_btn_def";
		if (item.arw) item.arw.className = String(item.obj.className).replace("btn","arw");
		var imgObj = this._getObj(item.obj, "img");
		if (item.imgDis != "") {
			if (imgObj == null) imgObj = this._addImgObj(item.obj);
			imgObj.src = this.conf.icons_path+item.imgDis;
		} else {
			if (imgObj != null) imgObj.parentNode.removeChild(imgObj);
		}
		// if (this.objPull[item.id]["type"] == "buttonTwoState") this.objPull[item.id]["obj"]["pressed"] = false;
		// hide opened polygon if any
		if (item.polygon != null) {
			if (item.polygon.style.display != "none") {
				window.dhx4.zim.clear(item.polygon._idd);
				item.polygon.style.display = "none";
				if (item.polygon._ie6cover) item.polygon._ie6cover.style.display = "none";
				// fix border
				if (this.conf.skin == "dhx_terrace") this._improveTerraceButtonSelect(item.id, true);
			}
		}
		this.anyUsed = "none";
	}
	
	this.clearAll = function() {
		for (var a in this.objPull) this._removeItem(String(a).replace(this.idPrefix,""));
	}
	
	
	//
	this._doOnClick = function(e) {
		if (main_self && main_self.forEachItem) {
			main_self.forEachItem(function(itemId){
				if (main_self.objPull[main_self.idPrefix+itemId]["type"] == "buttonSelect") {
					// hide any opened buttonSelect's polygons, clear selection if any
					var item = main_self.objPull[main_self.idPrefix+itemId];
					if (item.arw._skip === true) {
						item.arw._skip = false;
					} else if (item.polygon.style.display != "none") {
						item.obj.renderAs = "dhx_toolbar_btn dhxtoolbar_btn_def";
						item.obj.className = item.obj.renderAs;
						item.arw.className = String(item.obj.renderAs).replace("btn","arw");
						main_self.anyUsed = "none";
						window.dhx4.zim.clear(item.polygon._idd);
						item.polygon.style.display = "none";
						if (item.polygon._ie6cover) item.polygon._ie6cover.style.display = "none";
						// fix border
						if (main_self.conf.skin == "dhx_terrace") main_self._improveTerraceButtonSelect(item.id, true);
					}
				}
			});
		}
	}
	if (window.dhx4.isIPad) {
		document.addEventListener("touchstart", this._doOnClick, false);
	} else {
		if (typeof(window.addEventListener) != "undefined") {
			window.addEventListener("mousedown", this._doOnClick, false);
		} else {
			document.body.attachEvent("onmousedown", this._doOnClick);
		}
	}
	
	if (this.conf.icons_size_autoload != null) {
		this.setIconSize(this.conf.icons_size_autoload);
		this.conf.icons_size_autoload = null;
	}
	
	if (this.conf.items_autoload != null) {
		this.loadStruct(this.conf.items_autoload, this.conf.onload_autoload);
		this.conf.items_autoload = null;
	} else if (this.conf.json_autoload != null) {
		this.loadStruct(this.conf.json_autoload, this.conf.onload_autoload);
		this.conf.json_autoload = null;
	} else if (this.conf.xml_autoload != null) {
		this.loadStruct(this.conf.xml_autoload, this.conf.onload_autoload);
		this.conf.xml_autoload = null;
	}
	
	if (this.conf.align_autostart != this.conf.align) {
		this.setAlign(this.conf.align_autostart);
		this.conf.align_autostart = null;
	}
	
	if (typeof(this.conf.auto_onclick) == "function") {
		this.attachEvent("onClick", this.conf.auto_onclick);
	} else if (typeof(this.conf.auto_onclick) == "string" && typeof(window[this.conf.auto_onclick]) == "function") {
		this.attachEvent("onClick", window[this.conf.auto_onclick]);
	}
	
	//
	return this;
}
dhtmlXToolbarObject.prototype.addSpacer = function(nextToId) {
	var nti = this.idPrefix+nextToId;
	if (this._spacer != null) {
		// spacer already at specified position
		if (this._spacer.idd == nextToId) return;
		// if current spacer contain nextToId item
		// move all items from first to nextToId to this.base
		if (this._spacer == this.objPull[nti].obj.parentNode) {
			var doMove = true;
			while (doMove) {
				var idd = this._spacer.childNodes[0].idd;
				this.base.appendChild(this._spacer.childNodes[0]);
				if (idd == nextToId || this._spacer.childNodes.length == 0) {
					if (this.objPull[nti].arw != null) this.base.appendChild(this.objPull[nti].arw);
					doMove = false;
				}
			}
			this._spacer.idd = nextToId;
			this._fixSpacer();
			return;
		}
		// if this.base contain nextToId item, move (insertBefore[0])
		if (this.base == this.objPull[nti].obj.parentNode) {
			var doMove = true;
			var chArw = (this.objPull[nti].arw!=null);
			while (doMove) {
				var q = this.base.childNodes.length-1;
				if (chArw == true) if (this.base.childNodes[q] == this.objPull[nti].arw) doMove = false;
				if (this.base.childNodes[q].idd == nextToId) doMove = false;
				if (doMove) { if (this._spacer.childNodes.length > 0) this._spacer.insertBefore(this.base.childNodes[q], this._spacer.childNodes[0]); else this._spacer.appendChild(this.base.childNodes[q]); }
			}
			this._spacer.idd = nextToId;
			this._fixSpacer();
			return;
		}
		
	} else {
		var np = null;
		for (var q=0; q<this.base.childNodes.length; q++) {
			if (this.base.childNodes[q] == this.objPull[this.idPrefix+nextToId].obj) {
				np = q;
				if (this.objPull[this.idPrefix+nextToId].arw != null) np = q+1;
			}
		}
		if (np != null) {
			this._spacer = document.createElement("DIV");
			this._spacer.className = (this.conf.align=="right"?" dhxtoolbar_float_left":" dhxtoolbar_float_right");
			this._spacer.dir = "ltr";
			this._spacer.idd = nextToId;
			while (this.base.childNodes.length > np+1) this._spacer.appendChild(this.base.childNodes[np+1]);
			this.cont.appendChild(this._spacer);
			this._fixSpacer();
		}
	}
	if (this.conf.skin == "dhx_terrace") this._improveTerraceSkin();
}
dhtmlXToolbarObject.prototype.removeSpacer = function() {
	if (!this._spacer) return;
	while (this._spacer.childNodes.length > 0) this.base.appendChild(this._spacer.childNodes[0]);
	this._spacer.parentNode.removeChild(this._spacer);
	this._spacer = null;
	if (this.conf.skin == "dhx_terrace") this._improveTerraceSkin();
}
dhtmlXToolbarObject.prototype._fixSpacer = function() {
	// IE icons mixing fix
	if (typeof(window.addEventListener) == "undefined" && this._spacer != null) {
		this._spacer.style.borderLeft = "1px solid #a4bed4";
		var k = this._spacer;
		window.setTimeout(function(){k.style.borderLeft="0px solid #a4bed4";k=null;},1);
	}
}

dhtmlXToolbarObject.prototype.getType = function(itemId) {
	var parentId = this.getParentId(itemId);
	if (parentId != null) {
		var typeExt = null;
		var itemData = this.objPull[this.idPrefix+parentId]._listOptions[itemId];
		if (itemData != null) if (itemData.sep != null) typeExt = "buttonSelectSeparator"; else typeExt = "buttonSelectButton";
		return typeExt;
	} else {
		if (this.objPull[this.idPrefix+itemId] == null) return null;
		return this.objPull[this.idPrefix+itemId]["type"];
	}
}

dhtmlXToolbarObject.prototype.getTypeExt = function(itemId) {
	var type = this.getType(itemId);
	if (type == "buttonSelectButton" || type == "buttonSelectSeparator") {
		if (type == "buttonSelectButton") type = "button"; else type = "separator";
		return type;
	}
	return null;
}
dhtmlXToolbarObject.prototype.inArray = function(array, value) {
	for (var q=0; q<array.length; q++) { if (array[q]==value) return true; }
	return false;
}
dhtmlXToolbarObject.prototype.getParentId = function(listId) {
	var parentId = null;
	for (var a in this.objPull) if (this.objPull[a]._listOptions) for (var b in this.objPull[a]._listOptions) if (b == listId) parentId = String(a).replace(this.idPrefix,"");
	return parentId;
}
/* adding items */
dhtmlXToolbarObject.prototype._addItem = function(itemData, pos) {
	if (typeof(itemData.text) == "string") {
		itemData.text = window.dhx4.trim(itemData.text);
		if (itemData.text.length == 0) itemData.text = null;
	}
	this._addItemToStorage(itemData, pos);
	if (this.conf.skin == "dhx_terrace") this._improveTerraceSkin();
}

dhtmlXToolbarObject.prototype.addButton = function(id, pos, text, imgEnabled, imgDisabled) {
	this._addItem({id:id, type:"button", text:text, img:imgEnabled, imgdis:imgDisabled}, pos);
}

dhtmlXToolbarObject.prototype.addText = function(id, pos, text) {
	this._addItem({id:id,type:"text",text:text}, pos);
}

dhtmlXToolbarObject.prototype.addButtonSelect = function(id, pos, text, opts, imgEnabled, imgDisabled, renderSelect, openAll, maxOpen, mode) { 
	var options = [];
	for (var q=0; q<opts.length; q++) {
		var u = {};
		if (opts[q] instanceof Array) {
			u.id = opts[q][0];
			u.type = (opts[q][1]=="obj"?"button":"separator");
			u.text = (opts[q][2]||null);
			u.img = (opts[q][3]||null);
		} else if (opts[q] instanceof Object && opts[q] != null && typeof(opts[q].id) != "undefined" && typeof(opts[q].type) != "undefined") {
			u.id = opts[q].id;
			u.type = (opts[q].type=="obj"?"button":"separator");
			u.text = opts[q].text;
			u.img = opts[q].img;
		}
		options.push(u);
	}
	this._addItem({id:id, type:"buttonSelect", text:text, img:imgEnabled, imgdis:imgDisabled, renderSelect:renderSelect, openAll:openAll, options:options, maxOpen:maxOpen, mode:mode}, pos);
}

dhtmlXToolbarObject.prototype.addButtonTwoState = function(id, pos, text, imgEnabled, imgDisabled) {
	this._addItem({id:id, type:"buttonTwoState", img:imgEnabled, imgdis:imgDisabled, text:text}, pos);
}

dhtmlXToolbarObject.prototype.addSeparator = function(id, pos) {
	this._addItem({id:id,type:"separator"}, pos);
}

dhtmlXToolbarObject.prototype.addSlider = function(id, pos, len, valueMin, valueMax, valueNow, textMin, textMax, tip) {
	this._addItem({id:id, type:"slider", length:len, valueMin:valueMin, valueMax:valueMax, valueNow:valueNow, textMin:textMin, textMax:textMax, toolTip:tip}, pos);
}

dhtmlXToolbarObject.prototype.addInput = function(id, pos, value, width) {
	this._addItem({id:id,type:"buttonInput",value:value,width:width}, pos);
}

dhtmlXToolbarObject.prototype.forEachItem = function(handler) {
	for (var a in this.objPull) {
		if (this.inArray(this.rootTypes, this.objPull[a]["type"])) {
			handler(this.objPull[a]["id"].replace(this.idPrefix,""));
		}
	}
};
(function(){
	var list="isVisible,enableItem,disableItem,isEnabled,setItemText,getItemText,setItemToolTip,getItemToolTip,getInput,setItemImage,setItemImageDis,clearItemImage,clearItemImageDis,setItemState,getItemState,setItemToolTipTemplate,getItemToolTipTemplate,setValue,getValue,setMinValue,getMinValue,setMaxValue,getMaxValue,setWidth,getWidth,setMaxOpen".split(",")
	var ret=[false,"","",false,"","","","","","","","","",false,"","","",null,"",[null,null],"",[null,null],"",null]
	var functor=function(name,res){
		return function(itemId,a,b){
			itemId = this.idPrefix+itemId;
			if (this.objPull[itemId][name] != null) return this.objPull[itemId][name].call(this.objPull[itemId],a,b); else return res;
		};
	}
	for (var i=0; i<list.length; i++){
		var name=list[i];
		var res=ret[i];
		dhtmlXToolbarObject.prototype[name] = functor(name,res);
	}
})();

dhtmlXToolbarObject.prototype.showItem = function(itemId) {
	itemId = this.idPrefix+itemId;
	if (this.objPull[itemId] != null && this.objPull[itemId].showItem != null) {
		this.objPull[itemId].showItem();
		if (this.conf.skin == "dhx_terrace") this._improveTerraceSkin();
	}
}

dhtmlXToolbarObject.prototype.hideItem = function(itemId) {
	itemId = this.idPrefix+itemId;
	if (this.objPull[itemId] != null && this.objPull[itemId].hideItem != null) {
		this.objPull[itemId].hideItem();
		if (this.conf.skin == "dhx_terrace") this._improveTerraceSkin();
	}
}
dhtmlXToolbarObject.prototype.getPosition = function(itemId) {
	return this._getPosition(itemId);
}
dhtmlXToolbarObject.prototype._getPosition = function(id, getRealPosition) {
	
	if (this.objPull[this.idPrefix+id] == null) return null;
	
	var pos = null;
	var w = 0;
	for (var q=0; q<this.base.childNodes.length; q++) {
		if (this.base.childNodes[q].idd != null) {
			if (this.base.childNodes[q].idd == id) pos = w;
			w++;
		}
	}
	if (!pos && this._spacer != null) {
		for (var q=0; q<this._spacer.childNodes.length; q++) {
			if (this._spacer.childNodes[q].idd != null) {
				if (this._spacer.childNodes[q].idd == id) pos = w;
				w++;
			}
		}
	}
	return pos;
}

dhtmlXToolbarObject.prototype.setPosition = function(itemId, pos) {
	this._setPosition(itemId, pos);
}

dhtmlXToolbarObject.prototype._setPosition = function(id, pos) {
	
	if (this.objPull[this.idPrefix+id] == null) return;
	
	if (isNaN(pos)) pos = this.base.childNodes.length;
	if (pos < 0) pos = 0;
	
	var spacerId = null;
	if (this._spacer) {
		spacerId = this._spacer.idd;
		this.removeSpacer();
	}
	
	var item = this.objPull[this.idPrefix+id];
	this.base.removeChild(item.obj);
	if (item.arw) this.base.removeChild(item.arw);
	
	var newPos = this._getIdByPosition(pos, true);
	
	if (newPos[0] == null) {
		this.base.appendChild(item.obj);
		if (item.arw) this.base.appendChild(item.arw);
	} else {
		this.base.insertBefore(item.obj, this.base.childNodes[newPos[1]]);
		if (item.arw) this.base.insertBefore(item.arw, this.base.childNodes[newPos[1]+1]);
	}
	if (spacerId != null) this.addSpacer(spacerId);
	
}
dhtmlXToolbarObject.prototype._getIdByPosition = function(pos, retRealPos) {
	
	var id = null;
	var w = 0;
	var realPos = 0;
	for (var q=0; q<this.base.childNodes.length; q++) {
		if (this.base.childNodes[q]["idd"] != null && id == null) {
			if ((w++) == pos) id = this.base.childNodes[q]["idd"];
		}
		if (id == null) realPos++;
	}
	realPos = (id==null?null:realPos);
	return (retRealPos==true?new Array(id, realPos):id);
}

dhtmlXToolbarObject.prototype.removeItem = function(itemId) {
	this._removeItem(itemId);
	if (this.conf.skin == "dhx_terrace") this._improveTerraceSkin();
};

dhtmlXToolbarObject.prototype._removeItem = function(itemId) {
	
	var t = this.getType(itemId);
	
	itemId = this.idPrefix+itemId;
	var p = this.objPull[itemId];
	
	
	if (t == "button") {
		
		p.obj._doOnMouseOver = null;
		p.obj._doOnMouseOut = null;
		p.obj._doOnMouseUp = null;
		p.obj._doOnMouseUpOnceAnywhere = null;
		
		p.obj.onclick = null;
		p.obj.onmouseover = null;
		p.obj.onmouseout = null;
		p.obj.onmouseup = null;
		p.obj.onmousedown = null;
		p.obj.onselectstart = null;
		
		p.obj.renderAs = null;
		p.obj.idd = null;
		p.obj.parentNode.removeChild(p.obj);
		p.obj = null;

		p.id = null;
		p.state = null;
		p.img = null;
		p.imgEn = null;
		p.imgDis = null;
		p.type = null;
		
		p.enableItem = null;
		p.disableItem = null;
		p.isEnabled = null;
		p.showItem = null;
		p.hideItem = null;
		p.isVisible = null;
		p.setItemText = null;
		p.getItemText = null;
		p.setItemImage = null;
		p.clearItemImage = null;
		p.setItemImageDis = null;
		p.clearItemImageDis = null;
		p.setItemToolTip = null;
		p.getItemToolTip = null;
		
	}
	
	if (t == "buttonTwoState") {
		
		p.obj._doOnMouseOver = null;
		p.obj._doOnMouseOut = null;
		
		p.obj.onmouseover = null;
		p.obj.onmouseout = null;
		p.obj.onmousedown = null;
		p.obj.onselectstart = null;
		
		p.obj.renderAs = null;
		p.obj.idd = null;
		p.obj.parentNode.removeChild(p.obj);
		p.obj = null;
		
		p.id = null;
		p.state = null;
		p.img = null;
		p.imgEn = null;
		p.imgDis = null;
		p.type = null;
		
		p.enableItem = null;
		p.disableItem = null;
		p.isEnabled = null;
		p.showItem = null;
		p.hideItem = null;
		p.isVisible = null;
		p.setItemText = null;
		p.getItemText = null;
		p.setItemImage = null;
		p.clearItemImage = null;
		p.setItemImageDis = null;
		p.clearItemImageDis = null;
		p.setItemToolTip = null;
		p.getItemToolTip = null;
		p.setItemState = null;
		p.getItemState = null;
		
	}
	
	if (t == "buttonSelect") {
		
		for (var a in p._listOptions) this.removeListOption(itemId, a);
		p._listOptions = null;
		
		if (p.polygon._ie6cover) {
			document.body.removeChild(p.polygon._ie6cover);
			p.polygon._ie6cover = null;
		}
		
		p.p_tbl.removeChild(p.p_tbody);
		p.polygon.removeChild(p.p_tbl);
		p.polygon.onselectstart = null;
		document.body.removeChild(p.polygon);
		
		p.p_tbody = null;
		p.p_tbl = null;
		p.polygon = null;
		
		p.obj.onclick = null;
		p.obj.onmouseover = null;
		p.obj.onmouseout = null;
		p.obj.onmouseup = null;
		p.obj.onmousedown = null;
		p.obj.onselectstart = null;
		p.obj.idd = null;
		p.obj.iddPrefix = null;
		p.obj.parentNode.removeChild(p.obj);
		p.obj = null;
		
		p.arw.onclick = null;
		p.arw.onmouseover = null;
		p.arw.onmouseout = null;
		p.arw.onmouseup = null;
		p.arw.onmousedown = null;
		p.arw.onselectstart = null;
		p.arw.parentNode.removeChild(p.arw);
		p.arw = null;
		
		p.renderSelect = null;
		p.state = null;
		p.type = null;
		p.id = null;
		p.img = null;
		p.imgEn = null;
		p.imgDis = null;
		p.openAll = null;
		
		p._isListButton = null;
		p._separatorButtonSelectObject = null;
		p._buttonButtonSelectObject = null;
		p.setWidth = null;
		p.enableItem = null;
		p.disableItem = null;
		p.isEnabled = null;
		p.showItem = null;
		p.hideItem = null;
		p.isVisible = null;
		p.setItemText = null;
		p.getItemText = null;
		p.setItemImage = null;
		p.clearItemImage = null;
		p.setItemImageDis = null;
		p.clearItemImageDis = null;
		p.setItemToolTip = null;
		p.getItemToolTip = null;
		p.addListOption = null;
		p.removeListOption = null;
		p.showListOption = null;
		p.hideListOption = null;
		p.isListOptionVisible = null;
		p.enableListOption = null;
		p.disableListOption = null;
		p.isListOptionEnabled = null;
		p.setListOptionPosition = null;
		p.getListOptionPosition = null;
		p.setListOptionImage = null;
		p.getListOptionImage = null;
		p.clearListOptionImage = null;
		p.setListOptionText = null;
		p.getListOptionText = null;
		p.setListOptionToolTip = null;
		p.getListOptionToolTip = null;
		p.forEachListOption = null;
		p.getAllListOptions = null;
		p.setListOptionSelected = null;
		p.getListOptionSelected = null;
		
	}
	
	if (t == "buttonInput") {
		
		p.obj.childNodes[0].onkeydown = null;
		p.obj.removeChild(p.obj.childNodes[0]);
		
		p.obj.w = null;
		p.obj.idd = null;
		p.obj.parentNode.removeChild(p.obj);
		p.obj = null;
		
		p.id = null;
		p.type = null;
		
		p.enableItem = null;
		p.disableItem = null;
		p.isEnabled = null;
		p.showItem = null;
		p.hideItem = null;
		p.isVisible = null;
		p.setItemToolTip = null;
		p.getItemToolTip = null;
		p.setWidth = null;
		p.getWidth = null;
		p.setValue = null;
		p.getValue = null;
		p.setItemText = null;
		p.getItemText = null;
		
	}
	
	if (t == "slider") {
		
		if (window.dhx4.isIPad) {
			document.removeEventListener("touchmove", pen._doOnMouseMoveStart, false);
			document.removeEventListener("touchend", pen._doOnMouseMoveEnd, false);
		} else {
			if (typeof(window.addEventListener) == "function") {
				window.removeEventListener("mousemove", p.pen._doOnMouseMoveStart, false);
				window.removeEventListener("mouseup", p.pen._doOnMouseMoveEnd, false);
			} else {
				document.body.detachEvent("onmousemove", p.pen._doOnMouseMoveStart);
				document.body.detachEvent("onmouseup", p.pen._doOnMouseMoveEnd);
			}
		}
		
		p.pen.allowMove = null;
		p.pen.initXY = null;
		p.pen.maxX = null;
		p.pen.minX = null;
		p.pen.nowX = null;
		p.pen.newNowX = null;
		p.pen.valueMax = null;
		p.pen.valueMin = null;
		p.pen.valueNow = null;
		
		p.pen._definePos = null;
		p.pen._detectLimits = null;
		p.pen._doOnMouseMoveStart = null;
		p.pen._doOnMouseMoveEnd = null;
		p.pen.onmousedown = null;
		
		p.obj.removeChild(p.pen);
		p.pen = null;
		
		p.label.tip = null;
		document.body.removeChild(p.label);
		p.label = null;
		
		p.obj.onselectstart = null;
		p.obj.idd = null;
		while (p.obj.childNodes.length > 0) p.obj.removeChild(p.obj.childNodes[0]);
		p.obj.parentNode.removeChild(p.obj);
		p.obj = null;
		
		p.id = null;
		p.type = null;
		p.state = null;
		
		p.enableItem = null;
		p.disableItem = null;
		p.isEnabled = null;
		p.setItemToolTipTemplate = null;
		p.getItemToolTipTemplate = null;
		p.setMaxValue = null;
		p.setMinValue = null;
		p.getMaxValue = null;
		p.getMinValue = null;
		p.setValue = null;
		p.getValue = null;
		p.showItem = null;
		p.hideItem = null;
		p.isVisible = null;
		
	}
	
	if (t == "separator") {
		
		p.obj.onselectstart = null;
		p.obj.idd = null;
		p.obj.parentNode.removeChild(p.obj);
		p.obj = null;
		
		p.id = null;
		p.type = null;
		
		p.showItem = null;
		p.hideItem = null;
		p.isVisible = null;
		
	}
	
	if (t == "text") {
		
		p.obj.onselectstart = null;
		p.obj.idd = null;
		p.obj.parentNode.removeChild(p.obj);
		p.obj = null;
		
		p.id = null;
		p.type = null;
		
		p.showItem = null;
		p.hideItem = null;
		p.isVisible = null;
		p.setWidth = null;
		p.setItemText = null;
		p.getItemText = null;
		
	}
	
	t = null;
	p = null;
	this.objPull[this.idPrefix+itemId] = null;
	delete this.objPull[this.idPrefix+itemId];
	
	
};
//#tool_list:06062008{
(function(){
	var list="addListOption,removeListOption,showListOption,hideListOption,isListOptionVisible,enableListOption,disableListOption,isListOptionEnabled,setListOptionPosition,getListOptionPosition,setListOptionText,getListOptionText,setListOptionToolTip,getListOptionToolTip,setListOptionImage,getListOptionImage,clearListOptionImage,forEachListOption,getAllListOptions,setListOptionSelected,getListOptionSelected".split(",")
	var functor = function(name){
				return function(parentId,a,b,c,d,e){
				parentId = this.idPrefix+parentId;
				if (this.objPull[parentId] == null) return;
				if (this.objPull[parentId]["type"] != "buttonSelect") return;
				return this.objPull[parentId][name].call(this.objPull[parentId],a,b,c,d,e);
			}
		}
	for (var i=0; i<list.length; i++){
		var name=list[i];
		dhtmlXToolbarObject.prototype[name]=functor(name)
	}
})();

dhtmlXToolbarObject.prototype._rtlParseBtn = function(t1, t2) {
	return t1+t2;
}
/*****************************************************************************************************************************************************************
	object: separator
*****************************************************************************************************************************************************************/
dhtmlXToolbarObject.prototype._separatorObject = function(that, id, data) {
	//
	this.id = that.idPrefix+id;
	this.obj = document.createElement("DIV");
	this.obj.className = "dhx_toolbar_sep";
	this.obj.style.display = (data.hidden!=null?"none":"");
	this.obj.idd = String(id);
	this.obj.title = (data.title||"");
	this.obj.onselectstart = function(e) { e = e||event; if (e.preventDefault) e.preventDefault(); else e.returnValue = false; }
	if (window.dhx4.isIPad) {
		this.obj.ontouchstart = function(e){
			e = e||event;
			if (e.preventDefault) e.preventDefault(); else e.returnValue = false;
			e.cancelBubble = true;
			return false;
		}
	}
	//
	// add object
	that.base.appendChild(this.obj);
	
	// functions
	this.showItem = function() {
		this.obj.style.display = "";
	}
	this.hideItem = function() {
		this.obj.style.display = "none";
	}
	this.isVisible = function() {
		return (this.obj.style.display == "");
	}
	//
	return this;
}
/*****************************************************************************************************************************************************************
	object: text
*****************************************************************************************************************************************************************/
dhtmlXToolbarObject.prototype._textObject = function(that, id, data) {
	this.id = that.idPrefix+id;
	this.obj = document.createElement("DIV");
	this.obj.className = "dhx_toolbar_text";
	this.obj.style.display = (data.hidden!=null?"none":"");
	this.obj.idd = String(id);
	this.obj.title = (data.title||"");
	this.obj.onselectstart = function(e) { e = e||event; if (e.preventDefault) e.preventDefault(); else e.returnValue = false; }
	if (window.dhx4.isIPad) {
		this.obj.ontouchstart = function(e){
			e = e||event;
			if (e.preventDefault) e.preventDefault(); else e.returnValue = false;
			e.cancelBubble = true;
			return false;
		}
	}
	//
	this.obj.innerHTML = (data.text||"");
	//
	that.base.appendChild(this.obj);
	//
	this.showItem = function() {
		this.obj.style.display = "";
	}
	this.hideItem = function() {
		this.obj.style.display = "none";
	}
	this.isVisible = function() {
		return (this.obj.style.display == "");
	}
	this.setItemText = function(text) {
		this.obj.innerHTML = text;
	}
	this.getItemText = function() {
		return this.obj.innerHTML;
	}
	this.setWidth = function(width) {
		this.obj.style.width = width+"px";
	}
	this.setItemToolTip = function(t) {
		this.obj.title = t;
	}
	this.getItemToolTip = function() {
		return this.obj.title;
	}
	//
	return this;
}
/*****************************************************************************************************************************************************************
	object: button
******************************************************************************************************************************************************************/
dhtmlXToolbarObject.prototype._buttonObject = function(that, id, data) {
	
	this.id = that.idPrefix+id;
	this.state = (data.enabled!=null?false:true);
	this.imgEn = (data.img||"");
	this.imgDis = (data.imgdis||"");
	this.img = (this.state?(this.imgEn!=""?this.imgEn:""):(this.imgDis!=""?this.imgDis:""));
	
	//
	this.obj = document.createElement("DIV");
	this.obj.className = "dhx_toolbar_btn dhxtoolbar_btn_"+(this.state?"def":"dis");
	this.obj.style.display = (data.hidden!=null?"none":"");
	this.obj.allowClick = false;
	this.obj.extAction = (data.action||null);
	this.obj.renderAs = this.obj.className;
	this.obj.idd = String(id);
	this.obj.title = (data.title||"");
	this.obj.pressed = false;
	//
	this.obj.innerHTML = that._rtlParseBtn((this.img!=""?"<img src='"+that.conf.icons_path+this.img+"'>":""), (data.text!=null?"<div class='dhxtoolbar_text'>"+data.text+"</div>":""));
	
	var obj = this;
	
	this.obj.onselectstart = function(e) { e = e||event; if (e.preventDefault) e.preventDefault(); else e.returnValue = false; }
	this.obj.onmouseover = function() { this._doOnMouseOver(); }
	this.obj.onmouseout = function() { this._doOnMouseOut(); }
	this.obj._doOnMouseOver = function() {
		this.allowClick = true;
		if (obj.state == false) return;
		if (that.anyUsed != "none") return;
		this.className = "dhx_toolbar_btn dhxtoolbar_btn_over";
		this.renderAs = this.className;
	}
	this.obj._doOnMouseOut = function() {
		this.allowClick = false;
		if (obj.state == false) return;
		if (that.anyUsed != "none") return;
		this.className = "dhx_toolbar_btn dhxtoolbar_btn_def";
		this.renderAs = this.renderAs;
	}
	
	this.obj.onclick = function(e) {
		if (obj.state == false) return;
		if (this.allowClick == false) return;
		e = e||event;
		// event
		var id = this.idd.replace(that.idPrefix,"");
		if (this.extAction) try {window[this.extAction](id);} catch(e){};
		if(that&&that.callEvent) that.callEvent("onClick", [id]);
	}
	
	this.obj[window.dhx4.isIPad?"ontouchstart":"onmousedown"] = function(e) {
		if (obj.state == false) { e = e||event; if (e.preventDefault) e.preventDefault(); else e.returnValue = false; e.cancelBubble = true; return false; }
		if (that.anyUsed != "none") return;
		that.anyUsed = this.idd;
		this.className = "dhx_toolbar_btn dhxtoolbar_btn_pres";
		this.pressed = true;
		this.onmouseover = function() { this._doOnMouseOver(); }
		this.onmouseout = function() { that.anyUsed = "none"; this._doOnMouseOut(); }
		return false;
	}
	this.obj[window.dhx4.isIPad?"ontouchend":"onmouseup"] = function(e) {
		if (obj.state == false) return;
		if (that.anyUsed != "none") { if (that.anyUsed != this.idd) return; }
		var t = that.anyUsed;
		this._doOnMouseUp();
		if (window.dhx4.isIPad && t != "none") that.callEvent("onClick", [this.idd.replace(that.idPrefix,"")]);
	}
	if (window.dhx4.isIPad) {
		this.obj.ontouchmove = function(e) {
			this._doOnMouseUp();
		}
	}
	this.obj._doOnMouseUp = function() {
		that.anyUsed = "none";
		this.className = this.renderAs;
		this.pressed = false;
	}
	this.obj._doOnMouseUpOnceAnywhere = function() {
		this._doOnMouseUp();
		this.onmouseover = function() { this._doOnMouseOver(); }
		this.onmouseout = function() { this._doOnMouseOut(); }
	}
	
	// add object
	that.base.appendChild(this.obj);
	//
	// functions
	this.enableItem = function() {
		that._enableItem(this);
	}
	this.disableItem = function() {
		that._disableItem(this);
	}
	this.isEnabled = function() {
		return this.state;
	}
	this.showItem = function() {
		this.obj.style.display = "";
	}
	this.hideItem = function() {
		this.obj.style.display = "none";
	}
	this.isVisible = function() {
		return (this.obj.style.display == "");
	}
	this.setItemText = function(text) {
		that._setItemText(this, text);
	}
	this.getItemText = function() {
		return that._getItemText(this);
	}
	this.setItemImage = function(url) {
		that._setItemImage(this, url, true);
	}
	this.clearItemImage = function() {
		that._clearItemImage(this, true);
	}
	this.setItemImageDis = function(url) {
		that._setItemImage(this, url, false);
	}
	this.clearItemImageDis = function() {
		that._clearItemImage(this, false);
	}
	this.setItemToolTip = function(tip) {
		this.obj.title = tip;
	}
	this.getItemToolTip = function() {
		return this.obj.title;
	}
	return this;
}

/******************************************************************************************************************************************************************
	object: buttonSelect
*******************************************************************************************************************************************************************/
dhtmlXToolbarObject.prototype._buttonSelectObject = function(that, id, data) {
	this.id = that.idPrefix+id;
	this.state = (data.enabled!=null?(data.enabled=="true"?true:false):true);
	this.imgEn = (data.img||"");
	this.imgDis = (data.imgdis||"");
	this.img = (this.state?(this.imgEn!=""?this.imgEn:""):(this.imgDis!=""?this.imgDis:""));
	
	this.mode = (data.mode||"button"); // button, select
	if (this.mode == "select") {
		this.openAll = true;
		this.renderSelect = false;
		if (!data.text||data.text.length==0) data.text = "&nbsp;"
	} else {
		this.openAll = (window.dhx4.s2b(data.openAll)==true);
		this.renderSelect = (data.renderSelect == null ? true : window.dhx4.s2b(data.renderSelect));
	}
	this.maxOpen = (!isNaN(data.maxOpen?data.maxOpen:"")?data.maxOpen:null);
	
	this._maxOpenTest = function() {
		if (!isNaN(this.maxOpen)) {
			if (!that._sbw) {
				var t = document.createElement("DIV");
				t.className = "dhxtoolbar_maxopen_test";
				document.body.appendChild(t);
				var k = document.createElement("DIV");
				k.className = "dhxtoolbar_maxopen_test2";
				t.appendChild(k);
				that._sbw = t.offsetWidth-k.offsetWidth;
				t.removeChild(k);
				k = null;
				document.body.removeChild(t);
				t = null;
			}
		}
	}
	this._maxOpenTest();
	
	//
	this.obj = document.createElement("DIV");
	this.obj.allowClick = false;
	this.obj.extAction = (data.action||null);
	this.obj.className = "dhx_toolbar_btn dhxtoolbar_btn_"+(this.state?"def":"dis");
	this.obj.style.display = (data.hidden!=null?"none":"");
	this.obj.renderAs = this.obj.className;
	this.obj.onselectstart = function(e) { e = e||event; if (e.preventDefault) e.preventDefault(); else e.returnValue = false; }
	this.obj.idd = String(id);
	this.obj.title = (data.title||"");
	this.obj.pressed = false;
	
	this.callEvent = false;
	
	
	
	this.obj.innerHTML = that._rtlParseBtn((this.img!=""?"<img src='"+that.conf.icons_path+this.img+"'>":""),(data.text!=null?"<div class='dhxtoolbar_text'>"+data.text+"</div>":""));
	
	// add object
	that.base.appendChild(this.obj);
	
	this.arw = document.createElement("DIV");
	this.arw.className = "dhx_toolbar_arw dhxtoolbar_btn_"+(this.state?"def":"dis");
	this.arw.style.display = this.obj.style.display;
	this.arw.innerHTML = "<div class='arwimg'>&nbsp;</div>";
	
	this.arw.title = this.obj.title;
	this.arw.onselectstart = function(e) { e = e||event; if (e.preventDefault) e.preventDefault(); else e.returnValue = false; }
	that.base.appendChild(this.arw);
	
	var self = this;
	
	this.obj.onmouseover = function(e) {
		e = e||event;
		if (that.anyUsed != "none") return;
		if (!self.state) return;
		self.obj.renderAs = "dhx_toolbar_btn dhxtoolbar_btn_over";
		self.obj.className = self.obj.renderAs;
		self.arw.className = String(self.obj.renderAs).replace("btn","arw");
	}
	this.obj.onmouseout = function() {
		self.obj.allowClick = false;
		if (that.anyUsed != "none") return;
		if (!self.state) return;
		self.obj.renderAs = "dhx_toolbar_btn dhxtoolbar_btn_def";
		self.obj.className = self.obj.renderAs;
		self.arw.className = String(self.obj.renderAs).replace("btn","arw");
		self.callEvent = false;
	}
	this.arw.onmouseover = this.obj.onmouseover;
	this.arw.onmouseout = this.obj.onmouseout;
	
	if (this.openAll == true) {
		
	} else {
	
		this.obj.onclick = function(e) {
			e = e||event;
			if (!self.obj.allowClick) return;
			if (!self.state) return;
			if (that.anyUsed != "none") return;
			// event
			var id = self.obj.idd.replace(that.idPrefix,"");
			if (self.obj.extAction) try {window[self.obj.extAction](id);} catch(e){};
			that.callEvent("onClick", [id]);
		}
		this.obj[window.dhx4.isIPad?"ontouchstart":"onmousedown"] = function(e) {
			e = e||event;
			if (that.anyUsed != "none") return;
			if (!self.state) return;
			self.obj.allowClick = true;
			self.obj.className = "dhx_toolbar_btn dhxtoolbar_btn_pres";
			self.arw.className = "dhx_toolbar_arw dhxtoolbar_btn_pres";
			self.callEvent = true;
		}
		this.obj[window.dhx4.isIPad?"ontouchend":"onmouseup"] = function(e) {
			e = e||event;
			e.cancelBubble = true;
			if (that.anyUsed != "none") return;
			if (!self.state) return;
			self.obj.className = self.obj.renderAs;
			self.arw.className = String(self.obj.renderAs).replace("btn","arw");
			if (window.dhx4.isIPad && self.callEvent) {
				var id = self.obj.idd.replace(that.idPrefix,"");
				that.callEvent("onClick", [id]);
			}
		}
		
	}
	
	if (window.dhx4.isIPad) {
		this.obj.ontouchmove = this.obj.onmouseout;
	}
	
	this.arw[window.dhx4.isIPad?"ontouchstart":"onmousedown"] = function(e) {
		e = e||event;
		
		//clickfix
		var st = (this.className.indexOf("dhx_toolbar_arw") === 0 ? this:this.nextSibling);
		if (st._skip) { e = e||event; e.cancelBubble = true; } else { st._skip = true; }
		st = null;
		
		if (!self.state) return;
		if (that.anyUsed == self.obj.idd) {
			// hide
			self.obj.className = self.obj.renderAs;
			self.arw.className = String(self.obj.renderAs).replace("btn","arw");
			that.anyUsed = "none";
			window.dhx4.zim.clear(self.polygon._idd);
			self.polygon.style.display = "none";
			if (self.polygon._ie6cover) self.polygon._ie6cover.style.display = "none";
			// fix border
			if (that.conf.skin == "dhx_terrace") that._improveTerraceButtonSelect(self.id, true);
		} else { 
			if (that.anyUsed != "none") {
				if (that.objPull[that.idPrefix+that.anyUsed]["type"] == "buttonSelect") {
					var item = that.objPull[that.idPrefix+that.anyUsed];
					if (item.polygon.style.display != "none") {
						item.obj.renderAs = "dhx_toolbar_btn dhxtoolbar_btn_def";
						item.obj.className = item.obj.renderAs;
						item.arw.className = String(self.obj.renderAs).replace("btn","arw");
						window.dhx4.zim.clear(item.polygon._idd);
						item.polygon.style.display = "none";
						if (item.polygon._ie6cover) item.polygon._ie6cover.style.display = "none";
						// fix border
						if (that.conf.skin == "dhx_terrace") that._improveTerraceButtonSelect(item.id, true);
					}
				}
			}
			self.obj.className = "dhx_toolbar_btn dhxtoolbar_btn_over";
			self.arw.className = "dhx_toolbar_arw dhxtoolbar_btn_pres";
			that.anyUsed = self.obj.idd;
			// show
			self.polygon.style.top = "0px";
			self.polygon.style.visibility = "hidden";
			self.polygon.style.zIndex = window.dhx4.zim.reserve(self.polygon._idd);
			self.polygon.style.display = "";
			// fix border
			if (that.conf.skin == "dhx_terrace") that._improveTerraceButtonSelect(self.id, false);
			// check maxOpen
			self._fixMaxOpenHeight(self.maxOpen||null);
			// detect overlay by Y axis
			that._autoDetectVisibleArea();
			// calculate top position
			var newTop = window.dhx4.absTop(self.obj)+self.obj.offsetHeight+that.conf.sel_ofs_y;
			var newH = self.polygon.offsetHeight;
			if (newTop + newH > that.tY2) {
				// if maxOpen mode enabled, check if at bottom at least one item can be shown
				// and show it, if no space - show on top. in maxOpen mode not enabled, show at top
				var k0 = (self.maxOpen!=null?Math.floor((that.tY2-newTop)/22):0); // k0 = count of items that can be visible
				if (k0 >= 1) {
					self._fixMaxOpenHeight(k0);
				} else {
					newTop = window.dhx4.absTop(self.obj)-newH-that.conf.sel_ofs_y;
					if (newTop < 0) newTop = 0;
				}
			}
			self.polygon.style.top = newTop+"px";
			// calculate left position
			if (that.rtl) {
				self.polygon.style.left = window.dhx4.absLeft(self.obj)+self.obj.offsetWidth-self.polygon.offsetWidth+that.conf.sel_ofs_x+"px";
			} else {
				var x1 = document.body.scrollLeft;
				var x2 = x1+(window.innerWidth||document.body.clientWidth);
				var newLeft = window.dhx4.absLeft(self.obj)+that.conf.sel_ofs_x;
				if (newLeft+self.polygon.offsetWidth > x2) newLeft = window.dhx4.absLeft(self.arw)+self.arw.offsetWidth-self.polygon.offsetWidth;
				self.polygon.style.left = Math.max(newLeft,5)+"px";
			}
			self.polygon.style.visibility = "visible";
			// show IE6 cover if needed
			if (self.polygon._ie6cover) {
				self.polygon._ie6cover.style.left = self.polygon.style.left;
				self.polygon._ie6cover.style.top = self.polygon.style.top;
				self.polygon._ie6cover.style.width = self.polygon.offsetWidth+"px";
				self.polygon._ie6cover.style.height = self.polygon.offsetHeight+"px";
				self.polygon._ie6cover.style.display = "";
			}
		}
		return false;
	}
	this.arw.onclick = function(e) {
		e = e||event;
		e.cancelBubble = true;
	}
	this.arw[window.dhx4.isIPad?"ontouchend":"onmouseup"] = function(e) {
		e = e||event;
		e.cancelBubble = true;
	}
	
	
	if (this.openAll === true) {
		this.obj.onclick = this.arw.onclick;
		this.obj.onmousedown = this.arw.onmousedown;
		this.obj.onmouseup = this.arw.onmouseup;
		if (window.dhx4.isIPad) {
			this.obj.ontouchstart = this.arw.ontouchstart;
			this.obj.ontouchend = this.arw.ontouchend;
		}
	}
	
	this.obj.iddPrefix = that.idPrefix;
	this._listOptions = {};
	
	this._fixMaxOpenHeight = function(maxOpen) {
		var h = "auto";
		var h0 = false;
		if (maxOpen !== null) {
			var t = 0;
			for (var a in this._listOptions) t++;
			if (t > maxOpen) {
				this._ph = 22*maxOpen;
				h = this._ph+"px";
			} else {
				h0 = true;
			}
		}
		this.polygon.style.width = "auto";
		this.polygon.style.height = "auto";
		if (!h0 && self.maxOpen != null) {
			this.polygon.style.width = this.p_tbl.offsetWidth+that._sbw+"px";
			this.polygon.style.height = h;
		}
	}
	
	// inner objects: separator
	this._separatorButtonSelectObject = function(id, data, pos) {
		
		this.obj = {};
		this.obj.tr = document.createElement("TR");
		this.obj.tr.className = "tr_sep";
		this.obj.tr.onselectstart = function(e) { e = e||event; if (e.preventDefault) e.preventDefault(); else e.returnValue = false; return false; }
		this.obj.td = document.createElement("TD");
		this.obj.td.colSpan = "2";
		this.obj.td.className = "td_btn_sep";
		this.obj.td.onselectstart = function(e) { e = e||event; if (e.preventDefault) e.preventDefault(); else e.returnValue = false; return false; }
		
		if (isNaN(pos)) pos = self.p_tbody.childNodes.length+1; else if (pos < 1) pos = 1;
		if (pos > self.p_tbody.childNodes.length) self.p_tbody.appendChild(this.obj.tr); else self.p_tbody.insertBefore(this.obj.tr, self.p_tbody.childNodes[pos-1]);
		
		this.obj.tr.appendChild(this.obj.td);
		
		this.obj.sep = document.createElement("DIV");
		this.obj.sep.className = "btn_sep";
		this.obj.sep.onselectstart = function(e) { e = e||event; if (e.preventDefault) e.preventDefault(); else e.returnValue = false; return false; }
		this.obj.td.appendChild(this.obj.sep);
		
		self._listOptions[id] = this.obj;
		return this;
	}
	// inner objects: button
	this._buttonButtonSelectObject = function(id, data, pos) {
		
		var en = true;
		if (typeof(data.enabled) != "undefined") {
			en = window.dhx4.s2b(data.enabled);
		} else if (typeof(data.disabled) != "undefined") {
			en = window.dhx4.s2b(data.disabled);
		}
		
		this.obj = {};
		this.obj.tr = document.createElement("TR");
		this.obj.tr.en = en;
		this.obj.tr.extAction = (data.action||null);
		this.obj.tr._selected = (data.selected!=null);
		this.obj.tr.className = "tr_btn"+(this.obj.tr.en?(this.obj.tr._selected&&self.renderSelect?" tr_btn_selected":""):" tr_btn_disabled");
		this.obj.tr.onselectstart = function(e) { e = e||event; if (e.preventDefault) e.preventDefault(); else e.returnValue = false; return false; }
		this.obj.tr.idd = String(id);
		
		if (isNaN(pos)) pos = self.p_tbody.childNodes.length+1; else if (pos < 1) pos = 1;
		if (pos > self.p_tbody.childNodes.length) self.p_tbody.appendChild(this.obj.tr); else self.p_tbody.insertBefore(this.obj.tr, self.p_tbody.childNodes[pos-1]);
		
		this.obj.td_a = document.createElement("TD");
		this.obj.td_a.className = "td_btn_img";
		this.obj.td_a.onselectstart = function(e) { e = e||event; if (e.preventDefault) e.preventDefault(); else e.returnValue = false; return false; }
		this.obj.td_b = document.createElement("TD");
		this.obj.td_b.className = "td_btn_txt";
		this.obj.td_b.onselectstart = function(e) { e = e||event; if (e.preventDefault) e.preventDefault(); else e.returnValue = false; return false; }
		
		if (that.rtl) {
			this.obj.tr.appendChild(this.obj.td_b);
			this.obj.tr.appendChild(this.obj.td_a);
		} else {
			this.obj.tr.appendChild(this.obj.td_a);
			this.obj.tr.appendChild(this.obj.td_b);
		}
		
		// image
		if (data.img != null) {
			this.obj.td_a.innerHTML = "<img class='btn_sel_img' src='"+that.conf.icons_path+data.img+"' border='0'>";
			this.obj.tr._img = data.img;
		} else {
			this.obj.td_a.innerHTML = "&nbsp;";
		}
		
		// text
		var itemText = (data.text!=null?data.text:(data.itemText||""));
		/*
		if (itemText == null) {
			var itm = data.getElementsByTagName("itemText");
			itemText = (itm[0]!=null?itm[0].firstChild.nodeValue:"");
		}
		*/
		this.obj.td_b.innerHTML = "<div class='btn_sel_text'>"+itemText+"</div>";
		
		this.obj.tr[window.dhx4.isIPad?"ontouchstart":"onmouseover"] = function() {
			if (!this.en || (this._selected && self.renderSelect)) return;
			this.className = "tr_btn tr_btn_over";
		}
		
		this.obj.tr.onmouseout = function() {
			if (!this.en) return;
			if (this._selected && self.renderSelect) {
				if (String(this.className).search("tr_btn_selected") == -1) this.className = "tr_btn tr_btn_selected";
			} else {
				this.className = "tr_btn";
			}
		}
		
		this.obj.tr[window.dhx4.isIPad?"ontouchend":"onclick"] = function(e) {
			
			e = e||event;
			e.cancelBubble = true;
			if (!this.en) return;
			
			self.setListOptionSelected(this.idd.replace(that.idPrefix,""));
			//
			self.obj.renderAs = "dhx_toolbar_btn dhxtoolbar_btn_def";
			self.obj.className = self.obj.renderAs;
			self.arw.className = String(self.obj.renderAs).replace("btn","arw");
			window.dhx4.zim.clear(self.polygon._idd);
			self.polygon.style.display = "none";
			if (self.polygon._ie6cover) self.polygon._ie6cover.style.display = "none";
			// fix border
			if (that.conf.skin == "dhx_terrace") that._improveTerraceButtonSelect(self.id, true);
			that.anyUsed = "none";
			// event
			var id = this.idd.replace(that.idPrefix,"");
			if (this.extAction) try {window[this.extAction](id);} catch(e){};
			that.callEvent("onClick", [id]);
		}		
		self._listOptions[id] = this.obj;
		
		return this;
		
	}
	
	// add polygon
	this.polygon = document.createElement("DIV");
	this.polygon.dir = "ltr";
	this.polygon.style.display = "none";
	this.polygon.className = "dhx_toolbar_poly_"+that.conf.skin+" dhxtoolbar_icons_"+that.conf.iconSize;
	this.polygon.onselectstart = function(e) { e = e||event; if (e.preventDefault) e.preventDefault(); else e.returnValue = false; }
	this.polygon.onmousedown = function(e) { e = e||event; e.cancelBubble = true; }
	this.polygon.style.overflowY = "auto";
	this.polygon._idd = window.dhx4.newId();
	
	if (window.dhx4.isIPad) {
		this.polygon.ontouchstart = function(e){
			e = e||event;
			if (e.preventDefault) e.preventDefault(); else e.returnValue = false;
			e.cancelBubble = true;
			return false;
		}
	}
	
	this.p_tbl = document.createElement("TABLE");
	this.p_tbl.className = "buttons_cont";
	this.p_tbl.cellSpacing = "0";
	this.p_tbl.cellPadding = "0";
	this.p_tbl.border = "0";
	this.polygon.appendChild(this.p_tbl);
	
	this.p_tbody = document.createElement("TBODY");
	this.p_tbl.appendChild(this.p_tbody);
	
	//
	if (data.options != null) {
		for (var q=0; q<data.options.length; q++) {
			var t = "_"+(data.options[q].type||"")+"ButtonSelectObject";
			if (data.options[q].id == null) data.options[q].id = that._genStr(24);
			if (typeof(this[t]) == "function") new this[t](data.options[q].id, data.options[q]);
		}
	}
	
	document.body.appendChild(this.polygon);
	
	// add poly ie6cover
	if (window.dhx4.isIE6) {
		this.polygon._ie6cover = document.createElement("IFRAME");
		this.polygon._ie6cover.frameBorder = 0;
		this.polygon._ie6cover.style.position = "absolute";
		this.polygon._ie6cover.style.border = "none";
		this.polygon._ie6cover.style.backgroundColor = "#000000";
		this.polygon._ie6cover.style.filter = "alpha(opacity=100)";
		this.polygon._ie6cover.style.display = "none";
		this.polygon._ie6cover.setAttribute("src","javascript:false;");
		document.body.appendChild(this.polygon._ie6cover);
	}
	
	// functions
	// new engine
	this.setWidth = function(width) {
		this.obj.style.width = width-this.arw.offsetWidth+"px";
		this.polygon.style.width = this.obj.offsetWidth+this.arw.offsetWidth-2+"px";
		this.p_tbl.style.width = this.polygon.style.width;
	}
	this.enableItem = function() {
		that._enableItem(this);
	}
	this.disableItem = function() {
		that._disableItem(this);
	}
	this.isEnabled = function() {
		return this.state;
	}
	this.showItem = function() {
		this.obj.style.display = "";
		this.arw.style.display = "";
	}
	this.hideItem = function() {
		this.obj.style.display = "none";
		this.arw.style.display = "none";
	}
	this.isVisible = function() {
		return (this.obj.style.display == "");
	}
	this.setItemText = function(text) {
		that._setItemText(this, text);
	}
	this.getItemText = function() {
		return that._getItemText(this);
	}
	this.setItemImage = function(url) {
		that._setItemImage(this, url, true);
	}
	this.clearItemImage = function() {
		that._clearItemImage(this, true);
	}
	this.setItemImageDis = function(url) {
		that._setItemImage(this, url, false);
	}
	this.clearItemImageDis = function() {
		that._clearItemImage(this, false);
	}
	this.setItemToolTip = function(tip) {
		this.obj.title = tip;
		this.arw.title = tip;
	}
	this.getItemToolTip = function() {
		return this.obj.title;
	}
	/* list option functions */
	// new engine
	this.addListOption = function(id, pos, type, text, img) {
		if (!(type == "button" || type == "separator")) return;
		var dataItem = {id:id,type:type,text:text,img:img};
		new this["_"+type+"ButtonSelectObject"](id, dataItem, pos);
	}
	// new engine
	this.removeListOption = function(id) {
		if (!this._isListButton(id, true)) return;
		var item = this._listOptions[id];
		if (item.td_a != null && item.td_b != null) {
			// button
			item.td_a.onselectstart = null;
			item.td_b.onselectstart = null;
			while (item.td_a.childNodes.length > 0) item.td_a.removeChild(item.td_a.childNodes[0]);
			while (item.td_b.childNodes.length > 0) item.td_b.removeChild(item.td_b.childNodes[0]);
			item.tr.onselectstart = null;
			item.tr.onmouseover = null;
			item.tr.onmouseout = null;
			item.tr.onclick = null;
			while (item.tr.childNodes.length > 0) item.tr.removeChild(item.tr.childNodes[0]);
			item.tr.parentNode.removeChild(item.tr);
			item.td_a = null;
			item.td_b = null;
			item.tr = null;
		} else {
			// separator
			item.sep.onselectstart = null;
			item.td.onselectstart = null;
			item.tr.onselectstart = null;
			while (item.td.childNodes.length > 0) item.td.removeChild(item.td.childNodes[0]);
			while (item.tr.childNodes.length > 0) item.tr.removeChild(item.tr.childNodes[0]);
			item.tr.parentNode.removeChild(item.tr);
			item.sep = null;
			item.td = null;
			item.tr = null;
		}
		item = null;
		this._listOptions[id] = null;
		try { delete this._listOptions[id]; } catch(e) {}
	}
	// new engine
	this.showListOption = function(id) {
		if (!this._isListButton(id, true)) return;
		this._listOptions[id].tr.style.display = "";
	}
	// new engine
	this.hideListOption = function(id) {
		if (!this._isListButton(id, true)) return;
		this._listOptions[id].tr.style.display = "none";
	}
	// new engine
	this.isListOptionVisible = function(id) {
		if (!this._isListButton(id, true)) return;
		return (this._listOptions[id].tr.style.display != "none");
	}
	// new engine
	this.enableListOption = function(id) {
		if (!this._isListButton(id)) return;
		this._listOptions[id].tr.en = true;
		this._listOptions[id].tr.className = "tr_btn"+(this._listOptions[id].tr._selected&&that.renderSelect?" tr_btn_selected":"");
	}
	// new engine
	this.disableListOption = function(id) {
		if (!this._isListButton(id)) return;
		this._listOptions[id].tr.en = false;
		this._listOptions[id].tr.className = "tr_btn tr_btn_disabled";
	}
	// new engine
	this.isListOptionEnabled = function(id) {
		if (!this._isListButton(id)) return;
		return this._listOptions[id].tr.en;
	}
	// new engine
	this.setListOptionPosition = function(id, pos) {
		if (!this._listOptions[id] || this.getListOptionPosition(id) == pos || isNaN(pos)) return;
		if (pos < 1) pos = 1;
		var tr = this._listOptions[id].tr;
		this.p_tbody.removeChild(tr);
		if (pos > this.p_tbody.childNodes.length) this.p_tbody.appendChild(tr); else this.p_tbody.insertBefore(tr, this.p_tbody.childNodes[pos-1]);
		tr = null;
	}
	// new engine
	this.getListOptionPosition = function(id) {
		var pos = -1;
		if (!this._listOptions[id]) return pos;
		for (var q=0; q<this.p_tbody.childNodes.length; q++) if (this.p_tbody.childNodes[q] == this._listOptions[id].tr) pos=q+1;
		return pos;
	}
	// new engine
	this.setListOptionImage = function(id, img) {
		if (!this._isListButton(id)) return;
		var td = this._listOptions[id].tr.childNodes[(that.rtl?1:0)];
		if (td.childNodes.length > 0) {
			td.childNodes[0].src = that.conf.icons_path+img;
		} else {
			var imgObj = document.createElement("IMG");
			imgObj.className = "btn_sel_img";
			imgObj.src = that.conf.icons_path+img;
			td.appendChild(imgObj);
		}
		td = null;
	}
	// new engine
	this.getListOptionImage = function(id) {
		if (!this._isListButton(id)) return;
		var td = this._listOptions[id].tr.childNodes[(that.rtl?1:0)];
		var src = null;
		if (td.childNodes.length > 0) src = td.childNodes[0].src;
		td = null;
		return src;
	}
	// new engine
	this.clearListOptionImage = function(id) {
		if (!this._isListButton(id)) return;
		var td = this._listOptions[id].tr.childNodes[(that.rtl?1:0)];
		while (td.childNodes.length > 0) td.removeChild(td.childNodes[0]);
		td.innerHTML = "&nbsp;";
		td = null;
	}
	// new engine
	this.setListOptionText = function(id, text) {
		if (!this._isListButton(id)) return;
		this._listOptions[id].tr.childNodes[(that.rtl?0:1)].childNodes[0].innerHTML = text;
	}
	// new engine
	this.getListOptionText = function(id) {
		if (!this._isListButton(id)) return;
		return this._listOptions[id].tr.childNodes[(that.rtl?0:1)].childNodes[0].innerHTML;
	}
	// new engine
	this.setListOptionToolTip = function(id, tip) {
		if (!this._isListButton(id)) return;
		this._listOptions[id].tr.title = tip;
	}
	// new engine
	this.getListOptionToolTip = function(id) {
		if (!this._isListButton(id)) return;
		return this._listOptions[id].tr.title;
	}
	// works
	this.forEachListOption = function(handler) {
		for (var a in this._listOptions) handler(a);
	}
	// works, return array with ids
	this.getAllListOptions = function() {
		var listData = new Array();
		for (var a in this._listOptions) listData[listData.length] = a;
		return listData;
	}
	// new engine
	this.setListOptionSelected = function(id) {
		for (var a in this._listOptions) {
			var item = this._listOptions[a];
			if (item.td_a != null && item.td_b != null && item.tr.en) {
				if (a == id) {
					item.tr._selected = true;
					item.tr.className = "tr_btn"+(this.renderSelect?" tr_btn_selected":"");
					//
					if (this.mode == "select") {
						if (item.tr._img) this.setItemImage(item.tr._img); else this.clearItemImage();
						this.setItemText(this.getListOptionText(id));
					}
				} else {
					item.tr._selected = false;
					item.tr.className = "tr_btn";
				}
			}
			item = null;
		}
	}
	// new engine
	this.getListOptionSelected = function() {
		var id = null;
		for (var a in this._listOptions) if (this._listOptions[a].tr._selected == true) id = a;
		return id;
	}
	// inner, return tru if list option is button and is exists
	this._isListButton = function(id, allowSeparator) {
		if (this._listOptions[id] == null) return false;
		if (!allowSeparator && this._listOptions[id].tr.className == "tr_sep") return false;
		return true;
	}
	
	this.setMaxOpen = function(r) {
		this._ph = null;
		if (typeof(r) == "number") {
			this.maxOpen = r;
			this._maxOpenTest();
			return;
		}
		this.maxOpen = null;
	}
	
	if (data.width) this.setWidth(data.width);
	
	if (this.mode == "select" && typeof(data.selected) != "undefined") this.setListOptionSelected(data.selected);
	
	//
	return this;
}

/*****************************************************************************************************************************************************************
	object: buttonInput
***************************************************************************************************************************************************************** */
dhtmlXToolbarObject.prototype._buttonInputObject = function(that, id, data) {
	//
	this.id = that.idPrefix+id;
	this.obj = document.createElement("DIV");
	this.obj.className = "dhx_toolbar_btn dhxtoolbar_btn_def";
	this.obj.style.display = (data.hidden!=null?"none":"");
	this.obj.idd = String(id);
	this.obj.w = (data.width!=null?data.width:100);
	this.obj.title = (data.title!=null?data.title:"");
	//
	this.obj.innerHTML = "<input class='dhxtoolbar_input' type='text' style='width:"+this.obj.w+"px;'"+(data.value!=null?" value='"+data.value+"'":"")+">";
	
	var th = that;
	var self = this;
	this.obj.childNodes[0].onkeydown = function(e) {
		e = e||event;
		if (e.keyCode == 13) { th.callEvent("onEnter", [self.obj.idd, this.value]); }
	}
	// add
	that.base.appendChild(this.obj);
	//
	this.enableItem = function() {
		this.obj.childNodes[0].disabled = false;
	}
	this.disableItem = function() {
		this.obj.childNodes[0].disabled = true;
	}
	this.isEnabled = function() {
		return (!this.obj.childNodes[0].disabled);
	}
	this.showItem = function() {
		this.obj.style.display = "";
	}
	this.hideItem = function() {
		this.obj.style.display = "none";
	}
	this.isVisible = function() {
		return (this.obj.style.display != "none");
	}
	this.setValue = function(value) {
		this.obj.childNodes[0].value = value;
	}
	this.getValue = function() {
		return this.obj.childNodes[0].value;
	}
	this.setWidth = function(width) {
		this.obj.w = width;
		this.obj.childNodes[0].style.width = this.obj.w+"px";
	}
	this.getWidth = function() {
		return this.obj.w;
	}
	this.setItemToolTip = function(tip) {
		this.obj.title = tip;
	}
	this.getItemToolTip = function() {
		return this.obj.title;
	}
	this.getInput = function() {
		return this.obj.firstChild;
	}
	
	if (typeof(data.enabled) != "undefined" && window.dhx4.s2b(data.enabled) == false) {
		this.disableItem();
	}
	
	//
	return this;
}

/*****************************************************************************************************************************************************************
	object: buttonTwoState
***************************************************************************************************************************************************************** */
dhtmlXToolbarObject.prototype._buttonTwoStateObject = function(that, id, data) {
	this.id = that.idPrefix+id;
	this.state = (data.enabled!=null?false:true);
	this.imgEn = (data.img!=null?data.img:"");
	this.imgDis = (data.imgdis!=null?data.imgdis:"");
	this.img = (this.state?(this.imgEn!=""?this.imgEn:""):(this.imgDis!=""?this.imgDis:""));
	//
	this.obj = document.createElement("DIV");
	this.obj.pressed = (data.selected!=null);
	this.obj.extAction = (data.action||null);
	this.obj.className = "dhx_toolbar_btn dhxtoolbar_btn_"+(this.obj.pressed?"pres"+(this.state?"":"_dis"):(this.state?"def":"dis"));
	this.obj.style.display = (data.hidden!=null?"none":"");
	this.obj.renderAs = this.obj.className;
	this.obj.idd = String(id);
	this.obj.title = (data.title||"");
	if (this.obj.pressed) { this.obj.renderAs = "dhx_toolbar_btn dhxtoolbar_btn_over"; }
	
	this.obj.innerHTML = that._rtlParseBtn((this.img!=""?"<img src='"+that.conf.icons_path+this.img+"'>":""),(data.text!=null?"<div class='dhxtoolbar_text'>"+data.text+"</div>":""));
	
	// add object
	that.base.appendChild(this.obj);
	
	var obj = this;
	
	this.obj.onselectstart = function(e) { e = e||event; if (e.preventDefault) e.preventDefault(); else e.returnValue = false; }
	this.obj.onmouseover = function() { this._doOnMouseOver(); }
	this.obj.onmouseout = function() { this._doOnMouseOut(); }
	this.obj._doOnMouseOver = function() {
		if (obj.state == false) return;
		if (that.anyUsed != "none") return;
		if (this.pressed) {
			this.renderAs = "dhx_toolbar_btn dhxtoolbar_btn_over";
			return;
		}
		this.className = "dhx_toolbar_btn dhxtoolbar_btn_over";
		this.renderAs = this.className;
	}
	this.obj._doOnMouseOut = function() {
		if (obj.state == false) return;
		if (that.anyUsed != "none") return;
		if (this.pressed) {
			this.renderAs = "dhx_toolbar_btn dhxtoolbar_btn_def";
			return;
		}
		this.className = "dhx_toolbar_btn dhxtoolbar_btn_def";
		this.renderAs = this.className;
	}
	this.obj[window.dhx4.isIPad?"ontouchstart":"onmousedown"] = function(e) {
		
		if (that.checkEvent("onBeforeStateChange")) if (!that.callEvent("onBeforeStateChange", [this.idd.replace(that.idPrefix, ""), this.pressed])) return;
		//
		if (obj.state == false) return;
		if (that.anyUsed != "none") return;
		this.pressed = !this.pressed;
		this.className = (this.pressed?"dhx_toolbar_btn dhxtoolbar_btn_pres":this.renderAs);
		
		// event
		var id = this.idd.replace(that.idPrefix, "");
		if (this.extAction) try {window[this.extAction](id, this.pressed);} catch(e){};
		that.callEvent("onStateChange", [id, this.pressed]);
		//this._doOnMouseOut();
		return false;
	}
	
	// functions
	this.setItemState = function(state, callEvent) {
		if (this.obj.pressed != state) {
			if (state == true) {
				this.obj.pressed = true;
				this.obj.className = "dhx_toolbar_btn dhxtoolbar_btn_pres"+(this.state?"":"_dis");
				this.obj.renderAs = "dhx_toolbar_btn dhxtoolbar_btn_over";
			} else {
				this.obj.pressed = false;
				this.obj.className = "dhx_toolbar_btn dhxtoolbar_btn_"+(this.state?"def":"dis");
				this.obj.renderAs = this.obj.className;
			}
			if (callEvent == true) {
				var id = this.obj.idd.replace(that.idPrefix, "");
				if (this.obj.extAction) try {window[this.obj.extAction](id, this.obj.pressed);} catch(e){};
				that.callEvent("onStateChange", [id, this.obj.pressed]);
			}
		}
	}
	this.getItemState = function() {
		return this.obj.pressed;
	}
	this.enableItem = function() {
		that._enableItem(this);
	}
	this.disableItem = function() {
		that._disableItem(this);
	}
	this.isEnabled = function() {
		return this.state;
	}
	this.showItem = function() {
		this.obj.style.display = "";
	}
	this.hideItem = function() {
		this.obj.style.display = "none";
	}
	this.isVisible = function() {
		return (this.obj.style.display == "");
	}
	this.setItemText = function(text) {
		that._setItemText(this, text);
	}
	this.getItemText = function() {
		return that._getItemText(this);
	}
	this.setItemImage = function(url) {
		that._setItemImage(this, url, true);
	}
	this.clearItemImage = function() {
		that._clearItemImage(this, true);
	}
	this.setItemImageDis = function(url) {
		that._setItemImage(this, url, false);
	}
	this.clearItemImageDis = function() {
		that._clearItemImage(this, false);
	}
	this.setItemToolTip = function(tip) {
		this.obj.title = tip;
	}
	this.getItemToolTip = function() {
		return this.obj.title;
	}
	//
	return this;
}

/*****************************************************************************************************************************************************************
	object: slider
***************************************************************************************************************************************************************** */
dhtmlXToolbarObject.prototype._sliderObject = function(that, id, data) {
	this.id = that.idPrefix+id;
	this.state = (data.enabled!=null?(data.enabled=="true"?true:false):true);
	this.obj = document.createElement("DIV");
	this.obj.className = "dhx_toolbar_btn dhxtoolbar_btn_"+(this.state?"def":"dis");
	this.obj.style.display = (data.hidden!=null?"none":"");
	this.obj.onselectstart = function(e) { e = e||event; if (e.preventDefault) e.preventDefault(); else e.returnValue = false; }
	this.obj.idd = String(id);
	this.obj.len = (data.length!=null?Number(data.length):50);
	//
	this.obj.innerHTML = "<div class='dhxtoolbar_text'>"+(data.textMin||"")+"</div>"+
				"<div class='dhxtoolbar_sl_bg_l'></div>"+
				"<div class='dhxtoolbar_sl_bg_m' style='width:"+this.obj.len+"px;'></div>"+
				"<div class='dhxtoolbar_sl_bg_r'></div>"+
				"<div class='dhxtoolbar_text'>"+(data.textMax||"")+"</div>";
	// add object
	that.base.appendChild(this.obj);
	var self = this;
	
	this.pen = document.createElement("DIV");
	this.pen.className = "dhxtoolbar_sl_pen";
	this.obj.appendChild(this.pen);
	var pen = this.pen;
	
	this.label = document.createElement("DIV");
	this.label.dir = "ltr";
	this.label.className = "dhx_toolbar_slider_label_"+that.conf.skin+(that.rtl?"_rtl":"");
	this.label.style.display = "none";
	this.label.tip = (data.toolTip||"%v");
	this.label._zi = window.dhx4.newId();
	document.body.appendChild(this.label);
	var label = this.label;
	
	// mix-max value
	this.pen.valueMin = (data.valueMin!=null?Number(data.valueMin):0);
	this.pen.valueMax = (data.valueMax!=null?Number(data.valueMax):100);
	if (this.pen.valueMin > this.pen.valueMax) this.pen.valueMin = this.pen.valueMax;
	
	// init value
	this.pen.valueNow = (data.valueNow!=null?Number(data.valueNow):this.pen.valueMax);
	if (this.pen.valueNow > this.pen.valueMax) this.pen.valueNow = this.pen.valueMax;
	if (this.pen.valueNow < this.pen.valueMin) this.pen.valueNow = this.pen.valueMin;
	
	// min/max x coordinate
	this.pen._detectLimits = function() {
		this.minX = self.obj.childNodes[1].offsetLeft+2;
		this.maxX = self.obj.childNodes[3].offsetLeft-this.offsetWidth+1;
	}
	this.pen._detectLimits();
	
	// position
	this.pen._definePos = function() {
		this.nowX = Math.round((this.valueNow-this.valueMin)*(this.maxX-this.minX)/(this.valueMax-this.valueMin)+this.minX);
		this.style.left = this.nowX+"px";
		this.newNowX = this.nowX;
	}
	this.pen._definePos();

	this.pen.initXY = 0;
	this.pen.allowMove = false;
	this.pen[window.dhx4.isIPad?"ontouchstart":"onmousedown"] = function(e) {
		if (self.state == false) return;
		e = e||event;
		this.initXY = (window.dhx4.isIPad?e.touches[0].clientX:e.clientX); //e.clientX;
		this.newValueNow = this.valueNow;
		this.allowMove = true;
		this.className = "dhxtoolbar_sl_pen dhxtoolbar_over";
		if (label.tip != "") {
			label.style.visibility = "hidden";
			label.style.display = "";
			label.innerHTML = label.tip.replace("%v", this.valueNow);
			label.style.left = Math.round(window.dhx4.absLeft(this)+this.offsetWidth/2-label.offsetWidth/2)+"px";
			label.style.top = window.dhx4.absTop(this)-label.offsetHeight-3+"px";
			label.style.visibility = "";
			label.style.zIndex = window.dhx4.zim.reserve(label._zi);
		}
	}
	
	this.pen._doOnMouseMoveStart = function(e) {
		// optimized for destructor
		e=e||event;
		if (!pen.allowMove) return;
		var ecx = (window.dhx4.isIPad?e.touches[0].clientX:e.clientX);
		var ofst = ecx - pen.initXY;
		
		// mouse goes out to left/right from pen
		if (ecx < window.dhx4.absLeft(pen)+Math.round(pen.offsetWidth/2) && pen.nowX == pen.minX) return;
		if (ecx > window.dhx4.absLeft(pen)+Math.round(pen.offsetWidth/2) && pen.nowX == pen.maxX) return;
		
		pen.newNowX = pen.nowX + ofst;
		
		if (pen.newNowX < pen.minX) pen.newNowX = pen.minX;
		if (pen.newNowX > pen.maxX) pen.newNowX = pen.maxX;
		pen.nowX = pen.newNowX;
		pen.style.left = pen.nowX+"px";
		pen.initXY = ecx;
		pen.newValueNow = Math.round((pen.valueMax-pen.valueMin)*(pen.newNowX-pen.minX)/(pen.maxX-pen.minX)+pen.valueMin);
		if (label.tip != "") {
			label.innerHTML = label.tip.replace(/%v/gi, pen.newValueNow);
			label.style.left = Math.round(window.dhx4.absLeft(pen)+pen.offsetWidth/2-label.offsetWidth/2)+"px";
			label.style.top = window.dhx4.absTop(pen)-label.offsetHeight-3+"px";
		}
		e.cancelBubble = true;
		if (e.preventDefault) e.preventDefault(); else e.returnValue = false;
		return false;
	}
	this.pen._doOnMouseMoveEnd = function() {
		if (!pen.allowMove) return;
		pen.className = "dhxtoolbar_sl_pen";
		pen.allowMove = false;
		pen.nowX = pen.newNowX;
		pen.valueNow = pen.newValueNow;
		if (label.tip != "") {
			label.style.display = "none";
			window.dhx4.zim.clear(label._zi);
		}
		that.callEvent("onValueChange", [self.obj.idd.replace(that.idPrefix, ""), pen.valueNow]);
	}
	
	if (window.dhx4.isIPad) {
		document.addEventListener("touchmove", pen._doOnMouseMoveStart, false);
		document.addEventListener("touchend", pen._doOnMouseMoveEnd, false);
	} else {
		if (typeof(window.addEventListener) != "undefined") {
			window.addEventListener("mousemove", pen._doOnMouseMoveStart, false);
			window.addEventListener("mouseup", pen._doOnMouseMoveEnd, false);
		} else {
			document.body.attachEvent("onmousemove", pen._doOnMouseMoveStart);
			document.body.attachEvent("onmouseup", pen._doOnMouseMoveEnd);
		}
	}
	// functions
	this.enableItem = function() {
		if (this.state) return;
		this.state = true;
		this.obj.className = "dhx_toolbar_btn dhxtoolbar_btn_def";
	}
	this.disableItem = function() {
		if (!this.state) return;
		this.state = false;
		this.obj.className = "dhx_toolbar_btn dhxtoolbar_btn_dis";
	}
	this.isEnabled = function() {
		return this.state;
	}
	this.showItem = function() {
		this.obj.style.display = "";
	}
	this.hideItem = function() {
		this.obj.style.display = "none";
	}
	this.isVisible = function() {
		return (this.obj.style.display == "");
	}
	this.setValue = function(value, callEvent) {
		value = Number(value);
		if (value < this.pen.valueMin) value = this.pen.valueMin;
		if (value > this.pen.valueMax) value = this.pen.valueMax;
		this.pen.valueNow = value;
		this.pen._definePos();
		if (callEvent == true) that.callEvent("onValueChange", [this.obj.idd.replace(that.idPrefix, ""), this.pen.valueNow]);
	}
	this.getValue = function() {
		return this.pen.valueNow;
	}
	this.setMinValue = function(value, label) {
		value = Number(value);
		if (value > this.pen.valueMax) return;
		this.obj.childNodes[0].innerHTML = label;
		this.obj.childNodes[0].style.display = (label.length>0?"":"none");
		this.pen.valueMin = value;
		if (this.pen.valueNow < this.pen.valueMin) this.pen.valueNow = this.pen.valueMin;
		this.pen._detectLimits();
		this.pen._definePos();
	}
	this.setMaxValue = function(value, label) {
		value = Number(value);
		if (value < this.pen.valueMin) return;
		this.obj.childNodes[4].innerHTML = label;
		this.obj.childNodes[4].style.display = (label.length>0?"":"none");
		this.pen.valueMax = value;
		if (this.pen.valueNow > this.pen.valueMax) this.pen.valueNow = this.pen.valueMax;
		this.pen._detectLimits();
		this.pen._definePos();
	}
	this.getMinValue = function() {
		var label = this.obj.childNodes[0].innerHTML;
		var value = this.pen.valueMin;
		return new Array(value, label);
	}
	this.getMaxValue = function() {
		var label = this.obj.childNodes[4].innerHTML;
		var value = this.pen.valueMax;
		return new Array(value, label);
	}
	this.setItemToolTipTemplate = function(template) {
		this.label.tip = template;
	}
	this.getItemToolTipTemplate = function() {
		return this.label.tip;
	}
	//
	return this;
}

dhtmlXToolbarObject.prototype.unload = function() {
	
	if (this.conf.isIPad) {
		document.removeEventListener("touchstart", this._doOnClick, false);
	} else {
		if (typeof(window.addEventListener) == "function") {
			window.removeEventListener("mousedown", this._doOnClick, false);
		} else {
			document.body.detachEvent("onmousedown", this._doOnClick);
		}
	}
	this._doOnClick = null;
	
	this.clearAll();
	this.objPull = null;
	
	if (this._xmlLoader) {
		this._xmlLoader.destructor();
		this._xmlLoader = null;
	}
	
	while (this.base.childNodes.length > 0) this.base.removeChild(this.base.childNodes[0]);
	this.cont.removeChild(this.base);
	this.base = null;
	
	while (this.cont.childNodes.length > 0) this.cont.removeChild(this.cont.childNodes[0]);
	this.cont.className = "";
	this.cont = null;
	
	window.dhx4._enableDataLoading(this, null, null, null, "clear");
	window.dhx4._eventable(this, "clear");
	
	this.tX1 = null;
	this.tX2 = null;
	this.tY1 = null;
	this.tY2 = null;
	
	this.anyUsed = null;
	this.idPrefix = null;
	this.rootTypes = null;
	
	this._rtl = null;
	this._rtlParseBtn = null;
	this.setRTL = null;
	
	this._sbw = null;
	this._getObj = null;
	this._addImgObj = null;
	this._setItemImage = null;
	this._clearItemImage = null;
	this._setItemText = null;
	this._getItemText = null;
	this._enableItem = null;
	this._disableItem = null;
	this._xmlParser = null;
	
	this._addItemToStorage = null;
	this._genStr = null;
	this._addItem = null;
	this._getPosition = null;
	this._setPosition = null;
	this._getIdByPosition = null;
	this._separatorObject = null;
	this._textObject = null;
	this._buttonObject = null;
	this._buttonSelectObject = null;
	this._buttonInputObject = null;
	this._buttonTwoStateObject = null;
	this._sliderObject = null;
	this._autoDetectVisibleArea = null;
	this._removeItem = null;
	this.setAlign = null;
	this.setSkin = null;
	this.setIconsPath = null;
	this.setIconPath = null;
	this.loadXML = null;
	this.loadXMLString = null;
	this.clearAll = null;
	this.addSpacer = null;
	this.removeSpacer = null;
	this.getType = null;
	this.getTypeExt = null;
	this.inArray = null;
	this.getParentId = null;
	this.addButton = null;
	this.addText = null;
	this.addButtonSelect = null;
	this.addButtonTwoState = null;
	this.addSeparator = null;
	this.addSlider = null;
	this.addInput = null;
	this.forEachItem = null;
	this.showItem = null;
	this.hideItem = null;
	this.isVisible = null;
	this.enableItem = null;
	this.disableItem = null;
	this.isEnabled = null;
	this.setItemText = null;
	this.getItemText = null;
	this.setItemToolTip = null;
	this.getItemToolTip = null;
	this.setItemImage = null;
	this.setItemImageDis = null;
	this.clearItemImage = null;
	this.clearItemImageDis = null;
	this.setItemState = null;
	this.getItemState = null;
	this.setItemToolTipTemplate = null;
	this.getItemToolTipTemplate = null;
	this.setValue = null;
	this.getValue = null;
	this.setMinValue = null;
	this.getMinValue = null;
	this.setMaxValue = null;
	this.getMaxValue = null;
	this.setWidth = null;
	this.getWidth = null;
	this.getPosition = null;
	this.setPosition = null;
	this.removeItem = null;
	this.addListOption = null;
	this.removeListOption = null;
	this.showListOption = null;
	this.hideListOption = null;
	this.isListOptionVisible = null;
	this.enableListOption = null;
	this.disableListOption = null;
	this.isListOptionEnabled = null;
	this.setListOptionPosition = null;
	this.getListOptionPosition = null;
	this.setListOptionText = null;
	this.getListOptionText = null;
	this.setListOptionToolTip = null;
	this.getListOptionToolTip = null;
	this.setListOptionImage = null;
	this.getListOptionImage = null;
	this.clearListOptionImage = null;
	this.forEachListOption = null;
	this.getAllListOptions = null;
	this.setListOptionSelected = null;
	this.getListOptionSelected = null;
	this.unload = null;
	this.setUserData = null;
	this.getUserData = null;
	this.setMaxOpen = null;
	this.items = null;
	this.conf = null;
};

dhtmlXToolbarObject.prototype._autoDetectVisibleArea = function() {
	var d = window.dhx4.screenDim();
	this.tX1 = d.left;
	this.tX2 = d.right;
	this.tY1 = d.top;
	this.tY2 = d.bottom;
};


dhtmlXToolbarObject.prototype._initObj = function(data) {
	for (var q=0; q<data.length; q++) this._addItemToStorage(data[q]);
	if (this.conf.skin == "dhx_terrace") this._improveTerraceSkin();
};

dhtmlXToolbarObject.prototype._xmlToJson = function(xml) {
	
	var data = [];
	var root = xml.getElementsByTagName("toolbar");
	
	if (root != null && root[0] != null) {
		
		root = root[0];
		
		
		var t = ["id", "type", "hidden", "title", "text", "enabled", "img", "imgdis", "action", "openAll", "renderSelect", "mode", "maxOpen", "width", "value", "selected", "length", "textMin", "textMax", "toolTip", "valueMin", "valueMax", "valueNow"];
		var p = ["id", "type", "enabled", "disabled", "action", "selected", "img", "text"];
		//
		for (var q=0; q<root.childNodes.length; q++) {
			if (root.childNodes[q].tagName == "item") {
				
				var itemData = {};
				for (var w=0; w<t.length; w++) {
					var val = root.childNodes[q].getAttribute(t[w]);
					if (val != null) itemData[t[w]] = val;
				}
				
				for (var e=0; e<root.childNodes[q].childNodes.length; e++) {
					if (root.childNodes[q].childNodes[e].tagName == "item" && itemData.type == "buttonSelect") {
						var u = {};
						for (var w=0; w<p.length; w++) {
							var val = root.childNodes[q].childNodes[e].getAttribute(p[w]);
							if (val != null) u[p[w]] = val;
						}
						var t0 = root.childNodes[q].childNodes[e].getElementsByTagName("itemText");
						if (t0 != null && t0[0] != null) u.itemText = t0[0].firstChild.nodeValue;
						// listed options userdata
						var h = root.childNodes[q].childNodes[e].getElementsByTagName("userdata");
						for (var w=0; w<h.length; w++) {
							if (!u.userdata) u.userdata = {};
							var r = {};
							try { r.name = h[w].getAttribute("name"); } catch(k) { r.name = null; }
							try { r.value = h[w].firstChild.nodeValue; } catch(k) { r.value = ""; }
							if (r.name != null) u.userdata[r.name] = r.value;
						}
						//
						if (itemData.options == null) itemData.options = [];
						itemData.options.push(u);
					}
					
					// items userdata
					if (root.childNodes[q].childNodes[e].tagName == "userdata") {
						if (itemData.userdata == null) itemData.userdata = {};
						var u = {};
						try { u.name = root.childNodes[q].childNodes[e].getAttribute("name"); } catch(k) { u.name = null; }
						try { u.value = root.childNodes[q].childNodes[e].firstChild.nodeValue; } catch(k) { u.value = ""; }
						if (u.name != null) itemData.userdata[u.name] = u.value;
					}
				}
				data.push(itemData);
			}
		}
	}
	
	return data;
};

dhtmlXToolbarObject.prototype._addItemToStorage = function(data, pos) {
	
	var id = (data.id||this._genStr(24));
	var type = (data.type||"");
	
	if (type == "spacer") {
		this.addSpacer(this._lastId);
	} else {
		this._lastId = id;
	}
	
	if (type != "" && this["_"+type+"Object"] != null) {
		
		if (type == "buttonSelect") {
			if (data.options != null) {
				for (var q=0; q<data.options.length; q++) { // js-array button select init used obj/sep
					if (data.options[q].type == "obj") data.options[q].type = "button";
					if (data.options[q].type == "sep") data.options[q].type = "separator";
				}
			}
		}
		
		if (type == "slider") {
			var k = {
				tip_template: "toolTip",
				value_min: "valueMin",
				value_max: "valueMax",
				value_now: "valueNow",
				text_min: "textMin",
				text_max: "textMax"
			};
			for (var a in k) {
				if (data[k[a]] == null && data[a] != null) data[k[a]] = data[a];
			}
		}
		
		if (type == "buttonInput") {
			if (data.value == null && data.text != null) data.value = data.text;
		}
		
		if (type == "buttonTwoState") {
			if (typeof(data.selected) == "undefined" && typeof(data.pressed) != "undefined" && window.dhx4.s2b(data.pressed)) {
				data.selected = true;
			}
		}
		
		// common
		if (typeof(data.enabled) == "undefined" && typeof(data.disabled) != "undefined" && window.dhx4.s2b(data.disabled)) {
			data.enabled = false;
		}
		if (data.imgDis == null && data.img_disabled != null) {
			data.imgdis = data.img_disabled;
		}
		
		if ((typeof(data.openAll) == "undefined" || data.openAll == null) && this.conf.skin == "dhx_terrace") data.openAll = true;
		this.objPull[this.idPrefix+id] = new this["_"+type+"Object"](this, id, data);
		this.objPull[this.idPrefix+id]["type"] = type;
		this.setPosition(id, pos);
	}
	
	// userdata
	if (data.userdata != null) {
		for (var a in data.userdata) this.setUserData(id, a, data.userdata[a]);
	}
	// userdata for options
	if (data.options != null) {
		for (var q=0; q<data.options.length; q++) {
			if (data.options[q].userdata != null) {
				for (var a in data.options[q].userdata) {
					this.setListOptionUserData(data.id, data.options[q].id, a, data.options[q].userdata[a]);
				}
			}
		}
	}

};

// skin
dhtmlXToolbarObject.prototype.setSkin = function(skin, onlyIcons) {
	if (onlyIcons === true) {
		// prevent of removing skin postfixes when attached to layout/acc/etc
		this.cont.className = this.cont.className.replace(/dhxtoolbar_icons_\d{1,}/,"dhxtoolbar_icons_"+this.conf.iconSize);
	} else {
		this.conf.skin = skin;
		if (this.conf.skin == "dhx_skyblue") {
			this.conf.sel_ofs_y = 1;
		}
		if (this.conf.skin == "dhx_web") {
			this.conf.sel_ofs_y = 1;
			this.conf.sel_ofs_x = 1;
		}
		if (this.conf.skin == "dhx_terrace") {
			this.conf.sel_ofs_y = -1;
			this.conf.sel_ofs_x = 0;
		}
		this.cont.className = "dhx_toolbar_"+this.conf.skin+" dhxtoolbar_icons_"+this.conf.iconSize;
	}
	
	for (var a in this.objPull) {
		var item = this.objPull[a];
		if (item["type"] == "slider") {
			item.pen._detectLimits();
			item.pen._definePos();
			item.label.className = "dhx_toolbar_slider_label_"+this.conf.skin;
		}
		if (item["type"] == "buttonSelect") {
			item.polygon.className = "dhx_toolbar_poly_"+this.conf.skin+" dhxtoolbar_icons_"+this.conf.iconSize;
		}
	}
	if (skin == "dhx_terrace") this._improveTerraceSkin();
};

dhtmlXToolbarObject.prototype.setAlign = function(align) {
	this.conf.align = (align=="right"?"right":"left");
	this.base.className = (align=="right"?"dhxtoolbar_float_right":"dhxtoolbar_float_left");
	if (this._spacer) this._spacer.className = (align=="right"?" dhxtoolbar_float_left":" dhxtoolbar_float_right")
};

dhtmlXToolbarObject.prototype.setIconSize = function(size) {
	this.conf.iconSize = ({18:true,24:true,32:true,48:true}[size]?size:18);
	this.setSkin(this.conf.skin, true);
	this.callEvent("_onIconSizeChange",[this.conf.iconSize]);
};

dhtmlXToolbarObject.prototype.setIconsPath = function(path) {
	this.conf.icons_path = path;
};


// user data
dhtmlXToolbarObject.prototype.setUserData = function(id, name, value) {
	id = this.idPrefix+id;
	if (this.objPull[id] != null) {
		if (this.objPull[id].userData == null) this.objPull[id].userData = {};
		this.objPull[id].userData[name] = value;
	}
};
dhtmlXToolbarObject.prototype.getUserData = function(id, name) {
	id = this.idPrefix+id;
	if (this.objPull[id] != null && this.objPull[id].userData != null) return this.objPull[id].userData[name]||null;
	return null;
};
// userdata for listed options
dhtmlXToolbarObject.prototype._isListOptionExists = function(listId, optionId) {
	if (this.objPull[this.idPrefix+listId] == null) return false;
	var item = this.objPull[this.idPrefix+listId];
	if (item.type != "buttonSelect") return false;
	if (item._listOptions[optionId] == null) return false;
	return true;
};
dhtmlXToolbarObject.prototype.setListOptionUserData = function(listId, optionId, name, value) {
	// is exists?
	if (!this._isListOptionExists(listId, optionId)) return;
	// set userdata
	var opt = this.objPull[this.idPrefix+listId]._listOptions[optionId];
	if (opt.userData == null) opt.userData = {};
	opt.userData[name] = value;
};
dhtmlXToolbarObject.prototype.getListOptionUserData = function(listId, optionId, name) {
	// is exists?
	if (!this._isListOptionExists(listId, optionId)) return null;
	// get userdata
	var opt = this.objPull[this.idPrefix+listId]._listOptions[optionId];
	if (!opt.userData) return null;
	return (opt.userData[name]?opt.userData[name]:null);
};


// terrace skin fixes
dhtmlXToolbarObject.prototype._improveTerraceSkin = function() {
	
	if (this.conf.terrace_radius == null) this.conf.terrace_radius = "3px";
	
	var p = [];
	var bn = {separator: true, text: true}; // border-less items
	
	var e = [this.base];
	if (this._spacer != null) e.push(this._spacer);
	for (var w=0; w<e.length; w++) {
		p[w] = [];
		for (var q=0; q<e[w].childNodes.length; q++) {
			if (e[w].childNodes[q].idd != null && e[w].childNodes[q].style.display != "none") {
				var a = this.idPrefix+e[w].childNodes[q].idd;
				if (this.objPull[a] != null && this.objPull[a].obj == e[w].childNodes[q]) {
					p[w].push({a:a,type:this.objPull[a].type,node:this.objPull[a][this.objPull[a].type=="buttonSelect"?"arw":"obj"]});
				}
			}
		}
		e[w] = null;
	}
	
	for (var w=0; w<p.length; w++) {
		for (var q=0; q<p[w].length; q++) {
			
			var t = p[w][q];
			
			// check if border-right/border-left needed
			var br = false;
			var bl = false;
			
			if (!bn[t.type]) {
				
				// right side - check if item last-child or next-sibling is borderless item
				if (q == p[w].length-1 || (p[w][q+1] != null && bn[p[w][q+1].type])) br = true;
				
				// left side, check if item first-child or prev-sibling is borderless item
				if (q == 0 || (q-1 >= 0 && p[w][q-1] != null && bn[p[w][q-1].type])) bl = true;
				
			}
			
			t.node.style.borderRightWidth = (br?"1px":"0px");
			t.node.style.borderTopRightRadius = t.node.style.borderBottomRightRadius = (br?this.conf.terrace_radius:"0px");
			
			if (t.type == "buttonSelect") {
				t.node.previousSibling.style.borderTopLeftRadius = t.node.previousSibling.style.borderBottomLeftRadius = (bl?this.conf.terrace_radius:"0px");
				t.node.previousSibling._br = br;
				t.node.previousSibling._bl = bl;
			} else {
				t.node.style.borderTopLeftRadius = t.node.style.borderBottomLeftRadius = (bl?this.conf.terrace_radius:"0px");
			}
			
			t.node._br = br;
			t.node._bl = bl;
			
		}
	}
	
	for (var w=0; w<p.length; w++) {
		for (var q=0; q<p[w].length; q++) {
			for (var a in p[w][q]) p[w][q][a] = null;
			p[w][q] = null;
		}
		p[w] = null;
	}
	
	p = e = null;
};

// enable/disable riunded corners when sublist opened
dhtmlXToolbarObject.prototype._improveTerraceButtonSelect = function(id, state) {
	var item = this.objPull[id];
	if (state == true) {
		item.obj.style.borderBottomLeftRadius = (item.obj._bl?this.conf.terrace_radius:"0px");
		item.arw.style.borderBottomRightRadius = (item.obj._br?this.conf.terrace_radius:"0px");
	} else {
		item.obj.style.borderBottomLeftRadius = "0px";
		item.arw.style.borderBottomRightRadius = "0px";
	}
	item = null;
};

if (typeof(window.dhtmlXCellObject) != "undefined") {
	
	dhtmlXCellObject.prototype._createNode_toolbar = function(obj, type, htmlString, append, node) {
		
		if (typeof(node) != "undefined") {
			obj = node;
		} else {
			obj = document.createElement("DIV");
			obj.className = "dhx_cell_toolbar_"+(this.conf.borders?"def":"no_borders");
			obj.appendChild(document.createElement("DIV"));
			obj.firstChild.className = "dhx_toolbar_base_18_dhx_skyblue";
		}
		
		this.cell.insertBefore(obj, this.cell.childNodes[this.conf.idx.cont]); // before cont only
		
		this.conf.ofs_nodes.t.toolbar = true;
		this._updateIdx();
		// adjust cont will performed after toolbar init
		
		return obj;
		
	}
	
	dhtmlXCellObject.prototype.attachToolbar = function(conf) {
		
		if (!(this.dataNodes.ribbon == null && this.dataNodes.toolbar == null)) return;
		
		if (typeof(conf) == "undefined") {
			conf = {};
		} else if (typeof(conf) == "string") {
			conf = {skin:conf};
		}
		if (typeof(conf.skin) == "undefined") conf.skin = this.conf.skin;
		conf.parent = this._attachObject("toolbar").firstChild;
		
		this.dataNodes.toolbar = new dhtmlXToolbarObject(conf);
		this._adjustCont(this._idd);
		
		this.dataNodes.toolbar._masterCell = this;
		this.dataNodes.toolbar.attachEvent("_onIconSizeChange", function(){
			this._masterCell._adjustCont();
		});
		
		conf.parent = null;
		conf = null;
		
		return this.dataNodes.toolbar;
		
	};
	
	dhtmlXCellObject.prototype.detachToolbar = function() {
		
		if (!this.dataNodes.toolbar) return;
		this.dataNodes.toolbar._masterCell = null; // link to this
		this.dataNodes.toolbar.unload();
		this.dataNodes.toolbar = null;
		delete this.dataNodes.toolbar;
		
		this._detachObject("toolbar");
		
	};
	
	dhtmlXCellObject.prototype.showToolbar = function() {
		this._mtbShowHide("toolbar", "");
	};
	
	dhtmlXCellObject.prototype.hideToolbar = function() {
		this._mtbShowHide("toolbar", "none");
	};
	

	
	dhtmlXCellObject.prototype.getAttachedToolbar = function() {
		return this.dataNodes.toolbar;
	};
	
}


/*
Product Name: dhtmlxSuite 
Version: 4.1.3 
Edition: Professional 
License: content of this file is covered by DHTMLX Commercial or Enterprise license. Usage without proper license is prohibited. To obtain it contact sales@dhtmlx.com
Copyright UAB Dinamenta http://www.dhtmlx.com
*/

function dhtmlXEditor(base, skin) {
	
	var that = this;
	
	this.conf = {
		// set content after load
		content: "", // first if set
		contentHTML: "", // second
		// resize
		resizeTM: null,
		resizeTMTime: 100,
		// readonly
		roMode: false,
		// extended toolbar
		toolbar: false,
		iconsPath: "",
		// frame events
		evs: ["focus", "blur", "keydown", "keyup", "keypress", "mouseup", "mousedown", "click"]
	};
	
	
	this._doOnFocusChanged = null;
	this._doOnAccess = null;
	
	if (typeof(base) == "object" && base != null && base.tagName == null) {
		skin = base.skin;
		if (base.content != null) this.conf.content = base.content;
		if (base.contentHTML != null) this.conf.contentHTML = base.contentHTML;
		if (base.iconsPath != null) this.conf.iconsPath = base.iconsPath;
		if (base.toolbar != null) this.conf.toolbar = window.dhx4.s2b(base.toolbar);
		if (base.onFocusChanged != null) this._doOnFocusChanged = base.onFocusChanged;
		if (base.onAccess != null) this._doOnAccess = base.onAccess;
		base = base.parent;
	}
	
	// skin config
	this.conf.skin = (skin||window.dhx4.skin||(typeof(dhtmlx)!="undefined"?dhtmlx.skin:null)||window.dhx4.skinDetect("dhxeditor")||"dhx_skyblue");
	
	// configure base
	if (typeof(base) == "string") base = document.getElementById(base);
	this.base = base;
	this.base.className += " dhxeditor_"+this.conf.skin;
	
	while (this.base.childNodes.length > 0) this.base.removeChild(this.base.childNodes[0]);
	
	// configure base for dhxcont
	var pos = (window.dhx4.isIE ? this.base.currentStyle["position"] : window.getComputedStyle(this.base, null).getPropertyValue("position"));
	if (!(pos == "relative" || pos == "absolute")) this.base.style.position = "relative";
	
	// init dhxcont
	this.cell = new dhtmlXEditorCell(window.dhx4.newId(), this);
	this.base.appendChild(this.cell.cell);
	
	this.cBlock = document.createElement("DIV");
	this.cBlock.className = "dhxcont_content_blocker";
	this.cBlock.style.display = "none";
	this.base.appendChild(this.cBlock);
	
	// editable area
	this.editor = document.createElement("IFRAME");
	this.editor.className = "dhxeditor_mainiframe";
	this.editor.frameBorder = 0;
	if (window.dhx4.isOpera) this.editor.scrolling = "yes";
	
	// adjust self
	this.setSizes();
	
	// onAccess event - focus/blue as param
	var fr = this.editor;
	if (typeof(window.addEventListener) != "undefined") {
		fr.onload = function() {
			for (var q=0; q<that.conf.evs.length; q++) {
				fr.contentWindow.addEventListener(that.conf.evs[q], that._ev, false);
			}
		}
	} else {
		fr.onreadystatechange = function(a) {
			if (typeof(fr.readyState) != "undefined" && fr.readyState == "complete") {
				try {
					for (var q=0; q<that.conf.evs.length; q++) {
						fr.contentWindow.document.body.attachEvent("on"+that.conf.evs[q], that._ev);
					}
				} catch(e){};
			}
		}
	}
	
	this._ev = function(e) {
		e = e||event;
		var type = e.type;
		that.callEvent("onAccess", [type, e]);
		if (typeof(that._doOnAccess) == "function") {
			that._doOnAccess(type, e);
		} else if (typeof(that._doOnAccess) == "string" && typeof(window[that._doOnAccess]) == "function") {
			window[that._doOnAccess](type, e);
		}
	}
	this._focus = function() {
		if (window.dhx4.isIE) {
			this.editor.contentWindow.document.body.focus();
		} else {
			this.editor.contentWindow.focus();
		}
	}
	
	this.cell.attachObject(this.editor);
	this.edWin = this.editor.contentWindow;
	this.edDoc = this.edWin.document;
	
	this._prepareContent = function(saveContent, roMode) {
		
		var storedContent = "";
		if (saveContent === true && this.getContent != null) storedContent = this.getContent();
		
		var edDoc = this.editor.contentWindow.document;
		edDoc.open("text/html", "replace");
		if (window.dhx4.isOpera) {
			edDoc.write("<html><head><style> html, body { overflow:auto;-webkit-overflow-scrolling: touch; padding:0px; height:100%; margin:0px; font-family:Tahoma; font-size:12px; background-color:#ffffff;} </style></head><body "+(roMode!==true?"contenteditable='true'":"")+" tabindex='0'></body></html>");
		} else {
			if (window.dhx4.isKHTML) {
				edDoc.write("<html><head><style> html {overflow-x: auto;-webkit-overflow-scrolling: touch; overflow-y: auto;} body { overflow: auto; overflow-y: scroll;} html,body { padding:0px; height:100%; margin:0px; font-family:Tahoma; font-size:12px; background-color:#ffffff;} </style></head><body "+(roMode!==true?"contenteditable='true'":"")+" tabindex='0'></body></html>");
			} else {
				if (window.dhx4.isIE) {
					// && navigator.appVersion.indexOf("MSIE 9.0")!= -1
					edDoc.write("<html><head><style> html {overflow-y: auto;} body {overflow-y: scroll;-webkit-overflow-scrolling: touch;} html,body { overflow-x: auto; padding:0px; height:100%; margin:0px; font-family:Tahoma; font-size:12px; background-color: #ffffff; outline: none;} </style></head><body "+(roMode!==true?"contenteditable='true'":"")+" tabindex='0'></body></html>");
				} else {
					edDoc.write("<html><head><style> html,body { overflow-x: auto; overflow-y:-webkit-overflow-scrolling: touch; scroll; padding:0px; height:100%; margin:0px; font-family:Tahoma; font-size:12px; background-color:#ffffff;} </style></head><body "+(roMode!==true?"contenteditable='true'":"")+" tabindex='0'></body></html>");
				}
			}
		}
		edDoc.close();
		
		if (window.dhx4.isIE) edDoc.contentEditable = (roMode!==true); else edDoc.designMode = (roMode!==true?"On":"Off");
		if (window.dhx4.isFF) try { edDoc.execCommand("useCSS", false, true); } catch(e) {}
		if (saveContent === true && this.setContent != null) this.setContent(storedContent);
		
	}
	
	// fix
	this._prepareContent();
	
	// resize
	this._doOnResize = function() {
		window.clearTimeout(that.conf.resizeTM);
		that.conf.resizeTM = window.setTimeout(function(){if(that.setSizes)that.setSizes();}, that.conf.resizeTMTime);
	}
	
	// toolbar buttons
	this._runCommand = function(name,param){
		if (this.conf.roMode === true) return;
		if (arguments.length < 2) param = null;
		if (window.dhx4.isIE) this.edWin.focus();
		try {
			var edDoc = this.editor.contentWindow.document
			edDoc.execCommand(name,false,param);
		} catch(e){}
		if (window.dhx4.isIE) {
			this.edWin.focus();
			var self = this;
			window.setTimeout(function(){
				self.edWin.focus();
				self = null;
			},1);
		}
	}
	
	// commands
	this.applyBold = function() {
		this._runCommand("Bold");
	}
	this.applyItalic = function() {
		this._runCommand("Italic");
	}
	this.applyUnderscore = function() {
		this._runCommand("Underline");
	}
	this.clearFormatting = function() {
		this._runCommand("RemoveFormat");
	}
	
	this._doOnClick = function(e) {
		var ev = e||window.event;
		var el = ev.target||ev.srcElement;
		that._showInfo(el);
	}
	
	this._doOnMouseDown = function(e) { // opera only
		var ev = e||window.event;
		var el = ev.target||ev.srcElement;
		that._showInfo(el);
	}
	
	this._doOnKeyUp = function(e) {
		var ev = e||window.event;
		var key = ev.keyCode;
		var el = ev.target||ev.srcElement;
		if ({37:1,38:1,39:1,40:1,13:1}[key] == 1) that._showInfo(el);
	}
	

	this._getParentByTag = function(node, tag_name) {
		tag_name = tag_name.toLowerCase();
		var p = node;
		do {
			if (tag_name == '' || p.nodeName.toLowerCase() == tag_name) return p;
		} while (p = p.parentNode);
		return node;
	}
	
	this._isStyleProperty = function(node, tag_name, name, value){
		tag_name = tag_name.toLowerCase();
		var n = node;
		do {
			if ((n.nodeName.toLowerCase() == tag_name) && (n.style[name] == value)) return true;
   		} while (n = n.parentNode);
   		return false;
	}
	
	this._setStyleProperty = function(el, prop) {
		this.style[prop] = false;
		var n = this._getParentByTag(el, prop);
		if (n && (n.tagName.toLowerCase() == prop)) this.style[prop] = true;
		if (prop == "del" && this._getParentByTag(el, "strike") && this._getParentByTag(el,"strike").tagName.toLowerCase() == "strike") this.style.del = true;
	}
	
	this._showInfo = function(el) {
		
		var el = (this._getSelectionBounds().end)?this._getSelectionBounds().end : el;
		if (!el || !this._setStyleProperty) return;
		
		try {
			if (this.edWin.getComputedStyle) {
				var st = this.edWin.getComputedStyle(el, null);
				var fw = ((st.getPropertyValue("font-weight")==401)?700:st.getPropertyValue("font-weight"));
				this.style = {
					fontStyle	: st.getPropertyValue("font-style"),
					fontSize	: st.getPropertyValue("font-size"),
					textDecoration	: st.getPropertyValue("text-decoration"),
					fontWeight	: fw,
					fontFamily	: st.getPropertyValue("font-family"),
					textAlign	: st.getPropertyValue("text-align")
				};
				if (window.dhx4.isKHTML) { // safari
					this.style.fontStyle = st.getPropertyValue("font-style");
					this.style.vAlign = st.getPropertyValue("vertical-align");
					this.style.del = this._isStyleProperty(el,"span","textDecoration","line-through");
					this.style.u = this._isStyleProperty(el,"span","textDecoration","underline");
				}
			} else {
				var st = el.currentStyle;
				this.style = {
					fontStyle	: st.fontStyle,
					fontSize	: st.fontSize,
					textDecoration	: st.textDecoration,
					fontWeight	:  st.fontWeight,
					fontFamily	: st.fontFamily,
					textAlign	: st.textAlign
				};
			}
			this._setStyleProperty(el,"h1");
			this._setStyleProperty(el,"h2");
			this._setStyleProperty(el,"h3");
			this._setStyleProperty(el,"h4");
			if (!window.dhx4.isKHTML) {
				this._setStyleProperty(el,"del");
				this._setStyleProperty(el,"sub");
				this._setStyleProperty(el,"sup");
				this._setStyleProperty(el,"u");
			}
			this.callEvent("onFocusChanged", [this.style, st])
		} catch(e){ return null; }
	}
	
	this._getSelectionBounds = function() {
   		var range, root, start, end;
		if (this.edWin.getSelection) {
			var selection = this.edWin.getSelection();
			range = selection.getRangeAt(selection.rangeCount-1);
			start = range.startContainer;
			end = range.endContainer;
			root = range.commonAncestorContainer;
			if (start.nodeName == "#text") root = root.parentNode; 
			if (start.nodeName == "#text") start = start.parentNode;
			if (start.nodeName.toLowerCase() == "body") start = start.firstChild;
			if (end.nodeName == "#text") end = end.parentNode;
			if (end.nodeName.toLowerCase() == "body") end = end.lastChild;
			if (start == end) root = start;
			return {
				root: root,
				start: start,
				end: end
			};
		} else if (this.edWin.document.selection) {
			range = this.edDoc.selection.createRange()
			if(!range.duplicate) return null;
			root = range.parentElement();
			var r1 = range.duplicate();
			var r2 = range.duplicate();
			r1.collapse(true);
			r2.moveToElementText(r1.parentElement());
			r2.setEndPoint("EndToStart",r1);
			start = r1.parentElement();
			r1 = range.duplicate();
			r2 = range.duplicate();
			r2.collapse(false);
			r1.moveToElementText(r2.parentElement());
			r1.setEndPoint("StartToEnd", r2);
			end = r2.parentElement();
	   		if (start.nodeName.toLowerCase() == "body") start = start.firstChild;
			if (end.nodeName.toLowerCase() == "body") end = end.lastChild;
			
			if (start == end) root = start;
			return {
				root: root,
				start: start,
				end: end
			};
   		}
   		return null;
	}
	
	this.getContent = function(){
		if (!this.edDoc.body) {
			return "";
		} else {
			if (window.dhx4.isFF) return this.editor.contentWindow.document.body.innerHTML.replace(/<\/{0,}br\/{0,}>\s{0,}$/gi,"");
			if (window.dhx4.isIE && this.edDoc.body.innerText.length == 0) return "";
			return this.edDoc.body.innerHTML;
		}
	}
	
	this.setContent = function(str){
		str = str||"";
		if (this.edDoc.body) {
			var ffTest = false;
			if (window.dhx4.isFF) {
				var k = navigator.userAgent.match(/Firefox\/(\d*)/);
				ffTest = (k != null && k[1] < 28);
			}
			if (ffTest) {
				if (typeof(this.conf.ffTest) == "undefined") {
					this.editor.contentWindow.document.body.innerHTML = "";
					this._runCommand("InsertHTML", "test");
					this.conf.ffTest = (this.editor.contentWindow.document.body.innerHTML.length > 0);
				}
				if (this.conf.ffTest) {
					// FF 4.x+
					this.editor.contentWindow.document.body.innerHTML = str;
				} else {
					// FF 2.x, 3.x
					this.editor.contentWindow.document.body.innerHTML = "";
					if (str.length == 0) str=" ";
					this._runCommand("InsertHTML", str);
				}
			} else {
				this.editor.contentWindow.document.body.innerHTML = str;
			}
			this.callEvent("onContentSet",[]);
		} else {
			if (!this.conf.firstLoadEv) {
				this.conf.firstLoadEv = true;
				this.conf.firstLoadData = str;
				this._onFirstLoad = function() {
					that.setContent(that.conf.firstLoadData);
					if (typeof(window.addEventListener) == "function") {
						that.edWin.removeEventListener("load", that._onFirstLoad, false);
					} else {
						that.edWin.detachEvent("onload", that._onFirstLoad);
					}
					that.conf.firstLoadData = null;
					that.conf.firstLoadEv = false;
					that._onFirstLoad = null;
				}
				if (typeof(window.addEventListener) == "function") {
					this.edWin.addEventListener("load", this._onFirstLoad, false);
				} else {
					this.edWin.attachEvent("onload", this._onFirstLoad);
				}
			}
		}
	}
	
	this.setContentHTML = function(url) {
		window.dhx4.ajax.get(url, function(r) {
			if (r.xmlDoc.responseText != null) that.setContent(r.xmlDoc.responseText);
		});
	}
	
	// events
	window.dhx4._eventable(this);
	
	this.attachEvent("onFocusChanged", function(state){
		if (typeof(this._doOnFocusChanged) == "function") {
			this._doOnFocusChanged(state);
		} else if (typeof(this._doOnFocusChanged) == "string" && typeof(window[this._doOnFocusChanged]) == "function") {
			window[this._doOnFocusChanged](state);
		}
	});
	
	if (typeof(window.addEventListener) == "function") {
		window.addEventListener("resize", this._doOnResize, false);
		this.edDoc.addEventListener("click", this._doOnClick, false);
		this.edDoc.addEventListener("keyup", this._doOnKeyUp, false);
		if (window.dhx4.isOpera) this.edDoc.addEventListener("mousedown", this._doOnMouseDown, false);
	} else {
		window.attachEvent("onresize", this._doOnResize);
		this.edDoc.attachEvent("onclick", this._doOnClick);
		this.edDoc.attachEvent("onkeyup", this._doOnKeyUp);
	}
	
	this.unload = function() {
		
		// first detach events from iframe
		if (typeof(window.addEventListener) == "function") {
			window.removeEventListener("resize", this._doOnResize, false);
			this.edDoc.removeEventListener("click", this._doOnClick, false);
			this.edDoc.removeEventListener("keyup", this._doOnKeyUp, false);
			if (window.dhx4.isOpera) this.edDoc.removeEventListener("mousedown", this._doOnMouseDown, false);
			// editor's
			for (var q=0; q<that.conf.evs.length; q++) {
				fr.contentWindow.removeEventListener(that.conf.evs[q], that._ev, false);
			}
		} else {
			window.detachEvent("onresize", this._doOnResize, false);
			this.edDoc.detachEvent("onclick", this._doOnClick);
			this.edDoc.detachEvent("onkeyup", this._doOnKeyUp);
			// editor's
			for (var q=0; q<that.conf.evs.length; q++) {
				fr.contentWindow.document.body.detachEvent("on"+that.conf.evs[q], that._ev);
			}
		}
		
		this._doOnAccess = null;
		this._doOnFocusChanged = null;
		
		// remove editor
		if (typeof(window.addEventListener) == "function") {
			this.editor.onload = null;
		} else {
			this.editor.onreadystatechange = null;
		}
		this.editor.parentNode.removeChild(this.editor);
		this.editor = null;
		this.edDoc = null;
		this.edWin = null;
		
		// unload cell
		this.cell._unload();
		this.cell = null;
		
		// extended toolbar
		this.tb = null;
		
		window.dhx4._eventable(this, "clear");
		
		this.cBlock.parentNode.removeChild(this.cBlock);
		this.cBlock = null;
		
		// clear container features
		this.base.className = String(this.base.className).replace(new RegExp("\\s{0,}dhxeditor_"+this.conf.skin),"");
		while (this.base.childNodes.length > 0) this.base.removeChild(this.base.childNodes[0]);
		this.base = null;
		
		this._doOnClick = null;
		this._doOnKeyUp = null;
		this._doOnMouseDown = null;
		
		this._ev = null;
		this._focus = null;
		this._prepareContent = null;
		this._doOnResize = null;
		this.setIconsPath = null;
		this.init = null;
		this.setSizes = null;
		this._runCommand = null;
		this.applyBold = null;
		this.applyItalic = null;
		this.applyUnderscore = null;
		this.clearFormatting = null;
		this._showInfo = null;
		this._getSelectionBounds = null;
		this.getContent = null;
		this.setContent = null;
		this.setContentHTML = null;
		this.setReadonly = null;
		this.isReadonly = null;
		this.unload = null;
		
		that = fr = null;
	}
	
	// load extended toolbar if any
	if (this.conf.toolbar == true && typeof(this.attachToolbar) == "function" && typeof(window.dhtmlXToolbarObject) == "function") {
		this.attachToolbar(this.conf.iconsPath);
	}
	this.setIconsPath = function(iconsPath) {
		this.conf.iconsPath = iconsPath;
	}
	
	// load content if any
	if (this.conf.content.length > 0) {
		this.setContent(this.conf.content);
		this.conf.content = "";
	} else if (this.conf.contentHTML.length > 0) {
		this.setContentHTML(this.conf.contentHTML);
		this.conf.contentHTML = "";
	}
	
	return this;
};

dhtmlXEditor.prototype.setSizes = function() {
	this.cell._setSize(0, 0, this.base.clientWidth, this.base.clientHeight);
	if (this.editor != null) {
		this.editor.style.left = "5px";
		this.editor.style.width = this.base.clientWidth-5+"px";
	}
};

dhtmlXEditor.prototype.setReadonly = function(mode) {
	this.conf.roMode = (mode===true);
	this._prepareContent(true, this.conf.roMode);
	this.cBlock.style.display = (this.conf.roMode?"":"none");
};

dhtmlXEditor.prototype.isReadonly = function(mode) {
	return (this.conf.roMode||false);
};

dhtmlXEditor.prototype.setSkin = function(skin) {
	this.base.className = String(this.base.className).replace(new RegExp("dhxeditor_"+this.conf.skin),"dhxeditor_"+skin);
	this.conf.skin = this.cell.conf.skin = skin;
	if (this.tb) {
		this.cell.detachToolbar(skin);
		this.tb = null;
		this.attachToolbar();
	}
	this.setSizes();
};

window.dhtmlXEditorCell = function(id, editor) {
	
	dhtmlXCellObject.apply(this, [id, "_editor"]);
	
	var that = this;
	this.editor = editor;
	
	this.conf.skin = this.editor.conf.skin;
	
	this.attachEvent("_onCellUnload", function(){
		
		// unload simple toolbar
		this._stbUnload();
		
		this.editor = null;
		that = null;
		
	});
	
	// simple toolbar init
	this._stbInit();
	
	return this;
};

dhtmlXEditorCell.prototype = new dhtmlXCellObject();

// simple toolbar
dhtmlXEditorCell.prototype._stbInit = function() {
	
	var that = this;
	
	var t = document.createElement("DIV");
	t.className = "dhx_cell_stb";
	this.cell.insertBefore(t, this.cell.childNodes[this.conf.idx.cont]);
	
	t.onselectstart = function(e) {
		e = e||event;
		e.cancelBubble = true;
		if (e.preventDefault) e.preventDefault(); else e.returnValue = false;
		return false;
	}
	
	var items = {
		bold: "applyBold",
		italic: "applyItalic",
		underline: "applyUnderscore",
		clearformat: "clearFormatting"
	};
	
	for (var k in items) {
		
		var a = document.createElement("A");
		a.href = "javascript:void(0);";
		a.tabIndex = -1;
		t.appendChild(a);
		
		a.onmousedown = a.onclick = function(e){
			e = e||event;
			if (e.preventDefault) e.preventDefault(); else e.returnValue = false;
			return false;
		}
		
		var d = document.createElement("DIV");
		d.className = "dhx_cell_stb_button btn_"+k;
		d._actv = k.charAt(0);
		d._cmd = items[k];
		a.appendChild(d);
		
		d.onclick = function(e){
			e = e||event;
			if (e.preventDefault) e.preventDefault(); else e.returnValue = false;
			return false;
		}
		d.onmousedown = function(e){
			e = e||event;
			if (e.preventDefault) e.preventDefault(); else e.returnValue = false;
			that.editor[this._cmd]();
			that.editor.callEvent("onToolbarClick",[this._actv]);
		}
		
		d = a = null;
	}
	
	t = null;
	
	this._stbUnload = function() {
		
		var t = this.cell.childNodes[this.conf.idx.stb];
		t.onselectstart = null;
		
		while (t.childNodes.length > 0) {
			t.lastChild.onmousedown = t.lastChild.onclick = null;
			t.lastChild.firstChild.onmousedown = t.lastChild.firstChild.onclick = null;
			t.lastChild.firstChild._actv = t.lastChild.firstChild._cmd = null;
			t.lastChild.removeChild(t.lastChild.firstChild);
			t.removeChild(t.lastChild);
		}
		t.parentNode.removeChild(t);
		t = that = null;
		
		this.conf.idx_data.stb = this.conf.ofs_nodes.t._getStbHeight = null;
		delete this.conf.ofs_nodes.t._getStbHeight
		delete this.conf.idx_data.stb;
		
		this._updateIdx();
		
	};
	
	// include into content top offset calculation
	this.conf.ofs_nodes.t._getStbHeight = "func";
	
	// include into index
	this.conf.idx_data.stb = "dhx_cell_stb";
	this._updateIdx();
	
};

dhtmlXEditorCell.prototype._stbHide = function() {
	this.cell.childNodes[this.conf.idx.stb].style.display = "none";
};

dhtmlXEditorCell.prototype._getStbHeight = function() {
	return this.cell.childNodes[this.conf.idx.stb].offsetHeight;
};

dhtmlXCellObject.prototype.attachEditor = function(conf) {
	
	var obj = document.createElement("DIV");
	obj.style.width = "100%";
	obj.style.height = "100%";
	obj.style.position = "relative";
	obj.style.overflow = "hidden";
	this._attachObject(obj);
	
	if (!(typeof(conf) == "object" && conf != null)) conf = {};
	conf.parent = obj;
	
	this.dataType = "editor";
	this.dataObj = new dhtmlXEditor(conf);
	
	obj = null;
	conf.parent = null;
	conf = null;
	
	// attach to portal extended logic
	if (typeof(window.dhtmlXPortalCell) != "undefined" && this instanceof window.dhtmlXPortalCell) {
		
		if (this.portal.conf.editor_ev == null) {
			
			var e1 = this.portal.attachEvent("onBeforeDrag", function(id) {
				if (this.cdata[id].dataType == "editor") {
					this.cdata[id].conf.editor_cont = this.cdata[id].dataObj.getContent();
				}
				return true;
			});
			
			var e2 = this.portal.attachEvent("onDrop", function(id) {
				if (this.cdata[id].dataType == "editor") {
					this.cdata[id].dataObj.setContent(this.cdata[id].conf.editor_cont);
					this.cdata[id].dataObj._prepareContent(true);
					this.cdata[id].conf.editor_cont = null;
				}
			});
			
			this.portal.conf.editor_ev = [e1, e2];
		}
		
		this.conf.editor_ev = this.attachEvent("_onBeforeContentDetach", function(){
			
			this.detachEvent(this.conf.editor_ev);
			this.conf.editor_ev = null;
			
			if (this instanceof window.dhtmlXPortalCell) {
				
				var ed = false;
				for (var a in this.portal.cdata) {
					if (this.portal.cdata[a] != this && this.portal.cdata[a].dataType == "editor") {
						ed = true; // portal still have attached editors
					}
				}
				// no more editors, clear events
				if (ed == false) {
					for (var q=0; q<this.portal.conf.editor_ev.length; q++) {
						this.portal.detachEvent(this.portal.conf.editor_ev[q]);
					}
					this.portal.conf.editor_ev = null;
				}
			}
		});
		
	}
	
	this.callEvent("_onContentAttach",[]);
	
	return this.dataObj;
	
};


/*
Product Name: dhtmlxSuite 
Version: 4.1.3 
Edition: Professional 
License: content of this file is covered by DHTMLX Commercial or Enterprise license. Usage without proper license is prohibited. To obtain it contact sales@dhtmlx.com
Copyright UAB Dinamenta http://www.dhtmlx.com
*/

dhtmlXEditor.prototype.attachToolbar = function(iconsPath) {
	
	if (this.tb != null) return;
	
	if (iconsPath != null) this.conf.iconsPath = iconsPath;
	
	this.cell._stbHide();
	this.tb = this.cell.attachToolbar({
		icons_path: this.conf.iconsPath+"/dhxeditor_"+String(this.conf.skin).replace(/^dhx_/,"")+"/",
		skin: this.conf.skin
	});
	this.setSizes();
	
	this._availFonts = new Array("Arial", "Arial Narrow", "Comic Sans MS", "Courier", "Georgia", "Impact", "Tahoma", "Times New Roman", "Verdana");
	this._initFont = this._availFonts[0];
	this._xmlFonts = "";
	for (var q=0; q<this._availFonts.length; q++) {
		var fnt = String(this._availFonts[q]).replace(/\s/g,"_");
		this._xmlFonts += '<item type="button" id="applyFontFamily:'+fnt+'"><itemText><![CDATA[<img src="'+this.tb.imagePath+'font_'+String(fnt).toLowerCase()+'.gif" border="0" style="/*margin-top:1px;margin-bottom:1px;*/width:110px;height:16px;">]]></itemText></item>';
	}
	//
	this._availSizes = {"1":"8pt", "2":"10pt", "3":"12pt", "4":"14pt", "5":"18pt", "6":"24pt", "7":"36pt"};
	this._xmlSizes = "";
	for (var a in this._availSizes) {
		this._xmlSizes += '<item type="button" id="applyFontSize:'+a+':'+this._availSizes[a]+'" text="'+this._availSizes[a]+'"/>';
	}
	this.tbXML = '<toolbar>'+
				// h1-h4
				'<item id="applyH1" type="buttonTwoState" img="h1.gif" imgdis="h4_dis.gif" title="H1"/>'+
				'<item id="applyH2" type="buttonTwoState" img="h2.gif" imgdis="h4_dis.gif" title="H2"/>'+
				'<item id="applyH3" type="buttonTwoState" img="h3.gif" imgdis="h4_dis.gif" title="H3"/>'+
				'<item id="applyH4" type="buttonTwoState" img="h4.gif" imgdis="h4_dis.gif" title="H4"/>'+
				'<item id="separ01" type="separator"/>'+
				// text
				'<item id="applyBold" type="buttonTwoState" img="bold.gif" imgdis="bold_dis.gif" title="Bold Text"/>'+
				'<item id="applyItalic" type="buttonTwoState" img="italic.gif" imgdis="italic_dis.gif" title="Italic Text"/>'+
				'<item id="applyUnderscore" type="buttonTwoState" img="underline.gif" imgdis="underline_dis.gif" title="Underscore Text"/>'+
				'<item id="applyStrikethrough" type="buttonTwoState" img="strike.gif" imgdis="strike_dis.gif" title="Strikethrough Text"/>'+
				'<item id="separ02" type="separator"/>'+
				// align
				'<item id="alignLeft" type="buttonTwoState" img="align_left.gif" imgdis="align_left_dis.gif" title="Left Alignment"/>'+
				'<item id="alignCenter" type="buttonTwoState" img="align_center.gif" imgdis="align_center_dis.gif" title="Center Alignment"/>'+
				'<item id="alignRight" type="buttonTwoState" img="align_right.gif" imgdis="align_right_dis.gif" title="Right Alignment"/>'+
				'<item id="alignJustify" type="buttonTwoState" img="align_justify.gif" title="Justified Alignment"/>'+
				'<item id="separ03" type="separator"/>'+
				// sub/super script
				'<item id="applySub" type="buttonTwoState" img="script_sub.gif" imgdis="script_sub.gif" title="Subscript"/>'+
				'<item id="applySuper" type="buttonTwoState" img="script_super.gif" imgdis="script_super_dis.gif" title="Superscript"/>'+
				'<item id="separ04" type="separator"/>'+
				// etc
				'<item id="createNumList" type="button" img="list_number.gif" imgdis="list_number_dis.gif" title="Number List"/>'+
				'<item id="createBulList" type="button" img="list_bullet.gif" imgdis="list_bullet_dis.gif" title="Bullet List"/>'+
				'<item id="separ05" type="separator"/>'+
				//
				'<item id="increaseIndent" type="button" img="indent_inc.gif" imgdis="indent_inc_dis.gif" title="Increase Indent"/>'+
				'<item id="decreaseIndent" type="button" img="indent_dec.gif" imgdis="indent_dec_dis.gif" title="Decrease Indent"/>'+
				'<item id="separ06" type="separator"/>'+
				'<item id="clearFormatting" type="button" img="clear.gif" title="Clear Formatting"/>'+
			'</toolbar>';
	
	this.tb.loadStruct(this.tbXML);
	
	this._checkAlign = function(alignSelected) {
		this.tb.setItemState("alignCenter", false);
		this.tb.setItemState("alignRight", false);
		this.tb.setItemState("alignJustify", false);
		this.tb.setItemState("alignLeft", false);
		if (alignSelected) this.tb.setItemState(alignSelected, true);
	}
	
	this._checkH = function(h) {
		this.tb.setItemState("applyH1", false);
		this.tb.setItemState("applyH2", false);
		this.tb.setItemState("applyH3", false);
		this.tb.setItemState("applyH4", false);
		if (h) this.tb.setItemState(h, true);
	}
	
	this._doOnFocusChanged = function(state) {
		/*bold*/
		if(!state.h1&&!state.h2&&!state.h3&&!state.h4){
			var bold = (String(state.fontWeight).search(/bold/i) != -1) || (Number(state.fontWeight) >= 700);
			this.tb.setItemState("applyBold", bold);
		} else this.tb.setItemState("applyBold", false);
		// align
		var alignId = "alignLeft";
		if (String(state.textAlign).search(/center/) != -1) { alignId = "alignCenter"; }
		if (String(state.textAlign).search(/right/) != -1) { alignId = "alignRight"; }
		if (String(state.textAlign).search(/justify/) != -1) { alignId = "alignJustify"; }
		this.tb.setItemState(alignId, true);
		this._checkAlign(alignId);
		/*heading*/
		this.tb.setItemState("applyH1", state.h1);
		this.tb.setItemState("applyH2", state.h2);
		this.tb.setItemState("applyH3", state.h3);
		this.tb.setItemState("applyH4", state.h4);
		if (window._KHTMLrv) {
			/*for Safari*/
			state.sub = (state.vAlign == "sub");
			state.sup = (state.vAlign == "super");
		}
		this.tb.setItemState("applyItalic", (state.fontStyle == "italic"));
		this.tb.setItemState("applyStrikethrough", state.del);
		this.tb.setItemState("applySub", state.sub);
		this.tb.setItemState("applySuper", state.sup);
		this.tb.setItemState("applyUnderscore", state.u);
	}
	
	this._doOnToolbarClick = function(id) {
		var action = String(id).split(":");
		if (this[action[0]] != null) {
			if (typeof(this[action[0]]) == "function") {
				this[action[0]](action[1]);
				this.callEvent("onToolbarClick",[id]);
			}
		}
	}
	
	this._doOnStateChange = function(itemId, state) {
		this[itemId]();
		switch (itemId) {
			case "alignLeft":
			case "alignCenter":
			case "alignRight":
			case "alignJustify":
				this._checkAlign(itemId);
				break;
			case "applyH1":
			case "applyH2":
			case "applyH3":
			case "applyH4":
				this._checkH(itemId);
				break;
		}
		this.callEvent("onToolbarClick",[itemId]);
	}
	this._doOnBeforeStateChange = function(itemId, state) {
		if ((itemId == "alignLeft" || itemId == "alignCenter" || itemId == "alignRight" || itemId == "alignJustify") && state == true) {
			return false;
		}
		return true;
	}
	var that = this;
	
	this.tb.attachEvent("onClick", function(id){that._doOnToolbarClick(id);});
	this.tb.attachEvent("onStateChange", function(id,st){that._doOnStateChange(id,st);});
	this.tb.attachEvent("onBeforeStateChange", function(id,st){return that._doOnBeforeStateChange(id,st);});
	
	this.applyBold = function(){
		this._runCommand("Bold");
	}
	
	this.applyItalic = function(){
		this._runCommand("Italic");
	}
	
	this.applyUnderscore = function(){
		this._runCommand("Underline");
	}
	
	this.applyStrikethrough = function(){
		this._runCommand("StrikeThrough");
	}
	
	this.alignLeft = function(){
		this._runCommand("JustifyLeft");
	}
	
	this.alignRight = function(){
		this._runCommand("JustifyRight");
	}
	
	this.alignCenter = function(){
		this._runCommand("JustifyCenter");
	}
	
	this.alignJustify = function(){
		this._runCommand("JustifyFull");
	}
	
	this.applySub = function(){
		this._runCommand("Subscript");
	}
	
	this.applySuper = function(){
		this._runCommand("Superscript");
	}
	
	this.applyH1 = function(){
		this._runCommand("FormatBlock","<H1>");
	}
	
	this.applyH2 = function(){
		this._runCommand("FormatBlock","<H2>");
	}
	
	this.applyH3 = function(){
		this._runCommand("FormatBlock","<H3>");
	}
	
	this.applyH4 = function(){
		this._runCommand("FormatBlock","<H4>");
	}
	
	this.createNumList = function(){
		this._runCommand("InsertOrderedList");
	}
	
	this.createBulList = function(){
		this._runCommand("InsertUnorderedList");
	}
	
	this.increaseIndent = function(){
		this._runCommand("Indent");
	}
	
	this.decreaseIndent = function(){
		this._runCommand("Outdent");
	}
	this.clearFormatting = function() {
		this._runCommand("RemoveFormat");
		this.tb.setItemState("applyBold", false);
		this.tb.setItemState("applyItalic", false);
		this.tb.setItemState("applyStrikethrough", false);
		this.tb.setItemState("applySub", false);
		this.tb.setItemState("applySuper", false);
		this.tb.setItemState("applyUnderscore", false);
	}
	
};


/*
Product Name: dhtmlxSuite 
Version: 4.1.3 
Edition: Professional 
License: content of this file is covered by DHTMLX Commercial or Enterprise license. Usage without proper license is prohibited. To obtain it contact sales@dhtmlx.com
Copyright UAB Dinamenta http://www.dhtmlx.com
*/

/*_TOPICS_
@0:Initialization
@1:Selection control
@2:Add/delete
@3:Private
@4:Node/level control
@5:Checkboxes/user data manipulation
@6:Appearence control
@7: Handlers
*/

function xmlPointer(data){
	this.d=data;
}
xmlPointer.prototype={
	text:function(){ if (!_isFF) return this.d.xml; var x = new XMLSerializer();   return x.serializeToString(this.d); },
	get:function(name){return this.d.getAttribute(name); },
	exists:function(){return !!this.d },
	content:function(){return this.d.firstChild?(this.d.firstChild.wholeText||this.d.firstChild.data):""; }, // <4k in FF
	each:function(name,f,t,i){  var a=this.d.childNodes; var c=new xmlPointer(); if (a.length) for (i=i||0; i<a.length; i++) if (a[i].tagName==name) { c.d=a[i]; if(f.apply(t,[c,i])==-1) return; } },
	get_all:function(){ var a={}; var b=this.d.attributes; for (var i=0; i<b.length; i++) a[b[i].name]=b[i].value; return a; },
	sub:function(name){ var a=this.d.childNodes; var c=new xmlPointer(); if (a.length) for (var i=0; i<a.length; i++) if (a[i].tagName==name) { c.d=a[i]; return c; } },
	up:function(name){ return new xmlPointer(this.d.parentNode);  },
	set:function(name,val){ this.d.setAttribute(name,val);  },
	clone:function(name){ return new xmlPointer(this.d); },
	sub_exists:function(name){ var a=this.d.childNodes; if (a.length) for (var i=0; i<a.length; i++) if (a[i].tagName==name) return true;  return false;  },
	through:function(name,rule,v,f,t){  var a=this.d.childNodes; if (a.length) for (var i=0; i<a.length; i++) { if (a[i].tagName==name && a[i].getAttribute(rule)!=null && a[i].getAttribute(rule)!="" &&  (!v || a[i].getAttribute(rule)==v )) { var c=new xmlPointer(a[i]);  f.apply(t,[c,i]); } var w=this.d; this.d=a[i]; this.through(name,rule,v,f,t); this.d=w;  } }
}



/**
*     @desc: tree constructor
*     @param: htmlObject - parent html object or id of parent html object
*     @param: width - tree width
*     @param: height - tree height
*     @param: rootId - id of virtual root node (same as tree node id attribute in xml)
*     @type: public
*     @topic: 0
*/
function dhtmlXTreeObject(htmlObject, width, height, rootId){
  if (dhtmlxEvent.initTouch)
    dhtmlxEvent.initTouch();

	if (_isIE) try { document.execCommand("BackgroundImageCache", false, true); } catch (e){}
	if (typeof(htmlObject)!="object")
      this.parentObject=document.getElementById(htmlObject);
	else
      this.parentObject=htmlObject;

	this.parentObject.style.overflow="hidden";
   	this._itim_dg=true;
    this.dlmtr=",";
    this.dropLower=false;
	  this.enableIEImageFix(true);

   this.xmlstate=0;
   this.mytype="tree";
   this.smcheck=true;   //smart checkboxes
   this.width=width;
   this.height=height;
   this.rootId=rootId;
   this.childCalc=null;
      this.def_img_x="18px";
      this.def_img_y="18px";
      this.def_line_img_x="18px";
      this.def_line_img_y="24px";

    this._dragged=new Array();
   this._selected=new Array();

   this.style_pointer="pointer";
   
   this._aimgs=true;
   this.htmlcA=" [";
   this.htmlcB="]";
   this.lWin=window;
   this.cMenu=0;
   this.mlitems=0;
   this.iconURL="";
   this.dadmode=0;
   this.slowParse=false;
   this.autoScroll=true;
   this.hfMode=0;
   this.nodeCut=new Array();
   this.XMLsource=0;
   this.XMLloadingWarning=0;
   this._idpull={};
   this._pullSize=0;
   this.treeLinesOn=true;
   this.tscheck=false;
   this.timgen=true;
   this.dpcpy=false;
   this._ld_id=null;
	this._oie_onXLE=[];
   this.imPath=window.dhx_globalImgPath||""; 
   this.checkArray=new Array("iconUncheckAll.gif","iconCheckAll.gif","iconCheckGray.gif","iconUncheckDis.gif","iconCheckDis.gif","iconCheckDis.gif");
   this.radioArray=new Array("radio_off.gif","radio_on.gif","radio_on.gif","radio_off.gif","radio_on.gif","radio_on.gif");

   this.lineArray=new Array("line2.gif","line3.gif","line4.gif","blank.gif","blank.gif","line1.gif");
   this.minusArray=new Array("minus2.gif","minus3.gif","minus4.gif","minus.gif","minus5.gif");
   this.plusArray=new Array("plus2.gif","plus3.gif","plus4.gif","plus.gif","plus5.gif");
   this.imageArray=new Array("leaf.gif","folderOpen.gif","folderClosed.gif");
   this.cutImg= new Array(0,0,0);
   this.cutImage="but_cut.gif";
   
   dhx4._eventable(this);

   this.dragger= new dhtmlDragAndDropObject();
//create root
   this.htmlNode=new dhtmlXTreeItemObject(this.rootId,"",0,this);
   this.htmlNode.htmlNode.childNodes[0].childNodes[0].style.display="none";
   this.htmlNode.htmlNode.childNodes[0].childNodes[0].childNodes[0].className="hiddenRow";
//init tree structures
   this.allTree=this._createSelf();
   this.allTree.appendChild(this.htmlNode.htmlNode);

   if (dhtmlx.$customScroll)
      dhtmlx.CustomScroll.enable(this);

    if(_isFF){
         this.allTree.childNodes[0].width="100%";
         this.allTree.childNodes[0].style.overflow="hidden";
    }

   var self=this;
   this.allTree.onselectstart=new Function("return false;");
   if (_isMacOS)
		this.allTree.oncontextmenu = function(e){ 
			return self._doContClick(e||window.event, true); 
		};   
   this.allTree.onmousedown = function(e){ return self._doContClick(e||window.event); };  
   
   this.XMLLoader=this._parseXMLTree;
   if (_isIE) this.preventIECashing(true);

//#__pro_feature:01112006{
//#complex_move:01112006{
   this.selectionBar=document.createElement("DIV");
   this.selectionBar.className="selectionBar";
   this.selectionBar.innerHTML="&nbsp;";
   this.selectionBar.style.display="none";
   this.allTree.appendChild(this.selectionBar);
//#}
//#}

    
    if (window.addEventListener) window.addEventListener("unload",function(){try{  self.destructor(); } catch(e){}},false);
    if (window.attachEvent) window.attachEvent("onunload",function(){ try{ self.destructor(); } catch(e){}});

	this.setImagesPath=this.setImagePath;
	this.setIconsPath=this.setIconPath;

	if (dhtmlx.image_path) this.setImagePath(dhtmlx.image_path);
	this.setSkin(window.dhx4.skin||(typeof(dhtmlx)!="undefined"?dhtmlx.skin:null)||window.dhx4.skinDetect("dhxtree")||"dhx_skyblue");

   return this;
};


/**
*     @desc: set default data transfer mode 
*     @param: mode - data mode (json,xml,csv)
*     @type: public
*     @topic: 0
*/
dhtmlXTreeObject.prototype.setDataMode=function(mode){
		this._datamode=mode;
}


	
dhtmlXTreeObject.prototype._doContClick=function(ev, force){
	if (!force && ev.button!=2) {
		if(this._acMenu){
			if (this._acMenu.hideContextMenu)
				this._acMenu.hideContextMenu()
			else
				this.cMenu._contextEnd();
		}
		return true;
	}
	
 	

	
	var el=(_isIE?ev.srcElement:ev.target);
	while ((el)&&(el.tagName!="BODY")) {
		if (el.parentObject) break;
    	 el=el.parentNode;
	 }
    	
    if ((!el)||(!el.parentObject)) return true;
    
    var obj=el.parentObject;
    
    if (!this.callEvent("onRightClick",[obj.id,ev]))
        (ev.srcElement||ev.target).oncontextmenu = function(e){ (e||event).cancelBubble=true; return false; };
        
    	this._acMenu=(obj.cMenu||this.cMenu);
        if (this._acMenu){
       		if (!(this.callEvent("onBeforeContextMenu", [
					obj.id
				]))) return true; 	
				if(!_isMacOS)
	        (ev.srcElement||ev.target).oncontextmenu = function(e){ (e||event).cancelBubble=true; return false; };
	               
			if (this._acMenu.showContextMenu){

var dEl0=window.document.documentElement;
var dEl1=window.document.body;
var corrector = new Array((dEl0.scrollLeft||dEl1.scrollLeft),(dEl0.scrollTop||dEl1.scrollTop));
if (_isIE){
	var x= ev.clientX+corrector[0];
	var y = ev.clientY+corrector[1];
} else {
	var x= ev.pageX;
	var y = ev.pageY;
}
				
				this._acMenu.showContextMenu(x-1,y-1)
				this.contextID=obj.id;
				ev.cancelBubble=true;
				this._acMenu._skip_hide=true;
			} else {
				el.contextMenuId=obj.id;
				el.contextMenu=this._acMenu;
				el.a=this._acMenu._contextStart;
				el.a(el, ev);
				el.a=null;
			}
	        	
			return false;           
    	}
    return true;
}


/**
*     @desc: replace IMG tag with background images - solve problem with IE image caching , not works for IE6 SP1
*     @param: mode - true/false - enable/disable fix
*     @type: public
*     @topic: 0
*/
dhtmlXTreeObject.prototype.enableIEImageFix=function(mode){
	if (!mode){

	this._getImg=function(id){ return document.createElement((id==this.rootId)?"div":"img"); }
	//this._setSrc=function(a,b){ a.src=b; }
	this._setSrc=function(a,b){ a.src=b; }
	this._getSrc=function(a){ return a.src; }
	}	else	{

	this._getImg=function(){ var z=document.createElement("DIV"); z.innerHTML="&nbsp;"; z.className="dhx_bg_img_fix"; return z; }
	this._setSrc=function(a,b){ a.style.backgroundImage="url("+b+")"; }
	this._getSrc=function(a){ var z=a.style.backgroundImage;  return z.substr(4,z.length-5).replace(/(^")|("$)/g,""); }
	}
}

/**
*	@desc: deletes tree and clears memory
*	@type: public
*/
dhtmlXTreeObject.prototype.destructor=function(){
    for (var a in this._idpull){
        var z=this._idpull[a];
		if (!z) continue;
        z.parentObject=null;z.treeNod=null;z.childNodes=null;z.span=null;z.tr.nodem=null;z.tr=null;z.htmlNode.objBelong=null;z.htmlNode=null;
        this._idpull[a]=null;
        }
    this.parentObject.innerHTML="";
    
    this.allTree.onselectstart = null;
    this.allTree.oncontextmenu = null;
    this.allTree.onmousedown = null;
        
    for(var a in this){
        this[a]=null;
        }
}

function cObject(){
    return this;
}
cObject.prototype= new Object;
cObject.prototype.clone = function () {
       function _dummy(){};
       _dummy.prototype=this;
       return new _dummy();
    }

/**
*   @desc: tree node constructor
*   @param: itemId - node id
*   @param: itemText - node label
*   @param: parentObject - parent item object
*   @param: treeObject - tree object
*   @param: actionHandler - onclick event handler(optional)
*   @param: mode - do not show images
*   @type: private
*   @topic: 0
*/
function dhtmlXTreeItemObject(itemId,itemText,parentObject,treeObject,actionHandler,mode){
   this.htmlNode="";
   this.acolor="";
   this.scolor="";
   this.tr=0;
   this.childsCount=0;
   this.tempDOMM=0;
   this.tempDOMU=0;
   this.dragSpan=0;
   this.dragMove=0;
   this.span=0;
   this.closeble=1;
   this.childNodes=new Array();
   this.userData=new cObject();


   this.checkstate=0;
   this.treeNod=treeObject;
   this.label=itemText;
   this.parentObject=parentObject;
   this.actionHandler=actionHandler;
   this.images=new Array(treeObject.imageArray[0],treeObject.imageArray[1],treeObject.imageArray[2]);


   this.id=treeObject._globalIdStorageAdd(itemId,this);
   if (this.treeNod.checkBoxOff ) this.htmlNode=this.treeNod._createItem(1,this,mode);
   else  this.htmlNode=this.treeNod._createItem(0,this,mode);

   this.htmlNode.objBelong=this;
   return this;
   };   


/**
*     @desc: register node
*     @type: private
*     @param: itemId - node id
*     @param: itemObject - node object
*     @topic: 3  
*/
   dhtmlXTreeObject.prototype._globalIdStorageAdd=function(itemId,itemObject){
      if (this._globalIdStorageFind(itemId,1,1)) {   itemId=itemId +"_"+(new Date()).valueOf(); return this._globalIdStorageAdd(itemId,itemObject); }
	  	 this._idpull[itemId]=itemObject;
         this._pullSize++;
      return itemId;
   };

/**
*     @desc: unregister node
*     @type: private
*     @param: itemId - node id
*     @topic: 3
*/
   dhtmlXTreeObject.prototype._globalIdStorageSub=function(itemId){
        if (this._idpull[itemId]){
		    this._unselectItem(this._idpull[itemId]);
			this._idpull[itemId]=null;
			this._pullSize--;
        }
		if ((this._locker)&&(this._locker[itemId])) this._locker[itemId]=false;
   };
   
/**
*     @desc: return node object
*     @param: itemId - node id
*     @type: private
*     @topic: 3
*/
   dhtmlXTreeObject.prototype._globalIdStorageFind=function(itemId,skipXMLSearch,skipParsing,isreparse){
		var z=this._idpull[itemId];
        if (z){
//#__pro_feature:01112006{
//#smart_parsing:01112006{
            if ((z.unParsed)&&(!skipParsing))
                    {
                    this.reParse(z,0);
                    }
            if (this._srnd && !z.htmlNode) this._buildSRND(z,skipParsing);
                if ((isreparse)&&(this._edsbpsA)){
                    for (var j=0; j<this._edsbpsA.length; j++)
                        if (this._edsbpsA[j][2]==itemId){
                            dhx4.callEvent("ongetItemError",["Requested item still in parsing process.",itemId]);
                            return null;
                        }
                    }
//#}
//#}
            return z;
            }
//#__pro_feature:01112006{
//#smart_parsing:01112006{
      if ((this.slowParse)&&(itemId!=0)&&(!skipXMLSearch)) return this.preParse(itemId);
      else
//#}
//#}
	  	return null;
   };
//#__pro_feature:01112006{
//#smart_parsing:01112006{
dhtmlXTreeObject.prototype._getSubItemsXML=function(p){
      var z=[];
      p.each("item",function(c){
      	z.push(c.get("id"));
      },this)
      return z.join(this.dlmtr);
    }

/**
*     @desc: enable/disable smart XML parsing mode (usefull for big, well structured XML)
*     @beforeInit: 1
*     @param: mode - 1 - on, 0 - off;
*     @type: public
*     @edition: Professional
*     @topic: 0
*/
   dhtmlXTreeObject.prototype.enableSmartXMLParsing=function(mode) { this.slowParse=dhx4.s2b(mode); };
   dhtmlXTreeObject.prototype.findXML=function(node,par,val){  }

dhtmlXTreeObject.prototype._getAllCheckedXML=function(p,list,mode){
	var z=[];
	
	if (mode==2)
		p.through("item","checked",-1,function(c){
			z.push(c.get("id"));
  		},this);
  	
  	if (mode==1)
  		p.through("item","id",null,function(c){
  			if (c.get("checked") && (c.get("checked") !=-1))
			z.push(c.get("id"));
  		},this);
  		
	if (mode==0)
  		p.through("item","id",null,function(c){
			if (!c.get("checked") || c.get("checked")==0 )
			z.push(c.get("id"));
  		},this);  		
    if(z.length)
  		return list+(list?this.dlmtr:"")+z.join(this.dlmtr);
      if (list) return list; else return "";
   };


/**
*     @desc: change state of node's checkbox and all childnodes checkboxes
*     @type: private
*     @param: itemId - target node id
*     @param: state - checkbox state
*     @param: sNode - target node object (optional, used by private methods)
*     @topic: 5
*/
   dhtmlXTreeObject.prototype._setSubCheckedXML=function(state,p){
	   	var val= state?"1":"";
	   	p.through("item","id",null,function(c){
			if (!c.get("disabled") || c.get("disabled")==0 )
	   		    c.set("checked",val);
	   	},this);
}

       dhtmlXTreeObject.prototype._getAllScraggyItemsXML=function(p,x){
        var z=[];
        var fff=function(c){
	   		if (!c.sub_exists("item"))
	   			z.push(c.get("id"));
	   		else
	   			c.each("item",fff,this);
		   	}
	    fff(p);
        return z.join(",");
    }
    
   dhtmlXTreeObject.prototype._getAllFatItemsXML=function(p,x){
        var z=[];
        var fff=function(c){
	   		if (!c.sub_exists("item"))
	   			return;
   			z.push(c.get("id"));
   			c.each("item",fff,this);
		   	}
	    fff(p);
        return z.join(",");
    }

dhtmlXTreeObject.prototype._getAllSubItemsXML=function(itemId,z,p){
      var z=[];
      p.through("item","id",null,function(c){
      	z.push(c.get("id"));
      },this)
      return z.join(",");
    }

/**
*     @desc: parse stored xml
*     @param: node - XML node
*     @type: private
*     @edition: Professional
*     @topic: 3  
*/
 dhtmlXTreeObject.prototype.reParse=function(node){
        var that=this;
      if (!this.parsCount) that.callEvent("onXLS",[that,node.id]);
      this.xmlstate=1;

      var tmp=node.unParsed;
      node.unParsed=0;
//               if (confirm("reParse "+node.id)) { window.asdasd.asdasd(); }
      this.XMLloadingWarning=1;
        var oldpid=this.parsingOn;
		var oldmd=this.waitUpdateXML;
		var oldpa=this.parsedArray;

		this.parsedArray=new Array();
	  	this.waitUpdateXML=false;
      this.parsingOn=node.id;
      this.parsedArray=new Array();

         this.setCheckList="";
         this._parse(tmp,node.id,2);
         var chArr=this.setCheckList.split(this.dlmtr);

      for (var i=0; i<this.parsedArray.length; i++)
         node.htmlNode.childNodes[0].appendChild(this.parsedArray[i]);
      
	  if (tmp.get("order") && tmp.get("order")!="none")
	  	 	this._reorderBranch(node,tmp.get("order"),true);
	  	 	
            this.oldsmcheck=this.smcheck;
            this.smcheck=false;

         for (var n=0; n<chArr.length; n++)
            if (chArr[n])  this.setCheck(chArr[n],1);
            this.smcheck=this.oldsmcheck;

      this.parsingOn=oldpid;
	  this.waitUpdateXML=oldmd;
	  this.parsedArray=oldpa;  	  
      this.XMLloadingWarning=0;
      this._redrawFrom(this,node);
      if (this._srnd && !node._sready)
      	this.prepareSR(node.id);
      this.xmlstate=0;
      return true;
   }

/**
*     @desc: search for item in unparsed chunks
*     @param: itemId - item ID
*     @type: private
*     @edition: Professional
*     @topic: 3
*/
dhtmlXTreeObject.prototype.preParse=function(itemId){
   if (!itemId || !this._p) return null; 
   var result=false;
   this._p.clone().through("item","id",itemId,function(c){
   		this._globalIdStorageFind(c.up().get("id"));
   		return result=true;
   	},this);
   	if (result){
   		var n=this._globalIdStorageFind(itemId,true,false);
   		if (!n)
   			dhx4.callEvent("ongetItemError",["The item "+itemId+" not operable. Seems you have non-unique|incorrect IDs in tree's XML.",itemId]);
   	}
   	return n;
}

//#}
//#}

/**
*     @desc: escape string
*     @param: itemId - item ID
*     @type: private
*     @topic: 3
*/
   dhtmlXTreeObject.prototype._escape=function(str){
        switch(this.utfesc){
        case "none":
            return str;
            break;
        case "utf8":
         return encodeURIComponent(str);
            break;
        default:
         return escape(str);
            break;
        }
   }



/**
*     @desc: create and return  new line in tree
*     @type: private
*     @param: htmlObject - parent Node object
*     @param: node - item object
*     @topic: 2  
*/
   dhtmlXTreeObject.prototype._drawNewTr=function(htmlObject,node)
   {
      var tr =document.createElement('tr');
      var td1=document.createElement('td');
      var td2=document.createElement('td');
      td1.appendChild(document.createTextNode(" "));
      td2.colSpan=3;
      td2.appendChild(htmlObject);
      tr.appendChild(td1);  tr.appendChild(td2);
      return tr;
   };
/**
*     @desc: load tree from xml string
*     @type: public
*     @param: xmlString - XML string
*     @param: afterCall - function which will be called after xml loading
*     @topic: 0
*/
   dhtmlXTreeObject.prototype.loadXMLString=function(xmlString,afterCall){
      var that=this;
      if (!this.parsCount) this.callEvent("onXLS",[that,null]);
      this.xmlstate=1;
      this.XMLLoader({ responseXML:dhx4.ajax.parse(xmlString)}, afterCall);
    };

/**
*     @desc: load tree from xml file
*     @type: public
*     @param: file - link to XML file
*     @param: afterCall - function which will be called after xml loading
*     @topic: 0
*/
	dhtmlXTreeObject.prototype.loadXML=function(file,afterCall){ 
	  if (this._datamode && this._datamode!="xml") return this["load"+this._datamode.toUpperCase()](file,afterCall);
        var that=this;
      if (!this.parsCount) this.callEvent("onXLS",[that,this._ld_id]);
      this._ld_id=null;
      this.xmlstate=1;
      this.XMLLoader=this._parseXMLTree;

      var self = this;
      dhx4.ajax.get(file, function(data){
        self.XMLLoader(data.xmlDoc, afterCall);
        self = null;
      });
   };
/**
*     @desc: create new child node
*     @type: private
*     @param: parentObject - parent node object
*     @param: itemId - new node id
*     @param: itemText - new node text
*     @param: itemActionHandler - function fired on node select event
*     @param: image1 - image for node without children;
*     @param: image2 - image for closed node;
*     @param: image3 - image for opened node
*     @param: optionStr - string of otions
*     @param: childs - node childs flag (for dynamical trees) (optional)
*     @param: beforeNode - node, after which new node will be inserted (optional)
*     @topic: 2
*/
   dhtmlXTreeObject.prototype._attachChildNode=function(parentObject,itemId,itemText,itemActionHandler,image1,image2,image3,optionStr,childs,beforeNode,afterNode){

         if (beforeNode && beforeNode.parentObject) parentObject=beforeNode.parentObject;
         if (((parentObject.XMLload==0)&&(this.XMLsource))&&(!this.XMLloadingWarning))
         {
            parentObject.XMLload=1;
                this._loadDynXML(parentObject.id);

         }

         var Count=parentObject.childsCount;
         var Nodes=parentObject.childNodes;


            if (afterNode && afterNode.tr.previousSibling){
            if (afterNode.tr.previousSibling.previousSibling){
               beforeNode=afterNode.tr.previousSibling.nodem;
               }
            else
               optionStr=optionStr.replace("TOP","")+",TOP";
               }

         if (beforeNode)
            {
            var ik,jk;
            for (ik=0; ik<Count; ik++)
               if (Nodes[ik]==beforeNode)
               {
               for (jk=Count; jk!=ik; jk--)
                  Nodes[1+jk]=Nodes[jk];
               break;
               }
            ik++;
            Count=ik;
            }


         if (optionStr) {
             var tempStr=optionStr.split(",");
            for (var i=0; i<tempStr.length; i++)
            {
               switch(tempStr[i])
               {
                  case "TOP": if (parentObject.childsCount>0) { beforeNode=new Object; beforeNode.tr=parentObject.childNodes[0].tr.previousSibling; }
				  	 parentObject._has_top=true;
                     for  (ik=Count; ik>0; ik--)
                        Nodes[ik]=Nodes[ik-1];
                        Count=0;
                     break;
               }
            };
          };

        	var n;
		if (!(n=this._idpull[itemId]) || n.span!=-1){
         	n=Nodes[Count]=new dhtmlXTreeItemObject(itemId,itemText,parentObject,this,itemActionHandler,1);
         	itemId = Nodes[Count].id;
         	parentObject.childsCount++;
     	}
        
        if(!n.htmlNode) {
           n.label=itemText;
		   n.htmlNode=this._createItem((this.checkBoxOff?1:0),n);
   		   n.htmlNode.objBelong=n;
   		  }

         if(image1) n.images[0]=image1;
         if(image2) n.images[1]=image2;
         if(image3) n.images[2]=image3;

		
         var tr=this._drawNewTr(n.htmlNode);
         if ((this.XMLloadingWarning)||(this._hAdI))
            n.htmlNode.parentNode.parentNode.style.display="none";

           
            if ((beforeNode)&&beforeNode.tr&&(beforeNode.tr.nextSibling))
               parentObject.htmlNode.childNodes[0].insertBefore(tr,beforeNode.tr.nextSibling);
            else
               if (this.parsingOn==parentObject.id){
                  this.parsedArray[this.parsedArray.length]=tr;
                        }
               else
                   parentObject.htmlNode.childNodes[0].appendChild(tr);


               if ((beforeNode)&&(!beforeNode.span)) beforeNode=null;

            if (this.XMLsource) if ((childs)&&(childs!=0)) n.XMLload=0; else n.XMLload=1;
            n.tr=tr;
            tr.nodem=n;

            if (parentObject.itemId==0)
                tr.childNodes[0].className="hiddenRow";

            if ((parentObject._r_logic)||(this._frbtr))
                this._setSrc(n.htmlNode.childNodes[0].childNodes[0].childNodes[1].childNodes[0],this.imPath+this.radioArray[0]);


          if (optionStr) {
             var tempStr=optionStr.split(",");

            for (var i=0; i<tempStr.length; i++)
            {
               switch(tempStr[i])
               {
                     case "SELECT": this.selectItem(itemId,false); break;
                  case "CALL": this.selectItem(itemId,true);   break;
                  case "CHILD":  n.XMLload=0;  break;
                  case "CHECKED":
                     if (this.XMLloadingWarning)
                        this.setCheckList+=this.dlmtr+itemId;
                     else
                        this.setCheck(itemId,1);
                        break;
                  case "HCHECKED":
                        this._setCheck(n,"unsure");
                        break;                        
                  case "OPEN": n.openMe=1;  break;
               }
            };
          };

      if (!this.XMLloadingWarning)
      {
             if ((this._getOpenState(parentObject)<0)&&(!this._hAdI)) this.openItem(parentObject.id);

             if (beforeNode)
                {
             this._correctPlus(beforeNode);
             this._correctLine(beforeNode);
                }
             this._correctPlus(parentObject);
             this._correctLine(parentObject);
             this._correctPlus(n);
             if (parentObject.childsCount>=2)
             {
                   this._correctPlus(Nodes[parentObject.childsCount-2]);
                   this._correctLine(Nodes[parentObject.childsCount-2]);
             }
             if (parentObject.childsCount!=2) this._correctPlus(Nodes[0]);

         if (this.tscheck) this._correctCheckStates(parentObject);

            if (this._onradh){
				if (this.xmlstate==1){
					var old=this.onXLE;
					this.onXLE=function(id){ this._onradh(itemId); if (old) old(id); }
					}
				else
					this._onradh(itemId);
			}

      }
   return n;
};


//#__pro_feature:01112006{
//#context_menu:01112006{

/**
*     @desc: enable context menu
*     @param: menu - dhtmlXMenu object
*     @edition: Professional
*     @type: public
*     @topic: 0
*/
   dhtmlXTreeObject.prototype.enableContextMenu=function(menu){  if (menu) this.cMenu=menu; };

/**
*     @desc: set context menu to individual nodes
*     @type: public
*     @param: itemId - node id
*     @param: cMenu - context menu object
*     @edition: Professional
*     @topic: 2
*/
dhtmlXTreeObject.prototype.setItemContextMenu=function(itemId,cMenu){
   var l=itemId.toString().split(this.dlmtr);
   for (var i=0; i<l.length; i++)
      {
      var temp=this._globalIdStorageFind(l[i]);
      if (!temp) continue;
      temp.cMenu=cMenu;
      }
}

//#}
//#}

/**
*     @desc: create new node as a child to specified with parentId
*     @type: deprecated
*     @param: parentId - parent node id
*     @param: itemId - new node id
*     @param: itemText - new node text
*     @param: itemActionHandler - function fired on node select event (optional)
*     @param: image1 - image for node without children; (optional)
*     @param: image2 - image for closed node; (optional)
*     @param: image3 - image for opened node (optional)
*     @param: optionStr - options string (optional)            
*     @param: children - node children flag (for dynamical trees) (optional)
*     @topic: 2  
*/
   dhtmlXTreeObject.prototype.insertNewItem=function(parentId,itemId,itemText,itemActionHandler,image1,image2,image3,optionStr,children){
      var parentObject=this._globalIdStorageFind(parentId);
      if (!parentObject) return (-1);
      var nodez=this._attachChildNode(parentObject,itemId,itemText,itemActionHandler,image1,image2,image3,optionStr,children);
      if(!this._idpull[this.rootId].XMLload)
         this._idpull[this.rootId].XMLload = 1;
//#__pro_feature:01112006{
//#child_calc:01112006{
      if ((!this.XMLloadingWarning)&&(this.childCalc))  this._fixChildCountLabel(parentObject);
//#}
//#}
        return nodez;
   };
/**
*     @desc: create new node as a child to specified with parentId
*     @type: public
*     @param: parentId - parent node id
*     @param: itemId - new node id
*     @param: itemText - new node label
*     @param: itemActionHandler - function fired on node select event (optional)
*     @param: image1 - image for node without children; (optional)
*     @param: image2 - image for closed node; (optional)
*     @param: image3 - image for opened node (optional)
*     @param: optionStr - options string (optional)            
*     @param: children - node children flag (for dynamical trees) (optional)
*     @topic: 2  
*/
   dhtmlXTreeObject.prototype.insertNewChild=function(parentId,itemId,itemText,itemActionHandler,image1,image2,image3,optionStr,children){
      return this.insertNewItem(parentId,itemId,itemText,itemActionHandler,image1,image2,image3,optionStr,children);
   }   
/**  
*     @desc: parse xml
*     @type: private
*     @param: dhtmlObject - jsTree object
*     @param: node - top XML node
*     @param: parentId - parent node id
*     @param: level - level of tree
*     @topic: 2
*/
	dhtmlXTreeObject.prototype._parseXMLTree=function(xml, callback){
		var p=new xmlPointer(dhx4.ajax.xmltop("tree", xml));
		this._parse(p);
		this._p=p;
    if (callback) callback.call(this, xml);
	}
	
	dhtmlXTreeObject.prototype._parseItem=function(c,temp,preNode,befNode){ 
		var id;
		if (this._srnd && (!this._idpull[id=c.get("id")] || !this._idpull[id].span))
		{
			this._addItemSRND(temp.id,id,c);
			return; 
		}
		
  var a=c.get_all();
        
        if ((typeof(this.waitUpdateXML)=="object")&&(!this.waitUpdateXML[a.id])){
			this._parse(c,a.id,1);
			return;
		}    

//#__pro_feature:01112006{
			if ((a.text===null)||(typeof(a.text)=="undefined")){
				a.text=c.sub("itemtext");
				if (a.text) a.text=a.text.content();
			}
//#}
              



                  var zST=[];
                  if (a.select) zST.push("SELECT");
                  if (a.top) zST.push("TOP");
                  if (a.call) this.nodeAskingCall=a.id;
                  if (a.checked==-1) zST.push("HCHECKED");
                     else if (a.checked) zST.push("CHECKED");
                  if (a.open) zST.push("OPEN");
	
    	          if (this.waitUpdateXML){
				  		if (this._globalIdStorageFind(a.id))
	    	            	var newNode=this.updateItem(a.id,a.text,a.im0,a.im1,a.im2,a.checked,a.child);
						else{
							if (this.npl==0) zST.push("TOP");
							else preNode=temp.childNodes[this.npl];

		                    var newNode=this._attachChildNode(temp,a.id,a.text,0,a.im0,a.im1,a.im2,zST.join(","),a.child,0,preNode);
                        a.id = newNode.id;
							preNode=null;
						}
					 }
                  else
                     var newNode=this._attachChildNode(temp,a.id,a.text,0,a.im0,a.im1,a.im2,zST.join(","),a.child,(befNode||0),preNode);
                  if (a.tooltip)
					newNode.span.parentNode.parentNode.title=a.tooltip;

                  if (a.style)
                            if (newNode.span.style.cssText)
                                newNode.span.style.cssText+=(";"+a.style);
                            else
                                newNode.span.setAttribute("style",newNode.span.getAttribute("style")+"; "+a.style);

                        if (a.radio) newNode._r_logic=true;

                  if (a.nocheckbox){
                  	 var check_node=newNode.span.parentNode.previousSibling.previousSibling;
                     check_node.style.display="none";
                     newNode.nocheckbox=true;
                  }
                        if (a.disabled){
                            if (a.checked!=null) this._setCheck(newNode,a.checked);
                            this.disableCheckbox(newNode,1);
                            }

				
                  newNode._acc=a.child||0;

                  if (this.parserExtension) this.parserExtension._parseExtension.call(this,c,a,(temp?temp.id:0));

                  this.setItemColor(newNode,a.aCol,a.sCol);
                  if (a.locked=="1")    this.lockItem(newNode.id,true,true);

                  if ((a.imwidth)||(a.imheight))   this.setIconSize(a.imwidth,a.imheight,newNode);
                  if ((a.closeable=="0")||(a.closeable=="1"))  this.setItemCloseable(newNode,a.closeable);
                  var zcall="";
                  if (a.topoffset) this.setItemTopOffset(newNode,a.topoffset);
                  if ((!this.slowParse)||(typeof(this.waitUpdateXML)=="object")){ 
                  	if (c.sub_exists("item"))
                    	zcall=this._parse(c,a.id,1);
                  }
//#__pro_feature:01112006{
//#smart_parsing:01112006{
                  else {
                  	if ((!newNode.childsCount) && c.sub_exists("item"))
                      newNode.unParsed=c.clone();
                     
						c.each("userdata",function(u){
							this.setUserData(a.id,u.get("name"),u.content());
						},this);
     	  	      }
//#}                     
//#}
                  if (zcall!="") this.nodeAskingCall=zcall;

   
        c.each("userdata",function(u){
    	  		this.setUserData(c.get("id"),u.get("name"),u.content());
 	  	  },this)
		
		
	}
   	dhtmlXTreeObject.prototype._parse=function(p,parentId,level,start){ 
   		if (this._srnd && !this.parentObject.offsetHeight) {
   			var self=this;
   			return window.setTimeout(function(){
   				self._parse(p,parentId,level,start);
   			},100);
   		}
		if (!p.exists()) return;
		
		this.skipLock=true; //disable item locking
		//loading flags
		
		
		if (!parentId) {          //top level  
			parentId=p.get("id");
      var skey = p.get("dhx_security");
      if (skey)
          dhtmlx.security_key = skey;

			if (p.get("radio"))
				this.htmlNode._r_logic=true;
			this.parsingOn=parentId;                 
			this.parsedArray=new Array();
			this.setCheckList="";
			this.nodeAskingCall="";
		}
		
		var temp=this._globalIdStorageFind(parentId);
		if (!temp) return dhx4.callEvent("onDataStructureError",["XML refers to not existing parent"]);

		this.parsCount=this.parsCount?(this.parsCount+1):1;
		this.XMLloadingWarning=1;

		if ((temp.childsCount)&&(!start)&&(!this._edsbps)&&(!temp._has_top))
            var preNode=0;//temp.childNodes[temp.childsCount-1];
        else
            var preNode=0;

        this.npl=0;

		p.each("item",function(c,i){
				
		temp.XMLload=1;
				
          this._parseItem(c,temp,0,preNode); 
 	  	  
//#__pro_feature:01112006{
//#distributed_load:01112006{
              if ((this._edsbps)&&(this.npl==this._edsbpsC)){
                this._distributedStart(p,i+1,parentId,level,temp.childsCount);
                return -1;
              }
//#}
//#}
              this.npl++;
         

 	  	  
      },this,start);


      if (!level) {
      	  p.each("userdata",function(u){
    	  		this.setUserData(p.get("id"),u.get("name"),u.content());
 	  	  },this);
 	  	  
	  	 temp.XMLload=1;
         if (this.waitUpdateXML){
            this.waitUpdateXML=false;
			for (var i=temp.childsCount-1; i>=0; i--)
				if (temp.childNodes[i]._dmark)
					this.deleteItem(temp.childNodes[i].id);
			}

         var parsedNodeTop=this._globalIdStorageFind(this.parsingOn);

         for (var i=0; i<this.parsedArray.length; i++)
               temp.htmlNode.childNodes[0].appendChild(this.parsedArray[i]);
		this.parsedArray = [];
		
         this.lastLoadedXMLId=parentId;
         this.XMLloadingWarning=0;

         var chArr=this.setCheckList.split(this.dlmtr);
         for (var n=0; n<chArr.length; n++)
            if (chArr[n]) this.setCheck(chArr[n],1);

               if ((this.XMLsource)&&(this.tscheck)&&(this.smcheck)&&(temp.id!=this.rootId)){
                if (temp.checkstate===0)
                    this._setSubChecked(0,temp);
                else if (temp.checkstate===1)
                    this._setSubChecked(1,temp);
            }

         this._redrawFrom(this,null,start)
		 if (p.get("order") && p.get("order")!="none")
	  	 	this._reorderBranch(temp,p.get("order"),true);
	  	 	
	  	 if (this.nodeAskingCall!="") this.callEvent("onClick",[this.nodeAskingCall,this.getSelectedItemId()]); 
         if (this._branchUpdate) this._branchUpdateNext(p);
	     }


      if (this.parsCount==1) {
      	 this.parsingOn=null;
//#__pro_feature:01112006{
//#smart_parsing:01112006{
          //if ((this.slowParse)&&(this.parsingOn==this.rootId))
         if (this._srnd && temp.id!=this.rootId){
 	  	 	this.prepareSR(temp.id);
 	  	 	if (this.XMLsource) this.openItem(temp.id)
 	  	 }
 	  	 
            p.through("item","open",null,function(c){
            	this.openItem(c.get("id"));
            	},this);
//#}
//#}

         
         if ((!this._edsbps)||(!this._edsbpsA.length)){
         		var that=this;
               	window.setTimeout( function(){  that.callEvent("onXLE",[that,parentId]); },1);
                this.xmlstate=0;
                }
             this.skipLock=false;
         }
      this.parsCount--;

//#__pro_feature:01112006{
//#distributed_load:01112006{
		var that=this;
        if (this._edsbps) window.setTimeout(function(){ that._distributedStep(parentId); },this._edsbpsD);
//#}
//#}

        
		
		if (!level && this.onXLE) this.onXLE(this,parentId);
      return this.nodeAskingCall;
  };
  

dhtmlXTreeObject.prototype._branchUpdateNext=function(p){
	p.each("item",function(c){
		var nid=c.get("id");
		if (this._idpull[nid] && (!this._idpull[nid].XMLload))  return;
		this._branchUpdate++;
		this.smartRefreshItem(c.get("id"),c);
	},this)
	this._branchUpdate--;
} 

  dhtmlXTreeObject.prototype.checkUserData=function(node,parentId){
      if ((node.nodeType==1)&&(node.tagName == "userdata"))
      {
         var name=node.getAttribute("name");
            if ((name)&&(node.childNodes[0]))
               this.setUserData(parentId,name,node.childNodes[0].data);
      }
  }




/**  
*     @desc: reset tree images from selected level
*     @type: private
*     @param: dhtmlObject - tree
*     @param: itemObject - current item
*     @topic: 6
*/
   dhtmlXTreeObject.prototype._redrawFrom=function(dhtmlObject,itemObject,start,visMode){
      if (!itemObject) {
      var tempx=dhtmlObject._globalIdStorageFind(dhtmlObject.lastLoadedXMLId);
      dhtmlObject.lastLoadedXMLId=-1;
      if (!tempx) return 0;
      }
      else tempx=itemObject;
      var acc=0;
      for (var i=(start?start-1:0); i<tempx.childsCount; i++)
      {
	  	 if ((!this._branchUpdate)||(this._getOpenState(tempx)==1))
	         if ((!itemObject)||(visMode==1)) tempx.childNodes[i].htmlNode.parentNode.parentNode.style.display="";
         if (tempx.childNodes[i].openMe==1)
            {
            this._openItem(tempx.childNodes[i]);
            tempx.childNodes[i].openMe=0;
            }

         dhtmlObject._redrawFrom(dhtmlObject,tempx.childNodes[i]);
//#__pro_feature:01112006{
//#child_calc:01112006{
      if (this.childCalc!=null){

      if ((tempx.childNodes[i].unParsed)||((!tempx.childNodes[i].XMLload)&&(this.XMLsource)))
      {

         if (tempx.childNodes[i]._acc)
         tempx.childNodes[i].span.innerHTML=tempx.childNodes[i].label+this.htmlcA+tempx.childNodes[i]._acc+this.htmlcB;
         else
         tempx.childNodes[i].span.innerHTML=tempx.childNodes[i].label;
      }
         if ((tempx.childNodes[i].childNodes.length)&&(this.childCalc))
         {
            if (this.childCalc==1)
               {
               tempx.childNodes[i].span.innerHTML=tempx.childNodes[i].label+this.htmlcA+tempx.childNodes[i].childsCount+this.htmlcB;
               }
            if (this.childCalc==2)
               {
               var zCount=tempx.childNodes[i].childsCount-(tempx.childNodes[i].pureChilds||0);
               if (zCount)
                  tempx.childNodes[i].span.innerHTML=tempx.childNodes[i].label+this.htmlcA+zCount+this.htmlcB;
               if (tempx.pureChilds) tempx.pureChilds++; else tempx.pureChilds=1;
               }
            if (this.childCalc==3)
               {
               tempx.childNodes[i].span.innerHTML=tempx.childNodes[i].label+this.htmlcA+tempx.childNodes[i]._acc+this.htmlcB;
               }
            if (this.childCalc==4)
               {
               var zCount=tempx.childNodes[i]._acc;
               if (zCount)
                  tempx.childNodes[i].span.innerHTML=tempx.childNodes[i].label+this.htmlcA+zCount+this.htmlcB;
               }               
         }
            else if (this.childCalc==4)   {
               acc++;
               }   
            
         acc+=tempx.childNodes[i]._acc;
         
         if (this.childCalc==3){
            acc++;
         }

         }
//#}
//#}

      };

      if ((!tempx.unParsed)&&((tempx.XMLload)||(!this.XMLsource)))
      tempx._acc=acc;
      dhtmlObject._correctLine(tempx);
      dhtmlObject._correctPlus(tempx);
//#__pro_feature:01112006{
//#child_calc:01112006{
      if ((this.childCalc)&&(!itemObject)) dhtmlObject._fixChildCountLabel(tempx);
//#}
//#}
   };

/**
*     @desc: create and return main html element of tree
*     @type: private
*     @topic: 0  
*/
   dhtmlXTreeObject.prototype._createSelf=function(){
      var div=document.createElement('div');
      div.className="containerTableStyle";
      div.style.width=this.width;
      div.style.height=this.height;
      this.parentObject.appendChild(div);
      return div;
   };

/**
*     @desc: collapse target node
*     @type: private
*     @param: itemObject - item object
*     @topic: 4  
*/
   dhtmlXTreeObject.prototype._xcloseAll=function(itemObject)
   {
        if (itemObject.unParsed) return;
      if (this.rootId!=itemObject.id) {
      		if (!itemObject.htmlNode) return;//srnd
          var Nodes=itemObject.htmlNode.childNodes[0].childNodes;
            var Count=Nodes.length;

          for (var i=1; i<Count; i++)
             Nodes[i].style.display="none";

          this._correctPlus(itemObject);
      }

       for (var i=0; i<itemObject.childsCount; i++)
            if (itemObject.childNodes[i].childsCount)
             this._xcloseAll(itemObject.childNodes[i]);
   };
/**
*     @desc: expand target node
*     @type: private
*     @param: itemObject - item object
*     @topic: 4
*/      
   dhtmlXTreeObject.prototype._xopenAll=function(itemObject)
   {
      this._HideShow(itemObject,2);
      for (var i=0; i<itemObject.childsCount; i++)
         this._xopenAll(itemObject.childNodes[i]);
   };      
/**  
*     @desc: set correct tree-line and node images
*     @type: private
*     @param: itemObject - item object
*     @topic: 6  
*/
dhtmlXTreeObject.prototype._correctPlus=function(itemObject){
	if (!itemObject.htmlNode) return;
        var imsrc=itemObject.htmlNode.childNodes[0].childNodes[0].childNodes[0].lastChild;
        var imsrc2=itemObject.htmlNode.childNodes[0].childNodes[0].childNodes[2].childNodes[0];
        
        var workArray=this.lineArray;
        if ((this.XMLsource)&&(!itemObject.XMLload)) {
        	var workArray=this.plusArray;
        	this._setSrc(imsrc2,this.iconURL+itemObject.images[2]);
                if (this._txtimg) return (imsrc.innerHTML="[+]");
        } else if ((itemObject.childsCount)||(itemObject.unParsed)) {
        	if ((itemObject.htmlNode.childNodes[0].childNodes[1])&&( itemObject.htmlNode.childNodes[0].childNodes[1].style.display!="none" )) {
        		if (!itemObject.wsign) var workArray=this.minusArray;
        		this._setSrc(imsrc2,this.iconURL+itemObject.images[1]);
        		if (this._txtimg) return (imsrc.innerHTML="[-]");
        	} else {
        		if (!itemObject.wsign) var workArray=this.plusArray;
        		this._setSrc(imsrc2,this.iconURL+itemObject.images[2]);
        		if (this._txtimg) return (imsrc.innerHTML="[+]");
        	}
        } else {
        	this._setSrc(imsrc2,this.iconURL+itemObject.images[0]);
        }
        
        
        var tempNum=2;
        if (!itemObject.treeNod.treeLinesOn) {
        	this._setSrc(imsrc,this.imPath+workArray[3]);
        } else {
        	if (itemObject.parentObject) tempNum=this._getCountStatus(itemObject.id,itemObject.parentObject);
        	this._setSrc(imsrc,this.imPath+workArray[tempNum]);
        }
};

/**
*     @desc: set correct tree-line images
*     @type: private
*     @param: itemObject - item object
*     @topic: 6
*/
   dhtmlXTreeObject.prototype._correctLine=function(itemObject){
   	  if (!itemObject.htmlNode) return;
      var sNode=itemObject.parentObject;
      if (sNode)
         if ((this._getLineStatus(itemObject.id,sNode)==0)||(!this.treeLinesOn))
               for(var i=1; i<=itemObject.childsCount; i++){
                  if (!itemObject.htmlNode.childNodes[0].childNodes[i]) break;
                  itemObject.htmlNode.childNodes[0].childNodes[i].childNodes[0].style.backgroundImage="";
                  itemObject.htmlNode.childNodes[0].childNodes[i].childNodes[0].style.backgroundRepeat="";
                }
            else
               for(var i=1; i<=itemObject.childsCount; i++){
               	 if (!itemObject.htmlNode.childNodes[0].childNodes[i]) break;
               	 itemObject.htmlNode.childNodes[0].childNodes[i].childNodes[0].style.backgroundImage="url("+this.imPath+this.lineArray[5]+")";
               	 itemObject.htmlNode.childNodes[0].childNodes[i].childNodes[0].style.backgroundRepeat="repeat-y";
	     }
   };
/**
*     @desc: return type of node
*     @type: private
*     @param: itemId - item id
*     @param: itemObject - parent node object
*     @topic: 6
*/
   dhtmlXTreeObject.prototype._getCountStatus=function(itemId,itemObject){
      if (itemObject.childsCount<=1) { if (itemObject.id==this.rootId) return 4; else  return 0; }

      if (itemObject.childNodes[0].id==itemId) if (itemObject.id==this.rootId) return 2; else return 1;
      if (itemObject.childNodes[itemObject.childsCount-1].id==itemId) return 0;

      return 1;
   };
/**
*     @desc: return type of node
*     @type: private
*     @param: itemId - node id        
*     @param: itemObject - parent node object
*     @topic: 6
*/      
   dhtmlXTreeObject.prototype._getLineStatus =function(itemId,itemObject){
         if (itemObject.childNodes[itemObject.childsCount-1].id==itemId) return 0;
         return 1;
      }

/**  
*     @desc: open/close node 
*     @type: private
*     @param: itemObject - node object        
*     @param: mode - open/close mode [1-close 2-open](optional)
*     @topic: 6
*/      
   dhtmlXTreeObject.prototype._HideShow=function(itemObject,mode){
      if ((this.XMLsource)&&(!itemObject.XMLload)) {
            if (mode==1) return; //close for not loaded node - ignore it
            itemObject.XMLload=1;
            this._loadDynXML(itemObject.id);
            return; };
//#__pro_feature:01112006{
//#smart_parsing:01112006{
        if (itemObject.unParsed) this.reParse(itemObject);
//#}
//#}
      var Nodes=itemObject.htmlNode.childNodes[0].childNodes; var Count=Nodes.length;
      if (Count>1){
         if ( ( (Nodes[1].style.display!="none") || (mode==1) ) && (mode!=2) ) {
//nb:solves standard doctype prb in IE
          this.allTree.childNodes[0].border = "1";
          this.allTree.childNodes[0].border = "0";
         nodestyle="none";
         }
         else  nodestyle="";

      for (var i=1; i<Count; i++)
         Nodes[i].style.display=nodestyle;
      }
      this._correctPlus(itemObject);
   }

/**
*     @desc: return node state
*     @type: private
*     @param: itemObject - node object        
*     @topic: 6
*/
   dhtmlXTreeObject.prototype._getOpenState=function(itemObject){
   	  if (!itemObject.htmlNode) return 0; //srnd
   	  var z=itemObject.htmlNode.childNodes[0].childNodes;
      if (z.length<=1) return 0;
      if    (z[1].style.display!="none") return 1;
      else return -1;
   }

   

/**  
*     @desc: ondblclick item  event handler
*     @type: private
*     @topic: 0  
*/      
   dhtmlXTreeObject.prototype.onRowClick2=function(){
   	  var that=this.parentObject.treeNod;
      if (!that.callEvent("onDblClick",[this.parentObject.id,that])) return false;
      if ((this.parentObject.closeble)&&(this.parentObject.closeble!="0"))
         that._HideShow(this.parentObject);
      else
         that._HideShow(this.parentObject,2);

   	if    (that.checkEvent("onOpenEnd"))
           if (!that.xmlstate)
				that.callEvent("onOpenEnd",[this.parentObject.id,that._getOpenState(this.parentObject)]);
            else{
                that._oie_onXLE.push(that.onXLE);
                that.onXLE=that._epnFHe;
                }
    	return false;
   };
/**
*     @desc: onclick item event handler
*     @type: private
*     @topic: 0
*/
   dhtmlXTreeObject.prototype.onRowClick=function(){ 
    var that=this.parentObject.treeNod;
	  if (!that.callEvent("onOpenStart",[this.parentObject.id,that._getOpenState(this.parentObject)])) return 0;
      if ((this.parentObject.closeble)&&(this.parentObject.closeble!="0"))
         that._HideShow(this.parentObject);
      else
         that._HideShow(this.parentObject,2);

	
   if    (that.checkEvent("onOpenEnd"))
           if (!that.xmlstate)
				that.callEvent("onOpenEnd",[this.parentObject.id,that._getOpenState(this.parentObject)]);
            else{
                that._oie_onXLE.push(that.onXLE);
                that.onXLE=that._epnFHe;
                }

   };

      dhtmlXTreeObject.prototype._epnFHe=function(that,id,flag){
      	if (id!=this.rootId)
	  		this.callEvent("onOpenEnd",[id,that.getOpenState(id)]);
        that.onXLE=that._oie_onXLE.pop();
        
        if (!flag && !that._oie_onXLE.length)
			if (that.onXLE) that.onXLE(that,id);
    }



/**
*     @desc: onclick item image event handler
*     @type: private
*     @edition: Professional
*     @topic: 0  
*/
   dhtmlXTreeObject.prototype.onRowClickDown=function(e){
            e=e||window.event;
         var that=this.parentObject.treeNod;
         that._selectItem(this.parentObject,e);
      };


/*****
SELECTION
*****/

/**
*     @desc: retun selected item id
*     @type: public
*     @return: id of selected item
*     @topic: 1
*/
   dhtmlXTreeObject.prototype.getSelectedItemId=function()
   {
        var str=new Array();
        for (var i=0; i<this._selected.length; i++) str[i]=this._selected[i].id;
      return (str.join(this.dlmtr));
   };

/**
*     @desc: visual select item in tree
*     @type: private
*     @param: node - tree item object
*     @edition: Professional
*     @topic: 0
*/
   dhtmlXTreeObject.prototype._selectItem=function(node,e){
   		if (this.checkEvent("onSelect")) this._onSSCFold=this.getSelectedItemId();
//#__pro_feature:01112006{
//#multiselect:01112006{
        if ((!this._amsel)||(!e)||((!e.ctrlKey)&&(!e.metaKey)&&(!e.shiftKey)))
//#}
//#}
            this._unselectItems();
//#__pro_feature:01112006{
//#multiselect:01112006{
            if ((node.i_sel)&&(this._amsel)&&(e)&&(e.ctrlKey || e.metaKey))
                this._unselectItem(node);
            else
            if ((!node.i_sel)&&((!this._amselS)||(this._selected.length==0)||(this._selected[0].parentObject==node.parentObject)))
                if ((this._amsel)&&(e)&&(e.shiftKey)&&(this._selected.length!=0)&&(this._selected[this._selected.length-1].parentObject==node.parentObject)){
                    var a=this._getIndex(this._selected[this._selected.length-1]);
                    var b=this._getIndex(node);
                    if (b<a) { var c=a; a=b; b=c; }
                    for (var i=a; i<=b; i++)
                        if (!node.parentObject.childNodes[i].i_sel)
                            this._markItem(node.parentObject.childNodes[i]);
                    }
                else
//#}
//#}
					this._markItem(node);
		if (this.checkEvent("onSelect")) {
		   	var z=this.getSelectedItemId();
			if (z!=this._onSSCFold)
				this.callEvent("onSelect",[z]);
		}
    }
    dhtmlXTreeObject.prototype._markItem=function(node){
              if (node.scolor)  node.span.style.color=node.scolor;
              node.span.className="selectedTreeRow";
             node.i_sel=true;
             this._selected[this._selected.length]=node;
    }

/**
*     @desc: retun node index in children collection by Id
*     @type: public
*     @param: itemId - node id
*     @return: node index
*     @topic: 2
*/
   dhtmlXTreeObject.prototype.getIndexById=function(itemId){
         var z=this._globalIdStorageFind(itemId);
         if (!z) return null;
         return this._getIndex(z);
   };
   dhtmlXTreeObject.prototype._getIndex=function(w){
        var z=w.parentObject;
        for (var i=0; i<z.childsCount; i++)
            if (z.childNodes[i]==w) return i;
   };





/**
*     @desc: visual unselect item in tree
*     @type: private
*     @param: node - tree item object
*     @edition: Professional
*     @topic: 0
*/
   dhtmlXTreeObject.prototype._unselectItem=function(node){
        if ((node)&&(node.i_sel))
            {

          node.span.className="standartTreeRow";
          if (node.acolor)  node.span.style.color=node.acolor;
            node.i_sel=false;
            for (var i=0; i<this._selected.length; i++)
                    if (!this._selected[i].i_sel) {
                        this._selected.splice(i,1);
                        break;
                 }
            }
       }

/**
*     @desc: visual unselect items in tree
*     @type: private
*     @param: node - tree item object
*     @edition: Professional
*     @topic: 0
*/
   dhtmlXTreeObject.prototype._unselectItems=function(){
      for (var i=0; i<this._selected.length; i++){
            var node=this._selected[i];
         node.span.className="standartTreeRow";
          if (node.acolor)  node.span.style.color=node.acolor;
         node.i_sel=false;
         }
         this._selected=new Array();
       }


/**  
*     @desc: select node text event handler
*     @type: private
*     @param: e - event object
*     @param: htmlObject - node object     
*     @param: mode - if false - call onSelect event
*     @topic: 0  
*/
   dhtmlXTreeObject.prototype.onRowSelect=function(e,htmlObject,mode){
      e=e||window.event;

        var obj=this.parentObject;
      if (htmlObject) obj=htmlObject.parentObject;
        var that=obj.treeNod;

        var lastId=that.getSelectedItemId();
		if ((!e)||(!e.skipUnSel))
	        that._selectItem(obj,e);

      if (!mode) {	 	
         if (obj.actionHandler) obj.actionHandler(obj.id,lastId);
		 else that.callEvent("onClick",[obj.id,lastId]);
         }
   };




   
/**
*     @desc: fix checkbox state
*     @type: private
*     @topic: 0
*/
dhtmlXTreeObject.prototype._correctCheckStates=function(dhtmlObject){
	
   if (!this.tscheck) return;
   if (!dhtmlObject) return;
   if (dhtmlObject.id==this.rootId) return;
   //calculate state
   var act=dhtmlObject.childNodes;
   var flag1=0; var flag2=0;
   if (dhtmlObject.childsCount==0) return;
   for (var i=0; i<dhtmlObject.childsCount; i++){
   	  if (act[i].dscheck) continue;
      if (act[i].checkstate==0) flag1=1;
      else if (act[i].checkstate==1) flag2=1;
         else { flag1=1; flag2=1; break; }
		 }

   if ((flag1)&&(flag2)) this._setCheck(dhtmlObject,"unsure");
   else if (flag1)  this._setCheck(dhtmlObject,false);
      else  this._setCheck(dhtmlObject,true);

      this._correctCheckStates(dhtmlObject.parentObject);
}

/**
*     @desc: checbox select action
*     @type: private
*     @topic: 0
*/   
   dhtmlXTreeObject.prototype.onCheckBoxClick=function(e){
	   	  if (!this.treeNod.callEvent("onBeforeCheck",[this.parentObject.id,this.parentObject.checkstate]))
	   	  	return;
   	  
      if (this.parentObject.dscheck) return true;
      if (this.treeNod.tscheck)
         if (this.parentObject.checkstate==1) this.treeNod._setSubChecked(false,this.parentObject);
         else this.treeNod._setSubChecked(true,this.parentObject);
      else
         if (this.parentObject.checkstate==1) this.treeNod._setCheck(this.parentObject,false);
         else this.treeNod._setCheck(this.parentObject,true);
      this.treeNod._correctCheckStates(this.parentObject.parentObject);

      return this.treeNod.callEvent("onCheck",[this.parentObject.id,this.parentObject.checkstate]);
   };
/**
*     @desc: create HTML elements for tree node
*     @type: private
*     @param: acheck - enable/disable checkbox
*     @param: itemObject - item object
*     @param: mode - mode
*     @topic: 0
*/
dhtmlXTreeObject.prototype._createItem=function(acheck,itemObject,mode){
	
	var table=document.createElement('table');
	table.cellSpacing = 0;
	table.cellPadding = 0;
	table.border = 0;
	
	if (this.hfMode) table.style.tableLayout="fixed";
	table.style.margin = 0;
	table.style.padding = 0;
	
	var tbody=document.createElement('tbody');
	var tr=document.createElement('tr');
	
	var td1=document.createElement('td');
	td1.className="standartTreeImage";
	
	if(this._txtimg){
		var img0=document.createElement("div");
		td1.appendChild(img0);
		img0.className="dhx_tree_textSign";
	} else {
		var img0 = this._getImg(itemObject.id);
		img0.border = "0";
		if (img0.tagName == "IMG") {
			img0.align="absmiddle";
		}
		td1.appendChild(img0);
		img0.style.padding = 0;
		img0.style.margin = 0;
    img0.style.width = this.def_line_img_x;
    //img0.style.height = this.def_line_img_y;
	}
	
	var td11=document.createElement('td');
	//         var inp=document.createElement("input");            inp.type="checkbox"; inp.style.width="12px"; inp.style.height="12px";
	var inp=this._getImg(this.cBROf?this.rootId:itemObject.id);
	inp.checked=0; this._setSrc(inp,this.imPath+this.checkArray[0]); inp.style.width="18px"; inp.style.height="18px";
	//can cause problems with hide/show check
	
	if (!acheck) td11.style.display="none";
	
	// td11.className="standartTreeImage";
	//if (acheck)
	td11.appendChild(inp);
	if ((!this.cBROf)&&(inp.tagName=="IMG")) inp.align="absmiddle";
	inp.onclick=this.onCheckBoxClick;
	inp.treeNod=this;
	inp.parentObject=itemObject;
	if (!window._KHTMLrv) td11.width="20px";
	else td11.width="16px";
	
	var td12=document.createElement('td');
	td12.className="standartTreeImage";
	var img=this._getImg(this.timgen?itemObject.id:this.rootId);
	img.onmousedown=this._preventNsDrag; img.ondragstart=this._preventNsDrag;
	img.border="0";
	if (this._aimgs){
		img.parentObject=itemObject;
		if (img.tagName=="IMG") img.align="absmiddle";
	img.onclick=this.onRowSelect; }
	if (!mode) this._setSrc(img,this.iconURL+this.imageArray[0]);
	td12.appendChild(img); img.style.padding=0; img.style.margin=0;
	if (this.timgen)
	{  
	td12.style.width=img.style.width=this.def_img_x; img.style.height=this.def_img_y; }
	else
	{
                img.style.width="0px"; img.style.height="0px";
                if (_isOpera || window._KHTMLrv )    td12.style.display="none";
        }
        
        
        var td2=document.createElement('td');
        td2.className="standartTreeRow";
        
        itemObject.span=document.createElement('span');
        itemObject.span.className="standartTreeRow";
        if (this.mlitems) {
        	itemObject.span.style.width=this.mlitems;
        	//	if (!_isIE)
        	itemObject.span.style.display="block";
        }
        else td2.noWrap=true;
        if (_isIE && _isIE>7) td2.style.width="999999px";
        else if (!window._KHTMLrv) td2.style.width="100%";
        
        //      itemObject.span.appendChild(document.createTextNode(itemObject.label));
        itemObject.span.innerHTML=itemObject.label;
        td2.appendChild(itemObject.span);
        td2.parentObject=itemObject;        td1.parentObject=itemObject;
        td2.onclick=this.onRowSelect; td1.onclick=this.onRowClick; td2.ondblclick=this.onRowClick2;
        if (this.ettip)
        	tr.title=itemObject.label;
        
        if (this.dragAndDropOff) {
        	if (this._aimgs) { this.dragger.addDraggableItem(td12,this); td12.parentObject=itemObject; }
        	this.dragger.addDraggableItem(td2,this);
        }
        
        itemObject.span.style.paddingLeft="5px";      itemObject.span.style.paddingRight="5px";   td2.style.verticalAlign="";
        td2.style.fontSize="10pt";       td2.style.cursor=this.style_pointer;
        tr.appendChild(td1);            tr.appendChild(td11);            tr.appendChild(td12);
        tr.appendChild(td2);
        tbody.appendChild(tr);
        table.appendChild(tbody);
        
        if (this.ehlt || this.checkEvent("onMouseIn") || this.checkEvent("onMouseOut")){//highlighting
		tr.onmousemove=this._itemMouseIn;
		tr[(_isIE)?"onmouseleave":"onmouseout"]=this._itemMouseOut;
	}
	return table;
};
   

/**  
*     @desc: set path to images directory
*     @param: newPath - path to images directory (related to the page with tree or absolute http url)
*     @type: public
*     @topic: 0
*/
   dhtmlXTreeObject.prototype.setImagePath=function( newPath ){ this.imPath=newPath; this.iconURL=newPath; };
    /**
	*   @desc: set path to external images used as tree icons
	*   @type: public
	*   @param: path - url (or relative path) of images folder with closing "/"
	*   @topic: 0,7
	*/
	dhtmlXTreeObject.prototype.setIconPath=function(path){
		this.iconURL=path;
	}	   

//#__pro_feature:01112006{
//#child_calc:01112006{

/**
*     @desc: return count of leafs
*     @param: itemNode -  node object
*     @type: private
*     @edition: Professional
*     @topic: 4
*/
   dhtmlXTreeObject.prototype._getLeafCount=function(itemNode){
      var a=0;
      for (var b=0; b<itemNode.childsCount; b++)
         if (itemNode.childNodes[b].childsCount==0) a++;
      return a;
   }

/**
*     @desc: get value of child counter (child counter must be enabled)
*     @type: private
*     @param: itemId - id of selected item
*     @edition: Professional
*     @return: counter value (related to counter mode)
*     @topic: 6
*/
   dhtmlXTreeObject.prototype._getChildCounterValue=function(itemId){
      var temp=this._globalIdStorageFind(itemId);
      if (!temp) return 0;
      if ((temp.unParsed)||((!temp.XMLload)&&(this.XMLsource)))
      return temp._acc
      switch(this.childCalc)
      {
         case 1: return temp.childsCount; break;
         case 2: return this._getLeafCount(temp); break;
         case 3: return temp._acc; break;
         case 4: return temp._acc; break;
      }
   }

  /**
*     @desc: fix node child counter
*     @param: itemNode -  node object
*     @type: private
*     @edition: Professional
*     @topic: 4
*/
   dhtmlXTreeObject.prototype._fixChildCountLabel=function(itemNode,index){
      if (this.childCalc==null) return;
      if ((itemNode.unParsed)||((!itemNode.XMLload)&&(this.XMLsource)))
      {
         if (itemNode._acc)
         itemNode.span.innerHTML=itemNode.label+this.htmlcA+itemNode._acc+this.htmlcB;
         else
         itemNode.span.innerHTML=itemNode.label;

      return;
      }

      switch(this.childCalc){
         case 1:
            if (itemNode.childsCount!=0)
               itemNode.span.innerHTML=itemNode.label+this.htmlcA+itemNode.childsCount+this.htmlcB;
            else itemNode.span.innerHTML=itemNode.label;
            break;
         case 2:
            var z=this._getLeafCount(itemNode);
            if (z!=0)
               itemNode.span.innerHTML=itemNode.label+this.htmlcA+z+this.htmlcB;
            else itemNode.span.innerHTML=itemNode.label;
            break;
         case 3:
            if (itemNode.childsCount!=0)
               {
               var bcc=0;
               for (var a=0; a<itemNode.childsCount; a++)   {
                  if (!itemNode.childNodes[a]._acc) itemNode.childNodes[a]._acc=0;
                  bcc+=itemNode.childNodes[a]._acc*1;      }
                  bcc+=itemNode.childsCount*1;

               itemNode.span.innerHTML=itemNode.label+this.htmlcA+bcc+this.htmlcB;
               itemNode._acc=bcc;
               }
            else { itemNode.span.innerHTML=itemNode.label;   itemNode._acc=0; }
            if ((itemNode.parentObject)&&(itemNode.parentObject!=this.htmlNode))
               this._fixChildCountLabel(itemNode.parentObject);
            break;
         case 4:
            if (itemNode.childsCount!=0)
               {
               var bcc=0;
               for (var a=0; a<itemNode.childsCount; a++)   {
                  if (!itemNode.childNodes[a]._acc) itemNode.childNodes[a]._acc=1;
                  bcc+=itemNode.childNodes[a]._acc*1;      }

               itemNode.span.innerHTML=itemNode.label+this.htmlcA+bcc+this.htmlcB;
               itemNode._acc=bcc;
               }
            else { itemNode.span.innerHTML=itemNode.label;   itemNode._acc=1; }
            if ((itemNode.parentObject)&&(itemNode.parentObject!=this.htmlNode))
               this._fixChildCountLabel(itemNode.parentObject);
            break;
      }
   }

/**
*     @desc: set children calculation mode
*     @param: mode - mode name as string . Possible values: child - children, no recursive; leafs - children without subchildren, no recursive;  ,childrec - children, recursive; leafsrec - children without subchildren, recursive; disabled (disabled by default)
*     @type: public
*     @edition: Professional
*     @topic: 0
*/ 
   dhtmlXTreeObject.prototype.setChildCalcMode=function( mode ){
      switch(mode){
         case "child": this.childCalc=1; break;
         case "leafs": this.childCalc=2; break;
         case "childrec": this.childCalc=3; break;
         case "leafsrec": this.childCalc=4; break;
         case "disabled": this.childCalc=null; break;
         default: this.childCalc=4;
      }
    }
/**
*     @desc: set children calculation prefix and postfix
*     @param: htmlA - postfix ([ - by default)
*     @param: htmlB - postfix (] - by default)
*     @type: public
*     @edition: Professional
*     @topic: 0
*/
   dhtmlXTreeObject.prototype.setChildCalcHTML=function( htmlA,htmlB ){
      this.htmlcA=htmlA;      this.htmlcB=htmlB;
    }
//#}
//#}

/**
*     @desc: set function called when tree node selected
*     @param: (function) func - event handling function
*     @type: deprecated
*     @topic: 0,7
*     @event: onRightClick
*     @depricated: use grid.attachEvent("onRightClick",func); instead
*     @eventdesc:  Event occurs after right mouse button was clicked.
         Assigning this handler can disable default context menu, and incompattible with dhtmlXMenu integration.
*     @eventparam: (string) ID of clicked item
*     @eventparam: (object) event object
*/
   dhtmlXTreeObject.prototype.setOnRightClickHandler=function(func){  this.attachEvent("onRightClick",func);   };

/**
*     @desc: set function called when tree node clicked, also can be forced to call from API
*     @param: func - event handling function
*     @type: deprecated
*     @topic: 0,7
*     @event: onClick
*     @depricated: use grid.attachEvent("onClick",func); instead
*     @eventdesc: Event raises immideatly after text part of item in tree was clicked, but after default onClick functionality was processed.
              Richt mouse button click can be catched by onRightClick event handler.
*     @eventparam:  ID of clicked item
*     @eventparam:  ID of previously selected item
*/
   dhtmlXTreeObject.prototype.setOnClickHandler=function(func){  this.attachEvent("onClick",func);  };

/**
*     @desc: set function called when tree node selected or unselected, include any select change caused by any functionality
*     @param: func - event handling function
*     @type: deprecated
*     @topic: 0,7
*     @event: onSelect
*     @depricated: use grid.attachEvent("onSelect",func); instead
*     @eventdesc: Event raises immideatly after selection in tree was changed
*     @eventparam:  selected item ID ( list of IDs in case of multiselection)
*/
   dhtmlXTreeObject.prototype.setOnSelectStateChange=function(func){  this.attachEvent("onSelect",func); };


/**
*     @desc: enables dynamic loading from XML
*     @type: public
*     @param: filePath - name of script returning XML; in case of virtual loading - user defined function
*     @topic: 0  
*/
   dhtmlXTreeObject.prototype.setXMLAutoLoading=function(filePath){  this.XMLsource=filePath; };

   /**
*     @desc: set function called before checkbox checked/unchecked
*     @param: func - event handling function
*     @type: deprecated
*     @topic: 0,7
*     @event: onCheck
*     @depricated: use tree.attachEvent("onCheck",func); instead
*     @eventdesc: Event raises right before item in tree was checked/unchecked. can be canceled (return false from event handler)
*     @eventparam: ID of item which will be checked/unchecked
*     @eventparam: Current checkbox state. 1 - item checked, 0 - item unchecked.
*		@eventreturn: true - confirm changing checked state; false - deny chaning checked state;
*/
   dhtmlXTreeObject.prototype.setOnCheckHandler=function(func){ this.attachEvent("onCheck",func);  };


/**
*     @desc: set function called before tree node opened/closed
*     @param: func - event handling function
*     @type: deprecated
*     @topic: 0,7
*     @event:  onOpen
*     @depricated: use grid.attachEvent("onOpenStart",func); instead
*     @eventdesc: Event raises immideatly after item in tree got command to open/close , and before item was opened//closed. Event also raised for unclosable nodes and nodes without open/close functionality - in that case result of function will be ignored.
            Event does not occur if node was opened by dhtmlXtree API.
*     @eventparam: ID of node which will be opened/closed
*     @eventparam: Current open state of tree item. 0 - item has not children, -1 - item closed, 1 - item opened.
*     @eventreturn: true - confirm opening/closing; false - deny opening/closing;
*/
   dhtmlXTreeObject.prototype.setOnOpenHandler=function(func){  this.attachEvent("onOpenStart",func);   };
/**
*     @desc: set function called before tree node opened/closed
*     @param: func - event handling function
*     @type: deprecated
*     @topic: 0,7
*     @event:  onOpenStart
*     @depricated: use grid.attachEvent("onOpenStart",func); instead
*     @eventdesc: Event raises immideatly after item in tree got command to open/close , and before item was opened//closed. Event also raised for unclosable nodes and nodes without open/close functionality - in that case result of function will be ignored.
            Event not raised if node opened by dhtmlXtree API.
*     @eventparam: ID of node which will be opened/closed
*     @eventparam: Current open state of tree item. 0 - item has not children, -1 - item closed, 1 - item opened.
*     @eventreturn: true - confirm opening/closing; false - deny opening/closing;
*/
   dhtmlXTreeObject.prototype.setOnOpenStartHandler=function(func){  this.attachEvent("onOpenStart",func);    };

/**
*     @desc: set function called after tree node opened/closed
*     @param: func - event handling function
*     @type: deprecated
*     @topic: 0,7
*     @event:  onOpenEnd
*     @depricated: use grid.attachEvent("onOpenEnd",func); instead
*     @eventdesc: Event raises immideatly after item in tree was opened//closed. Event also raised for unclosable nodes and nodes without open/close functionality - in that case result of function will be ignored.
            Event not raised if node opened by dhtmlXtree API.
*     @eventparam: ID of node which will be opened/closed
*     @eventparam: Current open state of tree item. 0 - item has not children, -1 - item closed, 1 - item opened.
*/
   dhtmlXTreeObject.prototype.setOnOpenEndHandler=function(func){  this.attachEvent("onOpenEnd",func);  };

   /**
*     @desc: set function called when tree node double clicked
*     @param: func - event handling function
*     @type: public
*     @topic: 0,7
*     @event: onDblClick
*     @depricated: use grid.attachEvent("onDblClick",func); instead
*     @eventdesc: Event raised immideatly after item in tree was doubleclicked, before default onDblClick functionality was processed.
         Beware using both onClick and onDblClick events, because component can  generate onClick event before onDblClick event while doubleclicking item in tree.
         ( that behavior depend on used browser )
*     @eventparam:  ID of item which was doubleclicked
*     @eventreturn:  true - confirm opening/closing; false - deny opening/closing;
*/
   dhtmlXTreeObject.prototype.setOnDblClickHandler=function(func){ this.attachEvent("onDblClick",func);   };









   /**
*     @desc: expand target node and all sub nodes
*     @type: public
*     @param: itemId - node id
*     @topic: 4
*/
   dhtmlXTreeObject.prototype.openAllItems=function(itemId)
   {
      var temp=this._globalIdStorageFind(itemId);
      if (!temp) return 0;
      this._xopenAll(temp);
   };
   
/**
*     @desc: return open/close state
*     @type: public
*     @param: itemId - node id
*     @return: -1 - close, 1 - opened, 0 - node doesn't have children
*     @topic: 4
*/   
   dhtmlXTreeObject.prototype.getOpenState=function(itemId){
      var temp=this._globalIdStorageFind(itemId);
      if (!temp) return "";
      return this._getOpenState(temp);
   };

/**  
*     @desc: collapse target node and all sub nodes
*     @type: public
*     @param: itemId - node id
*     @topic: 4  
*/
   dhtmlXTreeObject.prototype.closeAllItems=function(itemId)
   {
        if (itemId===window.undefined) itemId=this.rootId;
        
      var temp=this._globalIdStorageFind(itemId);
      if (!temp) return 0;
      this._xcloseAll(temp);

//nb:solves standard doctype prb in IE
         this.allTree.childNodes[0].border = "1";
       this.allTree.childNodes[0].border = "0";

   };
   
   
/**
*     @desc: set user data for target node
*     @type: public
*     @param: itemId - target node id
*     @param: name - key for user data
*     @param: value - user data value
*     @topic: 5
*/
   dhtmlXTreeObject.prototype.setUserData=function(itemId,name,value){
      var sNode=this._globalIdStorageFind(itemId,0,true);
         if (!sNode) return;
         if(name=="hint")
			 sNode.htmlNode.childNodes[0].childNodes[0].title=value;
            if (typeof(sNode.userData["t_"+name])=="undefined"){
                 if (!sNode._userdatalist) sNode._userdatalist=name;
                else sNode._userdatalist+=","+name;
            }
            sNode.userData["t_"+name]=value;
   };
   
/**  
*     @desc: get user data from target node
*     @type: public
*     @param: itemId - target node id
*     @param: name - key for user data
*     @return: value of user data
*     @topic: 5
*/
   dhtmlXTreeObject.prototype.getUserData=function(itemId,name){
      var sNode=this._globalIdStorageFind(itemId,0,true);
      if (!sNode) return;
      return sNode.userData["t_"+name];
   };




/**
*     @desc: get node color (text color)
*     @param: itemId - id of node
*     @type: public
*     @return: color of node (empty string for default color);
*     @topic: 6  
*/   
   dhtmlXTreeObject.prototype.getItemColor=function(itemId)
   {
      var temp=this._globalIdStorageFind(itemId);
      if (!temp) return 0;

      var res= new Object();
      if (temp.acolor) res.acolor=temp.acolor;
      if (temp.scolor) res.scolor=temp.scolor;      
      return res;
   };
/**  
*     @desc: set node text color
*     @param: itemId - id of node
*     @param: defaultColor - node color
*     @param: selectedColor - selected node color
*     @type: public
*     @topic: 6
*/
   dhtmlXTreeObject.prototype.setItemColor=function(itemId,defaultColor,selectedColor)
   {
      if ((itemId)&&(itemId.span))
         var temp=itemId;
      else
         var temp=this._globalIdStorageFind(itemId);
      if (!temp) return 0;
         else {
         if (temp.i_sel)
            {  if (selectedColor) temp.span.style.color=selectedColor; }
         else
            {  if (defaultColor) temp.span.style.color=defaultColor;  }

         if (selectedColor) temp.scolor=selectedColor;
         if (defaultColor) temp.acolor=defaultColor;
         }
   };

/**
*     @desc: return node text
*     @param: itemId - id of node
*     @type: public
*     @return: text of item (with HTML formatting, if any)
*     @topic: 6
*/
   dhtmlXTreeObject.prototype.getItemText=function(itemId)
   {
      var temp=this._globalIdStorageFind(itemId);
      if (!temp) return 0;
      return(temp.htmlNode.childNodes[0].childNodes[0].childNodes[3].childNodes[0].innerHTML);
   };
/**  
*     @desc: return parent item id
*     @param: itemId - id of node
*     @type: public
*     @return: id of parent item
*     @topic: 4
*/         
   dhtmlXTreeObject.prototype.getParentId=function(itemId)
   {
      var temp=this._globalIdStorageFind(itemId);
      if ((!temp)||(!temp.parentObject)) return "";
      return temp.parentObject.id;
   };



/**  
*     @desc: change item id
*     @type: public
*     @param: itemId - old node id
*     @param: newItemId - new node id        
*     @topic: 4
*/    
   dhtmlXTreeObject.prototype.changeItemId=function(itemId,newItemId)
   {
   	if (itemId==newItemId) return;
      var temp=this._globalIdStorageFind(itemId);
      if (!temp) return 0;
        temp.id=newItemId;
        temp.span.contextMenuId=newItemId;
        this._idpull[newItemId]=this._idpull[itemId];
        delete this._idpull[itemId];
   };


/**
*     @desc: mark selected item as cut
*     @type: public
*     @topic: 2  
*/    
   dhtmlXTreeObject.prototype.doCut=function(){
      if (this.nodeCut) this.clearCut();
      this.nodeCut=(new Array()).concat(this._selected);
        for (var i=0; i<this.nodeCut.length; i++){
          var tempa=this.nodeCut[i];
            tempa._cimgs=new Array();
          tempa._cimgs[0]=tempa.images[0];
          tempa._cimgs[1]=tempa.images[1];
          tempa._cimgs[2]=tempa.images[2];
          tempa.images[0]=tempa.images[1]=tempa.images[2]=this.cutImage;
          this._correctPlus(tempa);
        }
   };

/**
*     @desc: insert previously cut branch
*     @param: itemId - id of new parent node
*     @type: public
*     @topic: 2  
*/    
   dhtmlXTreeObject.prototype.doPaste=function(itemId){
      var tobj=this._globalIdStorageFind(itemId);
      if (!tobj) return 0;
        for (var i=0; i<this.nodeCut.length; i++){
               if (this._checkPNodes(tobj,this.nodeCut[i])) continue;
                this._moveNode(this.nodeCut[i],tobj);
               }
      this.clearCut();
   };

/**  
*     @desc: clear cut
*     @type: public
*     @topic: 2  
*/
   dhtmlXTreeObject.prototype.clearCut=function(){
      for (var i=0; i<this.nodeCut.length; i++)
         {
          var tempa=this.nodeCut[i];
          tempa.images[0]=tempa._cimgs[0];
          tempa.images[1]=tempa._cimgs[1];
          tempa.images[2]=tempa._cimgs[2];
          this._correctPlus(tempa);
         }
          this.nodeCut=new Array();
   };
   


   /**  
*     @desc: move node with subnodes
*     @type: private
*     @param: itemObject - moved node object
*     @param: targetObject - new parent node
*     @topic: 2  
*/
   dhtmlXTreeObject.prototype._moveNode=function(itemObject,targetObject){
//#__pro_feature:01112006{
//#complex_move:01112006{
      var mode=this.dadmodec;
      if (mode==1)
        {
            var z=targetObject;
         if (this.dadmodefix<0)
         {

                while (true){
            z=this._getPrevNode(z);
            if ((z==-1)) { z=this.htmlNode; break; }
                if ((z.tr==0)||(z.tr.style.display=="")||(!z.parentObject)) break;
                }

                var nodeA=z;
                var nodeB=targetObject;

            }
            else
            {
				if ((z.tr)&&(z.tr.nextSibling)&&(z.tr.nextSibling.nodem)&&(this._getOpenState(z)<1)){
  				 	z = z.tr.nextSibling.nodem;
				}
           		else{
            	   z=this._getNextNode(z);
				   if ((z==-1)) z=this.htmlNode; 
				}
				
                var nodeB=z;
                var nodeA=targetObject;
            }


            if (this._getNodeLevel(nodeA,0)>this._getNodeLevel(nodeB,0))
                {
                if (!this.dropLower)
                    return this._moveNodeTo(itemObject,nodeA.parentObject);
                else
                    if  (nodeB.id!=this.rootId)
                        return this._moveNodeTo(itemObject,nodeB.parentObject,nodeB);
                    else
                        return this._moveNodeTo(itemObject,this.htmlNode,null);
                }
            else
                {
                return this._moveNodeTo(itemObject,nodeB.parentObject,nodeB);
                }


      }
      else
//#}
//#}
	  return this._moveNodeTo(itemObject,targetObject);

   }

   /**
*     @desc: fix order of nodes in collection
*     @type: private
*     @param: target - parent item node
*     @param: zParent - before node
*     @edition: Professional
*     @topic: 2
*/

dhtmlXTreeObject.prototype._fixNodesCollection=function(target,zParent){
      var flag=0; var icount=0;
      var Nodes=target.childNodes;
      var Count=target.childsCount-1;

      if (zParent==Nodes[Count]) return;
      for (var i=0; i<Count; i++)
         if (Nodes[i]==Nodes[Count]) {  Nodes[i]=Nodes[i+1]; Nodes[i+1]=Nodes[Count]; }

//         Count=target.childsCount;
      for (var i=0; i<Count+1; i++)      
         {
         if (flag) { 
            var temp=Nodes[i];
            Nodes[i]=flag; 
            flag=temp; 
               }
         else 
         if (Nodes[i]==zParent) {   flag=Nodes[i]; Nodes[i]=Nodes[Count];  }
         }
   };
   
/**  
*     @desc: recreate branch
*     @type: private
*     @param: itemObject - moved node object
*     @param: targetObject - new parent node
*     @param: level - top level flag
*     @param: beforeNode - node for sibling mode
*     @mode: mode - DragAndDrop mode (0 - as child, 1 as sibling)
*     @edition: Professional
*     @topic: 2
*/
dhtmlXTreeObject.prototype._recreateBranch=function(itemObject,targetObject,beforeNode,level){
    var i; var st="";
    if (beforeNode){
    for (i=0; i<targetObject.childsCount; i++)
        if (targetObject.childNodes[i]==beforeNode) break;

    if (i!=0)
        beforeNode=targetObject.childNodes[i-1];
    else{
        st="TOP";
        beforeNode="";
        }
    }

   var t2=this._onradh; this._onradh=null;
   var newNode=this._attachChildNode(targetObject,itemObject.id,itemObject.label,0,itemObject.images[0],itemObject.images[1],itemObject.images[2],st,0,beforeNode);

   //copy user data
   newNode._userdatalist=itemObject._userdatalist;
   newNode.userData=itemObject.userData.clone();
   if(itemObject._attrs){
	   newNode._attrs={};
	   for(var attr in itemObject._attrs)
		   newNode._attrs[attr] = itemObject._attrs[attr];
	}

   newNode.XMLload=itemObject.XMLload;
   if (t2){
   	this._onradh=t2; this._onradh(newNode.id); }

//#__pro_feature:01112006{
//#smart_parsing:01112006{
   //copy unparsed chunk
      if (itemObject.treeNod.dpcpy) itemObject.treeNod._globalIdStorageFind(itemObject.id);
      else newNode.unParsed=itemObject.unParsed;
      this._correctPlus(newNode);
      //this._correctLine(newNode);
   
//#}
//#}
   for (var i=0; i<itemObject.childsCount; i++)
      this._recreateBranch(itemObject.childNodes[i],newNode,0,1);

//#__pro_feature:01112006{
//#child_calc:01112006{
      if ((!level)&&(this.childCalc)) { this._redrawFrom(this,targetObject);  }
//#}
//#}
   return newNode;
}

/**
*     @desc: move single node
*     @type: private
*     @param: itemObject - moved node object
*     @param: targetObject - new parent node
*     @mode: mode - DragAndDrop mode (0 - as child, 1 as sibling)
*     @topic: 2
*/
   dhtmlXTreeObject.prototype._moveNodeTo=function(itemObject,targetObject,beforeNode){
    //return;
    if   (itemObject.treeNod._nonTrivialNode)
        return itemObject.treeNod._nonTrivialNode(this,targetObject,beforeNode,itemObject);

	if (this._checkPNodes(targetObject,itemObject))
   		return false;
                           		
    if    (targetObject.mytype)
       var framesMove=(itemObject.treeNod.lWin!=targetObject.lWin);
    else
          var framesMove=(itemObject.treeNod.lWin!=targetObject.treeNod.lWin);

   if (!this.callEvent("onDrag",[itemObject.id,targetObject.id,(beforeNode?beforeNode.id:null),itemObject.treeNod,targetObject.treeNod])) return false;
      if ((targetObject.XMLload==0)&&(this.XMLsource))
         {
         targetObject.XMLload=1;
            this._loadDynXML(targetObject.id);
         }
	this.openItem(targetObject.id);

   var oldTree=itemObject.treeNod;
   var c=itemObject.parentObject.childsCount;
   var z=itemObject.parentObject;
   

   if ((framesMove)||(oldTree.dpcpy)) {//interframe drag flag
        var _otiid=itemObject.id;
      itemObject=this._recreateBranch(itemObject,targetObject,beforeNode);
        if (!oldTree.dpcpy) oldTree.deleteItem(_otiid);
        }
   else
      {
	
      var Count=targetObject.childsCount; var Nodes=targetObject.childNodes;
      	   	if (Count==0) targetObject._open=true;
      		oldTree._unselectItem(itemObject);
           Nodes[Count]=itemObject;
            itemObject.treeNod=targetObject.treeNod;
            targetObject.childsCount++;         
			
            var tr=this._drawNewTr(Nodes[Count].htmlNode);

            if (!beforeNode)
               {
                  targetObject.htmlNode.childNodes[0].appendChild(tr);
               if (this.dadmode==1) this._fixNodesCollection(targetObject,beforeNode);
               }
            else
               {
               targetObject.htmlNode.childNodes[0].insertBefore(tr,beforeNode.tr);
               this._fixNodesCollection(targetObject,beforeNode);
               Nodes=targetObject.childNodes;
               }

			
         }

            if ((!oldTree.dpcpy)&&(!framesMove))   {
                var zir=itemObject.tr;

                if ((document.all)&&(navigator.appVersion.search(/MSIE\ 5\.0/gi)!=-1))
                    {
                    window.setTimeout(function() { zir.parentNode.removeChild(zir); } , 250 );
                    }
                else   //if (zir.parentNode) zir.parentNode.removeChild(zir,true);

                itemObject.parentObject.htmlNode.childNodes[0].removeChild(itemObject.tr);

                //itemObject.tr.removeNode(true);
            if ((!beforeNode)||(targetObject!=itemObject.parentObject)){
               for (var i=0; i<z.childsCount; i++){
                  if (z.childNodes[i].id==itemObject.id) {
                  z.childNodes[i]=0;
                  break;            }}}
               else z.childNodes[z.childsCount-1]=0;

            oldTree._compressChildList(z.childsCount,z.childNodes);
            z.childsCount--;
            }


      if ((!framesMove)&&(!oldTree.dpcpy)) {
       itemObject.tr=tr;
      tr.nodem=itemObject;
      itemObject.parentObject=targetObject;

      if (oldTree!=targetObject.treeNod) {
	    if(itemObject.treeNod._registerBranch(itemObject,oldTree)) return;      this._clearStyles(itemObject);  this._redrawFrom(this,itemObject.parentObject);
		if(this._onradh) this._onradh(itemObject.id);
		   };

      this._correctPlus(targetObject);
      this._correctLine(targetObject);

      this._correctLine(itemObject);
      this._correctPlus(itemObject);

         //fix target siblings
      if (beforeNode)
      {

         this._correctPlus(beforeNode);
         //this._correctLine(beforeNode);
      }
      else 
      if (targetObject.childsCount>=2)
      {

         this._correctPlus(Nodes[targetObject.childsCount-2]);
         this._correctLine(Nodes[targetObject.childsCount-2]);
      }
      
      this._correctPlus(Nodes[targetObject.childsCount-1]);
      //this._correctLine(Nodes[targetObject.childsCount-1]);


      if (this.tscheck) this._correctCheckStates(targetObject);
      if (oldTree.tscheck) oldTree._correctCheckStates(z);

      }

      //fix source parent

      if (c>1) { oldTree._correctPlus(z.childNodes[c-2]);
               oldTree._correctLine(z.childNodes[c-2]);
               }


//      if (z.childsCount==0)
          oldTree._correctPlus(z);
            oldTree._correctLine(z);

//#__pro_feature:01112006{
//#child_calc:01112006{
      this._fixChildCountLabel(targetObject);
      oldTree._fixChildCountLabel(z);
//#}
//#}
      this.callEvent("onDrop",[itemObject.id,targetObject.id,(beforeNode?beforeNode.id:null),oldTree,targetObject.treeNod]);
      return itemObject.id;
   };

   

/**
*     @desc: recursive set default styles for node
*     @type: private
*     @param: itemObject - target node object
*     @topic: 6  
*/   
   dhtmlXTreeObject.prototype._clearStyles=function(itemObject){
   		if (!itemObject.htmlNode) return; //some weird case in SRND mode
         var td1=itemObject.htmlNode.childNodes[0].childNodes[0].childNodes[1];
         var td3=td1.nextSibling.nextSibling;

         itemObject.span.innerHTML=itemObject.label;
		 itemObject.i_sel=false;

   		 if (itemObject._aimgs)
	         this.dragger.removeDraggableItem(td1.nextSibling);

         if (this.checkBoxOff) {
		 	td1.childNodes[0].style.display="";
			td1.childNodes[0].onclick=this.onCheckBoxClick;
			this._setSrc(td1.childNodes[0],this.imPath+this.checkArray[itemObject.checkstate]);
			}
         else td1.style.display="none";
         td1.childNodes[0].treeNod=this;

         this.dragger.removeDraggableItem(td3);
         if (this.dragAndDropOff) this.dragger.addDraggableItem(td3,this);
		 if (this._aimgs) this.dragger.addDraggableItem(td1.nextSibling,this);
		 		 
         td3.childNodes[0].className="standartTreeRow";
         td3.onclick=this.onRowSelect; td3.ondblclick=this.onRowClick2;
         td1.previousSibling.onclick=this.onRowClick;

         this._correctLine(itemObject);
         this._correctPlus(itemObject);
         for (var i=0; i<itemObject.childsCount; i++) this._clearStyles(itemObject.childNodes[i]); 

   };
/**
*     @desc: register node and all children nodes
*     @type: private
*     @param: itemObject - node object
*     @topic: 2  
*/
   dhtmlXTreeObject.prototype._registerBranch=function(itemObject,oldTree){
      if (oldTree) oldTree._globalIdStorageSub(itemObject.id);
      itemObject.id=this._globalIdStorageAdd(itemObject.id,itemObject);
      itemObject.treeNod=this;
         for (var i=0; i<itemObject.childsCount; i++)
            this._registerBranch(itemObject.childNodes[i],oldTree);
      return 0;
   };

   
/**  
*     @desc: enable three state checkboxes
*     @beforeInit: 1
*     @param: mode - 1 - on, 0 - off;
*     @type: public
*     @topic: 0  
*/
   dhtmlXTreeObject.prototype.enableThreeStateCheckboxes=function(mode) { this.tscheck=dhx4.s2b(mode); };


/**
*     @desc: set function called when mouse is over tree node
*     @param: func - event handling function
*     @type: deprecated
*     @topic: 0,7
*     @event: onMouseIn
*     @depricated: use grid.attachEvent("onMouseIn",func); instead
*     @eventdesc: Event raised immideatly after mouse started moving over item
*     @eventparam:  ID of item
*/
   dhtmlXTreeObject.prototype.setOnMouseInHandler=function(func){
    	this.ehlt=true;
   		this.attachEvent("onMouseIn",func);
	};

/**
*     @desc: set function called when mouse is out of tree node
*     @param: func - event handling function
*     @type: deprecated
*     @topic: 0,7
*     @event: onMouseOut
*     @depricated: use grid.attachEvent("onMouseOut",func); instead
*     @eventdesc: Event raised immideatly after mouse moved out of item
*     @eventparam:  ID of clicked item
*/
   dhtmlXTreeObject.prototype.setOnMouseOutHandler=function(func){
		this.ehlt=true;
   		this.attachEvent("onMouseOut",func);
	};





//#__pro_feature:01112006{
/**
*     @desc: enable drag without removing (copy instead of move)
*     @beforeInit: 1
*     @param: mode - 1 - on, 0 - off;
*     @type: public
*     @edition:Professional
*     @topic: 0
*/
   dhtmlXTreeObject.prototype.enableMercyDrag=function(mode){ this.dpcpy=dhx4.s2b(mode); };
//#}



/**
*     @desc: enable tree images
*     @beforeInit: 1
*     @param: mode - 1 - on, 0 - off;
*     @type: public
*     @topic: 0  
*/         
   dhtmlXTreeObject.prototype.enableTreeImages=function(mode) { this.timgen=dhx4.s2b(mode); };
   

   
/**
*     @desc: enable mode with fixed tables (looks better, but has no horisontal scrollbar)
*     @beforeInit: 1
*     @param: mode - 1 - on, 0 - off;
*     @type: private
*     @topic: 0  
*/
   dhtmlXTreeObject.prototype.enableFixedMode=function(mode) { this.hfMode=dhx4.s2b(mode); };
   
/**  
*     @desc: show/hide checkboxes (all checkboxes in tree)
*     @type: public
*     @param: mode - true/false
*     @param: hidden - if set to true, checkboxes not rendered but can be shown by showItemCheckbox
*     @topic: 0  
*/
   dhtmlXTreeObject.prototype.enableCheckBoxes=function(mode, hidden){ this.checkBoxOff=dhx4.s2b(mode); this.cBROf=(!(this.checkBoxOff||dhx4.s2b(hidden))); 
   	};
/**
*     @desc: set default images for nodes (must be called before XML loading)
*     @type: public
*     @param: a0 - image for node without children;
*     @param: a1 - image for closed node;
*     @param: a2 - image for opened node                  
*     @topic: 6  
*/
   dhtmlXTreeObject.prototype.setStdImages=function(image1,image2,image3){
                  this.imageArray[0]=image1; this.imageArray[1]=image2; this.imageArray[2]=image3;};

/**
*     @desc: enable/disable tree lines (parent-child threads)
*     @type: public
*     @param: mode - enable/disable tree lines
*     @topic: 6
*/                  
   dhtmlXTreeObject.prototype.enableTreeLines=function(mode){
      this.treeLinesOn=dhx4.s2b(mode);
   }

/**
*     @desc: set images used for parent-child threads drawing (lines, plus, minus)
*     @type: public
*     @param: arrayName - name of array: plus, minus
*     @param: image1 - line crossed image
*     @param: image2 - image with top line
*     @param: image3 - image with bottom line
*     @param: image4 - image without line
*     @param: image5 - single root image
*     @topic: 6
*/      
   dhtmlXTreeObject.prototype.setImageArrays=function(arrayName,image1,image2,image3,image4,image5){
      switch(arrayName){
      case "plus": this.plusArray[0]=image1; this.plusArray[1]=image2; this.plusArray[2]=image3; this.plusArray[3]=image4; this.plusArray[4]=image5; break;
      case "minus": this.minusArray[0]=image1; this.minusArray[1]=image2; this.minusArray[2]=image3; this.minusArray[3]=image4;  this.minusArray[4]=image5; break;
      }
   };

/**  
*     @desc: expand node
*     @param: itemId - id of node
*     @type: public
*     @topic: 4
*/ 
   dhtmlXTreeObject.prototype.openItem=function(itemId){
	   this.skipLock = true;
	   var temp=this._globalIdStorageFind(itemId);
	   if (!temp) return 0;
	   else return this._openItem(temp);
	   this.skipLock = false;
   };

/**  
*     @desc: expand node
*     @param: item - tree node object
*     @type: private
*     @editing: pro
*     @topic: 4  
*/ 
   dhtmlXTreeObject.prototype._openItem=function(item){ 
   		   var state=this._getOpenState(item);
		   if ((state<0)||(((this.XMLsource)&&(!item.XMLload)))){
	           if    (!this.callEvent("onOpenStart",[item.id,state])) return 0;
	           this._HideShow(item,2);
				   if    (this.checkEvent("onOpenEnd")){ 
						   if (this.onXLE==this._epnFHe) this._epnFHe(this,item.id,true);
	                       if (!this.xmlstate || !this.XMLsource)
	                       		this.callEvent("onOpenEnd",[item.id,this._getOpenState(item)]);
	                        else{
	                            this._oie_onXLE.push(this.onXLE);
	                            this.onXLE=this._epnFHe;
	                            }
							}
			   } else if (this._srnd) this._HideShow(item,2);
           if (item.parentObject && !this._skip_open_parent) this._openItem(item.parentObject);
   };
   
/**  
*     @desc: collapse node
*     @param: itemId - id of node
*     @type: public
*     @topic: 4  
*/
   dhtmlXTreeObject.prototype.closeItem=function(itemId){
	   if (this.rootId==itemId) return 0;
	   this.skipLock = true;
	   var temp=this._globalIdStorageFind(itemId);
	   if (!temp) return 0;
	   if (temp.closeble)
		   this._HideShow(temp,1);
	   this.skipLock = false;
   };
   
   

   
   
   
   
   

   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
      
/**
*     @desc: get node level (position in hierarchy)
*     @param: itemId - id of node
*     @type: public
*     @return: node level (0 if no such item in hierarchy - probably super root)
*     @topic: 4
*/
   dhtmlXTreeObject.prototype.getLevel=function(itemId){
      var temp=this._globalIdStorageFind(itemId);
      if (!temp) return 0;
      return this._getNodeLevel(temp,0);
   };
   
      

/**  
*     @desc: prevent node from closing
*     @param: itemId - id of node
*     @param: flag -  if 0 - node can't be closed, else node can be closed
*     @type: public
*     @topic: 4  
*/ 
   dhtmlXTreeObject.prototype.setItemCloseable=function(itemId,flag)
   {
      flag=dhx4.s2b(flag);
      if ((itemId)&&(itemId.span)) 
         var temp=itemId;
      else      
         var temp=this._globalIdStorageFind(itemId);
      if (!temp) return 0;
         temp.closeble=flag;
   };

   /**  
*     @desc: recursive function used for node level calculation
*     @param: itemObject - pointer to node object
*     @param: count - counter of levels        
*     @type: private
*     @topic: 4  
*/   
   dhtmlXTreeObject.prototype._getNodeLevel=function(itemObject,count){
      if (itemObject.parentObject) return this._getNodeLevel(itemObject.parentObject,count+1);
      return(count);
   };
   
   /**  
*     @desc: return number of children
*     @param: itemId - id of node
*     @type: public
*     @return: number of child items for loaded branches; true - for not loaded branches
*     @topic: 4
*/
   dhtmlXTreeObject.prototype.hasChildren=function(itemId){
      var temp=this._globalIdStorageFind(itemId);
      if (!temp) return 0;
      else 
         {
            if ( (this.XMLsource)&&(!temp.XMLload) ) return true;
            else 
               return temp.childsCount;
         };
   };
   

   /**
*     @desc: get number of leafs (nodes without children)
*     @param: itemNode -  node object
*     @type: private
*     @edition: Professional
*     @topic: 4
*/
   dhtmlXTreeObject.prototype._getLeafCount=function(itemNode){
      var a=0;
      for (var b=0; b<itemNode.childsCount; b++)
         if (itemNode.childNodes[b].childsCount==0) a++;
      return a;
   }

   
/**
*     @desc: set new node text (HTML allowed)
*     @param: itemId - id of node
*     @param: newLabel - node text
*     @param: newTooltip - (optional)tooltip for the node
*     @type: public
*     @topic: 6
*/
   dhtmlXTreeObject.prototype.setItemText=function(itemId,newLabel,newTooltip)
   {
      var temp=this._globalIdStorageFind(itemId);
      if (!temp) return 0;
      temp.label=newLabel;
      temp.span.innerHTML=newLabel;
//#__pro_feature:01112006{
//#child_calc:01112006{
        if (this.childCalc) this._fixChildCountLabel(temp);
//#}
//#}
	      temp.span.parentNode.parentNode.title=newTooltip||"";
   };

/**
*     @desc: get item's tooltip
*     @param: itemId - id of node
*     @type: public
*     @topic: 6
*/
    dhtmlXTreeObject.prototype.getItemTooltip=function(itemId){
      var temp=this._globalIdStorageFind(itemId);
      if (!temp) return "";
	  return (temp.span.parentNode.parentNode._dhx_title||temp.span.parentNode.parentNode.title||"");
   };

/**  
*     @desc: refresh tree branch from xml (XML with child nodes rerequested from server)
*     @param: itemId - id of node, if not defined tree super root used.
*     @type: public
*     @topic: 6  
*/
   dhtmlXTreeObject.prototype.refreshItem=function(itemId){
      if (!itemId) itemId=this.rootId;
      var temp=this._globalIdStorageFind(itemId);
      this.deleteChildItems(itemId);
        this._loadDynXML(itemId);
   };

   /**  
*     @desc: set item images
*     @param: itemId - id of node
*     @param: image1 - node without children icon
*     @param: image2 - closed node icon          
*     @param: image3 - open node icon         
*     @type: public
*     @topic: 6
*/
   dhtmlXTreeObject.prototype.setItemImage2=function(itemId, image1,image2,image3){
      var temp=this._globalIdStorageFind(itemId);
      if (!temp) return 0;
            temp.images[1]=image2;
            temp.images[2]=image3;
            temp.images[0]=image1;
      this._correctPlus(temp);
   };
/**
*     @desc: set item icons (mostly usefull for childless nodes)
*     @param: itemId - id of node
*     @param: image1 - node without children icon or closed node icon (if image2 specified)
*     @param: image2 - open node icon (optional)        
*     @type: public
*     @topic: 6  
*/   
   dhtmlXTreeObject.prototype.setItemImage=function(itemId,image1,image2)
   {
      var temp=this._globalIdStorageFind(itemId);
      if (!temp) return 0;
         if (image2)
         {
            temp.images[1]=image1;
            temp.images[2]=image2;
         }
         else temp.images[0]=image1;
      this._correctPlus(temp);
   };


/**
*     @desc: Returns the list of all subitems Ids from the next level of tree, separated by commas.
*     @param: itemId - id of node
*     @type: public
*     @return: list of all subitems from the next level of tree, separated by commas.
*     @topic: 6
*/
   dhtmlXTreeObject.prototype.getSubItems =function(itemId)
   {
      var temp=this._globalIdStorageFind(itemId,0,1);
      if (!temp) return 0;
//#__pro_feature:01112006{
//#smart_parsing:01112006{
        if(temp.unParsed)
            return (this._getSubItemsXML(temp.unParsed));
//#}
//#}
      var z="";
      for (i=0; i<temp.childsCount; i++){
         if (!z) z= ""+temp.childNodes[i].id;
            else z+=this.dlmtr+temp.childNodes[i].id;

                                                         }

      return z;
   };




/**
*     @desc: Returns the list of all sub items from all next levels of tree, separated by commas.
*     @param: itemId - id of node
*     @edition: Professional
*     @type: private
*     @topic: 6
*/
   dhtmlXTreeObject.prototype._getAllScraggyItems =function(node)
   {
      var z="";
      for (var i=0; i<node.childsCount; i++)
        {
            if ((node.childNodes[i].unParsed)||(node.childNodes[i].childsCount>0))
            {
                    if (node.childNodes[i].unParsed)
                        var zb=this._getAllScraggyItemsXML(node.childNodes[i].unParsed,1);
                    else
                       var zb=this._getAllScraggyItems(node.childNodes[i])

                 if (zb)
                        if (z) z+=this.dlmtr+zb;
                        else z=zb;
         }
            else
               if (!z) z=""+node.childNodes[i].id;
             else z+=this.dlmtr+node.childNodes[i].id;
         }
          return z;
   };





/**
*     @desc: Returns the list of all children items from all next levels of tree, separated by commas.
*     @param: itemId - id of node
*     @type: private
*     @edition: Professional
*     @topic: 6
*/

   dhtmlXTreeObject.prototype._getAllFatItems =function(node)
   {
      var z="";
      for (var i=0; i<node.childsCount; i++)
        {
            if ((node.childNodes[i].unParsed)||(node.childNodes[i].childsCount>0))
            {
             if (!z) z=""+node.childNodes[i].id;
                else z+=this.dlmtr+node.childNodes[i].id;

                    if (node.childNodes[i].unParsed)
                        var zb=this._getAllFatItemsXML(node.childNodes[i].unParsed,1);
                    else
                       var zb=this._getAllFatItems(node.childNodes[i])

                 if (zb) z+=this.dlmtr+zb;
         }
         }
          return z;
   };


/**
*     @desc: Returns the list of all children items from all next levels of tree, separated by commas.
*     @param: itemId - id of node
*     @type: private
*     @topic: 6
*/
   dhtmlXTreeObject.prototype._getAllSubItems =function(itemId,z,node)
   {
      if (node) temp=node;
      else {
      var temp=this._globalIdStorageFind(itemId);
         };
      if (!temp) return 0;

      z="";
      for (var i=0; i<temp.childsCount; i++)
         {
         if (!z) z=""+temp.childNodes[i].id;
            else z+=this.dlmtr+temp.childNodes[i].id;
         var zb=this._getAllSubItems(0,z,temp.childNodes[i])

         if (zb) z+=this.dlmtr+zb;
         }

//#__pro_feature:01112006{
//#smart_parsing:01112006{
        if (temp.unParsed)
            z=this._getAllSubItemsXML(itemId,z,temp.unParsed);
//#}
//#}
          return z;
   };




   
/**  
*     @desc: select node ( and optionaly fire onselect event)
*     @type: public
*     @param: itemId - node id
*     @param: mode - If true, script function for selected node will be called.
*     @param: preserve - preserve earlier selected nodes
*     @topic: 1
*/
   dhtmlXTreeObject.prototype.selectItem=function(itemId,mode,preserve){
      mode=dhx4.s2b(mode);
         var temp=this._globalIdStorageFind(itemId);
      if ((!temp)||(!temp.parentObject)) return 0;

            if (this.XMLloadingWarning)
                temp.parentObject.openMe=1;
            else
             	this._openItem(temp.parentObject);

      //temp.onRowSelect(0,temp.htmlNode.childNodes[0].childNodes[0].childNodes[3],mode);
        var ze=null;
        if (preserve)  {
			ze=new Object; ze.ctrlKey=true;
			if (temp.i_sel) ze.skipUnSel=true;
		}
      if (mode)
         this.onRowSelect(ze,temp.htmlNode.childNodes[0].childNodes[0].childNodes[3],false);
      else
         this.onRowSelect(ze,temp.htmlNode.childNodes[0].childNodes[0].childNodes[3],true);
   };
   
/**
*     @desc: retun selected node text
*     @type: public
*     @return: text of selected node (or list of all selected nodes text if more than one selected)
*     @topic: 1
*/
   dhtmlXTreeObject.prototype.getSelectedItemText=function()
   {
        var str=new Array();
        for (var i=0; i<this._selected.length; i++) str[i]=this._selected[i].span.innerHTML;
      return (str.join(this.dlmtr));
   };




/**  
*     @desc: correct childNode list after node deleting
*     @type: private
*     @param: Count - childNodes collection length        
*     @param: Nodes - childNodes collection
*     @topic: 4  
*/   
   dhtmlXTreeObject.prototype._compressChildList=function(Count,Nodes)
   {
      Count--;
      for (var i=0; i<Count; i++)
      {
         if (Nodes[i]==0) { Nodes[i]=Nodes[i+1]; Nodes[i+1]=0;}
      };
   };
/**  
*     @desc: delete node
*     @type: private
*     @param: itemId - target node id
*     @param: htmlObject - target node object        
*     @param: skip - node unregistration mode (optional, used by private methods)
*     @topic: 2
*/      
   dhtmlXTreeObject.prototype._deleteNode=function(itemId,htmlObject,skip){
   if ((!htmlObject)||(!htmlObject.parentObject)) return 0;
   var tempos=0; var tempos2=0;
   if (htmlObject.tr.nextSibling)  tempos=htmlObject.tr.nextSibling.nodem;
   if (htmlObject.tr.previousSibling)  tempos2=htmlObject.tr.previousSibling.nodem;
   
      var sN=htmlObject.parentObject;
      var Count=sN.childsCount;
      var Nodes=sN.childNodes;
            for (var i=0; i<Count; i++)
            {
               if (Nodes[i].id==itemId) { 
               if (!skip) sN.htmlNode.childNodes[0].removeChild(Nodes[i].tr);
               Nodes[i]=0;
               break;
               }
            }
      this._compressChildList(Count,Nodes);
      if (!skip) {
        sN.childsCount--;
                 }

      if (tempos) {
      this._correctPlus(tempos);
      this._correctLine(tempos);
               }
      if (tempos2) {
      this._correctPlus(tempos2);
      this._correctLine(tempos2);
               }
      if (this.tscheck) this._correctCheckStates(sN);

      if (!skip) {
        this._globalIdStorageRecSub(htmlObject);
                 }
   };
/**
*     @desc: set state of node's checkbox
*     @type: public
*     @param: itemId - target node id
*     @param: state - checkbox state (0/1/"unsure")
*     @topic: 5
*/
   dhtmlXTreeObject.prototype.setCheck=function(itemId,state){
      var sNode=this._globalIdStorageFind(itemId,0,1);
      if (!sNode) return;

        if (state==="unsure")
            this._setCheck(sNode,state);
        else
        {
      state=dhx4.s2b(state);
        if ((this.tscheck)&&(this.smcheck)) this._setSubChecked(state,sNode);
      else this._setCheck(sNode,state);
        }
      if (this.smcheck)
         this._correctCheckStates(sNode.parentObject);
   };

   dhtmlXTreeObject.prototype._setCheck=function(sNode,state){
   		if (!sNode) return;
        if (((sNode.parentObject._r_logic)||(this._frbtr))&&(state))
			if (this._frbtrs){
				if (this._frbtrL)   this.setCheck(this._frbtrL.id,0);
				this._frbtrL=sNode;
			} else
    	        for (var i=0; i<sNode.parentObject.childsCount; i++)
	                this._setCheck(sNode.parentObject.childNodes[i],0);

      var z=sNode.htmlNode.childNodes[0].childNodes[0].childNodes[1].childNodes[0];

      if (state=="unsure") sNode.checkstate=2;
      else if (state) sNode.checkstate=1; else sNode.checkstate=0;
      if (sNode.dscheck) sNode.checkstate=sNode.dscheck;
      this._setSrc(z,this.imPath+((sNode.parentObject._r_logic||this._frbtr)?this.radioArray:this.checkArray)[sNode.checkstate]);
   };

/**
*     @desc: change state of node's checkbox and all children checkboxes
*     @type: public
*     @param: itemId - target node id
*     @param: state - checkbox state
*     @topic: 5
*/
dhtmlXTreeObject.prototype.setSubChecked=function(itemId,state){
   var sNode=this._globalIdStorageFind(itemId);
   this._setSubChecked(state,sNode);
   this._correctCheckStates(sNode.parentObject);
}



/**  
*     @desc: change state of node's checkbox and all childnodes checkboxes
*     @type: private
*     @param: itemId - target node id
*     @param: state - checkbox state
*     @param: sNode - target node object (optional, used by private methods)
*     @topic: 5  
*/
   dhtmlXTreeObject.prototype._setSubChecked=function(state,sNode){
      state=dhx4.s2b(state);
      if (!sNode) return;
        if (((sNode.parentObject._r_logic)||(this._frbtr))&&(state))
            for (var i=0; i<sNode.parentObject.childsCount; i++)
                this._setSubChecked(0,sNode.parentObject.childNodes[i]);

//#__pro_feature:01112006{
//#smart_parsing:01112006{
      if (sNode.unParsed)
         this._setSubCheckedXML(state,sNode.unParsed)
//#}
//#}
        if (sNode._r_logic||this._frbtr)
           this._setSubChecked(state,sNode.childNodes[0]);
        else
      for (var i=0; i<sNode.childsCount; i++)
         {
             this._setSubChecked(state,sNode.childNodes[i]);
         };
      var z=sNode.htmlNode.childNodes[0].childNodes[0].childNodes[1].childNodes[0];

      if (state) sNode.checkstate=1;
      else    sNode.checkstate=0;
      if (sNode.dscheck)  sNode.checkstate=sNode.dscheck;



      this._setSrc(z,this.imPath+((sNode.parentObject._r_logic||this._frbtr)?this.radioArray:this.checkArray)[sNode.checkstate]);
   };

/**
*     @desc: get state of nodes's checkbox
*     @type: public
*     @param: itemId - target node id
*     @return: node state (0 - unchecked,1 - checked, 2 - third state)
*     @topic: 5  
*/      
   dhtmlXTreeObject.prototype.isItemChecked=function(itemId){
      var sNode=this._globalIdStorageFind(itemId);
      if (!sNode) return;      
      return   sNode.checkstate;
   };







/**
*     @desc: delete all children of node
*     @type: public
*     @param: itemId - node id
*     @topic: 2
*/
    dhtmlXTreeObject.prototype.deleteChildItems=function(itemId)
   {
      var sNode=this._globalIdStorageFind(itemId);
      if (!sNode) return;
      var j=sNode.childsCount;
      for (var i=0; i<j; i++)
      {
         this._deleteNode(sNode.childNodes[0].id,sNode.childNodes[0]);
      };
   };

/**
*     @desc: delete node
*     @type: public
*     @param: itemId - node id
*     @param: selectParent - If true parent of deleted item get selection, else no selected items leaving in tree.
*     @topic: 2  
*/      
dhtmlXTreeObject.prototype.deleteItem=function(itemId,selectParent){
    if ((!this._onrdlh)||(this._onrdlh(itemId))){
		var z=this._deleteItem(itemId,selectParent);
//#__pro_feature:01112006{
//#child_calc:01112006{
    if (z)
        this._fixChildCountLabel(z);
//#}
//#}
	}

    //nb:solves standard doctype prb in IE
      this.allTree.childNodes[0].border = "1";
      this.allTree.childNodes[0].border = "0";
}
/**
*     @desc: delete node
*     @type: private
*     @param: id - node id
*     @param: selectParent - If true parent of deleted item get selection, else no selected items leaving in tree.
*     @param: skip - unregistering mode (optional, used by private methods)        
*     @topic: 2  
*/
dhtmlXTreeObject.prototype._deleteItem=function(itemId,selectParent,skip){
      selectParent=dhx4.s2b(selectParent);
      var sNode=this._globalIdStorageFind(itemId);
      if (!sNode) return;
        var pid=this.getParentId(itemId);

      var zTemp=sNode.parentObject;
      this._deleteNode(itemId,sNode,skip);
      if(this._editCell&&this._editCell.id==itemId)
     	this._editCell = null;
      this._correctPlus(zTemp);
      this._correctLine(zTemp);

      if  ((selectParent)&&(pid!=this.rootId)) this.selectItem(pid,1);
      return    zTemp;
   };

/**
*     @desc: uregister all child nodes of target node
*     @type: private
*     @param: itemObject - node object
*     @topic: 3  
*/      
   dhtmlXTreeObject.prototype._globalIdStorageRecSub=function(itemObject){
      for(var i=0; i<itemObject.childsCount; i++)
      {
         this._globalIdStorageRecSub(itemObject.childNodes[i]);
         this._globalIdStorageSub(itemObject.childNodes[i].id);
      };
      this._globalIdStorageSub(itemObject.id);

      	  /*anti memory leaking*/
	  	var z=itemObject;
//		var par=z.span.parentNode.parentNode.childNodes;
//		par[0].parentObject=null;
//		par[1].childNodes[0].parentObject=null;
//		par[2].childNodes[0].parentObject=null;
//		par[2].childNodes[0].treeNod=null;
//		par[2].parentObject=null;
//		par[3].parentObject=null;
		z.span=null;
		z.tr.nodem=null;
		z.tr=null;
		z.htmlNode=null;
   };

/**  
*     @desc: create new node next to specified
*     @type: public
*     @param: itemId - node id
*     @param: newItemId - new node id
*     @param: itemText - new node text
*     @param: itemActionHandler - function fired on node select event (optional)
*     @param: image1 - image for node without children; (optional)
*     @param: image2 - image for closed node; (optional)
*     @param: image3 - image for opened node (optional)
*     @param: optionStr - options string (optional)            
*     @param: children - node children flag (for dynamical trees) (optional)
*     @topic: 2  
*/
   dhtmlXTreeObject.prototype.insertNewNext=function(itemId,newItemId,itemText,itemActionHandler,image1,image2,image3,optionStr,children){
      var sNode=this._globalIdStorageFind(itemId);
      if ((!sNode)||(!sNode.parentObject)) return (0);

      var nodez=this._attachChildNode(0,newItemId,itemText,itemActionHandler,image1,image2,image3,optionStr,children,sNode);
//#__pro_feature:01112006{
//#child_calc:01112006{
      if ((!this.XMLloadingWarning)&&(this.childCalc))  this._fixChildCountLabel(sNode.parentObject);
//#}
//#}
        return nodez;
   };


   
/**
*     @desc: retun node id by index
*     @type: public
*     @param: itemId - parent node id
*     @param: index - index of node, 0 based
*     @return: node id
*     @topic: 1
*/
   dhtmlXTreeObject.prototype.getItemIdByIndex=function(itemId,index){
       var z=this._globalIdStorageFind(itemId);
       if ((!z)||(index>=z.childsCount)) return null;
          return z.childNodes[index].id;
   };

/**
*     @desc: retun child node id by index
*     @type: public
*     @param: itemId - parent node id        
*     @param: index - index of child node
*     @return: node id
*     @topic: 1
*/      
   dhtmlXTreeObject.prototype.getChildItemIdByIndex=function(itemId,index){
       var z=this._globalIdStorageFind(itemId);
       if ((!z)||(index>=z.childsCount)) return null;
          return z.childNodes[index].id;
   };



   

/**
*     @desc: set function called when drag-and-drop event occured
*     @param: aFunc - event handling function
*     @type: deprecated
*     @topic: 0,7
*     @event:    onDrag
*     @depricated: use grid.attachEvent("onDrag",func); instead
*     @eventdesc: Event occured after item was dragged and droped on another item, but before item moving processed.
      Event also raised while programmatic moving nodes.
*     @eventparam:  ID of source item
*     @eventparam:  ID of target item
*     @eventparam:  if node droped as sibling then contain id of item before whitch source node will be inserted
*     @eventparam:  source Tree object
*     @eventparam:  target Tree object
*     @eventreturn:  true - confirm drag-and-drop; false - deny drag-and-drop;
*/
   dhtmlXTreeObject.prototype.setDragHandler=function(func){ this.attachEvent("onDrag",func); };
   
   /**
*     @desc: clear selection from node
*     @param: htmlNode - pointer to node object
*     @type: private
*     @topic: 1
*/
    dhtmlXTreeObject.prototype._clearMove=function(){
		if (this._lastMark){
	   		this._lastMark.className=this._lastMark.className.replace(/dragAndDropRow/g,"");
	   		this._lastMark=null;
		}
//#__pro_feature:01112006{
//#complex_move:01112006{
		this.selectionBar.style.display="none";
//#}
//#}
		this.allTree.className=this.allTree.className.replace(" selectionBox","");
   };

   /**  
*     @desc: enable/disable drag-and-drop
*     @type: public
*     @param: mode - enabled/disabled [ can be true/false/temporary_disabled - last value mean that tree can be D-n-D can be switched to true later ]
*     @param: rmode - enabled/disabled drag and drop on super root
*     @topic: 0
*/
   dhtmlXTreeObject.prototype.enableDragAndDrop=function(mode,rmode){
        if  (mode=="temporary_disabled"){
            this.dADTempOff=false;
            mode=true;                  }
        else
            this.dADTempOff=true;

      this.dragAndDropOff=dhx4.s2b(mode);
         if (this.dragAndDropOff) this.dragger.addDragLanding(this.allTree,this);
        if (arguments.length>1)
            this._ddronr=(!dhx4.s2b(rmode));
       };   

/**
*     @desc: set selection on node
*     @param: node - pointer to node object
*     @type: private
*     @topic: 1
*/    
   dhtmlXTreeObject.prototype._setMove=function(htmlNode,x,y){
      if (htmlNode.parentObject.span) {
      //window.status=x;
      var a1=dhx4.absTop(htmlNode);
      var a2=dhx4.absTop(this.allTree)-this.allTree.scrollTop;

      this.dadmodec=this.dadmode;//this.dadmode;
      this.dadmodefix=0;
//#__pro_feature:01112006{
//#complex_move:01112006{
      if (this.dadmode==2)
      {

      var z=y-a1+(document.body.scrollTop||document.documentElement.scrollTop)-2-htmlNode.offsetHeight/2;
      if ((Math.abs(z)-htmlNode.offsetHeight/6)>0)
      {
         this.dadmodec=1;
         //sibbling zone
         if (z<0)
            this.dadmodefix=0-htmlNode.offsetHeight;
      }
      else this.dadmodec=0;

      }
      if (this.dadmodec==0)
         {
//#}
//#} 

			var zN=htmlNode.parentObject.span;
			zN.className+=" dragAndDropRow";
			this._lastMark=zN;
//#__pro_feature:01112006{
//#complex_move:01112006{
         }
      else{
 	  	 this._clearMove();
         this.selectionBar.style.top=(a1-a2+((parseInt(htmlNode.parentObject.span.parentNode.previousSibling.childNodes[0].style.height)||18)-1)+this.dadmodefix)+"px";
         this.selectionBar.style.left="5px";
           if (this.allTree.offsetWidth>20)
                this.selectionBar.style.width=(this.allTree.offsetWidth-(_isFF?30:25))+"px";
         this.selectionBar.style.display="";
         }
//#}
//#}
         this._autoScroll(null,a1,a2);

      }
   };

dhtmlXTreeObject.prototype._autoScroll=function(node,a1,a2){
         if (this.autoScroll)
         {
		 	if (node){
				a1=dhx4.absTop(node);
	      		a2=dhx4.absTop(this.allTree)-this.allTree.scrollTop;
			}
            //scroll down
            if ( (a1-a2-parseInt(this.allTree.scrollTop))>(parseInt(this.allTree.offsetHeight)-50) )
               this.allTree.scrollTop=parseInt(this.allTree.scrollTop)+20;
            //scroll top
            if ( (a1-a2)<(parseInt(this.allTree.scrollTop)+30) )
               this.allTree.scrollTop=parseInt(this.allTree.scrollTop)-20;
         }
}

/**
*     @desc: create html element for dragging
*     @type: private
*     @param: htmlObject - html node object
*     @topic: 1
*/
dhtmlXTreeObject.prototype._createDragNode=function(htmlObject,e){
      if (!this.dADTempOff) return null;

     var obj=htmlObject.parentObject;
     if (!this.callEvent("onBeforeDrag",[obj.id, e])) return null;
    if (!obj.i_sel){

         this._selectItem(obj,e);
}
//#__pro_feature:01112006{
//#multiselect:01112006{
      this._checkMSelectionLogic();
//#}
//#}
      var dragSpan=document.createElement('div');

            var text=new Array();
            if (this._itim_dg)
                    for (var i=0; i<this._selected.length; i++)
                        text[i]="<table cellspacing='0' cellpadding='0'><tr><td><img width='18px' height='18px' src='"+this._getSrc(this._selected[i].span.parentNode.previousSibling.childNodes[0])+"'></td><td>"+this._selected[i].span.innerHTML+"</td></tr></table>";
            else
                text=this.getSelectedItemText().split(this.dlmtr);

            dragSpan.innerHTML=text.join("");
         dragSpan.style.position="absolute";
         dragSpan.className="dragSpanDiv";
      this._dragged=(new Array()).concat(this._selected);
     return dragSpan;
}



/**  
*     @desc: focus item in tree
*     @type: private
*     @param: item - node object
*     @edition: Professional
*     @topic: 0  
*/
dhtmlXTreeObject.prototype._focusNode=function(item){
	var z=dhx4.absTop(item.htmlNode)-dhx4.absTop(this.allTree);
	if ((z>(this.allTree.offsetHeight-30)) || (z<0))
		this.allTree.scrollTop=z+this.allTree.scrollTop;
};




              








///DragAndDrop

dhtmlXTreeObject.prototype._preventNsDrag=function(e){
   if ((e)&&(e.preventDefault)) { e.preventDefault(); return false; }
   return false;
}

dhtmlXTreeObject.prototype._drag=function(sourceHtmlObject,dhtmlObject,targetHtmlObject){
      if (this._autoOpenTimer) clearTimeout(this._autoOpenTimer);

      if (!targetHtmlObject.parentObject){
            targetHtmlObject=this.htmlNode.htmlNode.childNodes[0].childNodes[0].childNodes[1].childNodes[0];
            this.dadmodec=0;
            }

      this._clearMove();
      var z=sourceHtmlObject.parentObject.treeNod;
        if ((z)&&(z._clearMove))   z._clearMove("");

       if ((!this.dragMove)||(this.dragMove()))
          {
              if ((!z)||(!z._clearMove)||(!z._dragged)) var col=new Array(sourceHtmlObject.parentObject);
              else var col=z._dragged;
				var trg=targetHtmlObject.parentObject;

                for (var i=0; i<col.length; i++){
                   var newID=this._moveNode(col[i],trg);
				   if ((this.dadmodec)&&(newID!==false)) trg=this._globalIdStorageFind(newID,true,true);
                   if ((newID)&&(!this._sADnD)) this.selectItem(newID,0,1);
                }

         }
        if (z) z._dragged=new Array();


}

dhtmlXTreeObject.prototype._dragIn=function(htmlObject,shtmlObject,x,y){

                    if (!this.dADTempOff) return 0;
                    var fobj=shtmlObject.parentObject;
                    var tobj=htmlObject.parentObject;
	                if ((!tobj)&&(this._ddronr)) return;
                    if (!this.callEvent("onDragIn",[fobj.id,tobj?tobj.id:null,fobj.treeNod,this])){
                    	if (tobj) this._autoScroll(htmlObject);
                    	return 0;
                    }
						

					if (!tobj) 
		            	this.allTree.className+=" selectionBox";
					else
					{
	                    if (fobj.childNodes==null){
		                	this._setMove(htmlObject,x,y);
        	             	return htmlObject;
                    	}

	                    var stree=fobj.treeNod;
    	                for (var i=0; i<stree._dragged.length; i++)
                        	if (this._checkPNodes(tobj,stree._dragged[i])){
						   		this._autoScroll(htmlObject);
                           		return 0;
							}
//#__pro_feature:01112006{
//#complex_move:01112006{	 
				this.selectionBar.parentNode.removeChild(this.selectionBar);
				tobj.span.parentNode.appendChild(this.selectionBar);
//#}
//#}
                       this._setMove(htmlObject,x,y);
                       if (this._getOpenState(tobj)<=0){
                           var self = this;
                           this._autoOpenId=tobj.id;
                           this._autoOpenTimer=window.setTimeout(function(){
                             self._autoOpenItem(null, self);
                             self = null;
                           }, 1000);
                       }
					}
					
				return htmlObject;

}
dhtmlXTreeObject.prototype._autoOpenItem=function(e,treeObject){
   treeObject.openItem(treeObject._autoOpenId);
};
dhtmlXTreeObject.prototype._dragOut=function(htmlObject){
this._clearMove();
if (this._autoOpenTimer) clearTimeout(this._autoOpenTimer);
 }


//#__pro_feature:01112006{

/**  
*     @desc: return next node
*     @type: private
*     @param: item - node object
*     @param: mode - inner flag
*     @return: next node or -1
*     @topic: 2
*/
dhtmlXTreeObject.prototype._getNextNode=function(item,mode){
   if ((!mode)&&(item.childsCount)) return item.childNodes[0];
   if (item==this.htmlNode)
      return -1;
   if ((item.tr)&&(item.tr.nextSibling)&&(item.tr.nextSibling.nodem))
   return item.tr.nextSibling.nodem;

   return this._getNextNode(item.parentObject,true);
};

/**  
*     @desc: return last child of item (include all sub-child collections)
*     @type: private
*     @param: item - node object
*     @topic: 2  
*/
dhtmlXTreeObject.prototype._lastChild=function(item){
   if (item.childsCount)
      return this._lastChild(item.childNodes[item.childsCount-1]);
   else return item;
};

/**  
*     @desc: return previous node
*     @type: private
*     @param: item - node object
*     @param: mode - inner flag
*     @return: previous node or -1
*     @topic: 2  
*/
dhtmlXTreeObject.prototype._getPrevNode=function(node,mode){
   if ((node.tr)&&(node.tr.previousSibling)&&(node.tr.previousSibling.nodem))
   return this._lastChild(node.tr.previousSibling.nodem);

   if (node.parentObject)
      return node.parentObject;
   else return -1;
};



//#find_item:01112006{

/**
*     @desc: find tree item by text, select and focus it
*     @type: public
*     @param: searchStr - search text
*     @param: direction - 0: top -> bottom; 1: bottom -> top
*     @param: top - 1: start searching from top
*     @return: node id
*     @edition: Professional
*     @topic: 2
*/
dhtmlXTreeObject.prototype.findItem=function(searchStr,direction,top){
   var z=this._findNodeByLabel(searchStr,direction,(top?this.htmlNode:null));
   if (z){
      this.selectItem(z.id,true);
      this._focusNode(z);
      return z.id;
      }
      else return null;
}

/**  
*     @desc: find tree item by text
*     @type: public
*     @param: searchStr - search text
*     @param: direction - 0: top -> bottom; 1: bottom -> top
*     @param: top - 1: start searching from top
*     @return: node id
*     @edition: Professional
*     @topic: 2  
*/
dhtmlXTreeObject.prototype.findItemIdByLabel=function(searchStr,direction,top){
   var z=this._findNodeByLabel(searchStr,direction,(top?this.htmlNode:null));
   if (z)
      return z.id
   else return null;
}

//#smart_parsing:01112006{
/**  
*     @desc: find tree item by text in unParsed XML
*     @type: private
*     @param: node - start xml node
*     @param: field - name of xml attribute
*     @param: cvalue - search text
*     @return: true/false
*     @topic: 2  
*/
dhtmlXTreeObject.prototype.findStrInXML=function(node,field,cvalue){ 
   if (!node.childNodes && node.item) return this.findStrInJSON(node,field,cvalue);
   if(!node.childNodes)
       return false;
   for (var i=0; i<node.childNodes.length; i++)
   {
   if (node.childNodes[i].nodeType==1)
      {
      	
        var z=node.childNodes[i].getAttribute(field);
        if (!z && node.childNodes[i].tagName=="itemtext")  z=node.childNodes[i].firstChild.data; 
      if ((z)&&(z.toLowerCase().search(cvalue)!=-1))
         return true;
      if (this.findStrInXML(node.childNodes[i],field,cvalue)) return true;
      }
   }
   return false;
}
dhtmlXTreeObject.prototype.findStrInJSON=function(node,field,cvalue){ 
   for (var i=0; i<node.item.length; i++)
   {
	    var z=node.item[i].text;
        if ((z)&&(z.toLowerCase().search(cvalue)!=-1))
         return true;
      if (node.item[i].item && this.findStrInJSON(node.item[i],field,cvalue)) return true;
   }
   return false;
}
//#}

/**  
*     @desc: find tree item by text
*     @type: private
*     @param: searchStr - search text
*     @param: direction - 0: top -> bottom; 1: bottom -> top
*     @param: fromNode - node from which search begin
*     @return: node id
*     @topic: 2  
*/
dhtmlXTreeObject.prototype._findNodeByLabel=function(searchStr,direction,fromNode){
   //trim
   var searchStr=searchStr.replace(new RegExp("^( )+"),"").replace(new RegExp("( )+$"),"");
   searchStr =  new RegExp(searchStr.replace(/([\^\.\?\*\+\\\[\]\(\)]{1})/gi,"\\$1").replace(/ /gi,".*"),"gi");

   //get start node
   if (!fromNode)
      {
      fromNode=this._selected[0];
      if (!fromNode) fromNode=this.htmlNode;
      }

   var startNode=fromNode;

   //first step
   if (!direction){
      if ((fromNode.unParsed)&&(this.findStrInXML(fromNode.unParsed.d,"text",searchStr)))
      this.reParse(fromNode);
   fromNode=this._getNextNode(startNode);
   if (fromNode==-1) fromNode=this.htmlNode.childNodes[0];
   }
   else
   {
      var z2=this._getPrevNode(startNode);
      if (z2==-1) z2=this._lastChild(this.htmlNode);
      if ((z2.unParsed)&&(this.findStrInXML(z2.unParsed.d,"text",searchStr)))
      {   this.reParse(z2); fromNode=this._getPrevNode(startNode); }
      else fromNode=z2;
      if (fromNode==-1) fromNode=this._lastChild(this.htmlNode);
   }



   while ((fromNode)&&(fromNode!=startNode)){
      if ((fromNode.label)&&(fromNode.label.search(searchStr)!=-1))
            return (fromNode);

      if (!direction){
      if (fromNode==-1) { if (startNode==this.htmlNode) break; fromNode=this.htmlNode.childNodes[0]; }
      if ((fromNode.unParsed)&&(this.findStrInXML(fromNode.unParsed.d,"text",searchStr)))
         this.reParse(fromNode);
      fromNode=this._getNextNode(fromNode);
      if (fromNode==-1) fromNode=this.htmlNode;
      }
      else
      {
      var z2=this._getPrevNode(fromNode);
      if (z2==-1) z2=this._lastChild(this.htmlNode);
      if ((z2.unParsed)&&(this.findStrInXML(z2.unParsed.d,"text",searchStr)))
         {   this.reParse(z2); fromNode=this._getPrevNode(fromNode); }
      else fromNode=z2;
      if (fromNode==-1) fromNode=this._lastChild(this.htmlNode);
      }
   }
   return null;
};

//#}
//#}


//#complex_move:01112006{

/**
*     @desc: move item (inside of tree)
*     @type:  public
*     @param: itemId - item Id
*     @param: mode - moving mode (left,up,down,item_child,item_sibling,item_sibling_next,up_strict,down_strict)
*     @param: targetId - target Node in item_child and item_sibling mode
*     @param: targetTree - used for moving between trees (optional)
*     @return: node id
*     @topic: 2
*/
dhtmlXTreeObject.prototype.moveItem=function(itemId,mode,targetId,targetTree)
{
	var sNode=this._globalIdStorageFind(itemId);
	if (!sNode) return (0);
	var resultId = null;
	switch(mode){
		case "right":
			alert('Not supported yet');
			break;
		case "item_child":
			var tNode=(targetTree||this)._globalIdStorageFind(targetId);
			if (!tNode) return (0);
			resultId = (targetTree||this)._moveNodeTo(sNode,tNode,0);
			break;
		case "item_sibling":
			var tNode=(targetTree||this)._globalIdStorageFind(targetId);
			if (!tNode) return (0);
			resultId = (targetTree||this)._moveNodeTo(sNode,tNode.parentObject,tNode);
			break;
		case "item_sibling_next":
			var tNode=(targetTree||this)._globalIdStorageFind(targetId);
			if (!tNode) return (0);
			if ((tNode.tr)&&(tNode.tr.nextSibling)&&(tNode.tr.nextSibling.nodem))
				resultId = (targetTree||this)._moveNodeTo(sNode,tNode.parentObject,tNode.tr.nextSibling.nodem);
			else
				resultId = (targetTree||this)._moveNodeTo(sNode,tNode.parentObject);
			break;
		case "left":
			if (sNode.parentObject.parentObject)
				resultId = this._moveNodeTo(sNode,sNode.parentObject.parentObject,sNode.parentObject);
			break;
		case "up":
			var z=this._getPrevNode(sNode);
			if ((z==-1)||(!z.parentObject)) return null;
			resultId = this._moveNodeTo(sNode,z.parentObject,z);
			break;
		case "up_strict":
			var z=this._getIndex(sNode);
			if (z!=0)
				resultId = this._moveNodeTo(sNode,sNode.parentObject,sNode.parentObject.childNodes[z-1]);
			break;
		case "down_strict":
			var z=this._getIndex(sNode);
			var count=sNode.parentObject.childsCount-2;
			if (z==count)
				resultId = this._moveNodeTo(sNode,sNode.parentObject);
			else if (z<count)
				resultId = this._moveNodeTo(sNode,sNode.parentObject,sNode.parentObject.childNodes[z+2]);
			break;
		case "down":
			var z=this._getNextNode(this._lastChild(sNode));
			if ((z==-1)||(!z.parentObject)) return;
			if (z.parentObject==sNode.parentObject)
				var z=this._getNextNode(z);
			if (z==-1){
				resultId = this._moveNodeTo(sNode,sNode.parentObject);
			}
			else{
				if ((z==-1)||(!z.parentObject)) return;
				resultId = this._moveNodeTo(sNode,z.parentObject,z);
			}
			break;
	}
	if (_isIE && _isIE<8){
		this.allTree.childNodes[0].border = "1";
		this.allTree.childNodes[0].border = "0";
	}
	return resultId;
}

//#__pro_feature:01112006{

/**
*     @desc: set Drag-And-Drop behavior (child - drop as chils, sibling - drop as sibling, complex - complex drop behaviour )
*     @type: public
*     @edition: Professional
*     @param: mode - behavior name (child,sibling,complex)
*     @param: select - select droped node after drag-n-drop, true by default
*     @topic: 0
*/
   dhtmlXTreeObject.prototype.setDragBehavior=function(mode,select){
		this._sADnD=(!dhx4.s2b(select));
		switch (mode) {
			case "child": this.dadmode=0; break;
			case "sibling": this.dadmode=1; break;
			case "complex": this.dadmode=2; break;
		}    };




//#}
//#}







/**
*     @desc: load xml for tree branch
*     @param: id - id of parent node
*     @param: src - path to xml, optional
*     @type: private
*     @topic: 1
*/
   dhtmlXTreeObject.prototype._loadDynXML=function(id,src) {
   		src=src||this.XMLsource;
        var sn=(new Date()).valueOf();
        this._ld_id=id;
//#__pro_feature:01112006{
        if (this.xmlalb=="function"){
            if (src) src(this._escape(id));
            }
        else
        if (this.xmlalb=="name")
            this.loadXML(src+this._escape(id));
        else
        if (this.xmlalb=="xmlname")
            this.loadXML(src+this._escape(id)+".xml?uid="+sn);
        else
//#}
            this.loadXML(src+dhtmlx.url(src)+"uid="+sn+"&id="+this._escape(id));
        };


//#__pro_feature:01112006{
//#multiselect:01112006{
/**
*     @desc: enable multiselection
*     @beforeInit: 1
*     @param: mode - 1 - on, 0 - off;
*     @param: strict - 1 - on, 0 - off; in strict mode only items on the same level can be selected
*     @type: public
*     @edition: Professional
*     @topic: 0
*/
   dhtmlXTreeObject.prototype.enableMultiselection=function(mode,strict) {
        this._amsel=dhx4.s2b(mode);
        this._amselS=dhx4.s2b(strict);
        };

/**
*     @desc: check logic of selection
*     @type: private
*     @edition: Professional
*     @topic: 0
*/
dhtmlXTreeObject.prototype._checkMSelectionLogic=function() {
            var usl=new Array();
         for (var i=0; i<this._selected.length; i++)
            for (var j=0; j<this._selected.length; j++)
                  if ((i!=j)&&(this._checkPNodes(this._selected[j],this._selected[i])))
                            usl[usl.length]=this._selected[j];

         for (var i=0; i<usl.length; i++)
             this._unselectItem(usl[i]);

         };
//#}
//#}




/**
*     @desc: check possibility of drag-and-drop
*     @type: private
*     @param: itemId - draged node id
*     @param: htmlObject - droped node object
*     @param: shtmlObject - sourse node object
*     @topic: 6
*/
    dhtmlXTreeObject.prototype._checkPNodes=function(item1,item2){
      if (this._dcheckf) return false;
      if (item2==item1) return 1
      if (item1.parentObject) return this._checkPNodes(item1.parentObject,item2); else return 0;
   };
   dhtmlXTreeObject.prototype.disableDropCheck = function(mode){
      this._dcheckf = dhx4.s2b(mode);
   };


//#__pro_feature:01112006{
//#distributed_load:01112006{

/**
*     @desc: enable distributed parsing of big tree (items loaded portion by portion with some timeouts)
*     @type: public
*     @edition: Professional
*     @param: mode - true/false
*     @param: count - critical count to start distibuting (optional)
*     @param: delay - delay between distributed calls, ms (optional)
*     @topic: 2
*/
dhtmlXTreeObject.prototype.enableDistributedParsing=function(mode,count,delay){
    this._edsbps=dhx4.s2b(mode);
    this._edsbpsA=new Array();
    this._edsbpsC=count||10;
    this._edsbpsD=delay||250;
}
/**
*     @desc: get current state of distributed parsing
*     @type: public
*     @edition: Professional
*     @returns: true - still parsing; false - parsing finished
*     @topic: 2
*/
dhtmlXTreeObject.prototype.getDistributedParsingState=function(){
    return (!((!this._edsbpsA)||(!this._edsbpsA.length)));
}
/**
*     @desc: get current parsing state of item
*     @type: public
*     @edition: Professional
*     @returns: 1 - item already parsed; 0 - item not parsed yet; -1 - item in parsing process
*     @topic: 2
*/
dhtmlXTreeObject.prototype.getItemParsingState=function(itemId){
    var z=this._globalIdStorageFind(itemId,true,true)
    if (!z) return 0;
    if (this._edsbpsA)
        for (var i=0; i<this._edsbpsA.length; i++)
            if (this._edsbpsA[i][2]==itemId) return -1;

    return 1;
}

dhtmlXTreeObject.prototype._distributedStart=function(node,start,parentId,level,start2){
    if (!this._edsbpsA)
        this._edsbpsA=new Array();
    this._edsbpsA[this._edsbpsA.length]=[node,start,parentId,level,start2];
}

dhtmlXTreeObject.prototype._distributedStep=function(pId){
    var self=this;
    if ((!this._edsbpsA)||(!this._edsbpsA.length)) {
         self.XMLloadingWarning=0;
         return;
         }
    var z=this._edsbpsA[0];
    this.parsedArray=new Array();
    this._parse(z[0],z[2],z[3],z[1]);
    var zkx=this._globalIdStorageFind(z[2]);
    this._redrawFrom(this,zkx,z[4],this._getOpenState(zkx));
    var chArr=this.setCheckList.split(this.dlmtr);
   for (var n=0; n<chArr.length; n++)
      if (chArr[n]) this.setCheck(chArr[n],1);

    this._edsbpsA=(new Array()).concat(this._edsbpsA.slice(1));


    if ((!this._edsbpsA.length)){
         window.setTimeout( function(){ if (self.onXLE) self.onXLE(self,pId); self.callEvent("onXLE",[self,pId]); },1);
            self.xmlstate=0;
            }
}

//#}
//#}




//#__pro_feature:01112006{

/**
*     @desc: replace images with text signs
*     @type: public
*     @param: mode - true/false
*     @edition: Professional
*     @topic: 1
*/
dhtmlXTreeObject.prototype.enableTextSigns=function(mode){
    this._txtimg=dhx4.s2b(mode);
}

//#}

/**
*   @desc:  prevent caching in IE  by adding random value to URL string
*   @param: mode - enable/disable random value ( disabled by default )
*   @type: public
*   @topic: 0
*/
dhtmlXTreeObject.prototype.preventIECaching=function(mode){
      dhx4.ajax.cache = !mode;
}
dhtmlXTreeObject.prototype.preventIECashing=dhtmlXTreeObject.prototype.preventIECaching;





/**
*     @desc: disable checkbox
*     @param: itemId - Id of tree item
*     @param: mode - 1 - on, 0 - off;
*     @type: public
*     @topic: 5
*/
   dhtmlXTreeObject.prototype.disableCheckbox=function(itemId,mode) {
            if (typeof(itemId)!="object")
             var sNode=this._globalIdStorageFind(itemId,0,1);
            else
                var sNode=itemId;
         if (!sNode) return;
            sNode.dscheck=dhx4.s2b(mode)?(((sNode.checkstate||0)%3)+3):((sNode.checkstate>2)?(sNode.checkstate-3):sNode.checkstate);
            this._setCheck(sNode);
                if (sNode.dscheck<3) sNode.dscheck=false;
         };

//#__pro_feature:01112006{


/**
*     @desc: refresh specified tree branch (get XML from server, add new nodes, remove not used nodes)
*     @param: itemId -  top node in branch
*     @param: source - server side script , optional
*     @type: public
*     @edition: Professional
*     @topic: 6
*/
   dhtmlXTreeObject.prototype.smartRefreshBranch=function(itemId,source){
   		this._branchUpdate=1;
		this.smartRefreshItem(itemId,source);
   }

/**
*     @desc: refresh specified tree item (get XML from server, add new nodes, remove not used nodes)
*     @param: itemId -  top node in branch
*     @param: source - server side script , optional
*     @type: public
*     @edition: Professional
*     @topic: 6
*/
dhtmlXTreeObject.prototype.smartRefreshItem=function(itemId,source){
		var sNode=this._globalIdStorageFind(itemId);
		for (var i=0; i<sNode.childsCount; i++)
			sNode.childNodes[i]._dmark=true;

		this.waitUpdateXML=true;
		if (source && source.exists)
			this._parse(source,itemId);
		else
			this._loadDynXML(itemId,source);
};


/**
*     @desc: refresh specified tree nodes (get XML from server and updat only nodes included in itemIdList)
*     @param: itemIdList - list of node identificators
*     @param: source - server side script
*     @type: public
*     @edition: Professional
*     @topic: 6
*/
   dhtmlXTreeObject.prototype.refreshItems=function(itemIdList,source){
   		var z=itemIdList.toString().split(this.dlmtr);
		this.waitUpdateXML=new Array();
		for (var i=0; i<z.length; i++)
			this.waitUpdateXML[z[i]]=true;
        this.loadXML((source||this.XMLsource)+dhtmlx.url(source||this.XMLsource)+"ids="+this._escape(itemIdList));
   };


/**
*     @desc: update item properties
*     @param: itemId - list of node identificators
*     @param: name - list of node identificators, optional
*     @param: im0 - list of node identificators, optional
*     @param: im1 - list of node identificators, optional
*     @param: im2 - list of node identificators, optional
*     @param: achecked - list of node identificators, optional
*     @param: child - child attribute for dynamic loading
*     @type: public
*     @edition: Professional
*     @topic: 6
*/
   dhtmlXTreeObject.prototype.updateItem=function(itemId,name,im0,im1,im2,achecked,child){
      var sNode=this._globalIdStorageFind(itemId);
	  sNode.userData=new cObject(); 
      if (name) sNode.label=name;
      sNode.images=new Array(im0||this.imageArray[0],im1||this.imageArray[1],im2||this.imageArray[2]);
	  this.setItemText(itemId,name);
      if (achecked) this._setCheck(sNode,true);
	  if(child=="1" && !this.hasChildren(itemId)) sNode.XMLload = 0;
      this._correctPlus(sNode);
	  sNode._dmark=false;
      return sNode;
   };

/**
*     @desc: set function called after drag-and-drap event occured
*     @param: func - event handling function
*     @type: deprecated
*     @edition: Professional
*     @topic: 0,7
*     @event:  onDrop
*     @depricated: use grid.attachEvent("onDrop",func); instead
*     @eventdesc:  Event raised after drag-and-drop processed. Event also raised while programmatic moving nodes.
*     @eventparam:  ID of source item (ID after inserting in tree, my be not equal to initial ID)
*     @eventparam:  ID of target item
*     @eventparam:  if node droped as sibling then contain id of item before whitch source node will be inserted
*     @eventparam:  source Tree object
*     @eventparam:  target Tree object
*/
   dhtmlXTreeObject.prototype.setDropHandler=function(func){  this.attachEvent("onDrop",func);  };

/**
*     @desc: set function called before xml loading/parsing started
*     @param: func - event handling function
*     @type: deprecated
*     @edition: Professional
*     @topic: 0,7
*     @event:  onXLS
*     @depricated: use grid.attachEvent("onXLS",func); instead
*     @eventdesc: event fired simultaneously with starting XML parsing
*     @eventparam: tree object
*     @eventparam: item id, for which xml loaded
*/
   dhtmlXTreeObject.prototype.setOnLoadingStart=function(func){    this.attachEvent("onXLS",func);  };
      /**
*     @desc: set function called after xml loading/parsing ended
*     @param: func - event handling function
*     @type: deprecated
*     @edition: Professional
*     @topic: 0,7
*     @event:  onXLE
*     @depricated: use grid.attachEvent("onXLE",func); instead
*     @eventdesc: event fired simultaneously with ending XML parsing, new items already available in tree
*     @eventparam: tree object
*     @eventparam: last parsed parent id
*/
     dhtmlXTreeObject.prototype.setOnLoadingEnd=function(func){  this.attachEvent("onXLE",func); };



/**
*     @desc: define which script be called on dynamic loading
*     @param: mode - id for some_script?id=item_id ;  name for  some_scriptitem_id, xmlname for  some_scriptitem_id.xml ; function for calling user defined handler
*     @type: public
*     @edition: Professional
*     @topic: 1
*/
   dhtmlXTreeObject.prototype.setXMLAutoLoadingBehaviour=function(mode) {
            this.xmlalb=mode;
         };


/**
*     @desc: enable smart checkboxes ,true by default (auto checking children and parents for 3-state checkboxes)
*     @param: mode - 1 - on, 0 - off;
*     @type: public
*     @edition: Professional
*     @topic: 0
*/
   dhtmlXTreeObject.prototype.enableSmartCheckboxes=function(mode) { this.smcheck=dhx4.s2b(mode); };

/**
*     @desc: return current state of XML loading
*     @type: public
*     @edition: Professional
*     @return: current state, true - xml loading now
*     @topic: 0
*/
   dhtmlXTreeObject.prototype.getXMLState=function(){ return (this.xmlstate==1); };

/**
*     @desc: set top offset for item
*     @type: public
*     @param: itemId - id of item
*     @param: value - value of top offset in px
*     @edition: Professional
*     @topic: 2
*/
dhtmlXTreeObject.prototype.setItemTopOffset=function(itemId,value){
    var node;
    if (typeof(itemId)!="object")
        node=this._globalIdStorageFind(itemId);
    else
        node=itemId;
    var z=node.span.parentNode.parentNode;
    node.span.style.paddingBottom="1px";
  
    for (var i=0; i<z.childNodes.length; i++){
        if (i!=0){
      
            if (_isIE){
                z.childNodes[i].style.height="18px";
                z.childNodes[i].style.paddingTop=parseInt(value)+"px";
            }else
                z.childNodes[i].style.height=18+parseInt(value)+"px";
        }
        else{
            var w=z.childNodes[i].firstChild;
            if (z.childNodes[i].firstChild.tagName!='DIV'){
              w=document.createElement("DIV");
              z.childNodes[i].insertBefore(w,z.childNodes[i].firstChild);
            }
            w.style.height=parseInt(value)+"px";
            if ((node.parentObject.id!=this.rootId || node.parentObject.childNodes[0]!=node) && this.treeLinesOn)
                w.style.backgroundImage="url("+this.imPath+this.lineArray[5]+")";
            w.innerHTML="&nbsp;";
            w.style.overflow='hidden';
            if (parseInt(value)==0)
                z.childNodes[i].removeChild(w);
        }
        if (!_isIE)
            z.childNodes[i].style.verticalAlign="bottom";
        if (_isIE){
            this.allTree.childNodes[0].border = "1";
            this.allTree.childNodes[0].border = "0";
        }
    }
}

/**
*     @desc: set size of icons
*     @type:  public
*     @param: newWidth - new icon width
*     @param: newHeight - new icon height
*     @param: itemId - item Id, if skipped set default value for all new icons, optional
*     @edition: Professional
*     @topic: 2
*/
dhtmlXTreeObject.prototype.setIconSize=function(newWidth,newHeight,itemId)
{
      if (itemId){
         if ((itemId)&&(itemId.span))
            var sNode=itemId;
         else
            var sNode=this._globalIdStorageFind(itemId);

         if (!sNode) return (0);
         var img=sNode.span.parentNode.previousSibling.childNodes[0];
            if (newWidth) {
            	img.style.width=newWidth+"px";
            	if (window._KHTMLrv) img.parentNode.style.width=newWidth+"px";
        	}
            if (newHeight) {
            	img.style.height=newHeight+"px";
            	if (window._KHTMLrv) img.parentNode.style.height=newHeight+"px";
        	}
         }
      else{
         this.def_img_x=newWidth;
         this.def_img_y=newHeight;
      }
}

/**
*     @desc: get url of item image
*     @type: public
*     @param: itemId - id of item
*     @param: imageInd - index of image ( 0 - leaf, 1 - closed folder, 2 - opened folder)
*     @param: value - value of top offset
*     @edition: Professional
*     @topic: 2
*/
dhtmlXTreeObject.prototype.getItemImage=function(itemId,imageInd,fullPath){
    var node=this._globalIdStorageFind(itemId);
    if (!node) return "";
    var img=node.images[imageInd||0];
    if (fullPath) img=this.iconURL+img;
    return img;
}

/**
*     @desc: replace checkboxes with radio buttons
*     @type: public
*     @param: mode - true/false
*     @param: itemId - node for which replacement called (optional)
*     @edition: Professional
*     @topic: 1
*/
dhtmlXTreeObject.prototype.enableRadioButtons=function(itemId,mode){
    if (arguments.length==1){
        this._frbtr=dhx4.s2b(itemId);
        this.checkBoxOff=this.checkBoxOff||this._frbtr;
        return;
        }


    var node=this._globalIdStorageFind(itemId);
    if (!node) return "";
    mode=dhx4.s2b(mode);
    if ((mode)&&(!node._r_logic)){
            node._r_logic=true;
            for (var i=0; i<node.childsCount; i++)
                this._setCheck(node.childNodes[i],node.childNodes[i].checkstate);
        }

    if ((!mode)&&(node._r_logic)){
            node._r_logic=false;
            for (var i=0; i<node.childsCount; i++)
                this._setCheck(node.childNodes[i],node.childNodes[i].checkstate);
        }
}
/**
*     @desc: replace checkboxes with radio buttons
*     @type: public
*     @param: mode - true/false
*     @param: itemId - node for which replacement called (optional)
*     @edition: Professional
*     @topic: 1
*/
dhtmlXTreeObject.prototype.enableSingleRadioMode=function(mode){
     this._frbtrs=dhx4.s2b(mode);
}


/**
*     @desc: configure if parent node will be expanded immideatly after child item added
*     @type: public
*     @param: mode - true/false
*     @edition: Professional
*     @topic: 2
*/
dhtmlXTreeObject.prototype.openOnItemAdded=function(mode){
    this._hAdI=!dhx4.s2b(mode);
}
dhtmlXTreeObject.prototype.openOnItemAdding=function(mode){
    this._hAdI=!dhx4.s2b(mode);
}

/**
*     @desc: enable multi line items
*     @beforeInit: 1
*     @param: width - text width, if equls zero then use single lines items;
*     @type: public
*     @edition: Professional
*     @topic: 0
*/
   dhtmlXTreeObject.prototype.enableMultiLineItems=function(width) { if (width===true) this.mlitems="100%"; else this.mlitems=width; }

/**
*     @desc: enable auto tooltips (node text as tooltip)
*     @beforeInit: 1
*     @param: mode - 1 - on, 0 - off;
*     @type: public
*     @edition:Professional
*     @topic: 0
*/
   dhtmlXTreeObject.prototype.enableAutoTooltips=function(mode) { this.ettip=dhx4.s2b(mode); };


/**
*     @desc: unselect item in tree
*     @type: public
*     @param: itemId - used in multi selection tree (optional)
*     @edition: Professional
*     @topic: 0
*/
   dhtmlXTreeObject.prototype.clearSelection=function(itemId){
       if (itemId)
            this._unselectItem(this._globalIdStorageFind(itemId));
            else
            this._unselectItems();
            }

/**
*     @desc: show/hide (+/-) icon (works only for individual items, not for entire tree )
*     @type: public
*     @param: itemId - id of selected item
*     @param: state - show state : 0/1
*     @edition: Professional
*     @topic: 6
*/
   dhtmlXTreeObject.prototype.showItemSign=function(itemId,state){
      var temp=this._globalIdStorageFind(itemId);
      if (!temp) return 0;

      var z=temp.span.parentNode.previousSibling.previousSibling.previousSibling;
      if (!dhx4.s2b(state)){
         this._openItem(temp)
         temp.closeble=false;
         temp.wsign=true;
      }
      else
      {
         temp.closeble=true;
         temp.wsign=false;
      }
      this._correctPlus(temp);
   }
/**
*     @desc: show/hide checkbox for tree item (works only for individual items, not for entire tree )
*     @type: public
*     @param: itemId - id of selected item, optional, set null to change states of all items
*     @param: state - checkbox show state : 0/1
*     @edition: Professional
*     @topic: 5
*/
   dhtmlXTreeObject.prototype.showItemCheckbox=function(itemId,state){
      if (!itemId)
		for (var a in this._idpull)
			this.showItemCheckbox(this._idpull[a],state);

      if (typeof(itemId)!="object")
	      itemId=this._globalIdStorageFind(itemId,0,0);

      if (!itemId) return 0;
   	  itemId.nocheckbox=!dhx4.s2b(state);
      var t=itemId.span.parentNode.previousSibling.previousSibling.childNodes[0];
      t.parentNode.style.display=(!itemId.nocheckbox)?"":"none";
   }

/**
*     @desc: set list separator ("," by default)
*     @type: public
*     @param: separator - char or string to use for separating items in lists
*     @edition: Professional
*     @topic: 0
*/
dhtmlXTreeObject.prototype.setListDelimeter=function(separator){
    this.dlmtr=separator;
}

//#}


/**
*     @desc: set escaping mode (used for escaping ID in requests)
*     @param: mode - escaping mode ("utf8" for UTF escaping)
*     @type: public
*     @topic: 0
*/
   dhtmlXTreeObject.prototype.setEscapingMode=function(mode){
        this.utfesc=mode;
        }


/**
*     @desc: enable item highlighting (item text highlited on mouseover)
*     @beforeInit: 1
*     @param: mode - 1 - on, 0 - off;
*     @type: public
*     @topic: 0
*/
   dhtmlXTreeObject.prototype.enableHighlighting=function(mode) { this.ehlt=true; this.ehlta=dhx4.s2b(mode); };

/**
*     @desc: called on mouse out
*     @type: private
*     @topic: 0
*/
   dhtmlXTreeObject.prototype._itemMouseOut=function(){
   		var that=this.childNodes[3].parentObject;
		var tree=that.treeNod;
 		tree.callEvent("onMouseOut",[that.id]);
		if (that.id==tree._l_onMSI) tree._l_onMSI=null;
        if (!tree.ehlta) return;
 	    that.span.className=that.span.className.replace("_lor","");
   }
/**
*     @desc: called on mouse in
*     @type: private
*     @topic: 0
*/
   dhtmlXTreeObject.prototype._itemMouseIn=function(){
   		var that=this.childNodes[3].parentObject;
		var tree=that.treeNod;

		if (tree._l_onMSI!=that.id) tree.callEvent("onMouseIn",[that.id]);
		tree._l_onMSI=that.id;
        if (!tree.ehlta) return;
 	    that.span.className=that.span.className.replace("_lor","");
 	    that.span.className=that.span.className.replace(/((standart|selected)TreeRow)/,"$1_lor");
   }

/**
*     @desc: enable active images (clickable and dragable). By default only text part of the node is active
*     @beforeInit: 1
*     @param: mode - 1 - on, 0 - off;
*     @type: public
*     @topic: 0
*/
   dhtmlXTreeObject.prototype.enableActiveImages=function(mode){this._aimgs=dhx4.s2b(mode); };

/**
*     @desc: focus item in tree (scroll to it if necessary)
*     @type: public
*     @param: itemId - item Id
*     @topic: 0
*/
dhtmlXTreeObject.prototype.focusItem=function(itemId){
      var sNode=this._globalIdStorageFind(itemId);
      if (!sNode) return (0);
      this._focusNode(sNode);
   };


/**
*     @desc: Returns the list of all children from all next levels of tree, separated by default delimiter.
*     @param: itemId - id of node
*     @type: public
*     @return: list of all children items from all next levels of tree, separated by default delimiter
*     @topic: 6
*/
   dhtmlXTreeObject.prototype.getAllSubItems =function(itemId){
      return this._getAllSubItems(itemId);
   }

/**
*     @desc: Returns the list of all items which doesn't have child nodes.
*     @type: public
*     @return: list of all items which doesn't have child nodes.
*     @topic: 6
*/
	dhtmlXTreeObject.prototype.getAllChildless =function(){
		return this._getAllScraggyItems(this.htmlNode);
	}
	dhtmlXTreeObject.prototype.getAllLeafs=dhtmlXTreeObject.prototype.getAllChildless;


/**
*     @desc: Returns the list of all children from all next levels of tree, separated by default delimiter.
*     @param: itemId - id of node
*     @edition: Professional
*     @type: private
*     @topic: 6
*/
   dhtmlXTreeObject.prototype._getAllScraggyItems =function(node)
   {
      var z="";
      for (var i=0; i<node.childsCount; i++)
        {
            if ((node.childNodes[i].unParsed)||(node.childNodes[i].childsCount>0))
            {
                    if (node.childNodes[i].unParsed)
                        var zb=this._getAllScraggyItemsXML(node.childNodes[i].unParsed,1);
                    else
                       var zb=this._getAllScraggyItems(node.childNodes[i])

                 if (zb)
                        if (z) z+=this.dlmtr+zb;
                        else z=zb;
         }
            else
               if (!z) z=""+node.childNodes[i].id;
             else z+=this.dlmtr+node.childNodes[i].id;
         }
          return z;
   };





/**
*     @desc: Returns the list of all children from all next levels of tree, separated by default delimiter.
*     @param: itemId - id of node
*     @type: private
*     @edition: Professional
*     @topic: 6
*/
   dhtmlXTreeObject.prototype._getAllFatItems =function(node)
   {
      var z="";
      for (var i=0; i<node.childsCount; i++)
        {
            if ((node.childNodes[i].unParsed)||(node.childNodes[i].childsCount>0))
            {
             if (!z) z=""+node.childNodes[i].id;
                else z+=this.dlmtr+node.childNodes[i].id;

                    if (node.childNodes[i].unParsed)
                        var zb=this._getAllFatItemsXML(node.childNodes[i].unParsed,1);
                    else
                       var zb=this._getAllFatItems(node.childNodes[i])

                 if (zb) z+=this.dlmtr+zb;
         }
         }
          return z;
   };

/**
*     @desc: Returns the list of all items which have child nodes, separated by default delimiter.
*     @type: public
*     @return: list of all items which has child nodes, separated by default delimiter.
*     @topic: 6
*/
	dhtmlXTreeObject.prototype.getAllItemsWithKids =function(){
		return this._getAllFatItems(this.htmlNode);
	}
	dhtmlXTreeObject.prototype.getAllFatItems=dhtmlXTreeObject.prototype.getAllItemsWithKids;



/**
*     @desc: return list of identificators of nodes with checked checkboxes, separated by default delimiter
*     @type: public
*     @return: list of ID of items with checked checkboxes, separated by default delimiter
*     @topic: 5
*/
   dhtmlXTreeObject.prototype.getAllChecked=function(){
      return this._getAllChecked("","",1);
   }
/**
*     @desc: return list of identificators of nodes with unchecked checkboxes, separated by default delimiter
*     @type: public
*     @return: list of ID of items with unchecked checkboxes, separated by default delimiter
*     @topic: 5
*/
   dhtmlXTreeObject.prototype.getAllUnchecked=function(itemId){
        if (itemId)
            itemId=this._globalIdStorageFind(itemId);
      return this._getAllChecked(itemId,"",0);
    }


/**
*     @desc: return list of identificators of nodes with third state checkboxes, separated by default delimiter
*     @type: public
*     @return: list of ID of items with third state checkboxes, separated by default delimiter
*     @topic: 5
*/
   dhtmlXTreeObject.prototype.getAllPartiallyChecked=function(){
      return this._getAllChecked("","",2);
   }


/**
*     @desc: return list of identificators of nodes with checked and third state checkboxes, separated by default delimiter
*     @type: public
*     @return: list of ID of items with checked and third state checkboxes, separated by default delimiter
*     @topic: 5
*/
   dhtmlXTreeObject.prototype.getAllCheckedBranches=function(){
        var temp = [this._getAllChecked("","",1)];
        var second = this._getAllChecked("","",2);
        if (second) temp.push(second);
        return temp.join(this.dlmtr);
   }

/**
*     @desc: return list of identificators of nodes with checked checkboxes
*     @type: private
*     @param: node - node object (optional, used by private methods)
*     @param: list - initial identificators list (optional, used by private methods)
*     @topic: 5
*/
   dhtmlXTreeObject.prototype._getAllChecked=function(htmlNode,list,mode){
      if (!htmlNode) htmlNode=this.htmlNode;

      if (htmlNode.checkstate==mode)
         if (!htmlNode.nocheckbox)  { if (list) list+=this.dlmtr+htmlNode.id; else list=""+htmlNode.id;  }
      var j=htmlNode.childsCount;
      for (var i=0; i<j; i++)
      {
         list=this._getAllChecked(htmlNode.childNodes[i],list,mode);
      };
//#__pro_feature:01112006{
//#smart_parsing:01112006{
        if  (htmlNode.unParsed)
            list=this._getAllCheckedXML(htmlNode.unParsed,list,mode);
//#}
//#}

      if (list) return list; else return "";
   };

/**
*     @desc: set individual item style
*     @type: public
*     @param: itemId - node id
*     @param: styleString - valid CSS string
*     @param: resetCss - reset current style : 0/1
*     @topic: 2
*/
dhtmlXTreeObject.prototype.setItemStyle=function(itemId,style_string,resetCss){ 
	var resetCss= resetCss|| false; 
	var temp=this._globalIdStorageFind(itemId); 
	if (!temp) return 0; 
	if (!temp.span.style.cssText) 
		temp.span.setAttribute("style",temp.span.getAttribute("style")+"; "+style_string); 
	else 
		temp.span.style.cssText = resetCss? style_string : temp.span.style.cssText+";"+style_string; 
}

/**
*     @desc: enable draging item image with item text
*     @type: public
*     @param: mode - true/false
*     @topic: 1
*/
dhtmlXTreeObject.prototype.enableImageDrag=function(mode){
    this._itim_dg=dhx4.s2b(mode);
}

/**
*     @desc: set function called when tree item draged over another item
*     @param: func - event handling function
*     @type: depricated
*     @edition: Professional
*     @topic: 4
*     @event: onDragIn
*     @depricated: use grid.attachEvent("onDragIn",func); instead
*     @eventdesc: Event raised when item draged other other dropable target
*     @eventparam:  ID draged item
*     @eventparam:  ID potencial drop landing
*     @eventparam:  source object
*     @eventparam:  target object
*     @eventreturn: true - allow drop; false - deny drop;
*/
	dhtmlXTreeObject.prototype.setOnDragIn=function(func){
		this.attachEvent("onDragIn",func);
        };

/**
*     @desc: enable/disable auto scrolling while drag-and-drop
*     @type: public
*     @param: mode - enabled/disabled
*     @topic: 0
*/
   dhtmlXTreeObject.prototype.enableDragAndDropScrolling=function(mode){ this.autoScroll=dhx4.s2b(mode); };


dhtmlXTreeObject.prototype.setSkin=function(name){
	var tmp = this.parentObject.className.replace(/dhxtree_[^ ]*/gi,"");
	this.parentObject.className= tmp+" dhxtree_"+name;
  if (name == "dhx_terrace" || name == "dhx_web")
    this.enableTreeLines(false);

};

//tree
(function(){
	
	dhtmlx.extend_api("dhtmlXTreeObject",{
		_init:function(obj){
			return [obj.parent,(obj.width||"100%"),(obj.height||"100%"),(obj.root_id||0)];
		},
		auto_save_selection:"enableAutoSavingSelected",
		auto_tooltip:"enableAutoTooltips",
		checkbox:"enableCheckBoxes",
		checkbox_3_state:"enableThreeStateCheckboxes",
		checkbox_smart:"enableSmartCheckboxes",
		context_menu:"enableContextMenu",
		distributed_parsing:"enableDistributedParsing",
		drag:"enableDragAndDrop",
		drag_copy:"enableMercyDrag",
		drag_image:"enableImageDrag",
		drag_scroll:"enableDragAndDropScrolling",
		editor:"enableItemEditor",
		hover:"enableHighlighting",
		images:"enableTreeImages",
		image_fix:"enableIEImageFix",
		image_path:"setImagePath",
		lines:"enableTreeLines",
		loading_item:"enableLoadingItem",
		multiline:"enableMultiLineItems",
		multiselect:"enableMultiselection",
		navigation:"enableKeyboardNavigation",
		radio:"enableRadioButtons",
		radio_single:"enableSingleRadioMode",
		rtl:"enableRTL",
		search:"enableKeySearch",
		smart_parsing:"enableSmartXMLParsing",
		smart_rendering:"enableSmartRendering",
		text_icons:"enableTextSigns",
		xml:"loadXML",
		skin:"setSkin"
	},{});
	
})();

dhtmlXTreeObject.prototype._dp_init=function(dp){
	dp.attachEvent("insertCallback", function(upd, id, parent) {
		var data = dhx4.ajax.xpath(".//item",upd);
		var text = data[0].getAttribute('text');
		this.obj.insertNewItem(parent, id, text, 0, 0, 0, 0, "CHILD");
	});

	dp.attachEvent("updateCallback", function(upd, id, parent) {
		var data = dhx4.ajax.xpath(".//item",upd);
		var text = data[0].getAttribute('text');
		this.obj.setItemText(id, text);
		if (this.obj.getParentId(id) != parent) {
			this.obj.moveItem(id, 'item_child', parent);
		}
		this.setUpdated(id, true, 'updated');
	});

	dp.attachEvent("deleteCallback", function(upd, id, parent) {
		this.obj.setUserData(id, this.action_param, "true_deleted");
		this.obj.deleteItem(id, false);
	});
	
	dp._methods=["setItemStyle","","changeItemId","deleteItem"];
    this.attachEvent("onEdit",function(state,id){
        if (state==3)
            dp.setUpdated(id,true)
		return true;
	});
    this.attachEvent("onDrop",function(id,id_2,id_3,tree_1,tree_2){
    	if (tree_1==tree_2)
        	dp.setUpdated(id,true);
    });
    this._onrdlh=function(rowId){
		var z=dp.getState(rowId);
		if (z=="inserted") {  dp.set_invalid(rowId,false); dp.setUpdated(rowId,false);	return true; }
		if (z=="true_deleted")  { dp.setUpdated(rowId,false); return true; }

		dp.setUpdated(rowId,true,"deleted")
		return false;
	};
	this._onradh=function(rowId){
		dp.setUpdated(rowId,true,"inserted")
	};
	dp._getRowData=function(rowId){
		var data = {};
		var z=this.obj._globalIdStorageFind(rowId);
		var z2=z.parentObject;
			
		var i=0;
		for (i=0; i<z2.childsCount; i++)
			if (z2.childNodes[i]==z) break;
		
		data["tr_id"] = z.id;
		data["tr_pid"] = z2.id;
		data["tr_order"] = i;
		data["tr_text"] = z.span.innerHTML;
		
		z2=(z._userdatalist||"").split(",");
		for (i=0; i<z2.length; i++)
			data[z2[i]]=z.userData["t_"+z2[i]];
			
    	return data;
	};	
};

//(c)dhtmlx ltd. www.dhtmlx.com
if (typeof(window.dhtmlXCellObject) != "undefined") {
	
	dhtmlXCellObject.prototype.attachTree = function(rootId) {
		
		var obj = document.createElement("DIV");
		obj.style.width = "100%";
		obj.style.height = "100%";
		obj.style.position = "relative";
		obj.style.overflow = "hidden";
		
		this._attachObject(obj);
		
		this.dataType = "tree";
		this.dataObj = new dhtmlXTreeObject(obj, "100%", "100%", (rootId||0));
		this.dataObj.setSkin(this.conf.skin);
		
		// cosmetic fix
		this.dataObj.allTree.childNodes[0].style.marginTop = "2px";
		this.dataObj.allTree.childNodes[0].style.marginBottom = "2px";
		
		//obj.style.overflow = "auto";
		obj = null;
		
		this.callEvent("_onContentAttach",[]);
		
		return this.dataObj;
		
	};
	
}


/*
Product Name: dhtmlxSuite 
Version: 4.1.3 
Edition: Professional 
License: content of this file is covered by DHTMLX Commercial or Enterprise license. Usage without proper license is prohibited. To obtain it contact sales@dhtmlx.com
Copyright UAB Dinamenta http://www.dhtmlx.com
*/

/**
*     @desc: adds drag-n-drop capabilities (with possibility to drop into dhtmlxTree) to HTML object. 
*     @param: obj - HTML object, or HTML object ID
*     @param: func - custom drag processor function, optional
*     @type: public
*     @topic: 0
*/
dhtmlXTreeObject.prototype.makeDraggable=function(obj,func){
	if (typeof(obj)!="object")
		obj=document.getElementById(obj);

    dragger=new dhtmlDragAndDropObject();
	dropper=new dhx_dragSomethingInTree();

    dragger.addDraggableItem(obj,dropper);
    obj.dragLanding=null;
    obj.ondragstart=dropper._preventNsDrag;
    obj.onselectstart=new Function("return false;");

    obj.parentObject=new Object;
    obj.parentObject.img=obj;
    obj.parentObject.treeNod=dropper;
	dropper._customDrop=func;
}
dhtmlXTreeObject.prototype.makeDragable=dhtmlXTreeObject.prototype.makeDraggable;
/**
*     @desc: adds drag-n-drop capabilities (with possibility to drop into dhtmlxTree) to all HTML items with dragInDhtmlXTree attribute
*     @param: func - custom drag processor function, optional
*     @type: public
*     @topic: 0
*/
dhtmlXTreeObject.prototype.makeAllDraggable=function(func){
	var z=document.getElementsByTagName("div");
	for (var i=0; i<z.length; i++)
		if (z[i].getAttribute("dragInDhtmlXTree"))
			this.makeDragable(z[i],func);
}

function dhx_dragSomethingInTree(){
	this.lWin=window;
	//this function creates a HTML object which will be used while drag-n-drop
    this._createDragNode=function(node){
    	var dragSpan=document.createElement('div');
        dragSpan.style.position="absolute";
        dragSpan.innerHTML=(node.innerHTML||node.value);
        dragSpan.className="dragSpanDiv";
        return dragSpan;
    };
	//this function necessary for correct browser support
	//doesn't change anything in it
    this._preventNsDrag=function(e){
    	(e||window.event).cancelBubble=true;
        if ((e)&&(e.preventDefault)) { e.preventDefault(); return false; }
        return false;
    }
	//this function contains a reaction on drop operation
	//the tree don't know what to do with custom item
	//so you must define this reaction
    this._nonTrivialNode=function(tree,item,bitem,source){
		if (this._customDrop) return this._customDrop(tree,source.img.id,item.id,bitem?bitem.id:null);

        var image=(source.img.getAttribute("image")||"");
		var id=source.img.id||"new";
		var text=(source.img.getAttribute("text")||(_isIE?source.img.innerText:source.img.textContent));
        tree[bitem?"insertNewNext":"insertNewItem"](bitem?bitem.id:item.id,id,text,"",image,image,image);
     }
}
//(c)dhtmlx ltd. www.dhtmlx.com

/*
Product Name: dhtmlxSuite 
Version: 4.1.3 
Edition: Professional 
License: content of this file is covered by DHTMLX Commercial or Enterprise license. Usage without proper license is prohibited. To obtain it contact sales@dhtmlx.com
Copyright UAB Dinamenta http://www.dhtmlx.com
*/

/*
Purpose: item edit extension
*/


/**
*     @desc: enable editing of item text
*     @param:  mode - true/false
*     @type: public
*     @topic: 0
*/
dhtmlXTreeObject.prototype.enableItemEditor=function(mode){
        this._eItEd=dhx4.s2b(mode);
        if (!this._eItEdFlag){

            this._edn_click_IE=true;
            this._edn_dblclick=true;
            this._ie_aFunc=this.aFunc;
            this._ie_dblclickFuncHandler=this.dblclickFuncHandler;

            this.setOnDblClickHandler(function (a,b) {
                if (this._edn_dblclick) this._editItem(a,b);
                return true;
				});

            this.setOnClickHandler(function (a,b) {
                this._stopEditItem(a,b);
                    if ((this.ed_hist_clcik==a)&&(this._edn_click_IE))
                        this._editItem(a,b);
                this.ed_hist_clcik=a;
                return true;
                });

            this._eItEdFlag=true;

            }
        };

/**
*     @desc: set onEdit handler ( multi handler event)
*     @param:  func - function which will be called on edit related events
*     @type: depricated
*     @event:  onEdit
*     @depricated: use grid.attachEvent("onEdit",func); instead
*     @eventdesc: Event occurs on 4 different stages of edit process: before editing started (cancelable), after editing started, before closing (cancelable), after closed
*     @eventparam: state - 0 before editing started , 1 after editing started, 2 before closing, 3 after closed
*     @eventparam: id - id of edited items
*     @eventparam: tree - tree object
*     @eventparam: value - for stage 0 and 2, value of editor
*     @eventreturn: for stages 0 and 2; true - confirm opening/closing, false - deny opening/closing;  text - edit value
*     @topic: 0
*/
dhtmlXTreeObject.prototype.setOnEditHandler=function(func){
		this.attachEvent("onEdit",func);
        };



/**
*     @desc: define which events must start editing
*     @param:  click_IE - click on already selected item - true/false [true by default]
*     @param:  dblclick - on double click
*     @type: public
*     @topic: 0
*/
dhtmlXTreeObject.prototype.setEditStartAction=function(click_IE, dblclick){
        this._edn_click_IE=dhx4.s2b(click_IE);
        this._edn_dblclick=dhx4.s2b(dblclick);
        };

dhtmlXTreeObject.prototype._stopEdit=function(a,mode){
    if  (this._editCell){
        this.dADTempOff=this.dADTempOffEd;
        if (this._editCell.id!=a){
			
			var editText=true;
			if(!mode){
	            editText=this.callEvent("onEdit",[2,this._editCell.id,this,this._editCell.span.childNodes[0].value]);
			}
			else{
				editText = false;
				this.callEvent("onEditCancel",[this._editCell.id,this._editCell._oldValue]);
			}
	        if (editText===true)
	           	editText=this._editCell.span.childNodes[0].value;
	        else if (editText===false) editText=this._editCell._oldValue;
	        
			var changed = (editText!=this._editCell._oldValue);
	        this._editCell.span.innerHTML=editText;
	        this._editCell.label=this._editCell.span.innerHTML;
			var cSS=this._editCell.i_sel?"selectedTreeRow":"standartTreeRow";
	        this._editCell.span.className=cSS;
	        this._editCell.span.parentNode.className="standartTreeRow";
	        this._editCell.span.style.paddingRight=this._editCell.span.style.paddingLeft='5px';
	        this._editCell.span.onclick=this._editCell.span.ondblclick=function(){};
	        
	        var id=this._editCell.id; 
	        if (this.childCalc)  this._fixChildCountLabel(this._editCell);
	        this._editCell=null;
	        
			if(!mode)
	        	this.callEvent("onEdit",[3,id,this,changed]);
	        
			if (this._enblkbrd){
				this.parentObject.lastChild.focus();
				this.parentObject.lastChild.focus();
			}
        }
    }
}

dhtmlXTreeObject.prototype._stopEditItem=function(id,tree){
    this._stopEdit(id);
};

/**
*     @desc:  switch currently edited item back to normal view
*     @type: public
*     @topic: 0
*/

dhtmlXTreeObject.prototype.stopEdit=function(mode){
    if (this._editCell)
        this._stopEdit(this._editCell.id+"_non",mode);
}

/**
*     @desc: open editor for specified item
*     @param:  id - item ID
*     @type: public
*     @topic: 0
*/
dhtmlXTreeObject.prototype.editItem=function(id){
    this._editItem(id,this);
}

dhtmlXTreeObject.prototype._editItem=function(id,tree){
    if (this._eItEd){
        this._stopEdit();
        var temp=this._globalIdStorageFind(id);
		if (!temp) return;
				
	    var editText = this.callEvent("onEdit",[0,id,this,temp.span.innerHTML]);
        if (editText===true)
            editText = (typeof temp.span.innerText!="undefined"?temp.span.innerText:temp.span.textContent);
        else if (editText===false) return;
        this.dADTempOffEd=this.dADTempOff;
        this.dADTempOff=false;


        this._editCell=temp;
        temp._oldValue=editText;
        temp.span.innerHTML="<input type='text' class='intreeeditRow' />";
        temp.span.style.paddingRight=temp.span.style.paddingLeft='0px';
        temp.span.onclick = temp.span.ondblclick= function(e){
			(e||event).cancelBubble = true;
		}

        temp.span.childNodes[0].value=editText;

        temp.span.childNodes[0].onselectstart=function(e){
            (e||event).cancelBubble=true;
            return true;
        }
        temp.span.childNodes[0].onmousedown=function(e){
            (e||event).cancelBubble=true;
            return true;
        }

        temp.span.childNodes[0].focus();
        temp.span.childNodes[0].focus();
//		temp.span.childNodes[0].select();
        temp.span.onclick=function (e){ (e||event).cancelBubble=true; return false; };
        temp.span.className="";
        temp.span.parentNode.className="";

        var self=this;

        temp.span.childNodes[0].onkeydown=function(e){
            if (!e) e=window.event;
            if (e.keyCode==13){
				 e.cancelBubble=true;
				 self._stopEdit(window.undefined);	
			}
			else if (e.keyCode==27){
				self._stopEdit(window.undefined, true);
			}
			(e||event).cancelBubble=true;
        }
        this.callEvent("onEdit",[1,id,this]);
    }
};
//(c)dhtmlx ltd. www.dhtmlx.com


/*
Product Name: dhtmlxSuite 
Version: 4.1.3 
Edition: Professional 
License: content of this file is covered by DHTMLX Commercial or Enterprise license. Usage without proper license is prohibited. To obtain it contact sales@dhtmlx.com
Copyright UAB Dinamenta http://www.dhtmlx.com
*/

function jsonPointer(data,parent){
	this.d=data;
	this.dp=parent;
}
jsonPointer.prototype={
	text:function(){ var afff=function(n){ var p=[]; for(var i=0; i<n.length; i++) p.push("{"+sfff(n[i])+"}"); return p.join(","); }; var sfff=function(n){ var p=[]; for (var a in n) if (typeof(n[a])=="object"){ if (a.length) p.push('"'+a+'":['+afff(n[a])+"]");  else p.push('"'+a+'":{'+sfff(n[a])+"}"); }else p.push('"'+a+'":"'+n[a]+'"'); return p.join(","); }; return "{"+sfff(this.d)+"}"; },
	get:function(name){return this.d[name]; },
	exists:function(){return !!this.d },
	content:function(){return this.d.content; },
	each:function(name,f,t){  var a=this.d[name]; var c=new jsonPointer(); if (a) for (var i=0; i<a.length; i++) { c.d=a[i]; f.apply(t,[c,i]); } },
	get_all:function(){ return this.d; },
	sub:function(name){ return new jsonPointer(this.d[name],this.d) },
	sub_exists:function(name){ return !!this.d[name]; },
	each_x:function(name,rule,f,t,i){  var a=this.d[name]; var c=new jsonPointer(0,this.d); if (a) for (i=i||0; i<a.length; i++) if (a[i][rule]) { c.d=a[i]; if(f.apply(t,[c,i])==-1) return; } },
	up:function(name){ return new jsonPointer(this.dp,this.d);  },
	set:function(name,val){ this.d[name]=val;  },
	clone:function(name){ return new jsonPointer(this.d,this.dp); },
	through:function(name,rule,v,f,t){  var a=this.d[name]; if (a.length) for (var i=0; i<a.length; i++) { if (a[i][rule]!=null && a[i][rule]!="" &&  (!v || a[i][rule]==v )) { 
		var c=new jsonPointer(a[i],this.d);  f.apply(t,[c,i]); }  var w=this.d; this.d=a[i]; 
		if (this.sub_exists(name)) this.through(name,rule,v,f,t); this.d=w;   } }
}

/**
*     @desc: load tree from js array file|stream
*     @type: public
*     @param: file - link to JSArray file
*     @param: afterCall - function which will be called after xml loading
*     @topic: 0
*/
   dhtmlXTreeObject.prototype.loadJSArrayFile=function(file,callback){
      if (!this.parsCount) this.callEvent("onXLS",[this,this._ld_id]); this._ld_id=null; this.xmlstate=1;
      var that=this;
      
      this.XMLLoader=function(xml, callback){
      	eval("var z="+xml.responseText);
      	this.loadJSArray(z);
      	if (callback) callback.call(this, xml);
      };

      dhx4.ajax.get(file, function(obj){
      	that.XMLLoader(obj.xmlDoc, callback);
      });
   };
   
/**
*     @desc: load tree from csv file|stream
*     @type: public
*     @param: file - link to CSV file
*     @param: afterCall - function which will be called after xml loading
*     @topic: 0
*/
   dhtmlXTreeObject.prototype.loadCSV=function(file,callback){
      if (!this.parsCount) this.callEvent("onXLS",[this,this._ld_id]); this._ld_id=null; this.xmlstate=1;
      var that=this;
	  this.XMLLoader=function(xml, callback){
      	this.loadCSVString(xml.responseText);
      	if (callback) callback.call(this, xml);
      };

      dhx4.ajax.get(file, function(obj){
      	that.XMLLoader(obj.xmlDoc, callback);
      });
   };
   
/**
*     @desc: load tree from js array object
*     @type: public
*     @param: ar - js array
*     @param: afterCall - function which will be called after xml loading
*     @topic: 0
*/  
dhtmlXTreeObject.prototype.loadJSArray=function(ar,afterCall){
	//array id,parentid,text
	var z=[];
	for (var i=0; i<ar.length; i++){
		if (!z[ar[i][1]]) z[ar[i][1]]=[];
		z[ar[i][1]].push({id:ar[i][0],text:ar[i][2]});
	}
	
	var top={id: this.rootId};
	var f=function(top,f){
		if (z[top.id]){
			top.item=z[top.id];
			for (var j=0; j<top.item.length; j++)
				f(top.item[j],f);
		}
	}
	f(top,f);
	this.loadJSONObject(top,afterCall);
}


/**
*     @desc: load tree from csv string
*     @type: public
*     @param: csv - csv string 
*     @param: afterCall - function which will be called after xml loading
*     @topic: 0
*/
dhtmlXTreeObject.prototype.loadCSVString=function(csv,afterCall){
	//array id,parentid,text
	var z=[];
	var ar=csv.split("\n");
	for (var i=0; i<ar.length; i++){
		var t=ar[i].split(",");
		if (!z[t[1]]) z[t[1]]=[];
		z[t[1]].push({id:t[0],text:t[2]});
	}
	
	var top={id: this.rootId};
	var f=function(top,f){
		if (z[top.id]){
			top.item=z[top.id];
			for (var j=0; j<top.item.length; j++)
				f(top.item[j],f);
		}
	}
	f(top,f);
	this.loadJSONObject(top,afterCall);
}


/**
*     @desc: load tree from json object
*     @type: public
*     @param: json - json object
*     @param: afterCall - function which will be called after xml loading
*     @topic: 0
*/
   dhtmlXTreeObject.prototype.loadJSONObject=function(json,afterCall){
      if (!this.parsCount) this.callEvent("onXLS",[this,null]);this.xmlstate=1;
      var p=new jsonPointer(json);
	  this._parse(p);
	  this._p=p;
      if (afterCall) afterCall();
   };
   

/**   
*     @desc: load tree from json file
*     @type: public
*     @param: file - link to JSON file
*     @param: afterCall - function which will be called after xml loading
*     @topic: 0
*/
   dhtmlXTreeObject.prototype.loadJSON=function(file,callback){
      if (!this.parsCount) this.callEvent("onXLS",[this,this._ld_id]); this._ld_id=null; this.xmlstate=1;
      var that=this;
      
      this.XMLLoader=function(xml, callback){
      	try {
			eval("var t="+xml.responseText);
		} catch(e){
				dhx4.callEvent("onLoadXMLerror",["Incorrect JSON",
					(xml),
					this
				]);
				return;
		}
      	var p=new jsonPointer(t);
      	this._parse(p);
      	this._p=p;
      	if (callback) callback.call(this, xml);
      };
      
      dhx4.ajax.get(file, function(obj){
      	that.XMLLoader(obj.xmlDoc, callback);
      });
   };   
   
   
/**   
*     @desc: return tree as json string
*     @type: public
*     @topic: 0
*/
dhtmlXTreeObject.prototype.serializeTreeToJSON=function(){
	var out=['{"id":"'+this.rootId+'", "item":['];
	var p=[];
		for (var i=0; i<this.htmlNode.childsCount; i++)
			p.push(this._serializeItemJSON(this.htmlNode.childNodes[i]));
	out.push(p.join(","));
	out.push("]}");	
	return out.join("");
};
dhtmlXTreeObject.prototype._serializeItemJSON=function(itemNode){
	var out=[];
	if (itemNode.unParsed)
			return (itemNode.unParsed.text());
  
	if (this._selected.length)
		var lid=this._selected[0].id;
	else lid="";
    var text=itemNode.span.innerHTML;

	text=text.replace(/\"/g, "\\\"", text);

	if (!this._xfullXML)
		out.push('{ "id":"'+itemNode.id+'", '+(this._getOpenState(itemNode)==1?' "open":"1", ':'')+(lid==itemNode.id?' "select":"1",':'')+' "text":"'+text+'"'+( ((this.XMLsource)&&(itemNode.XMLload==0))?', "child":"1" ':''));
	else
		out.push('{ "id":"'+itemNode.id+'", '+(this._getOpenState(itemNode)==1?' "open":"1", ':'')+(lid==itemNode.id?' "select":"1",':'')+' "text":"'+text+'", "im0":"'+itemNode.images[0]+'", "im1":"'+itemNode.images[1]+'", "im2":"'+itemNode.images[2]+'" '+(itemNode.acolor?(', "aCol":"'+itemNode.acolor+'" '):'')+(itemNode.scolor?(', "sCol":"'+itemNode.scolor+'" '):'')+(itemNode.checkstate==1?', "checked":"1" ':(itemNode.checkstate==2?', "checked":"-1"':''))+(itemNode.closeable?', "closeable":"1" ':'')+( ((this.XMLsource)&&(itemNode.XMLload==0))?', "child":"1" ':''));

	if ((this._xuserData)&&(itemNode._userdatalist))
		{
			out.push(', "userdata":[');
			var names=itemNode._userdatalist.split(",");
			var p=[];
			for  (var i=0; i<names.length; i++)
				p.push('{ "name":"'+names[i]+'" , "content":"'+itemNode.userData["t_"+names[i]]+'" }');
			out.push(p.join(",")); out.push("]");
		}
		
		if (itemNode.childsCount){
			out.push(', "item":[');
			var p=[];
		for (var i=0; i<itemNode.childsCount; i++)
			p.push(this._serializeItemJSON(itemNode.childNodes[i]));
			out.push(p.join(","));
			out.push("]\n");
		}
			
		out.push("}\n")
	return out.join("");
}   
//(c)dhtmlx ltd. www.dhtmlx.com

/*
Product Name: dhtmlxSuite 
Version: 4.1.3 
Edition: Professional 
License: content of this file is covered by DHTMLX Commercial or Enterprise license. Usage without proper license is prohibited. To obtain it contact sales@dhtmlx.com
Copyright UAB Dinamenta http://www.dhtmlx.com
*/

function dhtmlXTreeFromHTML(obj){
			if (typeof(obj)!="object")
				obj=document.getElementById(obj);

            var n=obj;
			var id=n.id;
			var cont="";

			for (var j=0; j<obj.childNodes.length; j++)
				if (obj.childNodes[j].nodeType=="1"){
					if (obj.childNodes[j].tagName=="XMP"){
						var cHead=obj.childNodes[j];
						for (var m=0; m<cHead.childNodes.length; m++)
							cont+=cHead.childNodes[m].data;

						}
					else if (obj.childNodes[j].tagName.toLowerCase()=="ul")
						cont=dhx_li2trees(obj.childNodes[j],new Array(),0);
					break;
					}
			obj.innerHTML="";


			var t=new dhtmlXTreeObject(obj,"100%","100%",0);
			var z_all=new Array();
			for ( b in t )
				z_all[b.toLowerCase()]=b;

			var atr=obj.attributes;
			for (var a=0; a<atr.length; a++)
				if ((atr[a].name.indexOf("set")==0)||(atr[a].name.indexOf("enable")==0)){
					var an=atr[a].name;
                    if (!t[an])
						an=z_all[atr[a].name];
					t[an].apply(t,atr[a].value.split(","));
					}

			if (typeof(cont)=="object"){
			    t.XMLloadingWarning=1;
				for (var i=0; i<cont.length; i++){
					var n=t.insertNewItem(cont[i][0],cont[i][3],cont[i][1]);
					if (cont[i][2]) t._setCheck(n,cont[i][2]);
					}
				t.XMLloadingWarning=0;
				t.lastLoadedXMLId=0;
				t._redrawFrom(t);
			}
			else
			t.loadXMLString("<tree id='0'>"+cont+"</tree>");
            window[id]=t;
            
            var oninit = obj.getAttribute("oninit");
            if (oninit) eval(oninit);
			return t;
}

function dhx_init_trees(){
    var z=document.getElementsByTagName("div");
    for (var i=0; i<z.length; i++)
        if (z[i].className=="dhtmlxTree")
			dhtmlXTreeFromHTML(z[i])
}

function dhx_li2trees(tag,data,ind){
	for (var i=0; i<tag.childNodes.length; i++){
        var z=tag.childNodes[i];
		if ((z.nodeType==1)&&(z.tagName.toLowerCase()=="li")){
			var c=""; var ul=null;
				var check=z.getAttribute("checked");
				for (var j=0; j<z.childNodes.length; j++){
				var zc=z.childNodes[j];
				if (zc.nodeType==3) c+=zc.data;
				else if (zc.tagName.toLowerCase()!="ul")  c+=dhx_outer_html(zc);
					 else ul=zc;
			}

			data[data.length]=[ind,c,check,(z.id||(data.length+1))];
			if (ul)
				data=dhx_li2trees(ul,data,(z.id||data.length));
		}
	}
	return data;
}

function dhx_outer_html(node){
		if (node.outerHTML) return node.outerHTML;
		var temp=document.createElement("DIV");
		temp.appendChild(node.cloneNode(true));
		temp=temp.innerHTML;
		return temp;
}

if (window.addEventListener) window.addEventListener("load",dhx_init_trees,false);
else    if (window.attachEvent) window.attachEvent("onload",dhx_init_trees);
//(c)dhtmlx ltd. www.dhtmlx.com




/*
Product Name: dhtmlxSuite 
Version: 4.1.3 
Edition: Professional 
License: content of this file is covered by DHTMLX Commercial or Enterprise license. Usage without proper license is prohibited. To obtain it contact sales@dhtmlx.com
Copyright UAB Dinamenta http://www.dhtmlx.com
*/

dhtmlXTreeObject.prototype.parserExtension={
	_parseExtension:function(p,a,pid) {
		this._idpull[a.id]._attrs=a;
	}
};

dhtmlXTreeObject.prototype.getAttribute=function(id,name){
	this._globalIdStorageFind(id)
	var t=this._idpull[id]._attrs;
	return t?t[name]:window.undefined;
}
dhtmlXTreeObject.prototype.setAttribute=function(id,name,value){
	this._globalIdStorageFind(id)
	var t=(this._idpull[id]._attrs)||{};
	t[name]=value;
	this._idpull[id]._attrs=t;
}


/*
Product Name: dhtmlxSuite 
Version: 4.1.3 
Edition: Professional 
License: content of this file is covered by DHTMLX Commercial or Enterprise license. Usage without proper license is prohibited. To obtain it contact sales@dhtmlx.com
Copyright UAB Dinamenta http://www.dhtmlx.com
*/

/*
Purpose: keyboard navigation extension
*/

/**
*     @desc: enable keyboard navigation in tree
*     @param: mode - true/false
*     @edition: Professional
*     @type: public
*     @topic: 4
*/
dhtmlXTreeObject.prototype.enableKeyboardNavigation=function(mode){
        this._enblkbrd=dhx4.s2b(mode);
        if (this._enblkbrd){
            if (_isFF){
                var z=window.getComputedStyle(this.parentObject,null)["position"];
                if ((z!="absolute")&&(z!="relative"))
                    this.parentObject.style.position="relative";
                }
            this._navKeys=[["up",38],["down",40],["open",39],["close",37],["call",13],["edit",113]];
            var self=this;
            var z=document.createElement("INPUT");
                z.className="a_dhx_hidden_input";
                z.autocomplete="off";
                if (window._KHTMLrv) z.style.color="white";
            this.parentObject.appendChild(z);
            this.parentObject[_isOpera?"onkeypress":"onkeydown"]=function(e){
            	if (self.callEvent("onKeyPress",[(e||window.event).keyCode,(e||window.event)]))
                	return self._onKeyDown(e||window.event)
                
            }
            this.parentObject.onclick=function(e){
                    if (_isFF || _isIE)
                    	z.select();
                    if (window._KHTMLrv || _isOpera) 
                    	z.focus();
            }
        }
        else
            this.parentObject.onkeydown=null;
}


dhtmlXTreeObject.prototype._onKeyDown=function(e){
    if (window.globalActiveDHTMLGridObject && globalActiveDHTMLGridObject.isActive) 
        return true;
    var self=this;
    for (var i=0; i<this._navKeys.length; i++)
        if (this._navKeys[i][1]==e.keyCode){
        	
            this["_onkey_"+this._navKeys[i][0]].apply(this,[this.getSelectedItemId()]);
            if (e.preventDefault) e.preventDefault();
			(e||event).cancelBubble=true;
            return false;
            }
    if (this._textSearch) {
    	return this._searchItemByKey(e);
    }
    return true;
}

dhtmlXTreeObject.prototype._onkey_up=function(id){
   	var temp=this._globalIdStorageFind(id);
    if (!temp) return;
    var next=this._getPrevVisibleNode(temp);
    if (next.id==this.rootId) return;
    this.focusItem(next.id);
    this.selectItem(next.id,false);
}
dhtmlXTreeObject.prototype._onkey_down=function(id){
   	var temp=this._globalIdStorageFind(id);
    if (!temp) return;
    var next=this._getNextVisibleNode(temp);
    if (next.id==this.rootId) return;
    this.focusItem(next.id);
    this.selectItem(next.id,false);
}
dhtmlXTreeObject.prototype._onkey_open=function(id){
    this.openItem(id);
}
dhtmlXTreeObject.prototype._onkey_close=function(id){
    this.closeItem(id);
}
dhtmlXTreeObject.prototype._onkey_call=function(id){
	if (this.stopEdit){
		this.stopEdit();
		this.parentObject.lastChild.focus();
		this.parentObject.lastChild.focus();
	    this.selectItem(id,true);
		}
	else
	    this.selectItem(this.getSelectedItemId(),true);
}
dhtmlXTreeObject.prototype._onkey_edit=function(id){
	if (this.editItem)
   		this.editItem(id);
}


dhtmlXTreeObject.prototype._getNextVisibleNode=function(item,mode){
	if ((!mode)&&(this._getOpenState(item)>0)) return item.childNodes[0];
	if ((item.tr)&&(item.tr.nextSibling)&&(item.tr.nextSibling.nodem))
    	return item.tr.nextSibling.nodem;

    if (item.parentObject) return  this._getNextVisibleNode(item.parentObject,1);
	return item;
};

dhtmlXTreeObject.prototype._getPrevVisibleNode=function(item){
	if ((item.tr)&&(item.tr.previousSibling)&&(item.tr.previousSibling.nodem))
    	return this._lastVisibleChild(item.tr.previousSibling.nodem);

	if (item.parentObject)
		return item.parentObject;
	else return item;
};

dhtmlXTreeObject.prototype._lastVisibleChild=function(item){
	if (this._getOpenState(item)>0)
		return this._lastVisibleChild(item.childNodes[item.childsCount-1]);
	else return item;
};


dhtmlXTreeObject.prototype._searchItemByKey=function(e){
	if (e.keyCode==8) {
		this._textSearchString='';
		return true;
	}
    var key = String.fromCharCode(e.keyCode).toUpperCase();
    if (key.match(/[A-Z,a-z,0-9\ ]/)) {
	    this._textSearchString += key;
	    this._textSearchInProgress = true;
		if (!(this.getSelectedItemText()||"").match(RegExp('^'+this._textSearchString,"i"))){
		    this.findItem(this._textSearchString, 0);
		}
		this._textSearchInProgress = false;
	    if (e.preventDefault) e.preventDefault();
	    (e||event).cancelBubble=true;
	    return false;
    }
    return true;
}



/**
*     @desc: configure keys used for keyboard navigation
*     @param: keys - configuration array, please check pro_key_nav.html in samples for more details
*     @edition: Professional
*     @type: public
*     @topic: 4
*/
dhtmlXTreeObject.prototype.assignKeys=function(keys){
      this._navKeys=keys;
}

/**
*     @desc: enable search items by pressing keys (any item in tree should be focused/selected to make search work)
*     @param: mode - true/false
*     @edition: Professional
*     @type: public
*     @topic: 4
*/
dhtmlXTreeObject.prototype.enableKeySearch=function(mode){
	this._textSearch = dhx4.s2b(mode);
	if (!this._textSearch) return;
	this._textSearchString = '';
	var self = this;
	this._markItem2 = this._markItem;
	this._markItem = function(node)
				     { 
				     	if (!self._textSearchInProgress)
	                    	self._textSearchString = '';
						self._markItem2(node);
				     }

}
//(c)dhtmlx ltd. www.dhtmlx.com


/*
Product Name: dhtmlxSuite 
Version: 4.1.3 
Edition: Professional 
License: content of this file is covered by DHTMLX Commercial or Enterprise license. Usage without proper license is prohibited. To obtain it contact sales@dhtmlx.com
Copyright UAB Dinamenta http://www.dhtmlx.com
*/

/*
Purpose: temporary loading XML item
Warining - this extension is an experimental and not fully compatible
*/


/**
*     @desc: enable/disable "Loading..." item
*     @param: text - text of temporary item (default is "Loading...")
*     @edition: Professional
*     @type: public
*     @topic: 0
*/
 	dhtmlXTreeObject.prototype.enableLoadingItem=function(text) {
            this.attachEvent("onXLS",this._showFakeItem);
            this.attachEvent("onXLE",this._hideFakeItem);

            this._tfi_text=text||"Loading...";
    };


 	dhtmlXTreeObject.prototype._showFakeItem=function(tree,id) {
        if ((id===null)||(this._globalIdStorageFind("fake_load_xml_"+id))) return;
        var temp = this.XMLsource; this.XMLsource=null;
        this.insertNewItem(id,"fake_load_xml_"+id,this._tfi_text);
        this.XMLsource=temp;
    }
 	dhtmlXTreeObject.prototype._hideFakeItem=function(tree,id) {
        if (id===null) return;
        this.deleteItem("fake_load_xml_"+id);
    }
//(c)dhtmlx ltd. www.dhtmlx.com


/*
Product Name: dhtmlxSuite 
Version: 4.1.3 
Edition: Professional 
License: content of this file is covered by DHTMLX Commercial or Enterprise license. Usage without proper license is prohibited. To obtain it contact sales@dhtmlx.com
Copyright UAB Dinamenta http://www.dhtmlx.com
*/


/*
Purpose: locked item extension for dhtmlxTree
Last updated: 11.01.2006
*/


/**
*     @desc: get locked state of item
*     @param: itemId - id of item
*     @returns: true/false  - locked/unlocked
*     @edition: Professional
*     @type: public
*     @topic: 4
*/
dhtmlXTreeObject.prototype.isLocked=function(itemId)
	{
        if (!this._locker) this._init_lock();
        return  (this._locker[itemId]==true);
	};

dhtmlXTreeObject.prototype._lockItem=function(sNode,state,skipdraw){
	if (!this._locker) this._init_lock();
    if (state){

            if (this._locker[sNode.id]==true) return;
            this._locker[sNode.id]=true;

            sNode.bIm0=sNode.images[0];
            sNode.bIm1=sNode.images[1];
            sNode.bIm2=sNode.images[2];

            sNode.images[0]=this.lico0;
            sNode.images[1]=this.lico1;
            sNode.images[2]=this.lico2;

            var z1=sNode.span.parentNode;
            var z2=z1.previousSibling;

            this.dragger.removeDraggableItem(z1);
            this.dragger.removeDraggableItem(z2);
        }
        else{
            if (this._locker[sNode.id]!=true) return;
            this._locker[sNode.id]=false;

            sNode.images[0]=sNode.bIm0;
            sNode.images[1]=sNode.bIm1;
            sNode.images[2]=sNode.bIm2;

            var z1=sNode.span.parentNode;
            var z2=z1.previousSibling;

            this.dragger.addDraggableItem(z1,this);
            this.dragger.addDraggableItem(z2,this);
        }

       if (!skipdraw) this._correctPlus(sNode);
}
/**
*     @desc: lock/unlock item
*     @param: itemId - id of item
*     @param: state - true/false  - lock/unlock item
*     @edition: Professional
*     @type: public
*     @topic: 4
*/
dhtmlXTreeObject.prototype.lockItem=function(itemId,state)
	{
        if (!this._locker) this._init_lock();
        this._lockOn=false;
		var sNode=this._globalIdStorageFind(itemId);
        this._lockOn=true;
        this._lockItem(sNode,dhx4.s2b(state));
	}
/**
*     @desc: set icon for locked items
*     @param: im0 - icon for locked leaf
*     @param: im1 - icon for closed branch
*     @param: im2 - icon for opened branch
*     @edition: Professional
*     @type: public
*     @topic: 4
*/
dhtmlXTreeObject.prototype.setLockedIcons=function(im0,im1,im2)
	{
        if (!this._locker) this._init_lock();
        this.lico0=im0;
        this.lico1=im1;
        this.lico2=im2;
    };


dhtmlXTreeObject.prototype._init_lock=function()
	{
        this._locker=new Array();
        this._locker_count="0";
        this._lockOn=true;
        this._globalIdStorageFindA=this._globalIdStorageFind;
        this._globalIdStorageFind=this._lockIdFind;

        if (this._serializeItem){
            this._serializeItemA=this._serializeItem;
            this._serializeItem=this._serializeLockItem;


            this._serializeTreeA=this.serializeTree;
            this.serializeTree=this._serializeLockTree;

            }

        this.setLockedIcons(this.imageArray[0],this.imageArray[1],this.imageArray[2]);
    };


dhtmlXTreeObject.prototype._lockIdFind=function(itemId,skipXMLSearch,skipParsing)
	{
        if (!this.skipLock)
            if ((!skipParsing)&&(this._lockOn==true)&&(this._locker[itemId]==true)) {  return null; }
        return this._globalIdStorageFindA(itemId,skipXMLSearch,skipParsing);
    };
dhtmlXTreeObject.prototype._serializeLockItem=function(node)
	{
        if (this._locker[node.id]==true) return "";
        return this._serializeItemA(node);
    };
dhtmlXTreeObject.prototype._serializeLockTree=function()
	{
        var out=this._serializeTreeA();
        return out.replace(/<item[^>]+locked\=\"1\"[^>]+\/>/g,"");
    };


dhtmlXTreeObject.prototype._moveNodeToA=dhtmlXTreeObject.prototype._moveNodeTo;
dhtmlXTreeObject.prototype._moveNodeTo=function(itemObject,targetObject,beforeNode){
	   	if ((targetObject.treeNod.isLocked)&&(targetObject.treeNod.isLocked(targetObject.id))) {
			return false;
		}
		return this._moveNodeToA(itemObject,targetObject,beforeNode);
		}



/**
*     @desc: lock tree
*     @param: isLock - bool value. True - lock, false - unlock
*     @edition: Professional
*     @type: public
*     @topic: 4
*/
dhtmlXTreeObject.prototype.lockTree=function(isLock)
{
	if (dhx4.s2b(isLock))
		this._initTreeLocker();
	else
		if (this._TreeLocker) {
			this._TreeLocker.parentNode.removeChild(this._TreeLocker);
			this._TreeLocker=null;
		}
};


dhtmlXTreeObject.prototype._initTreeLocker=function(isLock)
{
	if (this._TreeLocker) return;
	this.parentObject.style.overflow="hidden";
   	if (this.parentObject.style.position != 'absolute')
		this.parentObject.style.position = 'relative';


	var div = document.createElement('div');
	div.style.position = 'absolute';
	div.style.left = '0px';
	div.style.top = '0px';
	div.className = 'dhx_tree_opacity';

	div.style.width = this.allTree.offsetWidth+'px';
	div.style.backgroundColor = '#FFFFFF';

	div.style.height = this.allTree.offsetHeight+'px';
	//div.style.display = 'none';
	this._TreeLocker = div;
   	this.parentObject.appendChild(this._TreeLocker);
};
//(c)dhtmlx ltd. www.dhtmlx.com

/*
Product Name: dhtmlxSuite 
Version: 4.1.3 
Edition: Professional 
License: content of this file is covered by DHTMLX Commercial or Enterprise license. Usage without proper license is prohibited. To obtain it contact sales@dhtmlx.com
Copyright UAB Dinamenta http://www.dhtmlx.com
*/

/*
Purpose: right-to-left extension for dhtmlxTree
Last updated: 17.02.2006
*/

/**
*     @desc: enables Right-to-Left mode in tree
*     @type: public
*     @param: mode - true/false
*     @edition: Professional
*     @topic: 2
*/
dhtmlXTreeObject.prototype.enableRTL=function(mode){
        var z=dhx4.s2b(mode);
        if (((z)&&(!this.rtlMode))||((!z)&&(this.rtlMode)))
        {
        this.rtlMode=z;
        this._switchToRTL(this.rtlMode);
        }
};



dhtmlXTreeObject.prototype._switchToRTL=function(mode) {
        if (mode){
            this.allTree.className=
            this._ltr_line=this.lineArray;
            this._ltr_min=this.minusArray;
            this._ltr_plus=this.plusArray;
        	this.lineArray=new Array("line2_rtl.gif","line3_rtl.gif","line4_rtl.gif","blank.gif","blank.gif","line1_rtl.gif");
        	this.minusArray=new Array("minus2_rtl.gif","minus3_rtl.gif","minus4_rtl.gif","minus.gif","minus5_rtl.gif");
    	    this.plusArray=new Array("plus2_rtl.gif","plus3_rtl.gif","plus4_rtl.gif","plus.gif","plus5_rtl.gif");
            this.allTree.className="containerTableStyleRTL";
                }
            else
                {
            this.allTree.className="containerTableStyle";
            this.lineArray=this._ltr_line;
            this.minusArray=this._ltr_min;
            this.plusArray=this._ltr_plus;
                }
           if (this.htmlNode.childsCount)
                this._redrawFrom(this,this.htmlNode);
};

//(c)dhtmlx ltd. www.dhtmlx.com



/*
Product Name: dhtmlxSuite 
Version: 4.1.3 
Edition: Professional 
License: content of this file is covered by DHTMLX Commercial or Enterprise license. Usage without proper license is prohibited. To obtain it contact sales@dhtmlx.com
Copyright UAB Dinamenta http://www.dhtmlx.com
*/

/*
Purpose: sorting extension for dhtmlxTree
Last updated: 03.05.2005
*/


/**
*     @desc: reorder items in tree according to their text
*     @type: public
*     @param: nodeId - id of node to start sorting from
*     @param: all_levels - sorting all levels or only current level
*     @param: order - sorting order - ASC or DES
*     @edition: Professional
*     @topic: 0
*/

dhtmlXTreeObject.prototype.sortTree=function(nodeId,order,all_levels)
	{
		var sNode=this._globalIdStorageFind(nodeId);
		if (!sNode) return false;

		this._reorderBranch(sNode,(order.toString().toLowerCase()=="asc"),dhx4.s2b(all_levels))
	};

/**
*     @desc: set custom sort functions, which has two parametrs - id_of_item1,id_of_item2
*     @type: public
*     @param: func - sorting function
*     @edition: Professional
*     @topic: 0
*/
dhtmlXTreeObject.prototype.setCustomSortFunction=function(func)
	{
        this._csfunca=func;
	};
	
	
dhtmlXTreeObject.prototype._reorderBranch=function(node,order,all_levels){ 
	var m=[];
	var count=node.childsCount;
	if (!count) return;

	var parent = node.childNodes[0].tr.parentNode;
	for (var i=0; i<count; i++){
			m[i]=node.childNodes[i];
			parent.removeChild(m[i].tr);
			}

var self=this;
if (order==1)
    if(this._csfunca)
    	m.sort( function(a,b){ return self._csfunca(a.id,b.id); } );
    else
    	m.sort( function(a,b){ return ((a.span.innerHTML.toUpperCase()>b.span.innerHTML.toUpperCase())?1:((a.span.innerHTML.toUpperCase()==b.span.innerHTML.toUpperCase())?0:-1)) } );
else
    if(this._csfunca)
    	m.sort( function(a,b){ return self._csfunca(b.id,a.id); } );
    else
    	m.sort( function(a,b){ return ((a.span.innerHTML.toUpperCase()<b.span.innerHTML.toUpperCase())?1:((a.span.innerHTML.toUpperCase()==b.span.innerHTML.toUpperCase())?0:-1)) } );

	for (var i=0; i<count; i++){
		parent.appendChild(m[i].tr);
		node.childNodes[i]=m[i];
		
		if ((all_levels)&&(m[i].unParsed))
			m[i].unParsed.set("order",order?1:-1);
		else
		if ((all_levels)&&(m[i].childsCount))
			this._reorderBranch(m[i],order,all_levels);
		
		}
	
	for (var i=0; i<count; i++){
		this._correctPlus(m[i]);
		this._correctLine(m[i]);
		}
}

dhtmlXTreeObject.prototype._reorderXMLBranch=function(node){
	var orderold=node.getAttribute("order");
    if (orderold=="none") return;
	var order=(orderold==1);
	var count=node.childNodes.length;
	if (!count) return;

	var m=new Array();
    var j=0;

	for (var i=0; i<count; i++)
        if (node.childNodes[i].nodeType==1)
    		{ m[j]=node.childNodes[i]; j++ }

	for (var i=count-1; i!=0; i--)
		node.removeChild(node.childNodes[i]);


	if (order)
		m.sort( function(a,b){ return ((a.getAttribute("text")>b.getAttribute("text"))?1:((a.getAttribute("text")==b.getAttribute("text"))?0:-1)) } );
	else
		m.sort( function(a,b){ return ((a.getAttribute("text")<b.getAttribute("text"))?1:((a.getAttribute("text")==b.getAttribute("text"))?0:-1)) } );

	for (var i=0; i<j; i++){
		m[i].setAttribute("order",orderold);
		node.appendChild(m[i]);
		}

    node.setAttribute("order","none");
}
//(c)dhtmlx ltd. www.dhtmlx.com

/*
Product Name: dhtmlxSuite 
Version: 4.1.3 
Edition: Professional 
License: content of this file is covered by DHTMLX Commercial or Enterprise license. Usage without proper license is prohibited. To obtain it contact sales@dhtmlx.com
Copyright UAB Dinamenta http://www.dhtmlx.com
*/

/*
Purpose: saving state extension for dhtmlxTree
Inner Version: 1.3
Last updated: 05.07.2005
*/

dhtmlXTreeObject.prototype._serEnts=[["&","&amp;"],["<","&lt;"],[">","&gt;"]];

/**
*     @desc: register XML entity for replacement while initialization (default are: ampersand, lessthen and greaterthen symbols)
*     @type: public
*     @edition: Professional
*	  @param: rChar - source char
*	  @param: rEntity - target entity
*     @topic: 2
*/
dhtmlXTreeObject.prototype.registerXMLEntity=function(rChar,rEntity){
    this._serEnts[this._serEnts.length]=[rChar,rEntity,new RegExp(rChar,"g")];
}

/**
*     @desc: configure XML serialization
*     @type: public
*     @edition: Professional
*	  @param: userData - enable/disable user data serialization
*	  @param: fullXML - enable/disable full XML serialization
*	  @param: escapeEntities - convert tag brackets to related html entitites
*	  @param: userDataAsCData - output user data in CDATA sections
*	  @param: DTD - if specified, then set as XML's DTD
*     @topic: 2
*/
dhtmlXTreeObject.prototype.setSerializationLevel=function(userData,fullXML,escapeEntities,userDataAsCData,DTD){
	this._xuserData=dhx4.s2b(userData);
	this._xfullXML=dhx4.s2b(fullXML);
    this._dtd=DTD;
    this._xescapeEntities=dhx4.s2b(escapeEntities);
    if (dhx4.s2b(userDataAsCData)){
        this._apreUC="<![CDATA[";
        this._apstUC="]]>";
    }
    else{
    }

    for (var i=0; i< this._serEnts.length; i++)
        this._serEnts[i][2]=new RegExp(this._serEnts[i][0],"g");
}

/**
*     @desc: get xml representation (as string) of tree
*     @type: public
*     @edition: Professional
*     @topic: 2
*/
dhtmlXTreeObject.prototype.serializeTree=function(){
    if (this.stopEdit) this.stopEdit();
    this._apreUC=this._apreUC||"";
    this._apstUC=this._apstUC||"";
	var out='<?xml version="1.0"?>';
    if (this._dtd)
        out+="<!DOCTYPE tree SYSTEM \""+this._dtd+"\">";
    out+='<tree id="'+this.rootId+'">';

		if ((this._xuserData)&&(this._idpull[this.rootId]._userdatalist))
		{
		var names=this._idpull[this.rootId]._userdatalist.split(",");
		for  (var i=0; i<names.length; i++)
			out+="<userdata name=\""+names[i]+"\">"+this._apreUC+this._idpull[this.rootId].userData["t_"+names[i]]+this._apstUC+"</userdata>";
		}


		for (var i=0; i<this.htmlNode.childsCount; i++)
		out+=this._serializeItem(this.htmlNode.childNodes[i]);
		
	out+="</tree>";
	return out;
};
/**  
*     @desc: return xml description of tree item
*     @type: private
*     @param: itemNode - tree item object
*     @edition: Professional
*     @topic: 2
*/
dhtmlXTreeObject.prototype._serializeItem=function(itemNode){


	if (itemNode.unParsed)
		if (document.all)
			return itemNode.unParsed.d.xml;
		else{
  var xmlSerializer = new XMLSerializer();
  return xmlSerializer.serializeToString(itemNode.unParsed.d);
		}

		
	var out="";
	if (this._selected.length)
		var lid=this._selected[0].id;
	else lid="\"";


    var text=itemNode.span.innerHTML;

    if (this._xescapeEntities)
        for (var i=0; i<this._serEnts.length; i++)
            text=text.replace(this._serEnts[i][2],this._serEnts[i][1]);

	if (!this._xfullXML)
		out='<item id="'+itemNode.id+'" '+(this._getOpenState(itemNode)==1?' open="1" ':'')+(lid==itemNode.id?' select="1"':'')+' text="'+text+'"'+( ((this.XMLsource)&&(itemNode.XMLload==0))?" child=\"1\" ":"")+'>';
	else
		out='<item id="'+itemNode.id+'" '+(this._getOpenState(itemNode)==1?' open="1" ':'')+(lid==itemNode.id?' select="1"':'')+' text="'+text+'" im0="'+itemNode.images[0]+'" im1="'+itemNode.images[1]+'" im2="'+itemNode.images[2]+'" '+(itemNode.acolor?('aCol="'+itemNode.acolor+'" '):'')+(itemNode.scolor?('sCol="'+itemNode.scolor+'" '):'')+(itemNode.checkstate==1?'checked="1" ':(itemNode.checkstate==2?'checked="-1"':''))+(itemNode.closeable?'closeable="1" ':'')+( ((this.XMLsource)&&(itemNode.XMLload==0))?" child=\"1\" ":"")+'>';

	if ((this._xuserData)&&(itemNode._userdatalist))
		{
		var names=itemNode._userdatalist.split(",");
		for  (var i=0; i<names.length; i++)
			out+="<userdata name=\""+names[i]+"\">"+this._apreUC+itemNode.userData["t_"+names[i]]+this._apstUC+"</userdata>";
		}

		for (var i=0; i<itemNode.childsCount; i++)
			out+=this._serializeItem(itemNode.childNodes[i]);
			


	out+="</item>";
	return out;
}
/**  
*     @desc: save selected item to cookie
*     @type: public
*     @param: name - optional, cookie name
*     @param: cookie_param - additional parametrs added to cookie
*     @edition: Professional
*     @topic: 2
*/
dhtmlXTreeObject.prototype.saveSelectedItem=function(name,cookie_param){
	name=name||"";
	this.setCookie("treeStateSelected"+name,this.getSelectedItemId(),cookie_param);
}
/**     @desc: restore selected item from cookie
*     @type: public
*     @param: name - optional, cookie name
*     @edition: Professional
*     @topic: 2
*/
dhtmlXTreeObject.prototype.restoreSelectedItem=function(name){
	name=name||"";
	var z=this.getCookie("treeStateSelected"+name);
	this.selectItem(z,false);
}


/**   @desc: enable/disable autosaving selected node in cookie
*     @type: public
*     @param: mode - true/false
*     @edition: Professional
*     @topic: 2
*/	
dhtmlXTreeObject.prototype.enableAutoSavingSelected=function(mode,cookieName){
 this.assMode=dhx4.s2b(mode);
 if ((this.assMode)&&(!this.oldOnSelect)){
		 this.oldOnSelect=this.onRowSelect;
		 this.onRowSelect=function(e,htmlObject,mode){
 			if (!htmlObject) htmlObject=this;
			htmlObject.parentObject.treeNod.oldOnSelect(e,htmlObject,mode);
			if (htmlObject.parentObject.treeNod.assMode)
				htmlObject.parentObject.treeNod.saveSelectedItem(htmlObject.parentObject.treeNod.assCookieName);
		}
 }

 this.assCookieName=cookieName;
}


/**   @desc: save tree to cookie
*     @type: public
*     @param: name - optional, cookie name
*     @param: cookie_param - additional parametrs added to cookie
*     @edition: Professional
*     @topic: 2
*/
dhtmlXTreeObject.prototype.saveState=function(name,cookie_param){
	var z=this._escape(this.serializeTree());
	var kusok = 4000;
	if (z.length>kusok)
	{
		if(navigator.appName.indexOf("Microsoft")!=-1)
			return false;//IE max cookie length is ~4100
	this.setCookie("treeStatex"+name,Math.ceil(z.length/kusok));
		for (var i=0; i<Math.ceil(z.length/kusok); i++)
		{
			this.setCookie("treeStatex"+name+"x"+i,z.substr(i*kusok,kusok),cookie_param);
		}
	}
	else
		this.setCookie("treeStatex"+name,z,cookie_param);
	var z=this.getCookie("treeStatex"+name);
    if (!z) {
		this.setCookie("treeStatex"+name,"",cookie_param);
		return false;
	}
    return true;
}
/**   @desc: load tree from cookie
*     @type: public
*     @param: name - optional,cookie name
*     @edition: Professional
*     @topic: 2
*/
dhtmlXTreeObject.prototype.loadState=function(name){
	var z=this.getCookie("treeStatex"+name);
//    alert("treeStatex"+name);
    if (!z) return false;

	if (z.length)
	{
		if (z.toString().length<4)
		{

			var z2="";
			for (var i=0; i<z; i++){
				z2+=this.getCookie("treeStatex"+name+"x"+i);
                }
			z=z2;
		}
		this.loadXMLString((this.utfesc=="utf8")?decodeURI(z):unescape(z));
	}

    return true;
}
/**   @desc: save cookie
*     @type: private
*     @param: name - cookie name
*     @param: value - cookie value
*     @param: cookie_param - additional parametrs added to cookie
*     @edition: Professional
*     @topic: 0
*/

dhtmlXTreeObject.prototype.setCookie=function(name,value,cookie_param) {
	var str = name + "=" + value +  (cookie_param?("; "+cookie_param):"");
  /*  ((expires) ? "; expires=" + expires.toGMTString() : "") +
    ((path) ? "; path=" + path : "; path=/") +
    ((domain) ? "; domain=" + domain : "") +
    ((secure) ? "; secure" : "");*/
	document.cookie = str;
}

/**   @desc: get cookie
*     @type: private
*     @param: name - cookie name
*     @edition: Professional
*     @topic: 0
*/	
dhtmlXTreeObject.prototype.getCookie=function(name) {
	var search = name + "=";
	if (document.cookie.length > 0) {
		var offset = document.cookie.indexOf(search);
		if (offset != -1) {
			offset += search.length;
			var end = document.cookie.indexOf(";", offset);
			if (end == -1)
				end = document.cookie.length;
			return document.cookie.substring(offset, end);
						}		}
};



/**   @desc: save open nodes to cookie
*     @type: public
*     @edition: Professional
*     @param: name - optional,cookie name
*     @param: cookie_param - additional parametrs added to cookie
*     @topic: 2
*/
dhtmlXTreeObject.prototype.saveOpenStates=function(name,cookie_param){
    var z=[];
    for (var i=0; i<this.htmlNode.childsCount; i++)
    	z=z.concat(this._collectOpenStates(this.htmlNode.childNodes[i]));
    z=z.join(this.dlmtr);

	this.setCookie("treeOpenStatex"+name,z,cookie_param);
};

/**   @desc: restore open nodes from cookie
*     @type: public
*     @edition: Professional
*     @param: name - optional,cookie name
*     @topic: 2
*/
dhtmlXTreeObject.prototype.loadOpenStates=function(name){
	for (var i=0; i<this.htmlNode.childsCount; i++)
    	this._xcloseAll(this.htmlNode.childNodes[i]);

 this.allTree.childNodes[0].border = "1";
 this.allTree.childNodes[0].border = "0";

	var z=getCookie("treeOpenStatex"+name);
	if (z) {
		var arr=z.split(this.dlmtr);
		for (var i=0; i<arr.length; i++)
			{
            var zNode=this._globalIdStorageFind(arr[i]);
            if (zNode){
                if  ((this.XMLsource)&&(!zNode.XMLload)&&(zNode.id!=this.rootId)){
                     this._delayedLoad(zNode,"loadOpenStates('"+name+"')");
                     return;
                    }
                else
           			this.openItem(arr[i]);
                }
			}
		}
	this.callEvent("onAllOpenDynamic",[]);
};

dhtmlXTreeObject.prototype._delayedLoad=function(node,name){
    this.afterLoadMethod=name;
	this.onLoadReserve = this.onXLE; //save loading end handler
	this.onXLE=this._delayedLoadStep2; //set on XML data loading end handler
	this._loadDynXML(node.id);
}
dhtmlXTreeObject.prototype._delayedLoadStep2=function(tree){
	tree.onXLE=tree.onLoadReserve; //save loading end handler
//    if (tree.onXLE) tree.onXLE(tree);
    window.setTimeout( function() { dhtmlx.temp = tree; eval("dhtmlx.temp."+tree.afterLoadMethod);  } ,100);
	if (tree.onXLE) tree.onXLE(tree);
	tree.callEvent("onXLE",[tree]);

}

/**   @desc: build list of opened nodes
*     @type: private
*     @edition: Professional
*     @param: node - start tree item
*     @param: list - start list value
*     @topic: 2
*/
dhtmlXTreeObject.prototype._collectOpenStates=function(node){
	var list=[];
	if (this._getOpenState(node)==1)
    {
    list.push(node.id);
	for (var i=0; i<node.childsCount; i++)
		list=list.concat(this._collectOpenStates(node.childNodes[i]));
    }
	return list;
};

/**   @desc: save cookie
*     @type: private
*     @edition: Professional
*     @param: name - cookie name
*     @param: value - cookie value
*     @topic: 0
*/
function setCookie(name,value) {
	document.cookie = name+'='+value;
}

/**   @desc: get cookie
*     @type: private
*     @edition: Professional
*     @param: name - cookie name
*     @topic: 0
*/
function getCookie(name) {
	var search = name + "=";
	if (document.cookie.length > 0) {
		var offset = document.cookie.indexOf(search);
		if (offset != -1) {
			offset += search.length;
			var end = document.cookie.indexOf(";", offset);
			if (end == -1)
				end = document.cookie.length;
			return (document.cookie.substring(offset, end));
						}		}
};

/**
*     @desc: expand target node and all child nodes (same as openAllItems, but works in dynamic trees)
*     @type: public
*     @edition: Professional
*     @param: itemId - node id, optional
*     @topic: 4
*/
	dhtmlXTreeObject.prototype.openAllItemsDynamic = function(itemId)
	{
        this.ClosedElem=new Array();
        this.G_node=null;
		var itemNode = this._globalIdStorageFind(itemId||this.rootId); //get node object by id of tree sart node
		if (itemNode.id != this.rootId &&this.getOpenState(itemNode.id) != 0) this.openItem(itemId);
		this._openAllNodeChilds(itemNode, 0); //open closed nodes that have data, or find nodes that have no data yet


		if(this.ClosedElem.length>0){
			this.onLoadReserve = this.onXLE; //save loading end handler
			this.onXLE=this._loadAndOpen; //set on XML data loading end handler
			this._loadAndOpen(this); //if there are not loaded items -> run load&open routine
		}
	};

	dhtmlXTreeObject.prototype._openAllNodeChilds = function(itemNode)
	{
			//for dynamic loading
    	if ((itemNode.XMLload==0)||(itemNode.unParsed))  this.ClosedElem.push(itemNode);  //if not loaded put in array
		for (var i=0; i<itemNode.childsCount; i++) //for all childnodes
		{
			//no dynamic loading
			if(this._getOpenState(itemNode.childNodes[i])<0) this._HideShow(itemNode.childNodes[i],2); //if closed -> open
			if(itemNode.childNodes[i].childsCount>0) this._openAllNodeChilds(itemNode.childNodes[i]); //if has childs -> run same routine for that node

			//for dynamic loading
			if ((itemNode.childNodes[i].XMLload==0)||(itemNode.childNodes[i].unParsed)) this.ClosedElem.push(itemNode.childNodes[i]); //if not loaded put in array
		}
	}

	dhtmlXTreeObject.prototype._loadAndOpen = function(that)
	{
		if(that.G_node) //if there was loaded one node
		{
			that._openItem(that.G_node); //open it
			that._openAllNodeChilds(that.G_node); //run open/find closed nodes for childs of this node
			that.G_node = null; //erase "just loaded node" pointer
		}

		if(that.ClosedElem.length>0) that.G_node = that.ClosedElem.shift(); //get not loaded node if any left in array

		if(that.G_node)
            if (that.G_node.unParsed)
                that.reParse(that.G_node);
            else
                window.setTimeout( function(){  that._loadDynXML(that.G_node.id); },100);
        else
			{
            that.onXLE = that.onLoadReserve; //restore loading end handler if finished opening
            if (that.onXLE) that.onXLE(that);
			that.callEvent("onAllOpenDynamic",[that]);
			}
	}


/**
*     @desc: expand list of nodes in dynamic tree (wait of loading of node before expanding next)
*     @type: public
*     @edition: Professional
*     @param: list - list of nodes which will be expanded
*     @param: flag - true/false - select last node in the list
*     @topic: 4
*/
    dhtmlXTreeObject.prototype.openItemsDynamic=function(list,flag){
    	if (this.onXLE==this._stepOpen) return;
        this._opnItmsDnmcFlg=dhx4.s2b(flag);
        this.onLoadReserve = this.onXLE;
        this.onXLE=this._stepOpen;
        this.ClosedElem=list.split(",").reverse();
        this._stepOpen(this);
        }

	dhtmlXTreeObject.prototype._stepOpen=function(that){
		if(!that.ClosedElem.length){
			that.onXLE = that.onLoadReserve;
			if (that._opnItmsDnmcFlg)
				that.selectItem(that.G_node,true);
			if ((that.onXLE)&&(arguments[1]))
				that.onXLE.apply(that,arguments);
			that.callEvent("onOpenDynamicEnd",[]);
			return;
		}
		that.G_node=that.ClosedElem.pop();
		that.skipLock = true;
		var temp=that._globalIdStorageFind(that.G_node);

		if(temp){
			if (temp.XMLload===0)
				that.openItem(that.G_node);
			else{
				that.openItem(that.G_node);
				that._stepOpen(that);
			}
		}
		that.skipLock = false;
	}

//(c)dhtmlx ltd. www.dhtmlx.com



/*
Product Name: dhtmlxSuite 
Version: 4.1.3 
Edition: Professional 
License: content of this file is covered by DHTMLX Commercial or Enterprise license. Usage without proper license is prohibited. To obtain it contact sales@dhtmlx.com
Copyright UAB Dinamenta http://www.dhtmlx.com
*/

//latest dev. version

/*_TOPICS_
@0:initialization
@1:selection control
@2:rows control
@3:colums control
@4:cells controll
@5:data manipulation
@6:appearence control
@7:overal control
@8:tools
@9:treegrid
@10: event handlers
@11: paginal output
*/

var globalActiveDHTMLGridObject;
String.prototype._dhx_trim=function(){
	return this.replace(/&nbsp;/g, " ").replace(/(^[ \t]*)|([ \t]*$)/g, "");
}

function dhtmlxArray(ar){
	return dhtmlx.extend((ar||new Array()), dhtmlxArray._master);
};
dhtmlxArray._master={
	_dhx_find:function(pattern){
		for (var i = 0; i < this.length; i++){
			if (pattern == this[i])
				return i;
		}
		return -1;
	},
	_dhx_insertAt:function(ind, value){
		this[this.length]=null;
		for (var i = this.length-1; i >= ind; i--)
			this[i]=this[i-1]
		this[ind]=value
	},
	_dhx_removeAt:function(ind){
			this.splice(ind,1)
	},
	_dhx_swapItems:function(ind1, ind2){
		var tmp = this[ind1];
		this[ind1]=this[ind2]
		this[ind2]=tmp;
	}
}

/**
*   @desc: dhtmlxGrid constructor
*   @param: id - (optional) id of div element to base grid on
*   @returns: dhtmlxGrid object
*   @type: public
*/
function dhtmlXGridObject(id){
	if (dhtmlxEvent.initTouch)
		dhtmlxEvent.initTouch();
	
	if (_isIE)
		try{
			document.execCommand("BackgroundImageCache", false, true);
		}
		catch (e){}

	if (id){
		if (typeof (id) == 'object'){
			this.entBox=id
			if (!this.entBox.id) this.entBox.id="cgrid2_"+this.uid();
		} else
			this.entBox=document.getElementById(id);
	} else {
		this.entBox=document.createElement("DIV");
		this.entBox.id="cgrid2_"+this.uid();
	}
	this.entBox.innerHTML="";
	dhx4._eventable(this);

	var self = this;

	this._wcorr=0;
	this.fontWidth = 7;
	this.cell=null;
	this.row=null;
	this.iconURL="";
	this.editor=null;
	this._f2kE=true;
	this._dclE=true;
	this.combos=new Array(0);
	this.defVal=new Array(0);
	this.rowsAr={
	};

	this.rowsBuffer=dhtmlxArray();
	this.rowsCol=dhtmlxArray(); //array of rows by index

	this._data_cache={
	};

	this._ecache={
	}

	this._ud_enabled=true;
	this.xmlLoader=this.doLoadDetails;

	this._maskArr=[];
	this.selectedRows=dhtmlxArray(); //selected rows array

	this.UserData={};//hash of row related userdata (and for grid - "gridglobaluserdata")
	this._sizeFix=this._borderFix=0;
	/*MAIN OBJECTS*/

	this.entBox.className+=" gridbox";

	this.entBox.style.width=this.entBox.getAttribute("width")
		||(window.getComputedStyle
			? (this.entBox.style.width||window.getComputedStyle(this.entBox, null)["width"])
			: (this.entBox.currentStyle
				? this.entBox.currentStyle["width"]
				: this.entBox.style.width||0))
		||"100%";

	this.entBox.style.height=this.entBox.getAttribute("height")
		||(window.getComputedStyle
			? (this.entBox.style.height||window.getComputedStyle(this.entBox, null)["height"])
			: (this.entBox.currentStyle
				? this.entBox.currentStyle["height"]
				: this.entBox.style.height||0))
		||"100%";
	//cursor and text selection
	this.entBox.style.cursor='default';

	this.entBox.onselectstart=function(){
		return false
	}; //avoid text select
	var t_creator=function(name){
		var t=document.createElement("TABLE");
		t.cellSpacing=t.cellPadding=0;
		t.style.cssText='width:100%;table-layout:fixed;';
		t.className=name.substr(2);
		return t;
	}
	this.obj=t_creator("c_obj");
	this.hdr=t_creator("c_hdr");
	this.hdr.style.marginRight="20px";
	this.hdr.style.paddingRight="20px";
	
	this.objBox=document.createElement("DIV");
	this.objBox.style.width="100%";
	this.objBox.style.overflow="auto";
	this.objBox.appendChild(this.obj);
	this.objBox.className="objbox";

	if (dhtmlx.$customScroll)
		dhtmlx.CustomScroll.enable(this);

	this.hdrBox=document.createElement("DIV");
	this.hdrBox.style.width="100%"
	this.hdrBox.style.height="25px";
	this.hdrBox.style.overflow="hidden";
	this.hdrBox.className="xhdr";
	

	this.preloadImagesAr=new Array(0)

	this.sortImg=document.createElement("DIV")
	this.sortImg.style.display="none";
	
	this.hdrBox.appendChild(this.sortImg)
	this.hdrBox.appendChild(this.hdr);
	this.hdrBox.style.position="relative";

	this.entBox.appendChild(this.hdrBox);
	this.entBox.appendChild(this.objBox);
	
	//add links to current object
	this.entBox.grid=this;
	this.objBox.grid=this;
	this.hdrBox.grid=this;
	this.obj.grid=this;
	this.hdr.grid=this;
	
	/*PROPERTIES*/
	this.cellWidthPX=[];                      //current width in pixels
	this.cellWidthPC=[];                      //width in % if cellWidthType set in pc
	this.cellWidthType=this.entBox.cellwidthtype||"px"; //px or %

	this.delim=this.entBox.delimiter||",";
	this._csvDelim=",";

	this.hdrLabels=[];
	this.columnIds=[];
	this.columnColor=[];
	this._hrrar=[];
	this.cellType=dhtmlxArray();
	this.cellAlign=[];
	this.initCellWidth=[];
	this.fldSort=[];
	this._srdh=(_isIE && (document.compatMode != "BackCompat") ? 22 : 20);
	this.imgURL=window.dhx_globalImgPath||""; 
	this.isActive=false; //fl to indicate if grid is in work now
	this.isEditable=true;
	this.useImagesInHeader=false; //use images in header or not
	this.pagingOn=false;          //paging on/off
	this.rowsBufferOutSize=0;     //number of rows rendered at a moment
	/*EVENTS*/
	dhtmlxEvent(window, "unload", function(){
		try{
			if (self.destructor) self.destructor();
		}
		catch (e){}
	});

	/*XML LOADER(S)*/
	/**
	*   @desc: set one of predefined css styles (xp, mt, gray, light, clear, modern)
	*   @param: name - style name
	*   @type: public
	*   @topic: 0,6
	*/
	this.setSkin=function(name){
		this._srdh=window.dhx4.readFromCss("dhxgrid_rh_"+name)+4;
		this.skin_name=name;
		if (this._imgURL)
			this.setImagePath(this._imgURL);

		var classname = this.entBox.className.split(" gridbox")[0];
		this.entBox.className=classname + " gridbox gridbox_"+name+(_isIE?" isIE":" isModern");
		this.skin_h_correction=0;
		
//#alter_css:06042008{		
		this.enableAlterCss("ev_"+name, "odd_"+name, this.isTreeGrid())
		this._fixAlterCss()
//#}
		switch (name){
			case "dhx_terrace":
				this._srdh=33;
				this.forceDivInHeader=true;
				break;

			case "dhx_skyblue":
			case "dhx_web":
				this.forceDivInHeader=true;
				break;
		}

		if (_isIE&&this.hdr){
			var d = this.hdr.parentNode;
			d.removeChild(this.hdr);
			d.appendChild(this.hdr);
		}
		this.setSizes();
	}

	if (_isIE)
		this.preventIECaching(true);
	if (window.dhtmlDragAndDropObject)
		this.dragger=new dhtmlDragAndDropObject();

	/*METHODS. SERVICE*/
	/**
	*   @desc: on scroll grid inner actions
	*   @type: private
	*   @topic: 7
	*/
	this._doOnScroll=function(e, mode){
		this.callEvent("onScroll", [
			this.objBox.scrollLeft,
			this.objBox.scrollTop
		]);

		this.doOnScroll(e, mode);
	}
	/**
	*   @desc: on scroll grid more inner action
	*   @type: private
	*   @topic: 7
	*/
	this.doOnScroll=function(e, mode){
		this.hdrBox.scrollLeft=this.objBox.scrollLeft;
		if (this.ftr)
			this.ftr.parentNode.scrollLeft=this.objBox.scrollLeft;

		if (mode)
			return;

		if (this._srnd){
			if (this._dLoadTimer)
				window.clearTimeout(this._dLoadTimer);
			this._dLoadTimer=window.setTimeout(function(){
				if (self._update_srnd_view)
					self._update_srnd_view();
			}, 100);
		}
	}
	/**
	*   @desc: attach grid to some object in DOM
	*   @param: obj - object to attach to
	*   @type: public
	*   @topic: 0,7
	*/
	this.attachToObject=function(obj){
		obj.appendChild(this.globalBox?this.globalBox:this.entBox);
		//this.objBox.style.height=this.entBox.style.height;
		this.setSizes();
	}
	/**
	*   @desc: initialize grid
	*   @param: fl - if to parse on page xml data island 
	*   @type: public
	*   @topic: 0,7
	*/
	this.init=function(fl){
		if ((this.isTreeGrid())&&(!this._h2)){
			this._h2=new dhtmlxHierarchy();

			if ((this._fake)&&(!this._realfake))
				this._fake._h2=this._h2;
			this._tgc={
				imgURL: null
				};
		}

		if (!this._hstyles)
			return;

		if (!this.skin_name)
			this.setSkin(window.dhx4.skin||(typeof(dhtmlx)!="undefined"?dhtmlx.skin:null)||window.dhx4.skinDetect("dhxgrid")||"dhx_skyblue");

		this.editStop()
		/*TEMPORARY STATES*/
		this.lastClicked=null;                //row clicked without shift key. used in multiselect only
		this.resized=null;                    //hdr cell that is resized now
		this.fldSorted=this.r_fldSorted=null; //hdr cell last sorted
		//empty grid if it already was initialized
		this.cellWidthPX=[];
		this.cellWidthPC=[];

		if (this.hdr.rows.length > 0){
			var temp = this.xmlFileUrl;
			this.clearAll(true);
			this.xmlFileUrl = temp;
		}

		var hdrRow = this.hdr.insertRow(0);

		for (var i = 0; i < this.hdrLabels.length; i++){
			hdrRow.appendChild(document.createElement("TH"));
			hdrRow.childNodes[i]._cellIndex=i;
			hdrRow.childNodes[i].style.height="0px";
		}

		if (_isIE && _isIE<8 && document.body.style.msTouchAction == this.undefined)
			hdrRow.style.position="absolute";
		else
			hdrRow.style.height='auto';

		var hdrRow = this.hdr.insertRow(_isKHTML ? 2 : 1);

		hdrRow._childIndexes=new Array();
		var col_ex = 0;

		for (var i = 0; i < this.hdrLabels.length; i++){
			hdrRow._childIndexes[i]=i-col_ex;

			if ((this.hdrLabels[i] == this.splitSign)&&(i != 0)){
				if (_isKHTML)
					hdrRow.insertCell(i-col_ex);
				hdrRow.cells[i-col_ex-1].colSpan=(hdrRow.cells[i-col_ex-1].colSpan||1)+1;
				hdrRow.childNodes[i-col_ex-1]._cellIndex++;
				col_ex++;
				hdrRow._childIndexes[i]=i-col_ex;
				continue;
			}

			hdrRow.insertCell(i-col_ex);

			hdrRow.childNodes[i-col_ex]._cellIndex=i;
			hdrRow.childNodes[i-col_ex]._cellIndexS=i;
			this.setColumnLabel(i, this.hdrLabels[i]);
		}

		if (col_ex == 0)
			hdrRow._childIndexes=null;
		this._cCount=this.hdrLabels.length;

		if (_isIE)
			window.setTimeout(function(){
				if (self.setSizes)
					self.setSizes();
			}, 1);

		//create virtual top row
		if (!this.obj.firstChild)
			this.obj.appendChild(document.createElement("TBODY"));

		var tar = this.obj.firstChild;

		if (!tar.firstChild){
			tar.appendChild(document.createElement("TR"));
			tar=tar.firstChild;

			if (_isIE && _isIE<8 && document.body.style.msTouchAction == this.undefined)
				tar.style.position="absolute";
			else
				tar.style.height='auto';

			for (var i = 0; i < this.hdrLabels.length; i++){
				tar.appendChild(document.createElement("TH"));
				tar.childNodes[i].style.height="0px";
			}
		}

		this._c_order=null;

		if (this.multiLine != true)
			this.obj.className+=" row20px";

		//
		//this.combos = new Array(this.hdrLabels.length);
		//set sort image to initial state
		this.sortImg.style.position="absolute";
		this.sortImg.style.display="none";
		this.sortImg.className = "dhxgrid_sort_desc";
		this.sortImg.defLeft=0;

		if (this.noHeader){
			this.hdrBox.style.display='none';
		}
		else {
			this.noHeader=false
		}
//#__pro_feature:21092006{
//#column_hidden:21092006{
		if (this._ivizcol)
			this.setColHidden();
//#}
//#}
//#header_footer:06042008{		
		this.attachHeader();
		this.attachHeader(0, 0, "_aFoot");
//#}
		this.setSizes();

		if (fl)
			this.parseXML()
		this.obj.scrollTop=0

		if (this.dragAndDropOff)
			this.dragger.addDragLanding(this.entBox, this);

		if (this._initDrF)
			this._initD();

		dhx4.callEvent("onGridCreated", [this]);
	};
	
	this.setColumnSizes=function(gridWidth){
		var summ = 0;
		var fcols = []; //auto-size columns

		var fix = 0;
		for (var i = 0; i < this._cCount; i++){
			if ((this.initCellWidth[i] == "*") && !this._hrrar[i]){
				this._awdth=false; //disable auto-width
				fcols.push(i);
				continue;
			}

			if (this.cellWidthType == '%'){
				if (typeof this.cellWidthPC[i]=="undefined")
					this.cellWidthPC[i]=this.initCellWidth[i];
				var cwidth = (gridWidth*this.cellWidthPC[i]/100)||0;
				if (fix>0.5){
					cwidth++;
					fix--;
				}
				var rwidth = this.cellWidthPX[i]=Math.floor(cwidth);
				var fix =fix + cwidth - rwidth;
			} else{
				if (typeof this.cellWidthPX[i]=="undefined")
					this.cellWidthPX[i]=this.initCellWidth[i];
			}
			if (!this._hrrar[i])
				summ+=this.cellWidthPX[i]*1;
		}

		//auto-size columns
		if (fcols.length){
			var ms = Math.floor((gridWidth-summ)/fcols.length);
			if (ms < 0) ms=1;

			for (var i = 0; i < fcols.length; i++){
				var next=Math.max((this._drsclmW ? (this._drsclmW[fcols[i]]||0) : 0),ms)
				this.cellWidthPX[fcols[i]]=next;
				summ+=next;
			}
			
			if(gridWidth > summ){
				var last=fcols[fcols.length-1];
    			this.cellWidthPX[last]=this.cellWidthPX[last] + (gridWidth-summ);
				summ = gridWidth;
			}
			
			this._setAutoResize();
		}
		
		
		this.obj.style.width=summ+"px";
		this.hdr.style.width=summ+"px";
		if (this.ftr) this.ftr.style.width=summ+"px";

		this.chngCellWidth();
		return summ;
	}
	
	/**shz)_
	*   @desc: sets sizes of grid elements
	*   @type: private
	*   @topic: 0,7
	*/
	this.setSizes=function(){
		//drop processing if grid still not initialized 
		if ((!this.hdr.rows[0])) return;

		var quirks=this.quirks = (_isIE && document.compatMode=="BackCompat");
		var outerBorder=(this.entBox.offsetWidth-this.entBox.clientWidth)/2;		
		
		if (!this.dontSetSizes){
			if (this.globalBox){
				var splitOuterBorder=(this.globalBox.offsetWidth-this.globalBox.clientWidth)/2;		
				if (this._delta_x && !this._realfake){
					var ow = this.globalBox.clientWidth;
					this.globalBox.style.width=this._delta_x;
					this.entBox.style.width=Math.max(0,(this.globalBox.clientWidth+(quirks?splitOuterBorder*2:0))-this._fake.entBox.clientWidth)+"px";
					if (ow != this.globalBox.clientWidth){
						this._fake._correctSplit(this._fake.entBox.clientWidth);
					}
				}
				if (this._delta_y && !this._realfake){
					this.globalBox.style.height = this._delta_y;
					this.entBox.style.overflow = this._fake.entBox.style.overflow="hidden";
					this.entBox.style.height = this._fake.entBox.style.height=this.globalBox.clientHeight+(quirks?splitOuterBorder*2:0)+"px";
				}
			} else {
				if (this._delta_x){
					/*when placed directly in TD tag, container can't use native percent based sizes, 
						because table auto-adjust to show all content - too clever*/
					if (this.entBox.parentNode && this.entBox.parentNode.tagName=="TD"){
						this.entBox.style.width="1px";
						this.entBox.style.width=parseInt(this._delta_x)*this.entBox.parentNode.clientWidth/100-outerBorder*2+"px";
					}else
						this.entBox.style.width=this._delta_x;
				}
				if (this._delta_y)
					this.entBox.style.height=this._delta_y;
			}
		}
			
		//if we have container without sizes, wait untill sizes defined
		window.clearTimeout(this._sizeTime);		
		if (!this.entBox.offsetWidth && (!this.globalBox || !this.globalBox.offsetWidth)){
			this._sizeTime=window.setTimeout(function(){
				if (self.setSizes)
					self.setSizes();
			}, 250);
			return;
		}		
		
		var border_x = ((!this._wthB) && ((this.entBox.cmp||this._delta_x) && (this.skin_name||"").indexOf("dhx")==0 && !quirks)?2:0);
		var border_y = ((!this._wthB) && ((this.entBox.cmp||this._delta_y) && (this.skin_name||"").indexOf("dhx")==0 && !quirks)?2:0);

		if (this._sizeFix){
			border_x -= this._sizeFix;
			border_y -= this._sizeFix;
		}
		
		var isVScroll = this.parentGrid?false:(this.objBox.scrollHeight > this.objBox.offsetHeight);
		
		var scrfix = dhtmlx.$customScroll?0:18;
		
		var gridWidth=this.entBox.clientWidth-(this.skin_h_correction||0)*(quirks?0:1)-border_x;
		var gridWidthActive=this.entBox.clientWidth-(this.skin_h_correction||0)-border_x;
		var gridHeight=this.entBox.clientHeight-border_y;
		var summ=this.setColumnSizes(gridWidthActive-(isVScroll?scrfix:0)-(this._correction_x||0));
		
		var isHScroll = this.parentGrid?false:((this.objBox.scrollWidth > this.objBox.offsetWidth)||(this.objBox.style.overflowX=="scroll")); 
		var headerHeight = this.hdr.clientHeight;
		var footerHeight = this.ftr?this.ftr.clientHeight:0;
		var newWidth=gridWidth;
		var newHeight=gridHeight-headerHeight-footerHeight;

		//if we have auto-width without limitations - ignore h-scroll
		if (this._awdth && this._awdth[0] && this._awdth[1]==99999) isHScroll=0;
		//auto-height
		if (this._ahgr){
			if (this._ahgrMA)
				newHeight=this.entBox.parentNode.clientHeight-headerHeight-footerHeight;
			else
				newHeight=this.obj.offsetHeight+(isHScroll?scrfix:0)+(this._correction_y||0);

			if (this._ahgrM){
				if (this._ahgrF) 
					newHeight=Math.min(this._ahgrM,newHeight+headerHeight+footerHeight)-headerHeight-footerHeight;
				else 
					newHeight=Math.min(this._ahgrM,newHeight);
				
			}
			if (isVScroll && newHeight>=this.obj.scrollHeight+(isHScroll?scrfix:0)){
				isVScroll=false;//scroll will be compensated;
				this.setColumnSizes(gridWidthActive-(this._correction_x||0)); //correct auto-size columns
			}
		}

		//auto-width
		if ((this._awdth)&&(this._awdth[0])){ 
			//convert percents to PX, because auto-width with procents has no sense
			if (this.cellWidthType == '%') this.cellWidthType="px";
			
			if (this._fake) summ+=this._fake.entBox.clientWidth;	//include fake grid in math
			var newWidth=Math.min(Math.max(summ+(isVScroll?scrfix:0),this._awdth[2]),this._awdth[1])+(this._correction_x||0);
			this.objBox.style.overflowX = (!isVScroll && this.objBox.scrollWidth <= newWidth)?"hidden":"auto";
			if (this._fake) newWidth-=this._fake.entBox.clientWidth;
		}

		newHeight=Math.max(0,newHeight);//validate value for IE
		
		//FF3.1, bug in table rendering engine
		this._ff_size_delta=(this._ff_size_delta==0.1)?0.2:0.1;
		if (!_isFF) this._ff_size_delta=0;
		
		if (!this.dontSetSizes){
			this.entBox.style.width=Math.max(0,newWidth+(quirks?2:0)*outerBorder+this._ff_size_delta)+"px";
			this.entBox.style.height=newHeight+(quirks?2:0)*outerBorder+headerHeight+footerHeight+"px";
		}
		this.objBox.style.height=newHeight+((quirks&&!isVScroll)?2:0)*outerBorder+"px";//):this.entBox.style.height);
		this.hdrBox.style.height=headerHeight+"px";		
		
		
		if (newHeight != gridHeight)
			this.doOnScroll(0, !this._srnd);
		var ext=this["setSizes_"+this.skin_name];
		if (ext) ext.call(this);
			
		this.setSortImgPos();	
		
		//it possible that changes of size, has changed header height 
		if (headerHeight != this.hdr.clientHeight && this._ahgr) 	
			this.setSizes();
		this.callEvent("onSetSizes",[]);
	};
	/**
	*   @desc: changes cell width
	*   @param: [ind] - index of row in grid
	*   @type: private
	*   @topic: 4,7
	*/
	this.chngCellWidth=function(){
		if ((_isOpera)&&(this.ftr))
			this.ftr.width=this.objBox.scrollWidth+"px";
		var l = this._cCount;

		for (var i = 0; i < l; i++){
			this.hdr.rows[0].cells[i].style.width=this.cellWidthPX[i]+"px";
			this.obj.rows[0].childNodes[i].style.width=this.cellWidthPX[i]+"px";
			
			if (this.ftr)
				this.ftr.rows[0].cells[i].style.width=this.cellWidthPX[i]+"px";
		}
	}
	/**
	*   @desc: set delimiter character used in list values (default is ",")
	*   @param: delim - delimiter as string
	*   @before_init: 1
	*   @type: public
	*   @topic: 0
	*/
	this.setDelimiter=function(delim){
		this.delim=delim;
	}
	/**
	*   @desc: set width of columns in percents
	*   @type: public
	*   @before_init: 1
	*   @param: wp - list of column width in percents
	*   @topic: 0,7
	*/
	this.setInitWidthsP=function(wp){
		this.cellWidthType="%";
		this.initCellWidth=wp.split(this.delim.replace(/px/gi, ""));
		if (!arguments[1]) this._setAutoResize();
	}
	/**
	*	@desc:
	*	@type: private
	*	@topic: 0
	*/
	this._setAutoResize=function(){
		if (this._realfake) return;
		var el = window;
		var self = this;
		
		dhtmlxEvent(window,"resize",function(){
			window.clearTimeout(self._resize_timer);
			if (self._setAutoResize)
				self._resize_timer=window.setTimeout(function(){
					if (self.setSizes)
						self.setSizes();
					if (self._fake)
						self._fake._correctSplit();
				}, 100);
		})
	}


	/**
	*   @desc: set width of columns in pixels
	*   @type: public
	*   @before_init: 1
	*   @param: wp - list of column width in pixels
	*   @topic: 0,7
	*/
	this.setInitWidths=function(wp){
		this.cellWidthType="px";
		this.initCellWidth=wp.split(this.delim);

		if (_isFF){
			for (var i = 0; i < this.initCellWidth.length; i++)
				if (this.initCellWidth[i] != "*")
					this.initCellWidth[i]=parseInt(this.initCellWidth[i]);
		}
	}

	/**
	*   @desc: set multiline rows support to enabled or disabled state
	*   @type: public
	*   @before_init: 1
	*   @param: state - true or false
	*   @topic: 0,7
	*/
	this.enableMultiline=function(state){
		this.multiLine=dhx4.s2b(state);
	}

	/**
	*   @desc: set multiselect mode to enabled or disabled state
	*   @type: public
	*   @param: state - true or false
	*   @topic: 0,7
	*/
	this.enableMultiselect=function(state){
		this.selMultiRows=dhx4.s2b(state);
	}

	/**
	*   @desc: set path to grid internal images (sort direction, any images used in editors, checkbox, radiobutton)
	*   @type: public
	*   @param: path - url (or relative path) of images folder with closing "/"
	*   @topic: 0,7
	*/
	this.setImagePath=function(path){
		path = path.replace(/imgs\/dhxgrid_[a-z]*\/$/,"imgs/");
		this._imgURL= path;
		this.imgURL = path + "dhxgrid_"+(this.skin_name || "dhx_skyblue").replace("dhx_", "") + "/";
		this.iconTree = this.imgURL + "tree/";
	}
	this.setImagesPath=this.setImagePath;
	/**
	*   @desc: set path to external images used in grid ( tree and img column types )
	*   @type: public
	*   @param: path - url (or relative path) of images folder with closing "/"
	*   @topic: 0,7
	*/
	this.setIconPath=function(path){
		this.iconURL=path;
	}	
	this.setIconsPath=this.setIconPath;
//#column_resize:06042008{
	/**
	*   @desc: part of column resize routine
	*   @type: private
	*   @param: ev - event
	*   @topic: 3
	*/
	this.changeCursorState=function(ev){
		var el = ev.target||ev.srcElement;

		if (el.tagName != "TD")
			el=this.getFirstParentOfType(el, "TD")
		if (!el) return;
		if ((el.tagName == "TD")&&(this._drsclmn)&&(!this._drsclmn[el._cellIndex]))
			return el.style.cursor="default";
		var check = (ev.layerX||0)+(((!_isIE)&&(ev.target.tagName == "DIV")) ? el.offsetLeft : 0);
		if ((el.offsetWidth-(ev.offsetX||(parseInt(this.getPosition(el, this.hdrBox))-check)*-1)) < (_isOpera?20:10)){
			el.style.cursor="E-resize";
		}
		else{
		    el.style.cursor="default";
		}

		if (_isOpera)
			this.hdrBox.scrollLeft=this.objBox.scrollLeft;
	}
	/**
	*   @desc: part of column resize routine
	*   @type: private
	*   @param: ev - event
	*   @topic: 3
	*/
	this.startColResize=function(ev){
		if (this.resized) this.stopColResize();
		this.resized=null;
		var el = ev.target||ev.srcElement;
		if (el.tagName != "TD")
			el=this.getFirstParentOfType(el, "TD")
		var x = ev.clientX;
		var tabW = this.hdr.offsetWidth;
		var startW = parseInt(el.offsetWidth)

		if (el.tagName == "TD"&&el.style.cursor != "default"){
			if ((this._drsclmn)&&(!this._drsclmn[el._cellIndex]))
				return;
				
			self._old_d_mm=document.body.onmousemove;
			self._old_d_mu=document.body.onmouseup;
			document.body.onmousemove=function(e){
				if (self)
					self.doColResize(e||window.event, el, startW, x, tabW)
			}
			document.body.onmouseup=function(){
				if (self)
					self.stopColResize();
			}
		}
	}
	/**
	*   @desc: part of column resize routine
	*   @type: private
	*   @param: ev - event
	*   @topic: 3
	*/
	this.stopColResize=function(){ 
		document.body.onmousemove=self._old_d_mm||"";
		document.body.onmouseup=self._old_d_mu||"";
		this.setSizes();
		this.doOnScroll(0, 1)
		this.callEvent("onResizeEnd", [this]);
	}
	/**
	*   @desc: part of column resize routine
	*   @param: el - element (column resizing)
	*   @param: startW - started width
	*   @param: x - x coordinate to resize from
	*   @param: tabW - started width of header table
	*   @type: private
	*   @topic: 3
	*/
	this.doColResize=function(ev, el, startW, x, tabW){
		el.style.cursor="E-resize";
		this.resized=el;
		var fcolW = startW+(ev.clientX-x);
		var wtabW = tabW+(ev.clientX-x)

		if (!(this.callEvent("onResize", [
			el._cellIndex,
			fcolW,
			this
		])))
			return;

		if (_isIE)
			this.objBox.scrollLeft=this.hdrBox.scrollLeft;

		var result = false;
		if (el.colSpan > 1){
			var a_sizes = new Array();

			for (var i = 0;
				i < el.colSpan;
				i++)a_sizes[i]=Math.round(fcolW*this.hdr.rows[0].childNodes[el._cellIndexS+i].offsetWidth/el.offsetWidth);

			for (var i = 0; i < el.colSpan; i++)
				result = this._setColumnSizeR(el._cellIndexS+i*1, a_sizes[i]);
		} else
			result = this._setColumnSizeR(el._cellIndex, fcolW);
		this.doOnScroll(0, 1);

        this.setSizes();
        if (this._fake && this._awdth) this._fake._correctSplit();
        
        return result;
	}

	/**
	*   @desc: set width of grid columns ( zero row of header and body )
	*   @type: private
	*   @topic: 7
	*/
	this._setColumnSizeR=function(ind, fcolW){
		if (fcolW > ((this._drsclmW&&!this._notresize) ? (this._drsclmW[ind]||10) : 10)){
			this.obj.rows[0].childNodes[ind].style.width=fcolW+"px";
			this.hdr.rows[0].childNodes[ind].style.width=fcolW+"px";

			if (this.ftr)
				this.ftr.rows[0].childNodes[ind].style.width=fcolW+"px";

			if (this.cellWidthType == 'px'){
				this.cellWidthPX[ind]=fcolW;
			}
			else {
				var gridWidth = parseInt(this.entBox.offsetWidth);

				if (this.objBox.scrollHeight > this.objBox.offsetHeight)
					gridWidth-=17;
				var pcWidth = Math.round(fcolW / gridWidth*100)
				this.cellWidthPC[ind]=pcWidth;
			}
			if (this.sortImg.style.display!="none")
				this.setSortImgPos();
		} else return false;
	}
//#}
//#sorting:06042008{
	/**
	*    @desc: sets position and visibility of sort arrow
	*    @param: state - true/false - show/hide image
	*    @param: ind - index of field
	*    @param: order - asc/desc - type of image
	*    @param: row - one based index of header row ( used in multirow headers, top row by default )
	*   @type: public
	*   @topic: 7
	*/
	this.setSortImgState=function(state, ind, order, row){
		order=(order||"asc").toLowerCase();

		if (!dhx4.s2b(state)){
			this.sortImg.style.display="none";
			this.fldSorted=this.r_fldSorted = null;
			return;
		}

		if (order == "asc")
			this.sortImg.className = "dhxgrid_sort_asc";
		else
			this.sortImg.className = "dhxgrid_sort_desc";

		this.sortImg.style.display="";
		this.fldSorted=this.hdr.rows[0].childNodes[ind];
		var r = this.hdr.rows[row||1];
		if (!r) return;

		for (var i = 0; i < r.childNodes.length; i++){
			if (r.childNodes[i]._cellIndexS == ind){
				this.r_fldSorted=r.childNodes[i];
				return  this.setSortImgPos();
			}
		}
		return this.setSortImgState(state,ind,order,(row||1)+1);
	}

	/**
	*    @desc: sets position and visibility of sort arrow
	*    @param: ind - index of field
	*    @param: ind - index of field
	*    @param: hRowInd - index of row in case of complex header, one-based, optional

	*   @type: private
	*   @topic: 7
	*/
	this.setSortImgPos=function(ind, mode, hRowInd, el){
		if (this._hrrar && this._hrrar[this.r_fldSorted?this.r_fldSorted._cellIndex:ind]) return;
		if (!el){
			if (!ind)
				var el = this.r_fldSorted;
			else
				var el = this.hdr.rows[hRowInd||0].cells[ind];
		}

		if (el != null){
			var pos = this.getPosition(el, this.hdrBox)
			var wdth = el.offsetWidth;
			this.sortImg.style.left=Number(pos[0]+wdth-13)+"px"; //Number(pos[0]+5)+"px";
			this.sortImg.defLeft=parseInt(this.sortImg.style.left)
			this.sortImg.style.top=Number(pos[1]+5)+"px";

			if ((!this.useImagesInHeader)&&(!mode))
				this.sortImg.style.display="inline";
			this.sortImg.style.left=this.sortImg.defLeft+"px"; //-parseInt(this.hdrBox.scrollLeft)
		}
	}
//#}
	/**
	*   @desc: manage activity of the grid.
	*   @param: fl - true to activate,false to deactivate
	*   @type: private
	*   @topic: 1,7
	*/
	this.setActive=function(fl){
		if (arguments.length == 0)
			var fl = true;

		if (fl == true){
			//document.body.onkeydown = new Function("","document.getElementById('"+this.entBox.id+"').grid.doKey()")//
			if (globalActiveDHTMLGridObject&&(globalActiveDHTMLGridObject != this)){
				globalActiveDHTMLGridObject.editStop();
				globalActiveDHTMLGridObject.callEvent("onBlur",[globalActiveDHTMLGridObject]);
			}

			globalActiveDHTMLGridObject=this;
			this.isActive=true;
		} else {
			this.isActive=false;
			this.callEvent("onBlur",[this]);
		}
	};
	/**
	*     @desc: called on click occured
	*     @type: private
	*/
	this._doClick=function(ev){
		var selMethod = 0;
		var el = this.getFirstParentOfType(_isIE ? ev.srcElement : ev.target, "TD");
		if (!el || !el.parentNode || !el.parentNode.idd) return;
		var fl = true;

		//mm
		//markers start
		if (this.markedCells){
			var markMethod = 0;

			if (ev.shiftKey||ev.metaKey){
				markMethod=1;
			}

			if (ev.ctrlKey){
				markMethod=2;
			}
			this.doMark(el, markMethod);
			return true;
		}
		//markers end
		//mm

		if (this.selMultiRows != false){
			if (ev.shiftKey && this.row != null && this.selectedRows.length){
				selMethod=1;
			}

			if (ev.ctrlKey||ev.metaKey){
				selMethod=2;
			}
		}
		return this.doClick(el, fl, selMethod, false)
	};

//#context_menu:06042008{
	/**
	*   @desc: called onmousedown inside grid area
	*   @type: private
	*/
	this._doContClick=function(ev){ 
		var el = this.getFirstParentOfType(_isIE ? ev.srcElement : ev.target, "TD");

		if ((!el)||( typeof (el.parentNode.idd) == "undefined")){
			this.callEvent("onEmptyClick", [ev]);
			return true;
		}

		if (ev.button == 2||(_isMacOS&&ev.ctrlKey)){
			if (!this.callEvent("onRightClick", [
				el.parentNode.idd,
				el._cellIndex,
				ev
			])){
				var z = function(e){
					(e||event).cancelBubble=true;
					return false;
				};

				(ev.srcElement||ev.target).oncontextmenu=z;
				return z(ev);
			}

			if (this._ctmndx){
				if (!(this.callEvent("onBeforeContextMenu", [
					el.parentNode.idd,
					el._cellIndex,
					this
				])))
					return true;
					
				if (_isIE)
					ev.srcElement.oncontextmenu=function(){
						event.cancelBubble=true;
						return false;
					};
					
				if (this._ctmndx.showContextMenu){
					
var dEl0=window.document.documentElement;
var dEl1=window.document.body;
var corrector = new Array((dEl0.scrollLeft||dEl1.scrollLeft),(dEl0.scrollTop||dEl1.scrollTop));
if (_isIE){
	var x= ev.clientX+corrector[0];
	var y = ev.clientY+corrector[1];
} else {
	var x= ev.pageX;
	var y = ev.pageY;
}
					this._ctmndx.showContextMenu(x-1,y-1)
					this.contextID=this._ctmndx.contextMenuZoneId=el.parentNode.idd+"_"+el._cellIndex;
					this._ctmndx._skip_hide=true;
				} else {
					el.contextMenuId=el.parentNode.idd+"_"+el._cellIndex;
					el.contextMenu=this._ctmndx;
					el.a=this._ctmndx._contextStart;
					el.a(el, ev);
					el.a=null;
				}
				ev.cancelBubble=true;
				return false;
			}
		}

		else if (this._ctmndx){
			if (this._ctmndx.hideContextMenu)
				this._ctmndx.hideContextMenu()
			else
				this._ctmndx._contextEnd();
		}
		return true;
	}
//#}
	/**
	*    @desc: occures on cell click (supports treegrid)
	*   @param: [el] - cell to click on
	*   @param:   [fl] - true if to call onRowSelect function
	*   @param: [selMethod] - 0 - simple click, 1 - shift, 2 - ctrl
	*   @param: show - true/false - scroll row to view, true by defaul    
	*   @type: private
	*   @topic: 1,2,4,9
	*/
	this.doClick=function(el, fl, selMethod, show){
		if (!this.selMultiRows) selMethod=0; //block programmatical multiselecton if mode not enabled explitly
		var psid = this.row ? this.row.idd : 0;

		this.setActive(true);

		if (!selMethod)
			selMethod=0;

		if (this.cell != null)
			this.cell.className=this.cell.className.replace(/cellselected/g, "");

		if (el.tagName == "TD"){
			if (this.checkEvent("onSelectStateChanged"))
				var initial = this.getSelectedId();
			var prow = this.row;
		if (selMethod == 1){
				var elRowIndex = this.rowsCol._dhx_find(el.parentNode)
				var lcRowIndex = this.rowsCol._dhx_find(this.lastClicked)

				if (elRowIndex > lcRowIndex){
					var strt = lcRowIndex;
					var end = elRowIndex;
				} else {
					var strt = elRowIndex;
					var end = lcRowIndex;
				}

				for (var i = 0; i < this.rowsCol.length; i++)
					if ((i >= strt&&i <= end)){
						if (this.rowsCol[i]&&(!this.rowsCol[i]._sRow)){
							if (this.rowsCol[i].className.indexOf("rowselected")
								== -1&& (this.callEvent("onBeforeSelect", [
								this.rowsCol[i].idd,
								psid,
								el._cellIndex
							]))){
								this.rowsCol[i].className+=" rowselected";
								this.selectedRows[this.selectedRows.length]=this.rowsCol[i]
							}
						} else {
							this.clearSelection();
							return this.doClick(el, fl, 0, show);
						}
					}
			} else if (selMethod == 2){
				if (el.parentNode.className.indexOf("rowselected") != -1){
					el.parentNode.className=el.parentNode.className.replace(/rowselected/g, "");
					this.selectedRows._dhx_removeAt(this.selectedRows._dhx_find(el.parentNode))
					var skipRowSelection = true;
					show = false;
				}
			}
			this.editStop()
			if (typeof (el.parentNode.idd) == "undefined")
				return true;

			if ((!skipRowSelection)&&(!el.parentNode._sRow)){
				if (this.callEvent("onBeforeSelect", [
					el.parentNode.idd,
					psid,
					el._cellIndex
				])){
					if (this.getSelectedRowId() != el.parentNode.idd){
						if (selMethod == 0)
							this.clearSelection();
						this.cell=el;
						if ((prow == el.parentNode)&&(this._chRRS))
							fl=false;
						this.row=el.parentNode;
						this.row.className+=" rowselected"
						
						if (this.selectedRows._dhx_find(this.row) == -1)
							this.selectedRows[this.selectedRows.length]=this.row;
					} else {
						this.cell=el;
						this.row = el.parentNode;
					}
				} else fl = false;
			}

			if (this.cell && this.cell.parentNode.className.indexOf("rowselected") != -1)
				this.cell.className=this.cell.className.replace(/cellselected/g, "")+" cellselected";
			
			if (selMethod != 1)
				if (!this.row)
					return;
			this.lastClicked=el.parentNode;

			var rid = this.row.idd;
			var cid = this.cell;

			if (fl&& typeof (rid) != "undefined" && cid && !skipRowSelection) {
				self.onRowSelectTime=setTimeout(function(){
					if (self.callEvent)
						self.callEvent("onRowSelect", [
							rid,
							cid._cellIndex
						]);
				}, 100);
			} else this.callEvent("onRowSelectRSOnly",[rid]);

			if (this.checkEvent("onSelectStateChanged")){
				var afinal = this.getSelectedId();

				if (initial != afinal)
					this.callEvent("onSelectStateChanged", [afinal,initial]);
			}

			if (skipRowSelection) return false;
		}
		this.isActive=true;
		if (show !== false && this.cell && this.cell.parentNode.idd)
			this.moveToVisible(this.cell)
	}

	/**
	*   @desc: select all rows in grid, it doesn't fire any events
	*   @param: edit - switch selected cell to edit mode
	*   @type: public
	*   @topic: 1,4
	*/
	this.selectAll=function(){
		this.clearSelection();

		var coll = this.rowsBuffer;
		//in paging mode, we select only current page
		if (this.pagingOn) coll = this.rowsCol;
		for (var i = 0; i<coll.length; i ++){
			this.render_row(i).className+=" rowselected";
		}
		
		this.selectedRows=dhtmlxArray([].concat(coll));
		
		if (this.selectedRows.length){
			this.row  = this.selectedRows[0];
			this.cell = this.row.cells[0];
		}

		if ((this._fake)&&(!this._realfake))
			this._fake.selectAll();
	}
	/**
	*   @desc: set selection to specified row-cell
	*   @param: r - row object or row index
	*   @param: cInd - cell index
	*   @param: [fl] - true if to call onRowSelect function
	  *   @param: preserve - preserve previously selected rows true/false (false by default)
	  *   @param: edit - switch selected cell to edit mode
	*   @param: show - true/false - scroll row to view, true by defaul         
	*   @type: public
	*   @topic: 1,4
	*/
	this.selectCell=function(r, cInd, fl, preserve, edit, show){
		if (!fl)
			fl=false;

		if (typeof (r) != "object")
			r=this.render_row(r)
		if (!r || r==-1) return null;
//#__pro_feature:21092006{
//#colspan:20092006{
		if (r._childIndexes)
			var c = r.childNodes[r._childIndexes[cInd]];
		else
//#}
//#}
			var c = r.childNodes[cInd];

		if (!c)
			c=r.childNodes[0];
        if(!this.markedCells){
			if (preserve)
				this.doClick(c, fl, 3, show)
			else
				this.doClick(c, fl, 0, show)
		}
		else 
			this.doMark(c,preserve?2:0);

		if (edit)
			this.editCell();
	}
	/**
	*   @desc: moves specified cell to visible area (scrolls)
	*   @param: cell_obj - object of the cell to work with
	*   @param: onlyVScroll - allow only vertical positioning

	*   @type: private
	*   @topic: 2,4,7
	*/
	this.moveToVisible=function(cell_obj, onlyVScroll){
		if (this.pagingOn){
			var newPage=Math.floor(this.getRowIndex(cell_obj.parentNode.idd) / this.rowsBufferOutSize)+1;
			if (newPage!=this.currentPage)
			this.changePage(newPage);
		}

		try{
			if (cell_obj.offsetHeight){
				var distance = cell_obj.offsetLeft+cell_obj.offsetWidth+20;
	
				var scrollLeft = 0;
	
				if (distance > (this.objBox.offsetWidth+this.objBox.scrollLeft)){
					if (cell_obj.offsetLeft > this.objBox.scrollLeft)
						scrollLeft= cell_obj.offsetLeft - (this.objBox.offsetWidth - cell_obj.offsetWidth) +5
				} else if (cell_obj.offsetLeft < this.objBox.scrollLeft){
					distance-=cell_obj.offsetWidth*2/3;
					if (distance < this.objBox.scrollLeft)
						scrollLeft=cell_obj.offsetLeft-5
				}
	
				if ((scrollLeft)&&(!onlyVScroll))
					this.objBox.scrollLeft=scrollLeft;
			}

			
			if (!cell_obj.offsetHeight){
				var mask=this._realfake?this._fake.rowsAr[cell_obj.parentNode.idd]:cell_obj.parentNode;
				distance = this.rowsBuffer._dhx_find(mask)*this._srdh;
			}
			else
				distance = cell_obj.offsetTop;
			var distancemax = distance + cell_obj.offsetHeight+38;

			if (distancemax > (this.objBox.offsetHeight+this.objBox.scrollTop)){
				var scrollTop = distance;
			} else if (distance < this.objBox.scrollTop){
				var scrollTop = distance-5
			}

			if (scrollTop)
				this.objBox.scrollTop=scrollTop;
		}
		catch (er){}
	}
	/**
	*   @desc: creates Editor object and switch cell to edit mode if allowed
	*   @type: public
	*   @topic: 4
	*/
	this.editCell = function(){
		if (this.editor&&this.cell == this.editor.cell)
			return; //prevent reinit for same cell

		this.editStop();

		if ((this.isEditable != true)||(!this.cell))
			return false;
		var c = this.cell;

//#locked_row:11052006{
		if (c.parentNode._locked)
			return false;
//#}

		this.editor=this.cells4(c);

		//initialize editor
		if (this.editor != null){
			if (this.editor.isDisabled()){
				this.editor=null;
				return false;
			}

			if (this.callEvent("onEditCell", [
				0,
				this.row.idd,
				this.cell._cellIndex
			]) != false&&this.editor.edit){
				this._Opera_stop=(new Date).valueOf();
				c.className+=" editable";
				this.editor.edit();
				this.callEvent("onEditCell", [
					1,
					this.row.idd,
					this.cell._cellIndex
				])
			} else { //preserve editing
				this.editor=null;
			}
		}
	}
	/**
	*   @desc: retuns value from editor(if presents) to cell and closes editor
	*   @mode: if true - current edit value will be reverted to previous one
	*   @type: public
	*   @topic: 4
	*/
	this.editStop=function(mode){
		if (_isOpera)
			if (this._Opera_stop){
				if ((this._Opera_stop*1+50) > (new Date).valueOf())
					return;

				this._Opera_stop=null;
			}

		if (this.editor&&this.editor != null){
			this.editor.cell.className=this.editor.cell.className.replace("editable", "");

			if (mode){
				var t = this.editor.val;
				this.editor.detach();
				this.editor.setValue(t);
				this.editor=null;
				
				this.callEvent("onEditCancel", [
					this.row.idd,
					this.cell._cellIndex,
					t
				]);
				return;
			}

			if (this.editor.detach())
				this.cell.wasChanged=true;

			var g = this.editor;
			if (g == null) return;
			
			this.editor=null;
			var z = this.callEvent("onEditCell", [
				2,
				this.row.idd,
				this.cell._cellIndex,
				g.getValue(),
				g.val
			]);

			if (( typeof (z) == "string")||( typeof (z) == "number"))
				g[g.setImage ? "setLabel" : "setValue"](z);

			else if (!z)
				g[g.setImage ? "setLabel" : "setValue"](g.val);
		
			if (this._ahgr && this.multiLine) this.setSizes();
		}
	}
	/**
	*	@desc: 
	*	@type: private
	*/
	this._nextRowCell=function(row, dir, pos){
		row=this._nextRow((this._groups?this.rowsCol:this.rowsBuffer)._dhx_find(row), dir);

		if (!row)
			return null;

		return row.childNodes[row._childIndexes ? row._childIndexes[pos] : pos];
	}
	/**
	*	@desc: 
	*	@type: private
	*/
	this._getNextCell=function(acell, dir, i){

		acell=acell||this.cell;

		var arow = acell.parentNode;

		if (this._tabOrder){
			i=this._tabOrder[acell._cellIndex];

			if (typeof i != "undefined")
				if (i < 0)
					acell=this._nextRowCell(arow, dir, Math.abs(i)-1);
				else
					acell=arow.childNodes[i];
		} else {
			var i = acell._cellIndex+dir;

			if (i >= 0&&i < this._cCount){
				if (arow._childIndexes)
					i=arow._childIndexes[acell._cellIndex]+dir;
				acell=arow.childNodes[i];
			} else {

				acell=this._nextRowCell(arow, dir, (dir == 1 ? 0 : (this._cCount-1)));
			}
		}

		if (!acell){
			if ((dir == 1)&&this.tabEnd){
				this.tabEnd.focus();
				this.tabEnd.focus();
				this.setActive(false);
			}

			if ((dir == -1)&&this.tabStart){
				this.tabStart.focus();
				this.tabStart.focus();
				this.setActive(false);
			}
			return null;
		}

		//tab out

		// tab readonly
		if (acell.style.display != "none"
			&&(!this.smartTabOrder||!this.cells(acell.parentNode.idd, acell._cellIndex).isDisabled()))
			return acell;
		return this._getNextCell(acell, dir);
	// tab readonly

	}
	/**
	*	@desc: 
	*	@type: private
	*/
	this._nextRow=function(ind, dir){
		var r = this.render_row(ind+dir);
		if (!r || r==-1) return null;
		if (r&&r.style.display == "none")
			return this._nextRow(ind+dir, dir);

		return r;
	}
	/**
	*	@desc: 
	*	@type: private
	*/
	this.scrollPage=function(dir){ 
		if (!this.rowsBuffer.length) return;
		var master = this._realfake?this._fake:this;
		var new_ind = Math.floor((master._r_select||this.getRowIndex(this.row.idd)||0)+(dir)*this.objBox.offsetHeight / (this._srdh||20));

		if (new_ind < 0)
			new_ind=0;
		if (new_ind >= this.rowsBuffer.length)
			new_ind=this.rowsBuffer.length-1;

		if (this._srnd && !this.rowsBuffer[new_ind]){			
			this.objBox.scrollTop+=Math.floor((dir)*this.objBox.offsetHeight / (this._srdh||20))*(this._srdh||20);
			if (this._fake) this._fake.objBox.scrollTop = this.objBox.scrollTop;
			master._r_select=new_ind;
		} else {
			this.selectCell(new_ind, this.cell._cellIndex, true, false,false,(this.multiLine || this._srnd));
			if (!this.multiLine && !this._srnd && !this._realfake){
				this.objBox.scrollTop=this.getRowById(this.getRowId(new_ind)).offsetTop;
				if (this._fake) this._fake.objBox.scrollTop = this.objBox.scrollTop;
			}
			master._r_select=null;
		}
	}

	/**
	*   @desc: manages keybord activity in grid
	*   @type: private
	*   @topic: 7
	*/
	this.doKey=function(ev){
		if (!ev)
			return true;

		if ((ev.target||ev.srcElement).value !== window.undefined){
			var zx = (ev.target||ev.srcElement);

			if (zx.className!="dhxcombo_input"&&((!zx.parentNode)||(zx.parentNode.className.indexOf("editable") == -1)))
				return true;
		}

		if ((globalActiveDHTMLGridObject)&&(this != globalActiveDHTMLGridObject))
			return globalActiveDHTMLGridObject.doKey(ev);

		if (this.isActive == false){
			//document.body.onkeydown = "";
			return true;
		}

		if (this._htkebl)
			return true;

		if (!this.callEvent("onKeyPress", [
			ev.keyCode,
			ev.ctrlKey,
			ev.shiftKey,
			ev
		]))
			return false;

		var code = "k"+ev.keyCode+"_"+(ev.ctrlKey ? 1 : 0)+"_"+(ev.shiftKey ? 1 : 0);

		if (this.cell){ //if selection exists in grid only
			if (this._key_events[code]){
				if (false === this._key_events[code].call(this))
					return true;

				if (ev.preventDefault)
					ev.preventDefault();
				ev.cancelBubble=true;
				return false;
			}

			if (this._key_events["k_other"])
				this._key_events.k_other.call(this, ev);
		}

		return true;
	}
	
	/**
	*   @desc: selects row (and first cell of it)
	*   @param: r - row index or row object
	*   @param: fl - if true, then call function on select
	*   @param: preserve - preserve previously selected rows true/false (false by default)
	*   @param: show - true/false - scroll row to view, true by defaul    
	*   @type: public
	*   @topic: 1,2
	*/
	this.selectRow=function(r, fl, preserve, show){
		if (typeof (r) != 'object')
			r=this.render_row(r);
		this.selectCell(r, 0, fl, preserve, false, show)
	};

	/**
	*   @desc: called when row was double clicked
	*   @type: private
	*   @topic: 1,2
	*/
	this.wasDblClicked=function(ev){
		var el = this.getFirstParentOfType(_isIE ? ev.srcElement : ev.target, "TD");

		if (el){
			var rowId = el.parentNode.idd;
			return this.callEvent("onRowDblClicked", [
				rowId,
				el._cellIndex,
				ev
			]);
		}
	}

	/**
	*   @desc: called when header was clicked
	*   @type: private
	*   @topic: 1,2
	*/
	this._onHeaderClick=function(e, el){
		var that = this.grid;
		el=el||that.getFirstParentOfType(_isIE ? event.srcElement : e.target, "TD");

		if (this.grid.resized == null){
			if (!(this.grid.callEvent("onHeaderClick", [
				el._cellIndexS,
				(e||window.event)
			])))
				return false;
//#sorting:06042008{				
			that.sortField(el._cellIndexS, false, el)
//#}
		}
		this.grid.resized = null;
	}

	/**
	*   @desc: deletes selected row(s)
	*   @type: public
	*   @topic: 2
	*/
	this.deleteSelectedRows=function(){
		var num = this.selectedRows.length //this.obj.rows.length

		if (num == 0)
			return;

		var tmpAr = this.selectedRows;
		this.selectedRows=dhtmlxArray()
		for (var i = num-1; i >= 0; i--){
			var node = tmpAr[i]

			if (!this.deleteRow(node.idd, node)){
				this.selectedRows[this.selectedRows.length]=node;
			}
			else {
				if (node == this.row){
					var ind = i;
				}
			}
/*
						   this.rowsAr[node.idd] = null;
						   var posInCol = this.rowsCol._dhx_find(node)
						   this.rowsCol[posInCol].parentNode.removeChild(this.rowsCol[posInCol]);//nb:this.rowsCol[posInCol].removeNode(true);
						   this.rowsCol._dhx_removeAt(posInCol)*/
		}

		if (ind){
			try{
				if (ind+1 > this.rowsCol.length) //this.obj.rows.length)
					ind--;
				this.selectCell(ind, 0, true)
			}
			catch (er){
				this.row=null
				this.cell=null
			}
		}
	}

	/**
	*   @desc: gets selected row id
	*   @returns: id of selected row (list of ids with default delimiter) or null if non row selected
	*   @type: public
	*   @topic: 1,2,9
	*/
	this.getSelectedRowId=function(){
		var selAr = new Array(0);
		var uni = {
		};

		for (var i = 0; i < this.selectedRows.length; i++){
			var id = this.selectedRows[i].idd;

			if (uni[id])
				continue;

			selAr[selAr.length]=id;
			uni[id]=true;
		}

		//..
		if (selAr.length == 0)
			return null;
		else
			return selAr.join(this.delim);
	}
	
	/**
	*   @desc: gets index of selected cell
	*   @returns: index of selected cell or -1 if there is no selected sell
	*   @type: public
	*   @topic: 1,4
	*/
	this.getSelectedCellIndex=function(){
		if (this.cell != null)
			return this.cell._cellIndex;
		else
			return -1;
	}
	/**
	*   @desc: gets width of specified column in pixels
	*   @param: ind - column index
	*   @returns: column width in pixels
	*   @type: public
	*   @topic: 3,7
	*/
	this.getColWidth=function(ind){
		return parseInt(this.cellWidthPX[ind]);
	}

	/**
	*   @desc: sets width of specified column in pixels (soen't works with procent based grid)
	*   @param: ind - column index
	*   @param: value - new width value
	*   @type: public
	*   @topic: 3,7
	*/
	this.setColWidth=function(ind, value){
		if (value == "*")
			this.initCellWidth[ind] = "*";
		else {
			if (this._hrrar[ind]) return; //hidden
			if (this.cellWidthType == 'px')
				this.cellWidthPX[ind]=parseInt(value);
			else
				this.cellWidthPC[ind]=parseInt(value);
		}
		this.setSizes();
	}
	/**
	*   @desc: gets row index by id (grid only)
	*   @param: row_id - row id
	*   @returns: row index or -1 if there is no row with specified id
	*   @type: public
	*   @topic: 2
	*/
	this.getRowIndex=function(row_id){
		for (var i = 0; i < this.rowsBuffer.length; i++)
			if (this.rowsBuffer[i]&&this.rowsBuffer[i].idd == row_id)
				return i;
		return -1;
	}
	/**
	*   @desc: gets row id by index
	*   @param: ind - row index
	*   @returns: row id or null if there is no row with specified index
	*   @type: public
	*   @topic: 2
	*/
	this.getRowId=function(ind){
		return this.rowsBuffer[ind] ? this.rowsBuffer[ind].idd : this.undefined;
	}
	/**
	*   @desc: sets new id for row by its index
	*   @param: ind - row index
	*   @param: row_id - new row id
	*   @type: public
	*   @topic: 2
	*/
	this.setRowId=function(ind, row_id){
		this.changeRowId(this.getRowId(ind), row_id)
	}
	/**
	*   @desc: changes id of the row to the new one
	*   @param: oldRowId - row id to change
	*   @param: newRowId - row id to set
	*   @type:public
	*   @topic: 2
	*/
	this.changeRowId=function(oldRowId, newRowId){
		if (oldRowId == newRowId)
			return;
		/*
						  for (var i=0; i<row.childNodes.length; i++)
							  if (row.childNodes[i]._code)
								  this._compileSCL("-",row.childNodes[i]);      */
		var row = this.rowsAr[oldRowId]
		row.idd=newRowId;

		if (this.UserData[oldRowId]){
			this.UserData[newRowId]=this.UserData[oldRowId]
			this.UserData[oldRowId]=null;
		}

		if (this._h2&&this._h2.get[oldRowId]){
			this._h2.get[newRowId]=this._h2.get[oldRowId];
			this._h2.get[newRowId].id=newRowId;
			delete this._h2.get[oldRowId];
		}

		this.rowsAr[oldRowId]=null;
		this.rowsAr[newRowId]=row;

		for (var i = 0; i < row.childNodes.length; i++)
			if (row.childNodes[i]._code)
				row.childNodes[i]._code=this._compileSCL(row.childNodes[i]._val, row.childNodes[i]);
				
		if (this._mat_links && this._mat_links[oldRowId]){
			var a=this._mat_links[oldRowId];
			delete this._mat_links[oldRowId];
			for (var c in a)
				for (var i=0; i < a[c].length; i++)
					this._compileSCL(a[c][i].original,a[c][i]);
		}
				
		this.callEvent("onRowIdChange",[oldRowId,newRowId]);
	}
	/**
	*   @desc: sets ids to every column. Can be used then to retreive the index of the desired colum
	*   @param: [ids] - delimitered list of ids (default delimiter is ","), or empty if to use values set earlier
	*   @type: public
	*   @topic: 3
	*/
	this.setColumnIds=function(ids){
		this.columnIds=ids.split(this.delim)
	}
	/**
	*   @desc: sets ids to specified column.
	*   @param: ind- index of column
	*   @param: id- id of column
	*   @type: public
	*   @topic: 3
	*/
	this.setColumnId=function(ind, id){
		this.columnIds[ind]=id;
	}
	/**
	*   @desc: gets column index by column id
	*   @param: id - column id
	*   @returns: index of the column
	*   @type: public
	*   @topic: 3
	*/
	this.getColIndexById=function(id){
		for (var i = 0; i < this.columnIds.length; i++)
			if (this.columnIds[i] == id)
				return i;
	}
	/**
	*   @desc: gets column id of column specified by index
	*   @param: cin - column index
	*   @returns: column id
	*   @type: public
	*   @topic: 3
	*/
	this.getColumnId=function(cin){
		return this.columnIds[cin];
	}
	
	/**
	*   @desc: gets label of column specified by index
	*   @param: cin - column index
	*   @returns: column label
	*   @type: public
	*   @topic: 3
	*/
	this.getColumnLabel=function(cin, ind, hdr){
		var z = (hdr||this.hdr).rows[(ind||0)+1];
		for (var i=0; i<z.cells.length; i++)
			if (z.cells[i]._cellIndexS==cin) return (_isIE ? z.cells[i].innerText : z.cells[i].textContent);
		return "";
	};
	this.getColLabel = this.getColumnLabel;
	/**
	*   @desc: gets label of footer specified by index
	*   @param: cin - column index
	*   @returns: column label
	*   @type: public
	*   @topic: 3
	*/
	this.getFooterLabel=function(cin, ind){
		return this.getColumnLabel(cin,ind,this.ftr);
	}	
	

	/**
	*   @desc: sets row text BOLD
	*   @param: row_id - row id
	*   @type: public
	*   @topic: 2,6
	*/
	this.setRowTextBold=function(row_id){
		var r=this.getRowById(row_id)
		if (r) r.style.fontWeight="bold";
	}
	/**
	*   @desc: sets style to row
	*   @param: row_id - row id
	*   @param: styleString - style string in common format (exmpl: "color:red;border:1px solid gray;")
	*   @type: public
	*   @topic: 2,6
	*/
	this.setRowTextStyle=function(row_id, styleString){
		var r = this.getRowById(row_id)
		if (!r) return;
		for (var i = 0; i < r.childNodes.length; i++){
			var pfix = r.childNodes[i]._attrs["style"]||"";
//#__pro_feature:21092006{
//#column_hidden:21092006{
	if ((this._hrrar)&&(this._hrrar[i]))
		pfix="display:none;";
//#}
//#}
			if (_isIE)
				r.childNodes[i].style.cssText=pfix+"width:"+r.childNodes[i].style.width+";"+styleString;
			else
				r.childNodes[i].style.cssText=pfix+"width:"+r.childNodes[i].style.width+";"+styleString;
		}
	}
	/**
	*   @desc: sets background color of row (via bgcolor attribute)
	*   @param: row_id - row id
	*   @param: color - color value
	*   @type: public
	*   @topic: 2,6
	*/
	this.setRowColor=function(row_id, color){
		var r = this.getRowById(row_id)

		for (var i = 0; i < r.childNodes.length; i++)r.childNodes[i].bgColor=color;
	}
	/**
	*   @desc: sets style to cell
	*   @param: row_id - row id
	*   @param: ind - cell index
	*   @param: styleString - style string in common format (exmpl: "color:red;border:1px solid gray;")
	*   @type: public
	*   @topic: 2,6
	*/
	this.setCellTextStyle=function(row_id, ind, styleString){
		var r = this.getRowById(row_id)

		if (!r)
			return;

		var cell = r.childNodes[r._childIndexes ? r._childIndexes[ind] : ind];

		if (!cell)
			return;
		var pfix = "";
//#__pro_feature:21092006{
//#column_hidden:21092006{
		if ((this._hrrar)&&(this._hrrar[ind]))
			pfix="display:none;";
//#}
//#}
		if (_isIE)
			cell.style.cssText=pfix+"width:"+cell.style.width+";"+styleString;
		else
			cell.style.cssText=pfix+"width:"+cell.style.width+";"+styleString;
	}

	/**
	*   @desc: sets row text weight to normal
	*   @param: row_id - row id
	*   @type: public
	*   @topic: 2,6
	*/
	this.setRowTextNormal=function(row_id){
		var r=this.getRowById(row_id);
		if (r) r.style.fontWeight="normal";
	}
	/**
	*   @desc: determines if row with specified id exists
	*   @param: row_id - row id
	*   @returns: true if exists, false otherwise
	*   @type: public
	*   @topic: 2,7
	*/
	this.doesRowExist=function(row_id){
		if (this.getRowById(row_id) != null)
			return true
		else
			return false
	}
	


	/**
	*   @desc: gets number of columns in grid
	*   @returns: number of columns in grid
	*   @type: public
	*   @topic: 3,7
	*/
	this.getColumnsNum=function(){
		return this._cCount;
	}
	
	
//#moving_rows:06042008{
	/**
	*   @desc: moves row one position up if possible
	*   @param: row_id -  row id
	*   @type: public
	*   @topic: 2
	*/
	this.moveRowUp=function(row_id){
		var r = this.getRowById(row_id)

		if (this.isTreeGrid())
			return this.moveRowUDTG(row_id, -1);

		var rInd = this.rowsCol._dhx_find(r)
		if ((r.previousSibling)&&(rInd != 0)){
			r.parentNode.insertBefore(r, r.previousSibling)
			this.rowsCol._dhx_swapItems(rInd, rInd-1)
			this.setSizes();
			var bInd=this.rowsBuffer._dhx_find(r);
			this.rowsBuffer._dhx_swapItems(bInd,bInd-1);

			if (this._cssEven)
				this._fixAlterCss(rInd-1);
		}
	}
	/**
	*   @desc: moves row one position down if possible
	*   @param: row_id -  row id
	*   @type: public
	*   @topic: 2
	*/
	this.moveRowDown=function(row_id){
		var r = this.getRowById(row_id)

		if (this.isTreeGrid())
			return this.moveRowUDTG(row_id, 1);

		var rInd = this.rowsCol._dhx_find(r);
		if (r.nextSibling){ 
			this.rowsCol._dhx_swapItems(rInd, rInd+1)

			if (r.nextSibling.nextSibling)
				r.parentNode.insertBefore(r, r.nextSibling.nextSibling)
			else
				r.parentNode.appendChild(r)
			this.setSizes();
			
			var bInd=this.rowsBuffer._dhx_find(r);
			this.rowsBuffer._dhx_swapItems(bInd,bInd+1);

			if (this._cssEven)
				this._fixAlterCss(rInd);
		}
	}
//#}
//#co_excell:06042008{
	/**
	* @desc: gets Combo object of specified column. Use it to change select box value for cell before editor opened
	*   @type: public
	*   @topic: 3,4
	*   @param: col_ind - index of the column to get combo object for
	*/
	this.getCombo=function(col_ind){
		if (!this.combos[col_ind]){
			this.combos[col_ind]=new dhtmlXGridComboObject();
		}
		return this.combos[col_ind];
	}
//#}
	/**
	*   @desc: sets user data to row
	*   @param: row_id -  row id. if empty then user data is set for grid (not row)
	*   @param: name -  name of user data block
	*   @param: value -  value of user data block
	*   @type: public
	*   @topic: 2,5
	*/
	this.setUserData=function(row_id, name, value){
		if (!row_id)
			row_id="gridglobaluserdata";

		if (!this.UserData[row_id])
			this.UserData[row_id]=new Hashtable()
		this.UserData[row_id].put(name, value)
	}
	/**
	*   @desc: gets user Data
	*   @param: row_id -  row id. if empty then user data is for grid (not row)
	*   @param: name -  name of user data
	*   @returns: value of user data
	*   @type: public
	*   @topic: 2,5
	*/
	this.getUserData=function(row_id, name){
		if (!row_id)
			row_id="gridglobaluserdata";		
		this.getRowById(row_id); //parse row if necessary
		
		var z = this.UserData[row_id];
		return (z ? z.get(name) : "");
	}

	/**
	*   @desc: manage editibility of the grid
	*   @param: [fl] - set not editable if FALSE, set editable otherwise
	*   @type: public
	*   @topic: 7
	*/
	this.setEditable=function(fl){
		this.isEditable=dhx4.s2b(fl);
	}
	/**
	*   @desc: selects row by ID
	*   @param: row_id - row id
	*   @param: multiFL - VOID. select multiple rows
	*   @param: show - true/false - scroll row to view, true by defaul    
	*   @param: call - true to call function on select
	*   @type: public
	*   @topic: 1,2
	*/
	this.selectRowById=function(row_id, multiFL, show, call){
		if (!call)
			call=false;
		this.selectCell(this.getRowById(row_id), 0, call, multiFL, false, show);
	}
	
	/**
	*   @desc: removes selection from the grid
	*   @type: public
	*   @topic: 1,9
	*/
	this.clearSelection=function(){
		this.editStop()

		for (var i = 0; i < this.selectedRows.length; i++){
			var r = this.rowsAr[this.selectedRows[i].idd];

			if (r)
				r.className=r.className.replace(/rowselected/g, "");
		}

		//..
		this.selectedRows=dhtmlxArray()
		this.row=null;

		if (this.cell != null){
			this.cell.className=this.cell.className.replace(/cellselected/g, "");
			this.cell=null;
		}
		
		this.callEvent("onSelectionCleared",[]);
	}
	/**
	*   @desc: copies row content to another existing row
	*   @param: from_row_id - id of the row to copy content from
	*   @param: to_row_id - id of the row to copy content to
	*   @type: public
	*   @topic: 2,5
	*/
	this.copyRowContent=function(from_row_id, to_row_id){
		var frRow = this.getRowById(from_row_id)

		if (!this.isTreeGrid())
			for (var i = 0; i < frRow.cells.length; i++){
				this.cells(to_row_id, i).setValue(this.cells(from_row_id, i).getValue())
			}
		else
			this._copyTreeGridRowContent(frRow, from_row_id, to_row_id);

		//for Mozilla (to avaoid visual glitches)
		if (!_isIE)
			this.getRowById(from_row_id).cells[0].height=frRow.cells[0].offsetHeight
	}
	/**
	*   @desc: sets new label for cell in footer
	*   @param: col - header column index
	*   @param: label - new label for the cpecified footer's column. Can contai img:[imageUrl]Text Label
	*	@param: ind - header row index 
	*   @type: public
	*   @topic: 3,6
	*/
	this.setFooterLabel=function(c, label, ind){
		return this.setColumnLabel(c,label,ind,this.ftr);
	};
	/**
	*   @desc: sets new column header label
	*   @param: col - header column index
	*   @param: label - new label for the cpecified header's column. Can contai img:[imageUrl]Text Label
	*	@param: ind - header row index 
	*   @type: public
	*   @topic: 3,6
	*/
	this.setColumnLabel=function(c, label, ind, hdr){
		var z = (hdr||this.hdr).rows[ind||1];
		var col = (z._childIndexes ? z._childIndexes[c] : c);
		if (!z.cells[col]) return;
		if (!this.useImagesInHeader){
			var hdrHTML = "<div class='hdrcell'>"

			if (label.indexOf('img:[') != -1){
				var imUrl = label.replace(/.*\[([^>]+)\].*/, "$1");
				label=label.substr(label.indexOf("]")+1, label.length)
				hdrHTML+="<img width='18px' height='18px' align='absmiddle' src='"+imUrl+"' hspace='2'>"
			}
			hdrHTML+=label;
			hdrHTML+="</div>";
			z.cells[col].innerHTML=hdrHTML;

			if (this._hstyles[col])
				z.cells[col].style.cssText=this._hstyles[col];
		} else { //if images in header header
			z.cells[col].style.textAlign="left";
			z.cells[col].innerHTML="<img src='"+label+"'>";
			//preload sorting headers (asc/desc)
			var a = new Image();
			a.src=""+label.replace(/(\.[a-z]+)/, ".des$1");
			this.preloadImagesAr[this.preloadImagesAr.length]=a;
			var b = new Image();
			b.src=""+label.replace(/(\.[a-z]+)/, ".asc$1");
			this.preloadImagesAr[this.preloadImagesAr.length]=b;
		}

		if ((label||"").indexOf("#") != -1){
			var t = label.match(/(^|{)#([^}]+)(}|$)/);

			if (t){
				var tn = "_in_header_"+t[2];

				if (this[tn])
					this[tn]((this.forceDivInHeader ? z.cells[col].firstChild : z.cells[col]), col, label.split(t[0]));
			}
		}
	};
	this.setColLabel = function(a,b,ind,c){
		return this.setColumnLabel(a,b,(ind||0)+1,c);
	};
	/**
	*   @desc: deletes all rows in grid
	*   @param: header - (boolean) enable/disable cleaning header
	*   @type: public
	*   @topic: 5,7,9
	*/
	this.clearAll=function(header){
	    if (!this.obj.rows[0]) return; //call before initilization
		if (this._h2){
			this._h2=new dhtmlxHierarchy();

			if (this._fake){
				if (this._realfake)
					this._h2=this._fake._h2;
				else
					this._fake._h2=this._h2;
			}
		}

		this.limit=this._limitC=0;
		this.editStop(true);

		if (this._dLoadTimer)
			window.clearTimeout(this._dLoadTimer);

		if (this._dload){
			this.objBox.scrollTop=0;
			this.limit=this._limitC||0;
			this._initDrF=true;
		}

		var len = this.rowsCol.length;

		//for some case
		len=this.obj.rows.length;

		for (var i = len-1; i > 0; i--){
			var t_r = this.obj.rows[i];
			t_r.parentNode.removeChild(t_r);
		}

		if (header){
			this._master_row=null;
			this.obj.rows[0].parentNode.removeChild(this.obj.rows[0]);

			for (var i = this.hdr.rows.length-1; i >= 0; i--){
				var t_r = this.hdr.rows[i];
				t_r.parentNode.removeChild(t_r);
			}

			if (this.ftr){
				this.ftr.parentNode.removeChild(this.ftr);
				this.ftr=null;
			}
			this._aHead=this.ftr=this.cellWidth=this._aFoot=null;
			this.cellType=dhtmlxArray();
			this._hrrar=[];
			this.columnIds=[];
			this.combos=[];
			this._strangeParams=[];
			this.defVal = [];
			this._ivizcol = null;
		}

		//..
		this.row=null;
		this.cell=null;

		this.rowsCol=dhtmlxArray()
		this.rowsAr={}; //array of rows by idd
		this._RaSeCol=[];
		this.rowsBuffer=dhtmlxArray()
		this.UserData=[]
		this.selectedRows=dhtmlxArray();

		if (this.pagingOn || this._srnd)
			this.xmlFileUrl="";
		if (this.pagingOn)
			this.changePage(1);
		
		//  if (!this._fake){
		/*
		   if ((this._hideShowColumn)&&(this.hdr.rows[0]))
			  for (var i=0; i<this.hdr.rows[0].cells.length; i++)
				  this._hideShowColumn(i,"");
	   this._hrrar=new Array();*/
		//}
		if (this._contextCallTimer)
			window.clearTimeout(this._contextCallTimer);

		if (this._sst)
			this.enableStableSorting(true);
		this._fillers=this.undefined;
		this.setSortImgState(false);
		this.setSizes();
		//this.obj.scrollTop = 0;

		this.callEvent("onClearAll", []);
	}

//#sorting:06042008{
	/**
	*   @desc: sorts grid by specified field
	*    @invoke: header click
	*   @param: [ind] - index of the field
	*   @param: [repeatFl] - if to repeat last sorting
	*   @type: private
	*   @topic: 3
	*/
	this.sortField=function(ind, repeatFl, r_el){
		if (this.getRowsNum() == 0)
			return false;

		var el = this.hdr.rows[0].cells[ind];

		if (!el)
			return; //somehow
		// if (this._dload  && !this.callEvent("onBeforeSorting",[ind,this]) ) return true;

		if (el.tagName == "TH"&&(this.fldSort.length-1) >= el._cellIndex
			&&this.fldSort[el._cellIndex] != 'na'){ //this.entBox.fieldstosort!="" &&
			var data=this.getSortingState();
			var sortType= ( data[0]==ind && data[1]=="asc" ) ? "des" : "asc";

			if (!this.callEvent("onBeforeSorting", [
				ind,
				this.fldSort[ind],
				sortType
			]))
				return;
			this.sortImg.className="dhxgrid_sort_"+(sortType == "asc" ? "asc" : "desc");

			//for header images
			if (this.useImagesInHeader){
				var cel = this.hdr.rows[1].cells[el._cellIndex].firstChild;

				if (this.fldSorted != null){
					var celT = this.hdr.rows[1].cells[this.fldSorted._cellIndex].firstChild;
					celT.src=celT.src.replace(/(\.asc\.)|(\.des\.)/, ".");
				}
				cel.src=cel.src.replace(/(\.[a-z]+)$/, "."+sortType+"$1")
			}
			//.
			this.sortRows(el._cellIndex, this.fldSort[el._cellIndex], sortType)
			this.fldSorted=el;
			this.r_fldSorted=r_el;
			var c = this.hdr.rows[1];
			var c = r_el.parentNode;
			var real_el = c._childIndexes ? c._childIndexes[el._cellIndex] : el._cellIndex;
			this.setSortImgPos(false, false, false, r_el);
		}
	}
//#__pro_feature:21092006{
//#custom_sort:21092006{
	/**
	*   @desc: set custom sorting (custom sort has three params - valueA,valueB,order; where order can be asc or des)
	*   @param: func - function to use for comparison
	*   @param:   col - index of column to apply custom sorting to
	*   @type: public
	*   @edition: Professional
	*   @topic: 3
	*/
	this.setCustomSorting=function(func, col){
		if (!this._customSorts)
			this._customSorts=new Array();
		this._customSorts[col]=( typeof (func) == "string") ? eval(func) : func;
		this.fldSort[col]="cus";
	}
//#}
//#}
//#}
	/**
	*   @desc: specify if values passed to Header are images file names
	*   @param: fl - true to treat column header values as image names
	*   @type: public
	*   @before_init: 1
	*   @topic: 0,3
	*/
	this.enableHeaderImages=function(fl){
		this.useImagesInHeader=fl;
	}

	/**
	*   @desc: set header label and default params for new headers
	*   @param: hdrStr - header string with delimiters
	*   @param: splitSign - string used as a split marker, optional. Default is "#cspan"
	*   @param: styles - array of header styles
	*   @type: public
	*   @before_init: 1
	*   @topic: 0,3
	*/
	this.setHeader=function(hdrStr, splitSign, styles){
		if (typeof (hdrStr) != "object")
			var arLab = this._eSplit(hdrStr);
		else
			arLab=[].concat(hdrStr);

		var arWdth = new Array(0);
		var arTyp = new dhtmlxArray(0);
		var arAlg = new Array(0);
		var arVAlg = new Array(0);
		var arSrt = new Array(0);

		for (var i = 0; i < arLab.length; i++){
			arWdth[arWdth.length]=Math.round(100 / arLab.length);
			arTyp[arTyp.length]="ed";
			arAlg[arAlg.length]="left";
			arVAlg[arVAlg.length]="middle"; //top
			arSrt[arSrt.length]="na";
		}

		this.splitSign=splitSign||"#cspan";
		this.hdrLabels=arLab;
		this.cellWidth=arWdth;
		if (!this.initCellWidth.length) this.setInitWidthsP(arWdth.join(this.delim),true);
		this.cellType=arTyp;
		this.cellAlign=arAlg;
		this.cellVAlign=arVAlg;
		this.fldSort=arSrt;
		this._hstyles=styles||[];
	}
	/**
   *   @desc: 
   *   @param: str - ...
   *   @type: private
   */
	this._eSplit=function(str){
		if (![].push)
			return str.split(this.delim);

		var a = "r"+(new Date()).valueOf();
		var z = this.delim.replace(/([\|\+\*\^])/g, "\\$1")
		return (str||"").replace(RegExp(z, "g"), a).replace(RegExp("\\\\"+a, "g"), this.delim).split(a);
	}

	/**
	*   @desc: get column type by column index
	*   @param: cInd - column index
	*   @returns:  type code
	*   @type: public
	*   @topic: 0,3,4
	*/
	this.getColType=function(cInd){
		return this.cellType[cInd];
	}

	/**
	*   @desc: get column type by column ID
	*   @param: cID - column id
	*   @returns:  type code
	*   @type: public
	*   @topic: 0,3,4
	*/
	this.getColTypeById=function(cID){
		return this.cellType[this.getColIndexById(cID)];
	}

	/**
	*   @desc: set column types
	*   @param: typeStr - type codes list (default delimiter is ",")
	*   @before_init: 2
	*   @type: public
	*   @topic: 0,3,4
	*/
	this.setColTypes=function(typeStr){
		this.cellType=dhtmlxArray(typeStr.split(this.delim));
		this._strangeParams=new Array();

		for (var i = 0; i < this.cellType.length; i++){
			if ((this.cellType[i].indexOf("[") != -1)){
				var z = this.cellType[i].split(/[\[\]]+/g);
				this.cellType[i]=z[0];
				this.defVal[i]=z[1];

				if (z[1].indexOf("=") == 0){
					this.cellType[i]="math";
					this._strangeParams[i]=z[0];
				}
			}
			if (!window["eXcell_"+this.cellType[i]]) dhx4.callEvent("onConfigurationError",["Incorrect cell type: "+this.cellType[i],this,this.cellType[i]]);
		}
	}
	/**
	*   @desc: set column sort types (avaialble: str, int, date, na or function object for custom sorting)
	*   @param: sortStr - sort codes list with default delimiter
	*   @before_init: 1
	*   @type: public
	*   @topic: 0,3,4
	*/
	this.setColSorting=function(sortStr){
		this.fldSort=sortStr.split(this.delim)
//#__pro_feature:21092006{
//#custom_sort:21092006{
		//str, int, date
		var check = {str:1, "int":1, date:1};
		for (var i = 0; i < this.fldSort.length; i++)
			if ((!check[this.fldSort[i]])&&( typeof (window[this.fldSort[i]]) == "function")){
				if (!this._customSorts)
					this._customSorts=new Array();
				this._customSorts[i]=window[this.fldSort[i]];
				this.fldSort[i]="cus";
			}
//#}
//#}
	}
	/**
	*   @desc: set align of values in columns
	*   @param: alStr - list of align values (possible values are: right,left,center,justify). Default delimiter is ","
	*   @before_init: 1
	*   @type: public
	*   @topic: 0,3
	*/
	this.setColAlign=function(alStr){
		this.cellAlign=alStr.split(this.delim)
		for (var i=0; i < this.cellAlign.length; i++)
			this.cellAlign[i]=this.cellAlign[i]._dhx_trim();
	}
/**
*   @desc: set vertical align of columns
*   @param: valStr - vertical align values list for columns (possible values are: baseline,sub,super,top,text-top,middle,bottom,text-bottom)
*   @before_init: 1
*   @type: public
*   @topic: 0,3
*/
	this.setColVAlign=function(valStr){
		this.cellVAlign=valStr.split(this.delim)
	}

/**
* 	@desc: create grid with no header. Call before initialization, but after setHeader. setHeader have to be called in any way as it defines number of columns
*   @param: fl - true to use no header in the grid
*   @type: public
*   @before_init: 1
*   @topic: 0,7
*/
	this.setNoHeader=function(fl){
			this.noHeader=dhx4.s2b(fl);
	}
	/**
	*   @desc: scrolls row to the visible area
	*   @param: rowID - row id
	*   @type: public
	*   @topic: 2,7
	*/
	this.showRow=function(rowID){
		this.getRowById(rowID)

		if (this._h2) this.openItem(this._h2.get[rowID].parent.id);
		var c = this.getRowById(rowID).childNodes[0];

		while (c&&c.style.display == "none")
			c=c.nextSibling;

		if (c)
			this.moveToVisible(c, true)
	}

	/**
	*   @desc: modify default style of grid and its elements. Call before or after Init
	*   @param: ss_header - style def. expression for header
	*   @param: ss_grid - style def. expression for grid cells
	*   @param: ss_selCell - style def. expression for selected cell
	*   @param: ss_selRow - style def. expression for selected Row
	*   @type: public
	*   @before_init: 2
	*   @topic: 0,6
	*/
	this.setStyle=function(ss_header, ss_grid, ss_selCell, ss_selRow){
		this.ssModifier=[
			ss_header,
			ss_grid,
			ss_selCell,
			ss_selCell,
			ss_selRow
		];

		var prefs = ["#"+this.entBox.id+" table.hdr td", "#"+this.entBox.id+" table.obj td",
			"#"+this.entBox.id+" table.obj tr.rowselected td.cellselected",
			"#"+this.entBox.id+" table.obj td.cellselected", "#"+this.entBox.id+" table.obj tr.rowselected td"];

		var index = 0;
		while (!_isIE){
			try{
				var temp = document.styleSheets[index].cssRules.length;
			} catch(e) { index++; continue; }
			break;
		}
		
		for (var i = 0; i < prefs.length; i++)
			if (this.ssModifier[i]){
				if (_isIE)
					document.styleSheets[0].addRule(prefs[i], this.ssModifier[i]);
				else
					document.styleSheets[index].insertRule(prefs[i]+(" { "+this.ssModifier[i]+" }"), document.styleSheets[index].cssRules.length);
			}
	}
	/**
	*   @desc: colorize columns  background.
	*   @param: clr - colors list
	*   @type: public
	*   @before_init: 1
	*   @topic: 3,6
	*/
	this.setColumnColor=function(clr){
		this.columnColor=clr.split(this.delim)
	}
//#alter_css:06042008{
	/**
	*   @desc: set even/odd css styles
	*   @param: cssE - name of css class for even rows
	*   @param: cssU - name of css class for odd rows
	*   @param: perLevel - true/false - mark rows not by order, but by level in treegrid
	*   @param: levelUnique - true/false - creates additional unique css class based on row level
	*   @type: public
	*   @before_init: 1
	*   @topic: 3,6
	*/
	this.enableAlterCss=function(cssE, cssU, perLevel, levelUnique){
		if (cssE||cssU)
			this.attachEvent("onGridReconstructed",function(){
				this._fixAlterCss();
				if (this._fake)
					this._fake._fixAlterCss();
			});

		this._cssSP=perLevel;
		this._cssSU=levelUnique;
		this._cssEven=cssE;
		this._cssUnEven=cssU;
	}
//#}
	/**
	*   @desc: recolor grid from defined point
	*   @type: private
	*   @before_init: 1
	*   @topic: 3,6
	*/
	this._fixAlterCss=function(ind){
//#alter_css:06042008{		
		if (this._h2 && (this._cssSP || this._cssSU))
			return this._fixAlterCssTGR(ind);
		if (!this._cssEven && !this._cssUnEven) return;
		ind=ind||0;
		var j = ind;

		for (var i = ind; i < this.rowsCol.length; i++){
			if (!this.rowsCol[i])
				continue;

			if (this.rowsCol[i].style.display != "none"){
				if (this.rowsCol[i]._cntr) { j=1; continue; }
				if (this.rowsCol[i].className.indexOf("rowselected") != -1){
					if (j%2 == 1)
						this.rowsCol[i].className=this._cssUnEven+" rowselected "+(this.rowsCol[i]._css||"");
					else
						this.rowsCol[i].className=this._cssEven+" rowselected "+(this.rowsCol[i]._css||"");
				} else {
					if (j%2 == 1)
						this.rowsCol[i].className=this._cssUnEven+" "+(this.rowsCol[i]._css||"");
					else
						this.rowsCol[i].className=this._cssEven+" "+(this.rowsCol[i]._css||"");
				}
				j++;
			}
		}
//#}		
	}
//#__pro_feature:21092006{
	/**
	*     @desc: clear wasChanged state for all cells in grid
	*     @type: public
	*     @edition: Professional
	*     @topic: 7
	*/
	this.clearChangedState=function(){
		for (var i = 0; i < this.rowsCol.length; i++){
			var row = this.rowsCol[i];
			if (row && row.childNodes){
				var cols = row.childNodes.length;
				for (var j = 0; j < cols; j++)row.childNodes[j].wasChanged=false;
			}
		}
	};

	/**
	*     @desc: get list of IDs of changed rows
	*     @type: public
	*     @edition: Professional
	*     @return: list of ID of changed rows
	*     @topic: 7
	*/
	this.getChangedRows=function(and_added){
		var res = new Array();
		this.forEachRow(function(id){
			var row = this.rowsAr[id];
			if (row.tagName!="TR") return; 
			var cols = row.childNodes.length;
			if (and_added && row._added)
				res[res.length]=row.idd;
			else
				for (var j = 0; j < cols; j++)
					if (row.childNodes[j].wasChanged){
						res[res.length]=row.idd;
						break;
					}
		})
		return res.join(this.delim);
	};


//#serialization:21092006{

	this._sUDa=false;
	this._sAll=false;

	/**
	*     @desc: configure XML serialization
	*     @type: public
	*     @edition: Professional
	*     @param: userData - enable/disable user data serialization
	*     @param: fullXML - enable/disable full XML serialization (selection state)
	*     @param: config - serialize grid configuration
	*     @param: changedAttr - include changed attribute
	*     @param: onlyChanged - include only Changed  rows in result XML
	*     @param: asCDATA - output cell values as CDATA sections (prevent invalid XML)
	*     @topic: 0,5,7
	*/
	this.setSerializationLevel=function(userData, fullXML, config, changedAttr, onlyChanged, asCDATA){
		this._sUDa=userData;
		this._sAll=fullXML;
		this._sConfig=config;
		this._chAttr=changedAttr;
		this._onlChAttr=onlyChanged;
		this._asCDATA=asCDATA;
	}


/**
*     @desc: configure which column must be serialized (if you do not use this method, then all columns will be serialized)
*     @type: public
*     @edition: Professional
*     @param: list - list of true/false values separated by comma, if list empty then all fields will be serialized
*     @topic: 0,5,7
*/
	this.setSerializableColumns=function(list){
		if (!list){
			this._srClmn=null;
			return;
		}
		this._srClmn=(list||"").split(",");

		for (var i = 0; i < this._srClmn.length; i++)this._srClmn[i]=dhx4.s2b(this._srClmn[i]);
	}

	/**
	*     @desc: serialize a collection of rows
	*     @type: private
	*     @topic: 0,5,7
	*/
	this._serialise=function(rCol, inner, closed){
		this.editStop()
		var out = [];
		//rows collection
		var close = "</"+this.xml.s_row+">"

		if (this.isTreeGrid()){
			this._h2.forEachChildF(0, function(el){
				var temp = this._serializeRow(this.render_row_tree(-1, el.id));
				out.push(temp);

				if (temp)
					return true;
				else
					return false;
			}, this, function(){
				out.push(close);
			});
		}
		else
			for (var i = 0; i < this.rowsBuffer.length; i++)
				if (this.rowsBuffer[i]){
					if (this._chAttr && this.rowsBuffer[i]._locator)
						continue;
						
					var temp = this._serializeRow(this.render_row(i));
					out.push(temp);

					if (temp)
						out.push(close);
				}

		return [out.join("")];
	}

	/**
	*   @desc: serialize TR or xml node to grid formated xml (row tag)
	*   @param: r - TR or xml node (row)
	*   @retruns: string - xml representation of passed row
	*   @type: private
	*/
	this._serializeRow=function(r, i){
		var out = [];
		var ra = this.xml.row_attrs;
		var ca = this.xml.cell_attrs;

		out.push("<"+this.xml.s_row);
		out.push(" id='"+r.idd+"'");

		if ((this._sAll)&&this.selectedRows._dhx_find(r) != -1)
			out.push(" selected='1'");

		if (this._h2&&this._h2.get[r.idd].state == "minus")
			out.push(" open='1'");

		if (ra.length)
			for (var i = 0; i < ra.length; i++)out.push(" "+ra[i]+"='"+r._attrs[ra[i]]+"'");
		out.push(">");

		//userdata
		if (this._sUDa&&this.UserData[r.idd]){
			keysAr=this.UserData[r.idd].getKeys()

			for (var ii = 0;
				ii < keysAr.length;
				ii++)out.push("<userdata name='"+keysAr[ii]+"'>"+(this._asCDATA?"<![CDATA[":"")+this.UserData[r.idd].get(keysAr[ii])+(this._asCDATA?"]]>":"")+"</userdata>");
		}


		//cells
		var changeFl = false;

		for (var jj = 0; jj < this._cCount; jj++){
			if ((!this._srClmn)||(this._srClmn[jj])){
				var zx = this.cells3(r, jj);
				out.push("<cell");

				if (ca.length)
					for (var i = 0; i < ca.length; i++)out.push(" "+ca[i]+"='"+zx.cell._attrs[ca[i]]+"'");
				zxVal=zx[this._agetm]();

				if (this._asCDATA)
					zxVal="<![CDATA["+zxVal+"]]>";

				//#colspan:20092006{
				if ((this._ecspn)&&(zx.cell.colSpan)&&zx.cell.colSpan > 1)
					out.push(" colspan=\""+zx.cell.colSpan+"\" ");
				//#}

				if (this._chAttr){
					if (zx.wasChanged()){
						out.push(" changed=\"1\"");
						changeFl=true;
					}
				}

				else if ((this._onlChAttr)&&(zx.wasChanged()))
					changeFl=true;

				if (this._sAll && this.cellType[jj]=="tree")
					out.push((this._h2 ? (" image='"+this._h2.get[r.idd].image+"'") : "")+">"+zxVal+"</cell>");
				else
					out.push(">"+zxVal+"</cell>");

				//#colspan:20092006{
				if ((this._ecspn)&&(zx.cell.colSpan))
					for (var u = 0; u < zx.cell.colSpan-1; u++){
						out.push("<cell/>");
						jj++;
					}
			//#}
			}
		}

		if ((this._onlChAttr)&&(!changeFl)&&(!r._added))
			return "";

		return out.join("");
	}

	/**
	*     @desc: serialize grid configuration
	*     @type: private
	*     @topic: 0,5,7
	*/
	this._serialiseConfig=function(){
		var out = "<head>";

		for (var i = 0; i < this.hdr.rows[0].cells.length; i++){
			if (this._srClmn && !this._srClmn[i]) continue;
			var sort = this.fldSort[i];
			if (sort == "cus"){
				sort = this._customSorts[i].toString();
				sort=sort.replace(/function[\ ]*/,"").replace(/\([^\f]*/,"");
			}
			out+="<column width='"+this.getColWidth(i)+"' align='"+this.cellAlign[i]+"' type='"+this.cellType[i]
				+"' sort='"+(sort||"na")+"' color='"+this.columnColor[i]+"'"
				+(this.columnIds[i]
					? (" id='"+this.columnIds[i]+"'")
					: "")+">";
			if (this._asCDATA)
				out+="<![CDATA["+this.getColumnLabel(i)+"]]>";
			else
				out+=this.getColumnLabel(i);
			var z = this.getCombo(i);

			if (z)
				for (var j = 0; j < z.keys.length; j++)out+="<option value='"+z.keys[j]+"'>"+z.values[j]+"</option>";
			out+="</column>"
		}
		return out+="</head>";
	}
	/**
	*     @desc: get actual xml of grid. The depth of serialization can be set with setSerializationLevel method
	*     @type: public
	*     @edition: Professional
	*     @topic: 5,7
	*/
	this.serialize=function(){
		var out = '<?xml version="1.0"?><rows>';

		if (this._mathSerialization)
			this._agetm="getMathValue";
		else
			this._agetm="getValue";

		if (this._sUDa&&this.UserData["gridglobaluserdata"]){
			var keysAr = this.UserData["gridglobaluserdata"].getKeys()

			for (var i = 0;
				i < keysAr.length;
				i++)out+="<userdata name='"+keysAr[i]+"'>"+this.UserData["gridglobaluserdata"].get(keysAr[i])
				+"</userdata>";
		}

		if (this._sConfig)
			out+=this._serialiseConfig();
		out+=this._serialise();

		out+='</rows>';
		return out;
	}
//#}
//#}

	/**
	*    @desc: returns absolute left and top position of specified element
	*    @returns: array of two values: absolute Left and absolute Top positions
	*    @param: oNode - element to get position of
	*   @type: private
	*   @topic: 8
	*/
	this.getPosition=function(oNode, pNode){
		if (!pNode){
			var pos = dhx4.getOffset(oNode);
			return [pos.left, pos.top];
		}
		pNode = pNode||document.body;

		var oCurrentNode = oNode;
		var iLeft = 0;
		var iTop = 0;

		while ((oCurrentNode)&&(oCurrentNode != pNode)){ //.tagName!="BODY"){
			iLeft+=oCurrentNode.offsetLeft-oCurrentNode.scrollLeft;
			iTop+=oCurrentNode.offsetTop-oCurrentNode.scrollTop;
			oCurrentNode=oCurrentNode.offsetParent;
		}

		if (pNode == document.body){
			if (_isIE){
				iTop+=document.body.offsetTop||document.documentElement.offsetTop;
				iLeft+=document.body.offsetLeft||document.documentElement.offsetLeft;
			} else if (!_isFF){
				iLeft+=document.body.offsetLeft;
				iTop+=document.body.offsetTop;
			}
		}
		return [iLeft, iTop];
	}
	/**
	*   @desc: gets nearest parent of specified type
	*   @param: obj - input object
	*   @param: tag - string. tag to find as parent
	*   @returns: object. nearest paraent object (including spec. obj) of specified type.
	*   @type: private
	*   @topic: 8
	*/
	this.getFirstParentOfType=function(obj, tag){
		while (obj&&obj.tagName != tag&&obj.tagName != "BODY"){
			obj=obj.parentNode;
		}
		return obj;
	}



	/*INTERNAL EVENT HANDLERS*/
	this.objBox.onscroll=function(){
		this.grid._doOnScroll();
	};
	this.objBox.ontouchend = function(){
		this.hdrBox.scrollLeft=this.objBox.scrollLeft;
	};
	this.hdrBox.onscroll=function(){
		if (this._try_header_sync) return;
		this._try_header_sync = true;
		if (Math.abs(this.grid.objBox.scrollLeft - this.scrollLeft)>1){
			this.grid.objBox.scrollLeft = this.scrollLeft;
		}
		this._try_header_sync = false;
	}
//#column_resize:06042008{
	if ((!_isOpera)||(_OperaRv > 8.5)){
		this.hdr.onmousemove=function(e){
			this.grid.changeCursorState(e||window.event);
		};
		this.hdr.onmousedown=function(e){
			return this.grid.startColResize(e||window.event);
		};		
	}
//#}
//#tooltips:06042008{
	this.obj.onmousemove=this._drawTooltip;
//#}
	this.objBox.onclick=function(e){
		(e||event).cancelBubble=true;
	};
	this.obj.onclick=function(e){
		if (this.grid._doClick(e||window.event) !== false){
			if (this.grid._sclE) 
				this.grid.editCell(e||window.event); 
			else
				this.grid.editStop();
		}
					
		(e||event).cancelBubble=true;
	};
//#context_menu:06042008{
	if (_isMacOS){
		this.entBox.oncontextmenu=function(e){
			e.cancelBubble=true;
			if (e.preventDefault) e.preventDefault(); else e.returnValue=false;
			var that = this.grid; if (that._realfake) that = that._fake;
			return that._doContClick(e||window.event);
		};
	} else {
    	this.entBox.onmousedown=function(e){
	    	return this.grid._doContClick(e||window.event);
    	};
    	this.entBox.oncontextmenu=function(e){
    		if (this.grid._ctmndx)
    			(e||event).cancelBubble=true;
    		return !this.grid._ctmndx;
		};
	}
    	
//#}		
	this.obj.ondblclick=function(e){
		if (!this.grid.wasDblClicked(e||window.event)) 
			return false; 
		if (this.grid._dclE) {
			var row = this.grid.getFirstParentOfType((_isIE?event.srcElement:e.target),"TR");
			if (row == this.grid.row)
				this.grid.editCell(e||window.event);  
		}
		(e||event).cancelBubble=true;
		if (_isOpera) return false; //block context menu for Opera 9+
	};
	this.hdr.onclick=this._onHeaderClick;
	this.sortImg.onclick=function(){
		self._onHeaderClick.apply({
			grid: self
			}, [
			null,
			self.r_fldSorted
		]);
	};

	this.hdr.ondblclick=this._onHeaderDblClick;


	if (!document.body._dhtmlxgrid_onkeydown){
		dhtmlxEvent(document, "keydown",function(e){
			if (globalActiveDHTMLGridObject) 
				return globalActiveDHTMLGridObject.doKey(e||window.event);
		});
		document.body._dhtmlxgrid_onkeydown=true;
	}

	dhtmlxEvent(document.body, "click", function(){
		if (self.editStop) self.editStop();
		if (self.isActive) self.setActive(false);
	});

	
	if (this.entBox.style.height.toString().indexOf("%") != -1)
		this._delta_y = this.entBox.style.height;
	if (this.entBox.style.width.toString().indexOf("%") != -1)
		this._delta_x = this.entBox.style.width;

	if (this._delta_x||this._delta_y)
		this._setAutoResize();
	
		
	/* deprecated names */
	this.setColHidden=this.setColumnsVisibility
	this.enableCollSpan = this.enableColSpan
	this.setMultiselect=this.enableMultiselect;
	this.setMultiLine=this.enableMultiline;
	this.deleteSelectedItem=this.deleteSelectedRows;
	this.getSelectedId=this.getSelectedRowId;
	this.getHeaderCol=this.getColumnLabel;
	this.isItemExists=this.doesRowExist;
	this.getColumnCount=this.getColumnsNum;
	this.setSelectedRow=this.selectRowById;
	this.setHeaderCol=this.setColumnLabel;
	this.preventIECashing=this.preventIECaching;
	this.enableAutoHeigth=this.enableAutoHeight;
	this.getUID=this.uid;
	
	if (dhtmlx.image_path) this.setImagePath(dhtmlx.image_path);
	if (dhtmlx.skin) this.setSkin(dhtmlx.skin);
	
	return this;
}

dhtmlXGridObject.prototype={
	getRowAttribute: function(id, name){
		return this.getRowById(id)._attrs[name];
	},
	setRowAttribute: function(id, name, value){
		this.getRowById(id)._attrs[name]=value;
	},
	/**
	*   @desc: detect is current grid is a treeGrid
	*   @type: private
	*   @topic: 2
	*/
	isTreeGrid:function(){
		return (this.cellType._dhx_find("tree") != -1);
	},
	
//#column_hidden:21092006{	
	/**
	*   @desc: hide/show row (warning! - this command doesn't affect row indexes, only visual appearance)
	*   @param: ind - column index
	*   @param: state - true/false - hide/show row
	*   @type:  public
	*/
	setRowHidden:function(id, state){
		var f = dhx4.s2b(state);
		//var ind=this.getRowIndex(id);
		//if (id<0)
		//   return;
		var row = this.getRowById(id) //this.rowsCol[ind];
	
		if (!row)
			return;
	
		if (row.expand === "")
			this.collapseKids(row);
	
		if ((state)&&(row.style.display != "none")){
			row.style.display="none";
			var z = this.selectedRows._dhx_find(row);
	
			if (z != -1){
				row.className=row.className.replace("rowselected", "");
	
				for (var i = 0;
					i < row.childNodes.length;
					i++)row.childNodes[i].className=row.childNodes[i].className.replace(/cellselected/g, "");
				this.selectedRows._dhx_removeAt(z);
			}
			this.callEvent("onGridReconstructed", []);
		}
	
		if ((!state)&&(row.style.display == "none")){
			row.style.display="";
			this.callEvent("onGridReconstructed", []);
		}
		this.callEvent("onRowHide",[id, state]);
		this.setSizes();
	},
	
//#__pro_feature:21092006{
	/**
	*   @desc: hide/show column
	*   @param: ind - column index
	*   @param: state - true/false - hide/show column
	*   @type:  public
	*   @edition: Professional
	*/
	setColumnHidden:function(ind, state){
		if (!this.hdr.rows.length){
			if (!this._ivizcol)
				this._ivizcol=[];
			return this._ivizcol[ind]=state;
		}
	
		if ((this.fldSorted)&&(this.fldSorted.cellIndex == ind)&&(state))
			this.sortImg.style.display="none";
	
		var f = dhx4.s2b(state);
	
		if (f){
			if (!this._hrrar)
				this._hrrar=new Array();
	
			else if (this._hrrar[ind])
				return;
			this._hrrar[ind]="display:none;";
			this._hideShowColumn(ind, "none");
		} else {
			if ((!this._hrrar)||(!this._hrrar[ind]))
				return;
			this._hrrar[ind]="";
			this._hideShowColumn(ind, "");
		}
	
		if ((this.fldSorted)&&(this.fldSorted.cellIndex == ind)&&(!state))
			this.sortImg.style.display="inline";
			
		this.setSortImgPos();
		this.callEvent("onColumnHidden",[ind,state])
	},
	
	
	/**
	*   @desc: get show/hidden status of column
	*   @param: ind - column index
	*   @type:  public
	*   @edition: Professional
	*   @returns:  if column hidden then true else false
	*/
	isColumnHidden:function(ind){
		if ((this._hrrar)&&(this._hrrar[ind]))
			return true;
	
		return false;
	},
	/**
	*   @desc: set list of visible/hidden columns
	*   @param: list - list of true/false separated by comma
	*   @type:  public
	*	@newmethod: setColumnsVisibility
	*   @edition: Professional
	*   @topic:0
	*/
	setColumnsVisibility:function(list){
		if (list)
			this._ivizcol=list.split(this.delim);
	
		if (this.hdr.rows.length&&this._ivizcol)
			for (var i = 0; i < this._ivizcol.length; i++)this.setColumnHidden(i, this._ivizcol[i]);
	},
	/**
	*   @desc: fix hidden state for column in all rows
	*   @type: private
	*/
	_fixHiddenRowsAll:function(pb, ind, prop, state, index){
		index=index||"_cellIndex";
		var z = pb.rows.length;
	
		for (var i = 0; i < z; i++){
			var x = pb.rows[i].childNodes;
	
			if (x.length != this._cCount){
				for (var j = 0; j < x.length; j++)
					if (x[j][index] == ind){
						x[j].style[prop]=state;
						break;
					}
			} else
				x[ind].style[prop]=state;
		}
	},
	/**
	*   @desc: hide column
	*   @param: ind - column index
	*   @param: state - hide/show
	*   @edition: Professional
	*   @type:  private
	*/
	_hideShowColumn:function(ind, state){
		var hind = ind;
	
		if (this.hdr.rows[1] && (this.hdr.rows[1]._childIndexes)&&(this.hdr.rows[1]._childIndexes[ind] != ind))
			hind=this.hdr.rows[1]._childIndexes[ind];
	
		if (state == "none"){
			this.hdr.rows[0].cells[ind]._oldWidth=this.hdr.rows[0].cells[ind].style.width||(this.initCellWidth[ind]+"px");
			this.hdr.rows[0].cells[ind]._oldWidthP=this.cellWidthPC[ind];
			this.obj.rows[0].cells[ind].style.width="0px";
	
			
			var t={rows:[this.obj.rows[0]]}
			this.forEachRow(function(id){
				if (this.rowsAr[id].tagName=="TR")
							t.rows.push(this.rowsAr[id])
			})
			this._fixHiddenRowsAll(t, ind, "display", "none");
	
			if (this.isTreeGrid())
				this._fixHiddenRowsAllTG(ind, "none");
	
			if ((_isOpera&&_OperaRv < 9)||_isKHTML||(_isFF)){ 
			    this._fixHiddenRowsAll(this.hdr, ind, "display", "none","_cellIndexS");
	
			}
			if (this.ftr)
				this._fixHiddenRowsAll(this.ftr.childNodes[0], ind, "display", "none");			
			this._fixHiddenRowsAll(this.hdr, ind, "whiteSpace", "nowrap","_cellIndexS");
	
			if (!this.cellWidthPX.length&&!this.cellWidthPC.length)
				this.cellWidthPX=[].concat(this.initCellWidth);
	
			if (this.cellWidthPX[ind])
				this.cellWidthPX[ind]=0;
	
			if (this.cellWidthPC[ind])
				this.cellWidthPC[ind]=0;
		} else {
			if (this.hdr.rows[0].cells[ind]._oldWidth){
				var zrow = this.hdr.rows[0].cells[ind];
	
				if (_isOpera||_isKHTML||(_isFF))
					this._fixHiddenRowsAll(this.hdr, ind, "display", "","_cellIndexS");
	
				if (this.ftr)
					this._fixHiddenRowsAll(this.ftr.childNodes[0], ind, "display", "");
	
				
				var t={rows:[this.obj.rows[0]]}
				this.forEachRow(function(id){
					if (this.rowsAr[id].tagName=="TR")
								t.rows.push(this.rowsAr[id])
				})
				this._fixHiddenRowsAll(t, ind, "display", "");
	
				if (this.isTreeGrid())
					this._fixHiddenRowsAllTG(ind, "");
	
				this._fixHiddenRowsAll(this.hdr, ind, "whiteSpace", "normal","_cellIndexS");
	
				if (zrow._oldWidthP)
					this.cellWidthPC[ind]=zrow._oldWidthP;
	
				if (zrow._oldWidth)
					this.cellWidthPX[ind]=parseInt(zrow._oldWidth);
			}
		}
		this.setSizes();
	
		if ((!_isIE)&&(!_isFF)){
			//dummy Opera/Safari fix
			this.obj.border=1;
			this.obj.border=0;
		}
	},
//#}	
//#}
//#__pro_feature:21092006{	
//#colspan:20092006{
	/**
	*   @desc: enable/disable colspan support
	*   @param: mode - true/false
	*   @type:  public
	*   @edition: Professional
	*/
	enableColSpan:function(mode){
		this._ecspn=dhx4.s2b(mode);
	},
//#}
//#}
//#hovering:060402008{	
	/**
	*   @desc: enable/disable hovering row on mouse over
	*   @param: mode - true/false
	*   @param: cssClass - css class for hovering row
	*   @type:  public
	*/
	enableRowsHover:function(mode, cssClass){
		this._unsetRowHover(false,true);
		this._hvrCss=cssClass;
	
		if (dhx4.s2b(mode)){
			if (!this._elmnh){
				this.obj._honmousemove=this.obj.onmousemove;
				this.obj.onmousemove=this._setRowHover;
	
				if (_isIE)
					this.obj.onmouseleave=this._unsetRowHover;
				else
					this.obj.onmouseout=this._unsetRowHover;
	
				this._elmnh=true;
			}
		} else {
			if (this._elmnh){
				this.obj.onmousemove=this.obj._honmousemove;
	
				if (_isIE)
					this.obj.onmouseleave=null;
				else
					this.obj.onmouseout=null;
	
				this._elmnh=false;
			}
		}
	},
//#}	
	/**
	*   @desc: enable/disable events which fire excell editing, mutual exclusive with enableLightMouseNavigation
	*   @param: click - true/false - enable/disable editing by single click
	*   @param: dblclick - true/false - enable/disable editing by double click
	*   @param: f2Key - enable/disable editing by pressing F2 key
	*   @type:  public
	*/
	enableEditEvents:function(click, dblclick, f2Key){
		this._sclE=dhx4.s2b(click);
		this._dclE=dhx4.s2b(dblclick);
		this._f2kE=dhx4.s2b(f2Key);
	},
	
//#hovering:060402008{	
	/**
	*   @desc: enable/disable light mouse navigation mode (row selection with mouse over, editing with single click), mutual exclusive with enableEditEvents
	*   @param: mode - true/false
	*   @type:  public
	*/
	enableLightMouseNavigation:function(mode){
		if (dhx4.s2b(mode)){
			if (!this._elmn){
				this.entBox._onclick=this.entBox.onclick;
				this.entBox.onclick=function(){
					return true;
				};
	
				this.obj._onclick=this.obj.onclick;
				this.obj.onclick=function(e){
					var c = this.grid.getFirstParentOfType(e ? e.target : event.srcElement, 'TD');
					if (!c) return;
					this.grid.editStop();
					this.grid.doClick(c);
					this.grid.editCell();
					(e||event).cancelBubble=true;
				}
	
				this.obj._onmousemove=this.obj.onmousemove;
				this.obj.onmousemove=this._autoMoveSelect;
				this._elmn=true;
			}
		} else {
			if (this._elmn){
				this.entBox.onclick=this.entBox._onclick;
				this.obj.onclick=this.obj._onclick;
				this.obj.onmousemove=this.obj._onmousemove;
				this._elmn=false;
			}
		}
	},
	
	
	/**
	*   @desc: remove hover state on row
	*   @type:  private
	*/
	_unsetRowHover:function(e, c){
		if (c)
			that=this;
		else
			that=this.grid;
	
		if ((that._lahRw)&&(that._lahRw != c)){
			for (var i = 0;
				i < that._lahRw.childNodes.length;
				i++)that._lahRw.childNodes[i].className=that._lahRw.childNodes[i].className.replace(that._hvrCss, "");
			that._lahRw=null;
		}
	},
	
	/**
	*   @desc: set hover state on row
	*   @type:  private
	*/
	_setRowHover:function(e){
		var c = this.grid.getFirstParentOfType(e ? e.target : event.srcElement, 'TD');
	
		if (c && c.parentNode!=this.grid._lahRw) {
			this.grid._unsetRowHover(0, c);
			c=c.parentNode;
	  		if (!c.idd || c.idd=="__filler__") return;
			for (var i = 0; i < c.childNodes.length; i++)c.childNodes[i].className+=" "+this.grid._hvrCss;
			this.grid._lahRw=c;
		}
		this._honmousemove(e);
	},
	
	/**
	*   @desc: onmousemove, used in light mouse navigaion mode
	*   @type:  private
	*/
	_autoMoveSelect:function(e){
		//this - grid.obj
		if (!this.grid.editor){
			var c = this.grid.getFirstParentOfType(e ? e.target : event.srcElement, 'TD');
	
			if (c.parentNode.idd)
				this.grid.doClick(c, true, 0);
		}
		this._onmousemove(e);
	},
//#}	
//#__pro_feature:21092006{
//#distrb_parsing:21092006{
	/**
	*   @desc: enable/disable distributed parsing (rows paresed portion by portion with some timeout)
	*   @param: mode - true/false
	*   @param: count - count of nodes parsed by one step (the 10 by default)
	*   @param: time - time between parsing counts in milli seconds (the 250 by default)
	*   @type:  public
	*   @edition: Professional
	*/
	enableDistributedParsing:function(mode, count, time){
		if (dhx4.s2b(mode)){
			this._ads_count=count||10;
			this._ads_time=time||250;
		} else
			this._ads_count=0;
	},
//#}
//#}
	/**
		*     @desc: destructor, removes grid and cleans used memory
		*     @type: public
	  *     @topic: 0
		*/
	destructor:function(){
		this.editStop(true);
		//add links to current object
		if (this._sizeTime)
			this._sizeTime=window.clearTimeout(this._sizeTime);
		this.entBox.className=(this.entBox.className||"").replace(/gridbox.*/,"");
		if (this.formInputs)
			for (var i = 0; i < this.formInputs.length; i++)this.parentForm.removeChild(this.formInputs[i]);
	
		var a;
	
		for (var i = 0; i < this.rowsCol.length; i++)
			if (this.rowsCol[i])
				this.rowsCol[i].grid=null;
	
		for (i in this.rowsAr)
			if (this.rowsAr[i])
				this.rowsAr[i]=null;
	
		this.rowsCol=new dhtmlxArray();
		this.rowsAr={};
		this.entBox.innerHTML="";
		
		var dummy=function(){};
		this.entBox.onclick = this.entBox.onmousedown = this.entBox.onbeforeactivate = this.entBox.onbeforedeactivate = this.entBox.onbeforedeactivate = this.entBox.onselectstart = dummy;
		this.setSizes = this._update_srnd_view = this.callEvent = dummy;
		this.entBox.grid=this.objBox.grid=this.hdrBox.grid=this.obj.grid=this.hdr.grid=null;
		if (this._fake){
			this.globalBox.innerHTML = "";
			this._fake.setSizes = this._fake._update_srnd_view = this._fake.callEvent = dummy;
			this.globalBox.onclick = this.globalBox.onmousedown = this.globalBox.onbeforeactivate = this.globalBox.onbeforedeactivate = this.globalBox.onbeforedeactivate = this.globalBox.onselectstart = dummy;
		}
	
		for (a in this){
			if ((this[a])&&(this[a].m_obj))
				this[a].m_obj=null;
			this[a]=null;
		}
	
		if (this == globalActiveDHTMLGridObject)
			globalActiveDHTMLGridObject=null;
		//   self=null;
		return null;
	},
	
//#sorting:06042008{	
	/**
	*     @desc: get sorting state of grid
	*     @type: public
	*     @returns: array, first element is index of sortef column, second - direction of sorting ("asc" or "des").
	*     @topic: 0
	*/
	getSortingState:function(){
		var z = new Array();
	
		if (this.fldSorted){
			z[0]=this.fldSorted._cellIndex;
			z[1]=(this.sortImg.className == "dhxgrid_sort_desc" ? "des" : "asc");
		}
		return z;
	},
//#}
	
	/**
	*     @desc: enable autoheight of grid
	*     @param: mode - true/false
	*     @param: maxHeight - maximum height before scrolling appears (no limit by default)
	*     @param: countFullHeight - control the usage of maxHeight parameter - when set to true all grid height included in max height calculation, if false then only data part (no header) of grid included in calcualation (false by default)
	*     @type: public
	*     @topic: 0
	*/
	enableAutoHeight:function(mode, maxHeight, countFullHeight){
		this._ahgr=dhx4.s2b(mode);
		this._ahgrF=dhx4.s2b(countFullHeight);
		this._ahgrM=maxHeight||null;
		if (arguments.length == 1){
			this.objBox.style.overflowY=mode?"hidden":"auto";
		}
		if (maxHeight == "auto"){
			this._ahgrM=null;
			this._ahgrMA=true;
			this._setAutoResize();
		//   this._activeResize();
		}
	},
//#sorting:06042008{	
	enableStableSorting:function(mode){
		this._sst=dhx4.s2b(mode);
		this.rowsCol.stablesort=function(cmp){
			var size = this.length-1;
	
			for (var i = 0; i < this.length-1; i++){
				for (var j = 0; j < size; j++)
					if (cmp(this[j], this[j+1]) > 0){
						var temp = this[j];
						this[j]=this[j+1];
						this[j+1]=temp;
					}
				size--;
			}
		}
	},
//#}
	
	/**
	*     @desc: enable/disable hot keys in grid
	*     @param: mode - true/false
	*     @type: public
	*     @topic: 0
	*/
	enableKeyboardSupport:function(mode){
		this._htkebl=!dhx4.s2b(mode);
	},
	
//#context_menu:06042008{	
	/**
	*     @desc: enable/disable context menu
	*     @param: dhtmlxMenu object, if null - context menu will be disabled
	*     @type: public
	*     @topic: 0
	*/
	enableContextMenu:function(menu){
		this._ctmndx=menu;
	},
//#}	
	
	/*backward compatibility*/
	setScrollbarWidthCorrection:function(width){
	},
//#tooltips:06042008{	
	/**
	*     @desc: enable/disable tooltips for specified colums
	*     @param: list - list of true/false values, tooltips enabled for all columns by default
	*     @type: public
	*     @topic: 0
	*/
	enableTooltips:function(list){
		this._enbTts=list.split(",");
	
		for (var i = 0; i < this._enbTts.length; i++)this._enbTts[i]=dhx4.s2b(this._enbTts[i]);
	},
//#}	
	
//#column_resize:06042008{
	/**
	*     @desc: enable/disable resizing for specified colums
	*     @param: list - list of true/false values, resizing enabled for all columns by default
	*     @type: public
	*     @topic: 0
	*/
	enableResizing:function(list){
		this._drsclmn=list.split(",");
	
		for (var i = 0; i < this._drsclmn.length; i++)this._drsclmn[i]=dhx4.s2b(this._drsclmn[i]);
	},
	
	/**
	*     @desc: set minimum column width ( works only for manual resizing )
	*     @param: width - minimum column width, can be set for specified column, or as comma separated list for all columns
	*     @param: ind - column index
	*     @type: public
	*     @topic: 0
	*/
	setColumnMinWidth:function(width, ind){
		if (arguments.length == 2){
			if (!this._drsclmW)
				this._drsclmW=new Array();
			this._drsclmW[ind]=width;
		} else
			this._drsclmW=width.split(",");
	},
//#}	
	
	/**
	*     @desc: enable/disable unique id for cells (id will be automaticaly created using the following template: "c_[RowId]_[colIndex]")
	*     @param: mode - true/false - enable/disable
	*     @type: public
	*     @topic: 0
	*/
	enableCellIds:function(mode){
		this._enbCid=dhx4.s2b(mode);
	},
	
	
//#locked_row:11052006{
	/**
	*     @desc: lock/unlock row for editing
	*     @param: rowId - id of row
	*     @param: mode - true/false - lock/unlock
	*     @type: public
	*     @topic: 0
	*/
	lockRow:function(rowId, mode){
		var z = this.getRowById(rowId);
	
		if (z){
			z._locked=dhx4.s2b(mode);
	
			if ((this.cell)&&(this.cell.parentNode.idd == rowId))
				this.editStop();
		}
	},
//#}
	
	/**
	*   @desc:  get values of all cells in row
	*   @type:  private
	*/
	_getRowArray:function(row){
		var text = new Array();
	
		for (var ii = 0; ii < row.childNodes.length; ii++){
			var a = this.cells3(row, ii);
			text[ii]=a.getValue();
		}
	
		return text;
	},
//#__pro_feature:21092006{	
//#data_format:12052006{
	/**
	*     @desc: set mask for date formatting in cell
	*     @param: mask - date mask, d,m,y will mean day,month,year; for example "d/m/y" - 22/05/1985
	*     @type: public
	*     @edition: Professional
	*     @topic: 0
	*/
	setDateFormat:function(mask,incoming){
		this._dtmask=mask;
		this._dtmask_inc=incoming;
	},
	
	/**
	*     @desc: set mask for formatting numeric data ( works for [ed/ro]n excell only or oher cell types with suport for this method)
	*     @param: mask - numeric mask; for example 0,000.00 - 1,234.56
	*     @param: cInd - column index
	*     @param: p_sep - char used as decimalseparator ( point by default )
	*     @param: d_sep - char used as groups part separator ( comma by default )
	*     @type: public
	*     @edition: Professional
	*     @topic: 0
	*/
	setNumberFormat:function(mask, cInd, p_sep, d_sep){
		var nmask = mask.replace(/[^0\,\.]*/g, "");
		var pfix = nmask.indexOf(".");
	
		if (pfix > -1)
			pfix=nmask.length-pfix-1;
		var dfix = nmask.indexOf(",");
	
		if (dfix > -1)
			dfix=nmask.length-pfix-2-dfix;
		if (typeof p_sep != "string")
			p_sep=this.i18n.decimal_separator;
		if (typeof d_sep != "string")
			d_sep=this.i18n.group_separator;
		var pref = mask.split(nmask)[0];
		var postf = mask.split(nmask)[1];
		this._maskArr[cInd]=[
			pfix,
			dfix,
			pref,
			postf,
			p_sep,
			d_sep
		];
	},
	/**
	*   @desc:  convert formated value to original
	*   @type:  private
	*/
	_aplNFb:function(data, ind){
		var a = this._maskArr[ind];
	
		if (!a)
			return data;
	
		var ndata = parseFloat(data.toString().replace(/[^0-9]*/g, ""));
	
		if (data.toString().substr(0, 1) == "-")
			ndata=ndata*-1;
	
		if (a[0] > 0)
			ndata=ndata / Math.pow(10, a[0]);
		return ndata;
	},
	
	/**
	*   @desc:  format data with mask
	*   @type:  private
	*/
	_aplNF:function(data, ind){
		var a = this._maskArr[ind];
	
		if (!a)
			return data;
	
		var c = (parseFloat(data) < 0 ? "-" : "")+a[2];
		data=Math.abs(Math.round(parseFloat(data)*Math.pow(10, a[0] > 0 ? a[0] : 0))).toString();
		data=(data.length
			< a[0]
				? Math.pow(10, a[0]+1-data.length).toString().substr(1, a[0]+1)+data.toString()
				: data).split("").reverse();
		data[a[0]]=(data[a[0]]||"0")+a[4];
	
		if (a[1] > 0)
			for (var j = (a[0] > 0 ? 0 : 1)+a[0]+a[1]; j < data.length; j+=a[1])data[j]+=a[5];
		return c+data.reverse().join("")+a[3];
	},
//#}
//#}	
	
//#config_from_xml:20092006{
	
	/**
	*   @desc:  configure grid structure from XML
	*   @type:  private
	*/
	_launchCommands:function(arr){
		for (var i = 0; i < arr.length; i++){
			var args = new Array();
	
			for (var j = 0; j < arr[i].childNodes.length; j++)
				if (arr[i].childNodes[j].nodeType == 1)
					args[args.length]=arr[i].childNodes[j].firstChild.data;
	
			this[arr[i].getAttribute("command")].apply(this, args);
		}
	},
	
	
	/**
	*   @desc:  configure grid structure from XML
	*   @type:  private
	*/
	_parseHead:function(xmlDoc){
		var hheadCol = dhx4.ajax.xpath("./head", xmlDoc);
	
		if (hheadCol.length){
			var headCol = dhx4.ajax.xpath("./column", hheadCol[0]);
			var asettings = dhx4.ajax.xpath("./settings", hheadCol[0]);
			var awidthmet = "setInitWidths";
			var split = false;
	
			if (asettings[0]){
				for (var s = 0; s < asettings[0].childNodes.length; s++)switch (asettings[0].childNodes[s].tagName){
					case "colwidth":
						if (asettings[0].childNodes[s].firstChild&&asettings[0].childNodes[s].firstChild.data == "%")
							awidthmet="setInitWidthsP";
						break;
	
					case "splitat":
						split=(asettings[0].childNodes[s].firstChild ? asettings[0].childNodes[s].firstChild.data : false);
						break;
				}
			}
			this._launchCommands(dhx4.ajax.xpath("./beforeInit/call", hheadCol[0]));
	
			if (headCol.length > 0){
			    if (this.hdr.rows.length > 0) this.clearAll(true); //drop existing grid here, to prevent loss of initialization parameters
				var sets = [
					[],
					[],
					[],
					[],
					[],
					[],
					[],
					[],
					[]
				];
	
				var attrs = ["", "width", "type", "align", "sort", "color", "format", "hidden", "id"];
				var calls = ["", awidthmet, "setColTypes", "setColAlign", "setColSorting", "setColumnColor", "",
					"", "setColumnIds"];
	
				for (var i = 0; i < headCol.length; i++){
					for (var j = 1; j < attrs.length; j++)sets[j].push(headCol[i].getAttribute(attrs[j]));
					sets[0].push((headCol[i].firstChild
						? headCol[i].firstChild.data
						: "").replace(/^\s*((\s\S)*.+)\s*$/gi, "$1"));
				};
	
				this.setHeader(sets[0]);
				for (var i = 0; i < calls.length; i++)
					if (calls[i])
						this[calls[i]](sets[i].join(this.delim))
	
				for (var i = 0; i < headCol.length; i++){
					if ((this.cellType[i].indexOf('co') == 0)||(this.cellType[i] == "clist")){
						var optCol = dhx4.ajax.xpath("./option", headCol[i]);
	
						if (optCol.length){
							var resAr = new Array();
	
							if (this.cellType[i] == "clist"){
								for (var j = 0;
									j < optCol.length;
									j++)resAr[resAr.length]=optCol[j].firstChild
									? optCol[j].firstChild.data
									: "";
	
								this.registerCList(i, resAr);
							} else {
								var combo = this.getCombo(i);
	
								for (var j = 0;
									j < optCol.length;
									j++)combo.put(optCol[j].getAttribute("value"),
									optCol[j].firstChild
										? optCol[j].firstChild.data
										: "");
							}
						}
					}
	
					else if (sets[6][i])
						if ((this.cellType[i].toLowerCase().indexOf("calendar")!=-1)||(this.fldSort[i] == "date"))
							this.setDateFormat(sets[6][i]);
						else
							this.setNumberFormat(sets[6][i], i);
				}
	
				this.init();
	
	            var param=sets[7].join(this.delim);
	            //preserving state of hidden columns, if not specified directly
				if (this.setColHidden && param.replace(/,/g,"")!="")
					this.setColHidden(param);
	
				if ((split)&&(this.splitAt))
					this.splitAt(split);
			}
			this._launchCommands(dhx4.ajax.xpath("./afterInit/call", hheadCol[0]));
		}
		//global(grid) user data
		var gudCol = dhx4.ajax.xpath("//rows/userdata", xmlDoc);
	
		if (gudCol.length > 0){
			
			if (!this.UserData["gridglobaluserdata"])
				this.UserData["gridglobaluserdata"]=new Hashtable();
	
			for (var j = 0; j < gudCol.length; j++){
				var u_record = "";
				for (var xj=0; xj < gudCol[j].childNodes.length; xj++)
					u_record += gudCol[j].childNodes[xj].nodeValue;
				this.UserData["gridglobaluserdata"].put(gudCol[j].getAttribute("name"),u_record);
			}
		}
	},
	
	
//#}
	
	
	/**
	*   @desc: get list of Ids of all rows with checked exCell in specified column
	*   @type: public
	*   @param: col_ind - column index
	*   @topic: 5
	*/
	getCheckedRows:function(col_ind){
		var d = new Array();
		this.forEachRowA(function(id){
			var cell = this.cells(id, col_ind);
			if (cell.changeState && cell.getValue() != 0)
				d.push(id);
		},true);
		return d.join(",");
	},
	/**
	*   @desc: check all checkboxes in grid
	*   @type: public
	*   @param: col_ind - column index
	*   @topic: 5
	*/	
	checkAll:function(){var mode=arguments.length?arguments[0]:1;
		 for (var cInd=0;cInd<this.getColumnsNum();cInd++){if(this.getColType(cInd)=="ch")this.setCheckedRows(cInd,mode)}},
	/**
	*   @desc: uncheck all checkboxes in grid
	*   @type: public
	*   @param: col_ind - column index
	*   @topic: 5
	*/	
	uncheckAll:function(){ this.checkAll(0); },
	/**
	*   @desc: set value for all checkboxes in specified column
	*   @type: public
	*   @param: col_ind - column index
	*   @topic: 5
	*/	
	setCheckedRows:function(cInd,v){this.forEachRowA(function(id){if(this.cells(id,cInd).isCheckbox())this.cells(id,cInd).setValue(v)})},
//#tooltips:06042008{	
	/**
	*   @desc:  grid body onmouseover function
	*   @type:  private
	*/
	_drawTooltip:function(e){
		var c = this.grid.getFirstParentOfType(e ? e.target : event.srcElement, 'TD');
	
		if (!c || ((this.grid.editor)&&(this.grid.editor.cell == c)))
			return true;
	
		var r = c.parentNode;
	
		if (!r.idd||r.idd == "__filler__")
			return;
		var el = (e ? e.target : event.srcElement);
	
		if (r.idd == window.unknown)
			return true;
	
		if (!this.grid.callEvent("onMouseOver", [
			r.idd,
			c._cellIndex,
			(e||window.event)
		]))
			return true;
	
		if ((this.grid._enbTts)&&(!this.grid._enbTts[c._cellIndex])){
			if (el.title)
				el.title='';
			return true;
		}
	
		if (c._cellIndex >= this.grid._cCount)
			return;
		var ced = this.grid.cells3(r, c._cellIndex);
		if (!ced || !ced.cell || !ced.cell._attrs) return; // fix for public release
	
		if (el._title)
			ced.cell.title="";
	
		if (!ced.cell._attrs['title'])
			el._title=true;
	
		if (ced)
			el.title=ced.cell._attrs['title']
				||(ced.getTitle
					? ced.getTitle()
					: (ced.getValue()||"").toString().replace(/<[^>]*>/gi, ""));
	
		return true;
	},
//#}	
	/**
	*   @desc:  can be used for setting correction for cell padding, while calculation setSizes
	*   @type:  private
	*/
	enableCellWidthCorrection:function(size){
		if (_isFF)
			this._wcorr=parseInt(size);
	},
	
	
	/**
	*	@desc: gets a list of all row ids in grid
	*	@param: separator - delimiter to use in list
	*	@returns: list of all row ids in grid
	*	@type: public
	*	@topic: 2,7
	*/
	getAllRowIds:function(separator){
		var ar = [];
	
		for (var i = 0; i < this.rowsBuffer.length; i++)
			if (this.rowsBuffer[i])
				ar.push(this.rowsBuffer[i].idd);
	
		return ar.join(separator||this.delim)
	},
	getAllItemIds:function(){
		return this.getAllRowIds();
	},
	
//#__pro_feature:21092006{	
//#colspan:20092006{
	
	/**
	*   @desc: dynamicaly set colspan in row starting from specified column index
	*   @param: row_id - row id
	*   @param: col_id - index of column
	*   @param: colspan - size of colspan
	*   @type: public
	*   @edition: Professional
	*   @topic: 2,9
	*/
	setColspan:function(row_id, col_ind, colspan){
		if (!this._ecspn)
			return;
	
		var r = this.getRowById(row_id);
	
		if ((r._childIndexes)&&(r.childNodes[r._childIndexes[col_ind]])){
			var j = r._childIndexes[col_ind];
			var n = r.childNodes[j];
			var m = n.colSpan;
			n.colSpan=1;
	
			if ((m)&&(m != 1))
				for (var i = 1; i < m; i++){
					var c = document.createElement("TD");
	
					if (n.nextSibling)
						r.insertBefore(c, n.nextSibling);
					else
						r.appendChild(c);
					r._childIndexes[col_ind+i]=j+i;
					c._cellIndex=col_ind+i;
					c.style.textAlign=this.cellAlign[i];
					c.style.verticalAlign=this.cellVAlign[i];
					n=c;
					this.cells3(r, col_ind+i).setValue("");
				}
	
			for (var z = col_ind*1+1*m; z < r._childIndexes.length; z++){
				r._childIndexes[z]+=(m-1)*1;
			}
		}
	
		if ((colspan)&&(colspan > 1)){
			if (r._childIndexes)
				var j = r._childIndexes[col_ind];
			else {
				var j = col_ind;
				r._childIndexes=new Array();
	
				for (var z = 0; z < r.childNodes.length; z++)r._childIndexes[z]=z;
			}
	
			r.childNodes[j].colSpan=colspan;
	
			for (var z = 1; z < colspan; z++){
				r._childIndexes[r.childNodes[j+1]._cellIndex]=j;
				r.removeChild(r.childNodes[j+1]);
			}
	
			var c1 = r.childNodes[r._childIndexes[col_ind]]._cellIndex;
	
			for (var z = c1*1+1*colspan; z < r._childIndexes.length; z++)r._childIndexes[z]-=(colspan-1);
		}
	},
	
//#}
//#}
	
	/**
	*   @desc: prevent caching in IE  by adding random values to URL string
	*   @param: mode - enable/disable random values in URLs ( disabled by default )
	*   @type: public
	*   @topic: 2,9
	*/
	preventIECaching:function(mode){
		dhx4.ajax.cache = !mode;
	},
	enableColumnAutoSize:function(mode){
		this._eCAS=dhx4.s2b(mode);
	},
	/**
	*   @desc: called when header was dbllicked
	*   @type: private
	*   @topic: 1,2
	*/
	_onHeaderDblClick:function(e){
		var that = this.grid;
		var el = that.getFirstParentOfType(_isIE ? event.srcElement : e.target, "TD");
	
		if (!that._eCAS)
			return false;
		that.adjustColumnSize(el._cellIndexS)
	},
	
	/**
	*   @desc: autosize column  to max content size
	*   @param: cInd - index of column
	*   @type:  public
	*/
	adjustColumnSize:function(cInd, complex){
		if (this._hrrar && this._hrrar[cInd]) return;
		this._notresize=true;
		var m = 0;
		this._setColumnSizeR(cInd, 20);
	
		for (var j = 1; j < this.hdr.rows.length; j++){
			var a = this.hdr.rows[j];
			a=a.childNodes[(a._childIndexes) ? a._childIndexes[cInd] : cInd];
	
			if ((a)&&((!a.colSpan)||(a.colSpan < 2)) && a._cellIndex==cInd){
				if ((a.childNodes[0])&&(a.childNodes[0].className == "hdrcell"))
					a=a.childNodes[0];
				m=Math.max(m, a.scrollWidth);
			}
		}
	
		var l = this.obj.rows.length;
		var z = 0;
		var tree = this.cellType._dhx_find("tree");

		for (var i = 1; i < l; i++){
			var row = this.obj.rows[i];
			if (!this.rowsAr[row.idd]) continue;
			
			if (row._childIndexes&&row._childIndexes[cInd] != cInd || !row.childNodes[cInd])
				continue;
	
			z= ( row.childNodes[cInd].innerText || row.childNodes[cInd].textContent || "" ).length*this.fontWidth;
			if (this._h2 && cInd == tree)
				z += this._h2.get[row.idd].level * 22;
			
			

			if (z > m)
				m=z;
		}
		m+=20+(complex||0);
	
		this._setColumnSizeR(cInd, m);
		this._notresize=false;
		this.setSizes();
	},
	
//#header_footer:06042008{
	/**
	*   @desc: remove header line from grid (opposite to attachHeader)
	*   @param: index - index of row to be removed ( zero based )
	*	@param: hdr - header object (optional)
	*   @type:  public
	*/
	detachHeader:function(index, hdr){
		hdr=hdr||this.hdr;
		var row = hdr.rows[index+1];
	
		if (row)
			row.parentNode.removeChild(row);
		this.setSizes();
	},
	
	/**
	*   @desc: remove footer line from grid (opposite to attachFooter)
	*   @param: values - array of header titles
	*   @type:  public
	*/
	detachFooter:function(index){
		this.detachHeader(index, this.ftr);
	},
	
	/**
	*   @desc: attach additional line to header
	*   @param: values - array of header titles
	*   @param: style - array of styles, optional
	*	@param: _type - reserved
	*   @type:  public
	*/
	attachHeader:function(values, style, _type){
		if (typeof (values) == "string")
			values=this._eSplit(values);
	
		if (typeof (style) == "string")
			style=style.split(this.delim);
		_type=_type||"_aHead";
	
		if (this.hdr.rows.length){
			if (values)
				this._createHRow([
					values,
					style
				], this[(_type == "_aHead") ? "hdr" : "ftr"]);
	
			else if (this[_type])
				for (var i = 0; i < this[_type].length; i++)this.attachHeader.apply(this, this[_type][i]);
		} else {
			if (!this[_type])
				this[_type]=new Array();
			this[_type][this[_type].length]=[
				values,
				style,
				_type
			];
		}
	},
	/**
	*	@desc:
	*	@type: private
	*/
	_createHRow:function(data, parent){
		if (!parent){
			if (this.entBox.style.position!="absolute")
				this.entBox.style.position="relative";
			var z = document.createElement("DIV");
			z.className="c_ftr".substr(2);
			this.entBox.appendChild(z);
			var t = document.createElement("TABLE");
			t.cellPadding=t.cellSpacing=0;
	
			if (!_isIE || _isIE == 8){
				t.width="100%";
				t.style.paddingRight="20px";
			}
			t.style.marginRight="20px";
			t.style.tableLayout="fixed";
	
			z.appendChild(t);
			t.appendChild(document.createElement("TBODY"));
			this.ftr=parent=t;
	
			var hdrRow = t.insertRow(0);
			var thl = ((this.hdrLabels.length <= 1) ? data[0].length : this.hdrLabels.length);
	
			for (var i = 0; i < thl; i++){
				hdrRow.appendChild(document.createElement("TH"));
				hdrRow.childNodes[i]._cellIndex=i;
			}
	
			if (_isIE && _isIE<8)
				hdrRow.style.position="absolute";
			else
				hdrRow.style.height='auto';
		}
		var st1 = data[1];
		var z = document.createElement("TR");
		parent.rows[0].parentNode.appendChild(z);
	
		for (var i = 0; i < data[0].length; i++){
			if (data[0][i] == "#cspan"){
				var pz = z.cells[z.cells.length-1];
				pz.colSpan=(pz.colSpan||1)+1;
				continue;
			}
	
			if ((data[0][i] == "#rspan")&&(parent.rows.length > 1)){
				var pind = parent.rows.length-2;
				var found = false;
				var pz = null;
	
				while (!found){
					var pz = parent.rows[pind];
	
					for (var j = 0; j < pz.cells.length; j++)
						if (pz.cells[j]._cellIndex == i){
							found=j+1;
							break;
						}
					pind--;
				}
	
				pz=pz.cells[found-1];
				pz.rowSpan=(pz.rowSpan||1)+1;
				continue;
			//            data[0][i]="";
			}
	
			var w = document.createElement("TD");
			w._cellIndex=w._cellIndexS=i;
			if (this._hrrar && this._hrrar[i] && !_isIE)
				w.style.display='none';

			if (typeof data[0][i] == "object")
				w.appendChild(data[0][i]);
			else {
				if (this.forceDivInHeader)
					w.innerHTML="<div class='hdrcell'>"+(data[0][i]||"&nbsp;")+"</div>";
				else
					w.innerHTML=(data[0][i]||"&nbsp;");
		
				if ((data[0][i]||"").indexOf("#") != -1){
					var t = data[0][i].match(/(^|{)#([^}]+)(}|$)/);
		
					if (t){
						var tn = "_in_header_"+t[2];
		
						if (this[tn])
							this[tn]((this.forceDivInHeader ? w.firstChild : w), i, data[0][i].split(t[0]));
					}
				}
			}
			if (st1)
				w.style.cssText=st1[i];
	
			z.appendChild(w);
		}
		var self = parent;
	
		if (_isKHTML){
			if (parent._kTimer)
				window.clearTimeout(parent._kTimer);
			parent._kTimer=window.setTimeout(function(){
				parent.rows[1].style.display='none';
				window.setTimeout(function(){
					parent.rows[1].style.display='';
				}, 1);
			}, 500);
		}
	},
//#__pro_feature:21092006{	
	/**
	*   @desc: attach additional line to footer
	*   @param: values - array of header titles
	*   @param: style - array of styles, optional
	*   @edition: Professional
	*   @type:  public
	*/
	attachFooter:function(values, style){
		this.attachHeader(values, style, "_aFoot");
	},
//#}
//#}
//#__pro_feature:21092006{
//#dyn_cell_types:04062008{
	/**
	*   @desc: set excell type for cell in question
	*   @param: rowId - row ID
	*   @param: cellIndex - cell index
	*   @param: type - type of excell (code like "ed", "txt", "ch" etc.)
	*   @edition: Professional
	*   @type:  public
	*/
	setCellExcellType:function(rowId, cellIndex, type){
		this.changeCellType(this.getRowById(rowId), cellIndex, type);
	},
	/**
	*	@desc: 
	*	@type: private
	*/
	changeCellType:function(r, ind, type){
		type=type||this.cellType[ind];
		var z = this.cells3(r, ind);
		var v = z.getValue();
		z.cell._cellType=type;
		var z = this.cells3(r, ind);
		z.setValue(v);
	},
	/**
	*   @desc: set excell type for all cells in specified row
	*   @param: rowId - row ID
	*   @param: type - type of excell
	*   @edition: Professional
	*   @type:  public
	*/
	setRowExcellType:function(rowId, type){
		var z = this.rowsAr[rowId];
	
		for (var i = 0; i < z.childNodes.length; i++)this.changeCellType(z, i, type);
	},
	/**
	*   @desc: set excell type for all cells in specified column
	*   @param: colIndex - column index
	*   @param: type - type of excell
	*   @edition: Professional
	*   @type:  public
	*/
	setColumnExcellType:function(colIndex, type){
		for (var i = 0; i < this.rowsBuffer.length; i++)
			if (this.rowsBuffer[i] && this.rowsBuffer[i].tagName=="TR")
				this.changeCellType(this.rowsBuffer[i], colIndex, type);
		if (this.cellType[colIndex]=="math")
			this._strangeParams[i]=type;
		else
			this.cellType[colIndex]=type;
	},
	
//#}
//#}

	/**
	*   @desc: execute code for each row in a grid
	*   @param: custom_code - function which get row id as incomming argument
	*   @type:  public
	*/
	forEachRow:function(custom_code){
		for (var a in this.rowsAr)
			if (this.rowsAr[a]&&this.rowsAr[a].idd)
				custom_code.apply(this, [this.rowsAr[a].idd]);
	},
	forEachRowA:function(custom_code){
		for (var a =0; a<this.rowsBuffer.length; a++){
			if (this.rowsBuffer[a])
				custom_code.call(this, this.render_row(a).idd);
		}
	},
	/**
	*   @desc: execute code for each cell in a row
	*   @param: rowId - id of row where cell must be itterated
	*   @param: custom_code - function which get eXcell object as incomming argument
	*   @type:  public
	*/
	forEachCell:function(rowId, custom_code){
		var z = this.getRowById(rowId);
	
		if (!z)
			return;
	
		for (var i = 0; i < this._cCount; i++) custom_code(this.cells3(z, i),i);
	},
	/**
	*   @desc: changes grid's container size on the fly to fit total width of grid columns
	*   @param: mode  - truse/false - enable / disable
	*   @param: max_limit  - max allowed width, not limited by default
	*   @param: min_limit  - min allowed width, not limited by default
	*   @type:  public
	*/
	enableAutoWidth:function(mode, max_limit, min_limit){
		this._awdth=[
			dhx4.s2b(mode),
			parseInt(max_limit||99999),
			parseInt(min_limit||0)
		];
		if (arguments.length == 1)
			this.objBox.style.overflowX=mode?"hidden":"auto";
	},
//#update_from_xml:06042008{	
	/**
	*   @desc: refresh grid from XML ( doesnt work for buffering, tree grid or rows in smart rendering mode )
	*   @param: insert_new - insert new items
	*   @param: del_missed - delete missed rows
	*   @param: afterCall - function, will be executed after refresh completted
	*   @type:  public
	*/
	
	updateFromXML:function(url, insert_new, del_missed, afterCall){
		if (typeof insert_new == "undefined")
			insert_new=true;
		this._refresh_mode=[
			true,
			insert_new,
			del_missed
		];
		this.load(url,afterCall)
	},
	_refreshFromXML:function(xml){
		if (this._f_rowsBuffer) this.filterBy(0,"");
		reset = false;
		if (window.eXcell_tree){
			eXcell_tree.prototype.setValueX=eXcell_tree.prototype.setValue;
			eXcell_tree.prototype.setValue=function(content){
				var r=this.grid._h2.get[this.cell.parentNode.idd]
				if (r && this.cell.parentNode.valTag){
					this.setLabel(content);
				} else
					this.setValueX(content);
			};
		}
	
		var tree = this.cellType._dhx_find("tree");
		var top = dhx4.ajax.xmltop("rows", xml);
		var pid = top.getAttribute("parent")||0;
	
		var del = {
		};
	
		if (this._refresh_mode[2]){
			if (tree != -1)
				this._h2.forEachChild(pid, function(obj){
					del[obj.id]=true;
				}, this);
			else
				this.forEachRow(function(id){
					del[id]=true;
				});
		}
	
		var rows = dhx4.ajax.xpath("//row", top);
	
		for (var i = 0; i < rows.length; i++){
			var row = rows[i];
			var id = row.getAttribute("id");
			del[id]=false;
			var pid = row.parentNode.getAttribute("id")||pid;
			if (this.rowsAr[id] && this.rowsAr[id].tagName!="TR"){
				if (this._h2)
					this._h2.get[id].buff.data=row;
				else
					this.rowsBuffer[this.getRowIndex(id)].data=row;
				this.rowsAr[id]=row;
			} else if (this.rowsAr[id]){
					this._process_xml_row(this.rowsAr[id], row, -1);
					this._postRowProcessing(this.rowsAr[id],true)
					if (this._fake && this._fake.rowsAr[id])
						this._fake._process_xml_row(this._fake.rowsAr[id], row, -1);
				} else if (this._refresh_mode[1]){
					var dadd={
						idd: id,
						data: row,
						_parser: this._process_xml_row,
						_locator: this._get_xml_data
					};
					
					var render_index = this.rowsBuffer.length;
					if (this._refresh_mode[1]=="top"){
						this.rowsBuffer.unshift(dadd);
						render_index = 0;
					} else
						this.rowsBuffer.push(dadd);
						
					if (this._h2){ 
						reset=true;
						(this._h2.add(id,(row.parentNode.getAttribute("id")||row.parentNode.getAttribute("parent")))).buff=this.rowsBuffer[this.rowsBuffer.length-1];
					} else if (this._srnd)
						reset = true;
						
					this.rowsAr[id]=row;
					row=this.render_row(render_index);
					this._insertRowAt(row,render_index?-1:0)
				}
		}
				
		if (this._refresh_mode[2])
			for (id in del){
				if (del[id]&&this.rowsAr[id])
					this.deleteRow(id);
			}
	
		this._refresh_mode=null;
		if (window.eXcell_tree)
			eXcell_tree.prototype.setValue=eXcell_tree.prototype.setValueX;
			
		if (reset){
			if (this._h2) 
				this._renderSort();
			else
				this.render_dataset();
		}

		if (this._f_rowsBuffer) {
			this._f_rowsBuffer = null;
			this.filterByAll();
		}
	},
//#}	
//#co_excell:06042008{
	/**
	*   @desc: get combobox specific for cell in question
	*   @param: id - row id
	*   @param: ind  - column index
	*   @type:  public
	*/
	getCustomCombo:function(id, ind){
		var cell = this.cells(id, ind).cell;
	
		if (!cell._combo)
			cell._combo=new dhtmlXGridComboObject();
		return cell._combo;
	},
//#}
	/**
	*   @desc: set tab order of columns
	*   @param: order - list of tab indexes (default delimiter is ",")
	*   @type:  public
	*/
	setTabOrder:function(order){
		var t = order.split(this.delim);
		this._tabOrder=[];
		var max=this._cCount||order.length;
	
		for (var i = 0; i < max; i++)t[i]={
			c: parseInt(t[i]),
			ind: i
			};
		t.sort(function(a, b){
			return (a.c > b.c ? 1 : -1);
		});
	
		for (var i = 0; i < max; i++)
			if (!t[i+1]||( typeof t[i].c == "undefined"))
				this._tabOrder[t[i].ind]=(t[0].ind+1)*-1;
			else
				this._tabOrder[t[i].ind]=t[i+1].ind;
	},
	
	i18n:{
		loading: "��������",
		decimal_separator:".",
		group_separator:" "
	},
	
	//key_ctrl_shift
	_key_events:{
		k13_1_0: function(){
			var rowInd = this.rowsCol._dhx_find(this.row)
			this.selectCell(this.rowsCol[rowInd+1], this.cell._cellIndex, true);
		},
		k13_0_1: function(){
			var rowInd = this.rowsCol._dhx_find(this.row)
			this.selectCell(this.rowsCol[rowInd-1], this.cell._cellIndex, true);
		},
		k13_0_0: function(){
			this.editStop();
			this.callEvent("onEnter", [
				(this.row ? this.row.idd : null),
				(this.cell ? this.cell._cellIndex : null)
			]);
			this._still_active=true;
		},
		k9_0_0: function(){
			this.editStop();
			if (!this.callEvent("onTab",[true])) return true;
			var z = this._getNextCell(null, 1);
		
			if (z){
				this.selectCell(z.parentNode, z._cellIndex, (this.row != z.parentNode), false, true);
				this._still_active=true;
			}
		},
		k9_0_1: function(){
			this.editStop();
			if (!this.callEvent("onTab",[false])) return false;
			var z = this._getNextCell(null, -1);
	
			if (z){
				this.selectCell(z.parentNode, z._cellIndex, (this.row != z.parentNode), false, true);
				this._still_active=true;
			}
		},
		k113_0_0: function(){
			if (this._f2kE)
				this.editCell();
		},
		k32_0_0: function(){
			var c = this.cells4(this.cell);
	
			if (!c.changeState||(c.changeState() === false))
				return false;
		},
		k27_0_0: function(){
			this.editStop(true);
		},
		k33_0_0: function(){
			if (this.pagingOn)
				this.changePage(this.currentPage-1);
			else
				this.scrollPage(-1);
		},
		k34_0_0: function(){
			if (this.pagingOn)
				this.changePage(this.currentPage+1);
			else
				this.scrollPage(1);
		},
		k37_0_0: function(){
			if (!this.editor&&this.isTreeGrid())
				this.collapseKids(this.row)
			else
				return false;
		},
		k39_0_0: function(){
			if (!this.editor&&this.isTreeGrid())
				this.expandKids(this.row)
			else
				return false;
		},
		k40_0_0: function(){
			var master = this._realfake?this._fake:this;
			if (this.editor&&this.editor.combo)
				this.editor.shiftNext();
			else {
				if (!this.row.idd) return;
				var rowInd = Math.max((master._r_select||0),this.getRowIndex(this.row.idd));
				var row = this._nextRow(rowInd, 1);
				if (row){
					master._r_select=null;
					this.selectCell(row, this.cell._cellIndex, true);
					if (master.pagingOn) master.showRow(row.idd);
				} else {
					if (!this.callEvent("onLastRow", [])) return false;
					this._key_events.k34_0_0.apply(this, []);
					if (this.pagingOn && this.rowsCol[rowInd+1])
						this.selectCell(rowInd+1, 0, true);
				}
			}
			this._still_active=true;
		},
		k38_0_0: function(){
			var master = this._realfake?this._fake:this;
			if (this.editor&&this.editor.combo)
				this.editor.shiftPrev();
			else {
				if (!this.row.idd) return;
				var rowInd = this.getRowIndex(this.row.idd)+1;
				if (rowInd != -1 && (!this.pagingOn || (rowInd!=1))){
					var nrow = this._nextRow(rowInd-1, -1);
					this.selectCell(nrow, this.cell._cellIndex, true);
					if (master.pagingOn && nrow) master.showRow(nrow.idd);
				} else {
					this._key_events.k33_0_0.apply(this, []);
					/*
					if (this.pagingOn && this.rowsCol[this.rowsBufferOutSize-1])
						this.selectCell(this.rowsBufferOutSize-1, 0, true);
						*/
				}
			}
			this._still_active=true;
		}
	},
	
	//(c)dhtmlx ltd. www.dhtmlx.com
	
	_build_master_row:function(){
		var t = document.createElement("DIV");
		var html = ["<table><tr>"];
	
		for (var i = 0; i < this._cCount; i++)html.push("<td></td>");
		html.push("</tr></table>");
		t.innerHTML=html.join("");
		this._master_row=t.firstChild.rows[0];
	},
	
	_prepareRow:function(new_id){ /*TODO: hidden columns */
		if (!this._master_row)
			this._build_master_row();
	
		var r = this._master_row.cloneNode(true);
	
		for (var i = 0; i < r.childNodes.length; i++){
			r.childNodes[i]._cellIndex=i;
	        if (this._enbCid) r.childNodes[i].id="c_"+new_id+"_"+i;
			if (this.dragAndDropOff)
				this.dragger.addDraggableItem(r.childNodes[i], this);
		}
		r.idd=new_id;
		r.grid=this;
	
		return r;
	},
	
//#non_xml_data:06042008{
	_process_jsarray_row:function(r, data){
		r._attrs={
		};
	
		for (var j = 0; j < r.childNodes.length; j++)r.childNodes[j]._attrs={
		};
	
		this._fillRow(r, (this._c_order ? this._swapColumns(data) : data));
		return r;
	},
	_get_jsarray_data:function(data, ind){
		return data[ind];
	},
	_process_json_row:function(r, data){
		data = this._c_order ? this._swapColumns(data.data) : data.data;
		return this._process_some_row(r, data);
	},
	_process_some_row:function(r,data){
		r._attrs={};
	
		for (var j = 0; j < r.childNodes.length; j++)
			r.childNodes[j]._attrs={};
	
		this._fillRow(r, data);
		return r;
	},
	_get_json_data:function(data, ind){
		return data.data[ind];
	},


	_process_js_row:function(r, data){
		var arr = [];
		for (var i=0; i<this.columnIds.length; i++){
			arr[i] = data[this.columnIds[i]];
			if (!arr[i] && arr[i]!==0)
				arr[i]="";
		}
		this._process_some_row(r,arr);

		r._attrs = data;
		return r;
	},
	_get_js_data:function(data, ind){
		return data[this.columnIds[ind]];
	},
	_process_csv_row:function(r, data){
		r._attrs={
		};
	
		for (var j = 0; j < r.childNodes.length; j++)r.childNodes[j]._attrs={
		};
	
		this._fillRow(r, (this._c_order ? this._swapColumns(data.split(this.csv.cell)) : data.split(this.csv.cell)));
		return r;
	},
	_get_csv_data:function(data, ind){
		return data.split(this.csv.cell)[ind];
	},
//#}
	_process_store_row:function(row, data){
		var result = [];
		for (var i = 0; i < this.columnIds.length; i++)
			result[i] = data[this.columnIds[i]];
		for (var j = 0; j < row.childNodes.length; j++)
		row.childNodes[j]._attrs={};

		row._attrs = data;
		this._fillRow(row, result);
	},	
//#xml_data:06042008{
	_process_xml_row:function(r, xml){		
		var cellsCol = dhx4.ajax.xpath(this.xml.cell, xml);
		var strAr = [];
	
		r._attrs=this._xml_attrs(xml);
	
		//load userdata
		if (this._ud_enabled){
			var udCol = dhx4.ajax.xpath("./userdata", xml);
	
			for (var i = udCol.length-1; i >= 0; i--){
				var u_record = "";
				for (var j=0; j < udCol[i].childNodes.length; j++)
					u_record += udCol[i].childNodes[j].nodeValue;

				this.setUserData(r.idd,udCol[i].getAttribute("name"), u_record);
			}
		}
	
		//load cell data
		for (var j = 0; j < cellsCol.length; j++){
			var cellVal = cellsCol[this._c_order?this._c_order[j]:j];
			if (!cellVal) continue;
			var cind = r._childIndexes?r._childIndexes[j]:j;
			var exc = cellVal.getAttribute("type");
	
			if (r.childNodes[cind]){
				if (exc)
					r.childNodes[cind]._cellType=exc;
				r.childNodes[cind]._attrs=this._xml_attrs(cellVal);
			}
	
			if (!cellVal.getAttribute("xmlcontent")){
				if (cellVal.firstChild)
				cellVal=cellVal.firstChild.data;
	
			else
				cellVal="";
			}
	
			strAr.push(cellVal);
		}
	
		for (j < cellsCol.length; j < r.childNodes.length; j++)r.childNodes[j]._attrs={
		};
	
		//treegrid
		if (r.parentNode&&r.parentNode.tagName == "row")
			r._attrs["parent"]=r.parentNode.getAttribute("idd");
	
		//back to common code
		this._fillRow(r, strAr);
		return r;
	},
	_get_xml_data:function(data, ind){ 
		data=data.firstChild;
	
		while (true){
			if (!data)
				return "";
	
			if (data.tagName == "cell")
				ind--;
	
			if (ind < 0)
				break;
			data=data.nextSibling;
		}
		return (data.firstChild ? data.firstChild.data : "");
	},
//#}	
	_fillRow:function(r, text){
		if (this.editor && this.editor.parentNode && this.editor.parentNode.idd == r.idd)
			this.editStop();
	
		for (var i = 0; i < r.childNodes.length; i++){
			if ((i < text.length)||(this.defVal[i])){
				
			    var ii=r.childNodes[i]._cellIndex;
			    var val = text[ii];
				var aeditor = this.cells4(r.childNodes[i]);
	
				if ((this.defVal[ii])&&((val == "")||( typeof (val) == "undefined")))
					val=this.defVal[ii];

				if (aeditor) aeditor.setValue(val)
			} else {
				r.childNodes[i].innerHTML="&nbsp;";
				r.childNodes[i]._clearCell=true;
			}
		}
	
		return r;
	},
	
	_postRowProcessing:function(r,donly){ 
		if (r._attrs["class"])
			r._css=r.className=r._attrs["class"];
	
		if (r._attrs.locked)
			r._locked=true;
	
		if (r._attrs.bgColor)
			r.bgColor=r._attrs.bgColor;
		var cor=0;	
		
		for (var i = 0; i < r.childNodes.length; i++){
			var c=r.childNodes[i];
			var ii=c._cellIndex;
			//style attribute
			var s = c._attrs.style||r._attrs.style;
	
			if (s)
				c.style.cssText+=";"+s;
	
			if (c._attrs["class"])
				c.className=c._attrs["class"];
			s=c._attrs.align||this.cellAlign[ii];

	
			if (s)
				c.align=s;
			c.vAlign=c._attrs.valign||this.cellVAlign[ii];
			var color = c._attrs.bgColor||this.columnColor[ii];

	
			if (color)
				c.bgColor=color;
	
			if (c._attrs["colspan"] && !donly){ 
				this.setColspan(r.idd, i+cor, c._attrs["colspan"]);
				//i+=(c._attrs["colspan"]-1);
				cor+=(c._attrs["colspan"]-1);
			}
	
			if (this._hrrar&&this._hrrar[ii]&&!donly){
				c.style.display="none";
			}
		};
		this.callEvent("onRowCreated", [
			r.idd,
			r,
			null
		]);
	},
	/**
	*   @desc: load data from external file ( xml, json, jsarray, csv )
	*   @param: url - url to external file
	*   @param: call - after loading callback function, optional, can be ommited
	*   @param: type - type of data (xml,csv,json,jsarray) , optional, xml by default
	*   @type:  public
	*/			
	load:function(url, call, type){
		this.callEvent("onXLS", [this]);
		if (arguments.length == 2 && typeof call != "function"){
			type=call;
			call=null;
		}
		type=type||"xml";
	
		if (!this.xmlFileUrl)
			this.xmlFileUrl=url;
		this._data_type=type;

		this.xmlLoader = this.doLoadDetails;

		var that = this;
		this.xmlLoader = function(xml){
			if (!that.callEvent) return;
			that["_process_"+type](xml.xmlDoc);
			if (!that._contextCallTimer)
				that.callEvent("onXLE", [that,0,0,xml.xmlDoc]);
	
			if (call){
				call();
				call=null;
			}
		};
		dhx4.ajax.get(url, this.xmlLoader);
	},
//#__pro_feature:21092006{		
	loadXMLString:function(str, afterCall){
		this.parse( { responseXML: dhx4.ajax.parse(str) }, afterCall, "xml")
	},
//#}
	loadXML:function(url, afterCall){
		this.load(url, afterCall, "xml")
	},
	/**
	*   @desc: load data from local datasource ( xml string, csv string, xml island, xml object, json objecs , javascript array )
	*   @param: data - string or object
	*   @param: type - data type (xml,json,jsarray,csv), optional, data threated as xml by default
	*   @type:  public
	*/			
	parse:function(data, call, type){
		if (arguments.length == 2 && typeof call != "function"){
			type=call;
			call=null;
		}
		type=type||"xml";
		this._data_type=type;

		if (type == "xml" && typeof data == "string")
			data = { responseXML: dhx4.ajax.parse(data) };

		this["_process_"+type](data);
		if (!this._contextCallTimer)
			this.callEvent("onXLE", [this,0,0,data]);
		if (call)
			call();
	},
	
	xml:{
		top: "rows",
		row: "./row",
		cell: "./cell",
		s_row: "row",
		s_cell: "cell",
		row_attrs: [],
		cell_attrs: []
	},
	
	csv:{
		row: "\n",
		cell: ","
	},
	
	_xml_attrs:function(node){
		var data = {
		};
	
		if (node.attributes.length){
			for (var i = 0; i < node.attributes.length; i++)data[node.attributes[i].name]=node.attributes[i].value;
		}
	
		return data;
	},
//#xml_data:06042008{	
	_process_xml:function(xhr){
		if (this._refresh_mode) return this._refreshFromXML(xhr);
		this._parsing=true;
		var top = dhx4.ajax.xmltop(this.xml.top, xhr);
		if (top.tagName!=this.xml.top) return;
		var skey = top.getAttribute("dhx_security");
		if (skey)
			dhtmlx.security_key = skey;

		//#config_from_xml:20092006{
		this._parseHead(top);
		//#}
		var rows = dhx4.ajax.xpath(this.xml.row, top)
		var cr = parseInt(top.getAttribute("pos")||0);
		var total = parseInt(top.getAttribute("total_count")||0);
		var total = Math.min(total, 32000000/this._srdh);
	
		var reset = false;
		if (total && total!=this.rowsBuffer.length){
			if (!this.rowsBuffer[total-1]){
				if (this.rowsBuffer.length)
					reset=true;
			this.rowsBuffer[total-1]=null;
			} 
			if (total<this.rowsBuffer.length){
				this.rowsBuffer.splice(total, this.rowsBuffer.length - total);
				reset = true;
			}
		}
		
			
		if (this.isTreeGrid())
			return this._process_tree_xml(top);
			 
	
		for (var i = 0; i < rows.length; i++){
			if (this.rowsBuffer[i+cr])
				continue;
			var id = rows[i].getAttribute("id")||(i+cr+1);
			this.rowsBuffer[i+cr]={
				idd: id,
				data: rows[i],
				_parser: this._process_xml_row,
				_locator: this._get_xml_data
				};
	
			this.rowsAr[id]=rows[i];
		//this.callEvent("onRowCreated",[r.idd]);
		}

		this.callEvent("onDataReady", []);
		if (reset && this._srnd){
			var h = this.objBox.scrollTop;
			this._reset_view();
			this.objBox.scrollTop = h;
		} else {
		this.render_dataset();
		}
			
		this._parsing=false;
	},
//#}
//#non_xml_data:06042008{	
	_process_jsarray:function(data){
		this._parsing=true;
		data = data.responseText || data;
		if (typeof data == "string"){
			eval("dhtmlx.temp="+data+";");
			data = dhtmlx.temp;
		}
	
		for (var i = 0; i < data.length; i++){
			var id = i+1;
			this.rowsBuffer.push({
				idd: id,
				data: data[i],
				_parser: this._process_jsarray_row,
				_locator: this._get_jsarray_data
				});
	
			this.rowsAr[id]=data[i];
		//this.callEvent("onRowCreated",[r.idd]);
		}
		this.render_dataset();
		this._parsing=false;
	},
	
	_process_csv:function(data){
		this._parsing=true;
		data=data.responseText || data;
		data=data.replace(/\r/g,"");
		data=data.split(this.csv.row);
	    if (this._csvHdr){
   			this.clearAll();
   			var thead=data.splice(0,1)[0].split(this.csv.cell);
   			if (!this._csvAID) thead.splice(0,1);
	   		this.setHeader(thead.join(this.delim));
	   		this.init();
   		}
	
		for (var i = 0; i < data.length; i++){
			if (!data[i] && i==data.length-1) continue; //skip new line at end of text
			if (this._csvAID){
				var id = i+1;
				this.rowsBuffer.push({
					idd: id,
					data: data[i],
					_parser: this._process_csv_row,
					_locator: this._get_csv_data
					});
			} else {
				var temp = data[i].split(this.csv.cell);
				var id = temp.splice(0,1)[0];
				this.rowsBuffer.push({
					idd: id,
					data: temp,
					_parser: this._process_jsarray_row,
					_locator: this._get_jsarray_data
					});
			}
			
	
			this.rowsAr[id]=data[i];
		//this.callEvent("onRowCreated",[r.idd]);
		}
		this.render_dataset();
		this._parsing=false;
	},
	
	_process_js:function(data){
		return this._process_json(data, "js");
	},

	_process_json:function(data, mode){
		this._parsing=true;
	
		var data = data.responseText || data;
		if (typeof data == "string"){
			eval("dhtmlx.temp="+data+";");
			data = dhtmlx.temp;
		}
	
		if (mode == "js"){
			if (data.data)
				data = data.data;
			for (var i = 0; i < data.length; i++){
				var row = data[i];
				var id  = row.id||(i+1);
				this.rowsBuffer.push({
					idd: id,
					data: row,
					_parser: this._process_js_row,
					_locator: this._get_js_data
					});
		
				this.rowsAr[id]=data[i];
			}
		} else {
			for (var i = 0; i < data.rows.length; i++){
				var id = data.rows[i].id;
				this.rowsBuffer.push({
					idd: id,
					data: data.rows[i],
					_parser: this._process_json_row,
					_locator: this._get_json_data
					});
		
				this.rowsAr[id]=data.rows[i];
			}
		}
		if (data.dhx_security)
			dhtmlx.security_key = data.dhx_security;

		this.callEvent("onDataReady", []);
		this.render_dataset();
		this._parsing=false;
	},
//#}	
	render_dataset:function(min, max){ 
		//normal mode - render all
		//var p=this.obj.parentNode;
		//p.removeChild(this.obj,true)
		if (this._srnd){
			if (this._fillers)
				return this._update_srnd_view();
	
			max=Math.min((this._get_view_size()+(this._srnd_pr||0)), this.rowsBuffer.length);
			
		}
	
		if (this.pagingOn){
			min=Math.max((min||0),(this.currentPage-1)*this.rowsBufferOutSize);
			max=Math.min(this.currentPage*this.rowsBufferOutSize, this.rowsBuffer.length)
		} else {
			min=min||0;
			max=max||this.rowsBuffer.length;
		}
	
		for (var i = min; i < max; i++){
			var r = this.render_row(i)
	
			if (r == -1){
				if (this.xmlFileUrl){
				    if (this.callEvent("onDynXLS",[i,(this._dpref?this._dpref:(max-i))]))
				        this.load(this.xmlFileUrl+dhtmlx.url(this.xmlFileUrl)+"posStart="+i+"&count="+(this._dpref?this._dpref:(max-i)), this._data_type);
				}
				max=i;
				break;
			}
						
			if (!r.parentNode||!r.parentNode.tagName){ 
				this._insertRowAt(r, i);
				if (r._attrs["selected"] || r._attrs["select"]){
					this.selectRow(r,r._attrs["call"]?true:false,true);
					r._attrs["selected"]=r._attrs["select"]=null;
				}
			}
			
							
			if (this._ads_count && i-min==this._ads_count){
				var that=this;
				this._context_parsing=this._context_parsing||this._parsing;
				return this._contextCallTimer=window.setTimeout(function(){
					that._contextCallTimer=null;
					that.render_dataset(i,max);
					if (!that._contextCallTimer){
						if(that._context_parsing)
					    	that.callEvent("onXLE",[])
					    else 
					    	that._fixAlterCss();
					    that.callEvent("onDistributedEnd",[]);
					    that._context_parsing=false;
				    }
				},this._ads_time)
			}
		}
		if (this._ads_count && i == max)
		    this.callEvent("onDistributedEnd",[]);

		if (this._srnd&&!this._fillers){
			var add_count = this.rowsBuffer.length-max;
			this._fillers = [];
			if (this._fake && !this._realfake) this._fake._fillers = [];

			while (add_count > 0){
				var add_step = (_isIE || window._FFrv)?Math.min(add_count, 50000):add_count;
				var new_filler = this._add_filler(max, add_step);
				if (new_filler)
					this._fillers.push(new_filler);
				add_count -= add_step;
				max += add_step;
			}				
		}
	
		//p.appendChild(this.obj)
		this.setSizes();
	},
	
	render_row:function(ind){
		if (!this.rowsBuffer[ind])
			return -1;
	
		if (this.rowsBuffer[ind]._parser){
			var r = this.rowsBuffer[ind];
			if (this.rowsAr[r.idd] && this.rowsAr[r.idd].tagName=="TR")
				return this.rowsBuffer[ind]=this.rowsAr[r.idd];
			var row = this._prepareRow(r.idd);
			this.rowsBuffer[ind]=row;
			this.rowsAr[r.idd]=row;
	
			r._parser.call(this, row, r.data);
			this._postRowProcessing(row);
			return row;
		}
		return this.rowsBuffer[ind];
	},
	
	
	_get_cell_value:function(row, ind, method){
		if (row._locator){
			/*if (!this._data_cache[row.idd])
				this._data_cache[row.idd]=[];
			if (this._data_cache[row.idd][ind]) 
				return this._data_cache[row.idd][ind];
			else
				 return this._data_cache[row.idd][ind]=row._locator.call(this,row.data,ind);
				 */
			if (this._c_order)
				ind=this._c_order[ind];
			return row._locator.call(this, row.data, ind);
		}
		return this.cells3(row, ind)[method ? method : "getValue"]();
	},
//#sorting:06042008{	
	/**
	*   @desc: sort grid
	*   @param: col - index of column, by which grid need to be sorted
	*   @param: type - sorting type (str,int,date), optional, by default sorting type taken from column setting
	*   @param: order - sorting order (asc,des), optional, by default sorting order based on previous sorting operation
	*   @type:  public
	*/		
	sortRows:function(col, type, order){
		this.editStop();
		//default values
		order=(order||"asc").toLowerCase();
		type=(type||this.fldSort[col]);
		col=col||0;
		
		if (this.isTreeGrid())
			this.sortTreeRows(col, type, order);
		else{
	
			var arrTS = {
			};
		
			var atype = this.cellType[col];
			var amet = "getValue";
		
			if (atype == "link")
				amet="getContent";
		
			if (atype == "dhxCalendar"||atype == "dhxCalendarA")
				amet="getDate";
		
			for (var i = 0;
				i < this.rowsBuffer.length;
				i++)arrTS[this.rowsBuffer[i].idd]=this._get_cell_value(this.rowsBuffer[i], col, amet);
		
			this._sortRows(col, type, order, arrTS);
		}
		this.callEvent("onAfterSorting", [col,type,order]);
	},
	/**
	*	@desc: 
	*	@type: private
	*/
	_sortCore:function(col, type, order, arrTS, s){
		var sort = "sort";
	
		if (this._sst){
			s["stablesort"]=this.rowsCol.stablesort;
			sort="stablesort";
		}
//#__pro_feature:21092006{	
//#custom_sort:21092006{
		if (type.length > 4)
			type=window[type];
	
		if (type == 'cus'){
			var cstr=this._customSorts[col];
			s[sort](function(a, b){
				return cstr(arrTS[a.idd], arrTS[b.idd], order, a.idd, b.idd);
			});
		}
		else if (typeof (type) == 'function'){
			s[sort](function(a, b){
				return type(arrTS[a.idd], arrTS[b.idd], order, a.idd, b.idd);
			});
		}
		else
//#}
//#}
		if (type == 'str'){
			s[sort](function(a, b){
				if (order == "asc")
					return arrTS[a.idd] > arrTS[b.idd] ? 1 : (arrTS[a.idd] < arrTS[b.idd] ? -1 : 0);
				else
					return arrTS[a.idd] < arrTS[b.idd] ? 1 : (arrTS[a.idd] > arrTS[b.idd] ? -1 : 0);
			});
		}
		else if (type == 'int'){
			s[sort](function(a, b){
				var aVal = parseFloat(arrTS[a.idd]);
				aVal=isNaN(aVal) ? -99999999999999 : aVal;
				var bVal = parseFloat(arrTS[b.idd]);
				bVal=isNaN(bVal) ? -99999999999999 : bVal;
	
				if (order == "asc")
					return aVal-bVal;
				else
					return bVal-aVal;
			});
		}
		else if (type == 'date'){
			s[sort](function(a, b){
				var aVal = Date.parse(arrTS[a.idd])||(Date.parse("01/01/1900"));
				var bVal = Date.parse(arrTS[b.idd])||(Date.parse("01/01/1900"));
	
				if (order == "asc")
					return aVal-bVal
				else
					return bVal-aVal
			});
		}
	},
	/**
	*   @desc: inner sorting routine
	*   @type: private
	*   @topic: 7
	*/
	_sortRows:function(col, type, order, arrTS){
		this._sortCore(col, type, order, arrTS, this.rowsBuffer);
		this._reset_view();
		this.callEvent("onGridReconstructed", []);
	},
//#}		
	_reset_view:function(skip){
		if (!this.obj.rows[0]) return;
		if (this._lahRw) this._unsetRowHover(0, true); //remove hovering during reset
		this.callEvent("onResetView",[]);
		var tb = this.obj.rows[0].parentNode;
		var tr = tb.removeChild(tb.childNodes[0], true)
	    if (_isKHTML) //Safari 2x
	    	for (var i = tb.parentNode.childNodes.length-1; i >= 0; i--) { if (tb.parentNode.childNodes[i].tagName=="TR") tb.parentNode.removeChild(tb.parentNode.childNodes[i],true); }
	    else if (_isIE)
			for (var i = tb.childNodes.length-1; i >= 0; i--) tb.childNodes[i].removeNode(true);
		else
			tb.innerHTML="";
		tb.appendChild(tr)
		this.rowsCol=dhtmlxArray();
		if (this._sst)
			this.enableStableSorting(true);
		this._fillers=this.undefined;
		if (!skip){
		    if (_isIE && this._srnd){
		        // var p=this._get_view_size;
		        // this._get_view_size=function(){ return 1; }
    		    this.render_dataset();
    		    // this._get_view_size=p;
    		}
    	    else
    	        this.render_dataset();
	    }
		
		
	},
	
	/**
	*   @desc: delete row from the grid
	*   @param: row_id - row ID
	*   @type:  public
	*/		
	deleteRow:function(row_id, node){
		if (!node)
			node=this.getRowById(row_id)
	
		if (!node)
			return;
	
		this.editStop();
		if (!this._realfake)
			if (this.callEvent("onBeforeRowDeleted", [row_id]) == false)
				return false;
		
		var pid=0;
		if (this.cellType._dhx_find("tree") != -1 && !this._realfake){
			pid=this._h2.get[row_id].parent.id;
			this._removeTrGrRow(node);
		}
		else {
			if (node.parentNode)
				node.parentNode.removeChild(node);
	
			var ind = this.rowsCol._dhx_find(node);
	
			if (ind != -1)
				this.rowsCol._dhx_removeAt(ind);
	
			for (var i = 0; i < this.rowsBuffer.length; i++)
				if (this.rowsBuffer[i]&&this.rowsBuffer[i].idd == row_id){
					this.rowsBuffer._dhx_removeAt(i);
					ind=i;
					break;
				}
		}
		this.rowsAr[row_id]=null;
	
		for (var i = 0; i < this.selectedRows.length; i++)
			if (this.selectedRows[i].idd == row_id)
				this.selectedRows._dhx_removeAt(i);
	
		if (this._srnd){
			for (var i = 0; i < this._fillers.length; i++){
				var f = this._fillers[i]
	            if (!f) continue; //can be null	
	            if (f[0] >= ind)
	            	this._update_fillers(i, 0, -1);
	            else if (f[0]+f[1] > ind)
	            	this._update_fillers(i, -1, 0);
			};
	
			this._update_srnd_view();
		}
	
		if (this.pagingOn)
			this.changePage();
		if (!this._realfake)  this.callEvent("onAfterRowDeleted", [row_id,pid]);
		this.callEvent("onGridReconstructed", []);
		if (this._ahgr) this.setSizes();
		return true;
	},
	
	_addRow:function(new_id, text, ind){
		if (ind == -1|| typeof ind == "undefined")
			ind=this.rowsBuffer.length;
		if (typeof text == "string") text=text.split(this.delim);
		var row = this._prepareRow(new_id);
		row._attrs={
		};
	
		for (var j = 0; j < row.childNodes.length; j++)row.childNodes[j]._attrs={
		};
	
	
		this.rowsAr[row.idd]=row;
		if (this._h2) this._h2.get[row.idd].buff=row;	//treegrid specific
		this._fillRow(row, text);
		this._postRowProcessing(row);
		if (this._skipInsert){
			this._skipInsert=false;
			return this.rowsAr[row.idd]=row;
		}
	
		if (this.pagingOn){
			this.rowsBuffer._dhx_insertAt(ind,row);
			this.rowsAr[row.idd]=row;
			return row;
		}
	
		if (this._fillers){ 
			this.rowsCol._dhx_insertAt(ind, null);
			this.rowsBuffer._dhx_insertAt(ind,row);
			if (this._fake) this._fake.rowsCol._dhx_insertAt(ind, null);
			this.rowsAr[row.idd]=row;
			var found = false;
	
			for (var i = 0; i < this._fillers.length; i++){
				var f = this._fillers[i];
	
				if (f&&f[0] <= ind&&(f[0]+f[1]) >= ind){
					f[1]=f[1]+1;
					var nh = f[2].firstChild.style.height=parseInt(f[2].firstChild.style.height)+this._srdh+"px";
					found=true;
					if (this._fake){
						this._fake._fillers[i][1]++;
						this._fake._fillers[i][2].firstChild.style.height = nh;
					}
				}
	
				if (f&&f[0] > ind){
					f[0]=f[0]+1
					if (this._fake) this._fake._fillers[i][0]++;
				}
			}
	
			if (!found)
				this._fillers.push(this._add_filler(ind, 1, (ind == 0 ? {
					parentNode: this.obj.rows[0].parentNode,
					nextSibling: (this.rowsCol[1])
					} : this.rowsCol[ind-1])));
	
			return row;
		}
		this.rowsBuffer._dhx_insertAt(ind,row);
		return this._insertRowAt(row, ind);
	},
	
	/**
	*   @desc: add row to the grid
	*   @param: new_id - row ID, must be unique
	*   @param: text - row values, may be a comma separated list or an array
	*   @param: ind - index of new row, optional, row added to the last position by default
	*   @type:  public
	*/	
	addRow:function(new_id, text, ind){
		var r = this._addRow(new_id, text, ind);
	
		if (!this.dragContext)
			this.callEvent("onRowAdded", [new_id]);
	
		if (this.pagingOn)
			this.changePage(this.currentPage)
	
		if (this._srnd)
			this._update_srnd_view();
	
		r._added=true;
	
		if (this._ahgr)
			this.setSizes();
		this.callEvent("onGridReconstructed", []);
		return r;
	},
	
	_insertRowAt:function(r, ind, skip){
		this.rowsAr[r.idd]=r;
	
		if (this._skipInsert){
			this._skipInsert=false;
			return r;
		}
	
		if ((ind < 0)||((!ind)&&(parseInt(ind) !== 0)))
			ind=this.rowsCol.length;
		else {
			if (ind > this.rowsCol.length)
				ind=this.rowsCol.length;
		}
	
		if (this._cssEven){
			var css = r.className.replace(this._cssUnEven, "");
			if ((this._cssSP ? this.getLevel(r.idd) : ind)%2 == 1)
				r.className=css+" "+this._cssUnEven+(this._cssSU ? (" "+this._cssUnEven+"_"+this.getLevel(r.idd)) : "");
			else
				r.className=css+" "+this._cssEven+(this._cssSU ? (" "+this._cssEven+"_"+this.getLevel(r.idd)) : "");
		}
		/*
		if (r._skipInsert) {                
			this.rowsAr[r.idd] = r;
			return r;
		}*/
		if (!skip)
			if ((ind == (this.obj.rows.length-1))||(!this.rowsCol[ind]))
				if (_isKHTML)
					this.obj.appendChild(r);
				else {
					this.obj.firstChild.appendChild(r);
				}
			else {
				this.rowsCol[ind].parentNode.insertBefore(r, this.rowsCol[ind]);
			}
	
		this.rowsCol._dhx_insertAt(ind, r);
		this.callEvent("onRowInserted",[r, ind]);
		return r;
	},
	
	getRowById:function(id){
		var row = this.rowsAr[id];
	
		if (row){
			if (row.tagName != "TR"){
				for (var i = 0; i < this.rowsBuffer.length; i++)
					if (this.rowsBuffer[i] && this.rowsBuffer[i].idd == id)
						return this.render_row(i);
				if (this._h2) return this.render_row(null,row.idd);
			}
			return row;
		}
		return null;
	},
	
/**
*   @desc: gets dhtmlXGridCellObject object (if no arguments then gets dhtmlXGridCellObject object of currently selected cell)
*   @param: row_id -  row id
*   @param: col -  column index
*   @returns: dhtmlXGridCellObject object (see its methods below)
*   @type: public
*   @topic: 4
*/
	cellById:function(row_id, col){
		return this.cells(row_id, col);
	},
/**
*   @desc: gets dhtmlXGridCellObject object (if no arguments then gets dhtmlXGridCellObject object of currently selected cell)
*   @param: row_id -  row id
*   @param: col -  column index
*   @returns: dhtmlXGridCellObject object (use it to get/set value to cell etc.)
*   @type: public
*   @topic: 4
*/
	cells:function(row_id, col){
		if (arguments.length == 0)
			return this.cells4(this.cell);
		else
			var c = this.getRowById(row_id);
		var cell = (c._childIndexes ? c.childNodes[c._childIndexes[col]] : c.childNodes[col]);
		if (!cell && c._childIndexes)
			cell = c.firstChild || {};
		return this.cells4(cell);
	},
	/**
	*   @desc: gets dhtmlXGridCellObject object
	*   @param: row_index -  row index
	*   @param: col -  column index
	*   @returns: dhtmlXGridCellObject object (see its methods below)
	*   @type: public
	*   @topic: 4
	*/
	cellByIndex:function(row_index, col){
		return this.cells2(row_index, col);
	},
	/**
	*   @desc: gets dhtmlXGridCellObject object
	*   @param: row_index -  row index
	*   @param: col -  column index
	*   @returns: dhtmlXGridCellObject object (see its methods below)
	*   @type: public
	*   @topic: 4
	*/
	cells2:function(row_index, col){
		var c = this.render_row(row_index);
		var cell = (c._childIndexes ? c.childNodes[c._childIndexes[col]] : c.childNodes[col]);
		if (!cell && c._childIndexes)
			cell = c.firstChild || {};
		return this.cells4(cell);
	},
	/**
	*   @desc: gets exCell editor for row  object and column id
	*   @type: private
	*   @topic: 4
	*/
	cells3:function(row, col){
		var cell = (row._childIndexes ? row.childNodes[row._childIndexes[col]] : row.childNodes[col]);
		return this.cells4(cell);
	},
	/**
	*   @desc: gets exCell editor for cell  object
	*   @type: private
	*   @topic: 4
	*/
	cells4:function(cell){
		var type = window["eXcell_"+(cell._cellType||this.cellType[cell._cellIndex])];

		if (type)
			return new type(cell);
	},	
	cells5:function(cell, type){ 
		var type = type||(cell._cellType||this.cellType[cell._cellIndex]);
	
		if (!this._ecache[type]){
			if (!window["eXcell_"+type])
				var tex = eXcell_ro;
			else
				var tex = window["eXcell_"+type];
	
			this._ecache[type]=new tex(cell);
		}
		this._ecache[type].cell=cell;
		return this._ecache[type];
	},
	dma:function(mode){
		if (!this._ecache)
			this._ecache={
			};
	
		if (mode&&!this._dma){
			this._dma=this.cells4;
			this.cells4=this.cells5;
		} else if (!mode&&this._dma){
			this.cells4=this._dma;
			this._dma=null;
		}
	},
	
	/**
	*   @desc: returns count of row in grid ( in case of dynamic mode it will return expected count of rows )
	*   @type:  public
	*	@returns: count of rows in grid
	*/	
	getRowsNum:function(){
		return this.rowsBuffer.length;
	},
	
	
	/**
	*   @desc: enables/disables mode when readonly cell is not available with tab 
	*   @param: mode - (boolean) true/false
	*   @type:  public
	*/
	enableEditTabOnly:function(mode){
		if (arguments.length > 0)
			this.smartTabOrder=dhx4.s2b(mode);
		else
			this.smartTabOrder=true;
	},
	/**
	*   @desc: sets elements which get focus when tab is pressed in the last or first (tab+shift) cell 
	*   @param: start - html object or its id - gets focus when tab+shift are pressed in the first cell  
	*   @param: end - html object or its id - gets focus when tab is pressed in the last cell  
	*   @type:  public
	*/
	setExternalTabOrder:function(start, end){
		var grid = this;
		this.tabStart=( typeof (start) == "object") ? start : document.getElementById(start);

		var oldkeydown_start = this.tabStart.onkeydown;
		this.tabStart.onkeydown=function(e){
			if (oldkeydown_start)
				oldkeydown_start.call(this, e);

			var ev = (e||window.event);
			if (ev.keyCode == 9 && !ev.shiftKey){
				
				ev.cancelBubble=true;		
				grid.selectCell(0, 0, 0, 0, 1);
	
				if (grid.smartTabOrder && grid.cells2(0, 0).isDisabled()){
					grid._key_events["k9_0_0"].call(grid);
				}
				this.blur();
				return false;
			}
		};
		if(_isOpera) this.tabStart.onkeypress = this.tabStart.onkeydown;
		this.tabEnd=( typeof (end) == "object") ? end : document.getElementById(end);

		var oldkeydown_end= this.tabEnd.onkeydown;
		this.tabEnd.onkeydown=this.tabEnd.onkeypress=function(e){
			if (oldkeydown_end)
				oldkeydown_end.call(this, e);

			var ev = (e||window.event);
			if (ev.keyCode == 9 && ev.shiftKey){
				ev.cancelBubble=true;
				grid.selectCell((grid.getRowsNum()-1), (grid.getColumnCount()-1), 0, 0, 1);
	
				if (grid.smartTabOrder && grid.cells2((grid.getRowsNum()-1), (grid.getColumnCount()-1)).isDisabled()){
					grid._key_events["k9_0_1"].call(grid);
				}
				this.blur();
				return false;
			}
		};
		if(_isOpera) this.tabEnd.onkeypress = this.tabEnd.onkeydown;
	},
	/**
	*   @desc: returns unique ID
	*   @type:  public
	*/	
	uid:function(){
		if (!this._ui_seed) this._ui_seed=(new Date()).valueOf();
		return this._ui_seed++;
	},
	/**
	*   @desc: clears existing grid state and load new XML
	*   @type:  public
	*/
	clearAndLoad:function(){
		var t=this._pgn_skin; this._pgn_skin=null;
		this.clearAll();
		this._pgn_skin=t;
		this.load.apply(this,arguments);
	},
	/**
	*   @desc: returns details about current grid state
	*   @type:  public
	*/
	getStateOfView:function(){
		if (this.pagingOn){
			var start = (this.currentPage-1)*this.rowsBufferOutSize;
			return [this.currentPage, start, Math.min(start+this.rowsBufferOutSize,this.rowsBuffer.length), this.rowsBuffer.length ];
		}
 		return [
            Math.floor(this.objBox.scrollTop/this._srdh),
			Math.ceil(parseInt(this.objBox.offsetHeight)/this._srdh),
			this.rowsBuffer.length
			];
	}
};

//grid
(function(){
	//local helpers
	function direct_set(name,value){ this[name]=value; 	}
	function direct_call(name,value){ this[name].call(this,value); 	}
	function joined_call(name,value){ this[name].call(this,value.join(this.delim));  }
	function set_options(name,value){
		for (var i=0; i < value.length; i++) 
			if (typeof value[i] == "object"){
				var combo = this.getCombo(i);
				for (var key in value[i])
					combo.put(key, value[i][key]);
			}
	}
	function header_set(name,value,obj){
		//make a matrix
		var rows = 1;
		var header = [];
		function add(i,j,value){
			if (!header[j]) header[j]=[];
			if (typeof value == "object") value.toString=function(){ return this.text; }
			header[j][i]=value;
		}
		
		for (var i=0; i<value.length; i++) {
			if (typeof(value[i])=="object" && value[i].length){
				for (var j=0; j < value[i].length; j++)
					add(i,j,value[i][j]);		
			} else
				add(i,0,value[i]);		
		}
		for (var i=0; i<header.length; i++)
			for (var j=0; j<header[0].length; j++){
				var h=header[i][j];
				header[i][j]=(h||"").toString()||"&nbsp;";
				if (h&&h.colspan)
					for (var k=1; k < h.colspan; k++) add(j+k,i,"#cspan");
				if (h&&h.rowspan)
					for (var k=1; k < h.rowspan; k++) add(j,i+k,"#rspan");
			}
				
		this.setHeader(header[0]);
		for (var i=1; i < header.length; i++) 
			this.attachHeader(header[i]);
	}
	
	//defenitions
	var columns_map=[
		{name:"label", 	def:"&nbsp;", 	operation:"setHeader",		type:header_set		},
		{name:"id", 	def:"", 		operation:"columnIds",		type:direct_set		},
		{name:"width", 	def:"*", 		operation:"setInitWidths", 	type:joined_call	},
		{name:"align", 	def:"left", 	operation:"cellAlign",		type:direct_set		},
		{name:"valign", def:"middle", 	operation:"cellVAlign",		type:direct_set		},
		{name:"sort", 	def:"na", 		operation:"fldSort",		type:direct_set		},
		{name:"type", 	def:"ro", 		operation:"setColTypes",	type:joined_call	},
		{name:"options",def:"", 		operation:"",				type:set_options	}
	];
	
	//extending	
	dhtmlx.extend_api("dhtmlXGridObject",{
		_init:function(obj){
			return [obj.parent];
		},
		image_path:"setImagePath",
		columns:"columns",
		rows:"rows",
		headers:"headers",
		skin:"setSkin",
		smart_rendering:"enableSmartRendering",
		css:"enableAlterCss",
		auto_height:"enableAutoHeight",
		save_hidden:"enableAutoHiddenColumnsSaving",
		save_cookie:"enableAutoSaving",
		save_size:"enableAutoSizeSaving",
		auto_width:"enableAutoWidth",
		block_selection:"enableBlockSelection",
		csv_id:"enableCSVAutoID",
		csv_header:"enableCSVHeader",
		cell_ids:"enableCellIds",
		colspan:"enableColSpan",
		column_move:"enableColumnMove",
		context_menu:"enableContextMenu",
		distributed:"enableDistributedParsing",
		drag:"enableDragAndDrop",
		drag_order:"enableDragOrder",
		tabulation:"enableEditTabOnly",
		header_images:"enableHeaderImages",
		header_menu:"enableHeaderMenu",
		keymap:"enableKeyboardSupport",
		mouse_navigation:"enableLightMouseNavigation",
		markers:"enableMarkedCells",
		math_editing:"enableMathEditing",
		math_serialization:"enableMathSerialization",
		drag_copy:"enableMercyDrag",
		multiline:"enableMultiline",
		multiselect:"enableMultiselect",
		save_column_order:"enableOrderSaving",
		hover:"enableRowsHover",
		rowspan:"enableRowspan",
		smart:"enableSmartRendering",
		save_sorting:"enableSortingSaving",
		stable_sorting:"enableStableSorting",
		undo:"enableUndoRedo",
		csv_cell:"setCSVDelimiter",
		date_format:"setDateFormat",
		drag_behavior:"setDragBehavior",
		editable:"setEditable",
		without_header:"setNoHeader",
		submit_changed:"submitOnlyChanged",
		submit_serialization:"submitSerialization",
		submit_selected:"submitOnlySelected",
		submit_id:"submitOnlyRowID",		
		xml:"load"
	},{
		columns:function(obj){
			for (var j=0; j<columns_map.length; j++){
				var settings = [];
				for (var i=0; i<obj.length; i++)
					settings[i]=obj[i][columns_map[j].name]||columns_map[j].def;
			var type=columns_map[j].type||direct_call;
				type.call(this,columns_map[j].operation,settings,obj);
			}
			this.init();
		},
		rows:function(obj){
			
		},
		headers:function(obj){
			for (var i=0; i < obj.length; i++) 
				this.attachHeader(obj[i]);
		}
	});

})();


dhtmlXGridObject.prototype._dp_init=function(dp){
	dp.attachEvent("insertCallback", function(upd, id) {
		if (this.obj._h2)
			this.obj.addRow(id, row, null, parent);
		else
			this.obj.addRow(id, [], 0);
			
		var row = this.obj.getRowById(id);
		if (row){
			this.obj._process_xml_row(row, upd.firstChild);
			this.obj._postRowProcessing(row);	
		}
	});
	dp.attachEvent("updateCallback", function(upd, id) {
		var row = this.obj.getRowById(id);
		if (row){
			this.obj._process_xml_row(row, upd.firstChild);
			this.obj._postRowProcessing(row);	
		}
	});
	dp.attachEvent("deleteCallback", function(upd, id) {
		this.obj.setUserData(id, this.action_param, "true_deleted");
		this.obj.deleteRow(id);
	});
	

	dp._methods=["setRowTextStyle","setCellTextStyle","changeRowId","deleteRow"];
	this.attachEvent("onEditCell",function(state,id,index){
		if (dp._columns && !dp._columns[index]) return true;
		var cell = this.cells(id,index)
		if (state==1){
			if(cell.isCheckbox()){
				dp.setUpdated(id,true)
			}
		} else if (state==2){
			if(cell.wasChanged()){
				dp.setUpdated(id,true)
			}
		}
    	return true;
	});
	this.attachEvent("onRowPaste",function(id){
		dp.setUpdated(id,true)
	});
	this.attachEvent("onUndo",function(id){
		dp.setUpdated(id,true)
	});
	this.attachEvent("onRowIdChange",function(id,newid){
		var ind=dp.findRow(id);
		if (ind<dp.updatedRows.length)
			dp.updatedRows[ind]=newid;
	});
	this.attachEvent("onSelectStateChanged",function(rowId){
		if(dp.updateMode=="row")
			dp.sendData();
        return true;
	});
	this.attachEvent("onEnter",function(rowId,celInd){
		if(dp.updateMode=="row")
			dp.sendData();
        return true;
	});
	this.attachEvent("onBeforeRowDeleted",function(rowId){
		if (!this.rowsAr[rowId]) return true;
		if (this.dragContext && dp.dnd) {
			window.setTimeout(function(){
				dp.setUpdated(rowId,true);
			},1);
			return true;
		}
    	var z=dp.getState(rowId);
		if (this._h2){
			this._h2.forEachChild(rowId,function(el){
				dp.setUpdated(el.id,false);
				dp.markRow(el.id,true,"deleted");
			},this);
		}
		if (z=="inserted") {  dp.set_invalid(rowId,false); dp.setUpdated(rowId,false);		return true; }
		if (z=="deleted")  return false;
		if (z=="true_deleted")  { dp.setUpdated(rowId,false); return true; }

		dp.setUpdated(rowId,true,"deleted");
		return false;
	});
	this.attachEvent("onBindUpdate", function(id){
		if (typeof id == "object")
			id = id.id;
		dp.setUpdated(id,true);
	});
	this.attachEvent("onRowAdded",function(rowId){
		if (this.dragContext && dp.dnd) return true;
		dp.setUpdated(rowId,true,"inserted")
    	return true;
	});
	dp._getRowData=function(rowId,pref){
		var data = [];
		
		data["gr_id"]=rowId;
		if (this.obj.isTreeGrid())
			data["gr_pid"]=this.obj.getParentId(rowId);
		
		var r=this.obj.getRowById(rowId);
		for (var i=0; i<this.obj._cCount; i++){
		   if (this.obj._c_order)
		   		var i_c=this.obj._c_order[i];
		   else
			   	var i_c=i;
		
		   var c=this.obj.cells(r.idd,i);
		   if (this._changed && !c.wasChanged()) continue;
		   if (this._endnm)
		       data[this.obj.getColumnId(i)]=c.getValue();
		   else
		       data["c"+i_c]=c.getValue();
		}
		   
		var udata=this.obj.UserData[rowId];
		if (udata){
			for (var j=0; j<udata.keys.length; j++)
				if (udata.keys[j] && udata.keys[j].indexOf("__")!=0)
					data[udata.keys[j]]=udata.values[j];
		}
		var udata=this.obj.UserData["gridglobaluserdata"];
		if (udata){
		   for (var j=0; j<udata.keys.length; j++)
		       data[udata.keys[j]]=udata.values[j];
		}
		return data;
	};
	dp._clearUpdateFlag=function(rowId){
		var row=this.obj.getRowById(rowId);
		if (row)
		for (var j=0; j<this.obj._cCount; j++)
			this.obj.cells(rowId,j).cell.wasChanged=false;	//using cells because of split
	};
	dp.checkBeforeUpdate=function(rowId){ 
		var valid=true; var c_invalid=[];
		for (var i=0; i<this.obj._cCount; i++)
			if (this.mandatoryFields[i]){
				var res=this.mandatoryFields[i].call(this.obj,this.obj.cells(rowId,i).getValue(),rowId,i);
				if (typeof res == "string"){
					this.messages.push(res);
					valid = false;
				} else {
					valid&=res;
					c_invalid[i]=!res;
				}
			}
		if (!valid){
			this.set_invalid(rowId,"invalid",c_invalid);
			this.setUpdated(rowId,false);
		}
		return valid;
	};	
};


dhx4.attachEvent("onGridCreated", function(grid){
	//make separate config array for each grid
	grid._con_f_used = [].concat(grid._con_f_used);
	dhtmlXGridObject.prototype._con_f_used=[];
	
	var clear_url=function(url){
		url=url.replace(/(\?|\&)connector[^\f]*/g,"");
		return url+(url.indexOf("?")!=-1?"&":"?")+"connector=true"+(this.hdr.rows.length > 0 ? "&dhx_no_header=1":"");
	};
	var combine_urls=function(url){
		return clear_url.call(this,url)+(this._connector_sorting||"")+(this._connector_filter||"");
	};
	var sorting_url=function(url,ind,dir){
		this._connector_sorting="&dhx_sort["+ind+"]="+dir;
		return combine_urls.call(this,url);
	};
	var filtering_url=function(url,inds,vals){
		var chunks = [];
		for (var i=0; i<inds.length; i++)
			chunks[i]="dhx_filter["+inds[i]+"]="+encodeURIComponent(vals[i]);
		this._connector_filter="&"+chunks.join("&");
		return combine_urls.call(this,url);
	};
	grid.attachEvent("onCollectValues",function(ind){
		if (this._con_f_used[ind]){
			if (typeof(this._con_f_used[ind]) == "object")
				return this._con_f_used[ind];
			else
				return false;
		}
		return true;
	});	
	grid.attachEvent("onDynXLS",function(){
			this.xmlFileUrl=combine_urls.call(this,this.xmlFileUrl);
			return true;
	});				
	grid.attachEvent("onBeforeSorting",function(ind,type,dir){
		if (type=="connector"){
			var self=this;
			this.clearAndLoad(sorting_url.call(this,this.xmlFileUrl,ind,dir),function(){
				self.setSortImgState(true,ind,dir);
			});
			return false;
		}
		return true;
	});
	grid.attachEvent("onFilterStart",function(a,b){
		var ss = this.getSortingState();
		if (this._con_f_used.length){
			var self=this;
			this.clearAndLoad(filtering_url.call(this,this.xmlFileUrl,a,b));
			if (ss.length)
				self.setSortImgState(true,ss[0],ss[1]);
			return false;
		}
		return true;
	});
});

	dhtmlXGridObject.prototype._con_f_used=[];
	dhtmlXGridObject.prototype._in_header_connector_text_filter=function(t,i){
		if (!this._con_f_used[i])
			this._con_f_used[i]=1;
		return this._in_header_text_filter(t,i);
	};
	dhtmlXGridObject.prototype._in_header_connector_select_filter=function(t,i){
		if (!this._con_f_used[i])
			this._con_f_used[i]=2;
		return this._in_header_select_filter(t,i);
	};
	dhtmlXGridObject.prototype.load_connector=dhtmlXGridObject.prototype.load;
	dhtmlXGridObject.prototype.load=function(url, call, type){
		if (!this._colls_loaded && this.cellType){
			var ar=[];
			for (var i=0; i < this.cellType.length; i++)
				if (this.cellType[i].indexOf("co")==0 || this.cellType[i].indexOf("clist")==0 || this._con_f_used[i]==2) ar.push(i);
			if (ar.length)
				arguments[0]+=(arguments[0].indexOf("?")!=-1?"&":"?")+"connector=true&dhx_colls="+ar.join(",");
		}
		return this.load_connector.apply(this,arguments);
	};
	dhtmlXGridObject.prototype._parseHead_connector=dhtmlXGridObject.prototype._parseHead;
	dhtmlXGridObject.prototype._parseHead=function(url, call, type){
		this._parseHead_connector.apply(this,arguments);
		if (!this._colls_loaded){
			var cols = dhx4.ajax.xpath("./coll_options", arguments[0]);
			for (var i=0; i < cols.length; i++){
				var f = cols[i].getAttribute("for");
				var v = [];
				var combo=null;
				if (this.cellType[f] == "combo")
					combo = this.getColumnCombo(f);
				else if (this.cellType[f].indexOf("co")==0)
					combo=this.getCombo(f);
					
				var os = dhx4.ajax.xpath("./item",cols[i]);
				var opts = [];
				for (var j=0; j<os.length; j++){
					var val=os[j].getAttribute("value");
					
					if (combo){
						var lab=os[j].getAttribute("label")||val;
						
						if (combo.addOption)
							opts.push([val, lab]);
						else
							combo.put(val,lab);
							
						v[v.length]=lab;
					} else
						v[v.length]=val;
				}
				if (opts.length){
					if (combo)
						combo.addOption(opts);
				} else if (v.length && !combo)
					if (this.registerCList)
						this.registerCList(f*1, v);

					
				if (this._con_f_used[f*1])
					this._con_f_used[f*1]=v;
			}
			this._colls_loaded=true;
		}
	};	

//(c)dhtmlx ltd. www.dhtmlx.com

/**
*	@desc: dhtmlxGrid cell object constructor (shouldn't be accesed directly. Use cells and cells2 methods of the grid instead)
*	@type: cell
*	@returns: dhtmlxGrid cell
*/
function dhtmlXGridCellObject(obj){
	/**
	*	@desc: desctructor, clean used memory
	*	@type: public
	*/
	this.destructor=function(){
		this.cell.obj=null;
		this.cell=null;
		this.grid=null;
		this.base=null;
		return null;
	}
	this.cell=obj;
	/**
	*	@desc: gets Value of cell
	*	@type: public
	*/
	this.getValue=function(){
		if ((this.cell.firstChild)&&(this.cell.firstChild.tagName == "TEXTAREA"))
			return this.cell.firstChild.value;
		else
			return this.cell.innerHTML._dhx_trim(); //innerText;
	}

	/**
	*	@desc: gets math formula of cell if any
	*	@type: public
	*/
	this.getMathValue=function(){
		if (this.cell.original)
			return this.cell.original; //innerText;
		else
			return this.getValue();
	}
	
//#excell_methods:04062008{
	/**
	*	@desc: determ. font style if it was set
	*	@returns: font name only if it was set for the cell
	*	@type: public
	*/
	this.getFont=function(){
		arOut=new Array(3);

		if (this.cell.style.fontFamily)
			arOut[0]=this.cell.style.fontFamily

		if (this.cell.style.fontWeight == 'bold'||this.cell.parentNode.style.fontWeight == 'bold')
			arOut[1]='bold';

		if (this.cell.style.fontStyle == 'italic'||this.cell.parentNode.style.fontWeight == 'italic')
			arOut[1]+='italic';

		if (this.cell.style.fontSize)
			arOut[2]=this.cell.style.fontSize
		else
			arOut[2]="";
		return arOut.join("-")
	}
	/**
	*	@desc: determ. cell's text color
	*	@returns: cell's text color
	*	@type: public
	*/
	this.getTextColor=function(){
		if (this.cell.style.color)
			return this.cell.style.color
		else
			return "#000000";
	}
	/**
	*	@desc: determ. cell's background color
	*	@returns: cell's background color
	*	@type: public
	*/
	this.getBgColor=function(){
		if (this.cell.bgColor)
			return this.cell.bgColor
		else
			return "#FFFFFF";
	}
	/**
	*	@desc: determines horisontal align od the cell
	*	@returns: horisontal align of cell content
	*	@type: public
	*/
	this.getHorAlign=function(){
		if (this.cell.style.textAlign)
			return this.cell.style.textAlign;

		else if (this.cell.style.textAlign)
			return this.cell.style.textAlign;

		else
			return "left";
	}
	/**
	*	@desc: gets width of the cell in pixel
	*	@returns: width of the cell in pixels
	*	@type: public
	*/
	this.getWidth=function(){
		return this.cell.scrollWidth;
	}

	/**
	*	@desc: sets font family to the cell
	*	@param: val - string in format: Arial-bold(italic,bolditalic,underline)-12px
	*	@type: public
	*/
	this.setFont=function(val){
		fntAr=val.split("-");
		this.cell.style.fontFamily=fntAr[0];
		this.cell.style.fontSize=fntAr[fntAr.length-1]

		if (fntAr.length == 3){
			if (/bold/.test(fntAr[1]))
				this.cell.style.fontWeight="bold";

			if (/italic/.test(fntAr[1]))
				this.cell.style.fontStyle="italic";

			if (/underline/.test(fntAr[1]))
				this.cell.style.textDecoration="underline";
		}
	}
	/**
	*	@desc: sets text color to the cell
	*	@param: val - color value (name or hex)
	*	@type: public
	*/
	this.setTextColor=function(val){
		this.cell.style.color=val;
	}
	/**
	*	@desc: sets background color to the cell
	*	@param: val - color value (name or hex)
	*	@type: public
	*/
	this.setBgColor=function(val){
		if (val == "")
			val=null;
		this.cell.style.background=val;
	}
	/**
	*	@desc: sets horisontal align to the cell
	*	@param: val - value in single-letter or full format(exmp: r or right)
	*	@type: public
	*/
	this.setHorAlign=function(val){
		if (val.length == 1){
			if (val == 'c')
				this.cell.style.textAlign='center'

			else if (val == 'l')
				this.cell.style.textAlign='left';

			else
				this.cell.style.textAlign='right';
		} else
			this.cell.style.textAlign=val
	}
//#}
	/**
	*	@desc: determines whether cell value was changed
	*	@returns: true if cell value was changed, otherwise - false
	*	@type: public
	*/
	this.wasChanged=function(){
		if (this.cell.wasChanged)
			return true;
		else
			return false;
	}
	/**
	*	@desc: determines whether first child of the cell is checkbox or radio
	*	@returns: true if first child of the cell is input element of type radio or checkbox
	*	@type: deprecated
	*/
	this.isCheckbox=function(){
		var ch = this.cell.firstChild;

		if (ch&&ch.tagName == 'INPUT'){
			type=ch.type;

			if (type == 'radio'||type == 'checkbox')
				return true;
			else
				return false;
		} else
			return false;
	}
	/**
	*	@desc: determines whether radio or checkbox inside is checked
	*	@returns: true if first child of the cell is checked
	*	@type: public
	*/
	this.isChecked=function(){
		if (this.isCheckbox()){
			return this.cell.firstChild.checked;
		}
	}
	/**
	*	@desc: determines whether cell content (radio,checkbox) is disabled
	*	@returns: true if first child of the cell is disabled
	*	@type: public
	*/
	this.isDisabled=function(){
		return this.cell._disabled;
	}
	/**
	*	@desc: checks checkbox or radion
	*	@param: fl - true or false
	*	@type: public
	*/
	this.setChecked=function(fl){
		if (this.isCheckbox()){
			if (fl != 'true'&&fl != 1)
				fl=false;
			this.cell.firstChild.checked=fl;
		}
	}
	/**
	*	@desc: disables radio or checkbox
	*	@param: fl - true or false
	*	@type: public
	*/
	this.setDisabled=function(fl){
		if (fl != 'true'&&fl != 1)
			fl=false;

		if (this.isCheckbox()){
			this.cell.firstChild.disabled=fl;

			if (this.disabledF)
				this.disabledF(fl);
		}
		this.cell._disabled=fl;
	}
}

dhtmlXGridCellObject.prototype={
	getAttribute: function(name){
		return this.cell._attrs[name];
	},
	setAttribute: function(name, value){
		this.cell._attrs[name]=value;
	},
	getInput:function(){
		if (this.obj && (this.obj.tagName=="INPUT" || this.obj.tagName=="TEXTAREA")) return this.obj;
		
		var inps=(this.obj||this.cell).getElementsByTagName("TEXTAREA");
		if (!inps.length)
			inps=(this.obj||this.cell).getElementsByTagName("INPUT");
		return inps[0];
	}
}

/**
*	@desc: sets value to the cell
*	@param: val - new value
*	@type: public
*/
dhtmlXGridCellObject.prototype.setValue=function(val){
	if (( typeof (val) != "number")&&(!val||val.toString()._dhx_trim() == "")){
		val="&nbsp;"
		this.cell._clearCell=true;
	} else
		this.cell._clearCell=false;
	this.setCValue(val);
}
/**
*	@desc: sets value to the cell
*	@param: val - new value
*	@param: val2
*	@type: private
*/
dhtmlXGridCellObject.prototype.getTitle=function(){
	return (_isIE ? this.cell.innerText : this.cell.textContent);
}

dhtmlXGridCellObject.prototype.setCValue=function(val, val2){
	this.cell.innerHTML=val;
//#__pro_feature:21092006{
//#on_cell_changed:23102006{
	this.grid.callEvent("onCellChanged", [
		this.cell.parentNode.idd,
		this.cell._cellIndex,
		(arguments.length > 1 ? val2 : val)
	]);
//#}
//#}
}

dhtmlXGridCellObject.prototype.setCTxtValue=function(val){
	this.cell.innerHTML="";
	this.cell.appendChild(document.createTextNode(val));
//#__pro_feature:21092006{	
//#on_cell_changed:23102006{
	this.grid.callEvent("onCellChanged", [
		this.cell.parentNode.idd,
		this.cell._cellIndex,
		val
	]);
//#}
//#}
}

/**
*	@desc: sets text representation of cell which contains math formula ( setLabel doesn't triger math calculations as setValue do)
*	@param: val - new value
*	@type: public
*/
dhtmlXGridCellObject.prototype.setLabel=function(val){
	this.cell.innerHTML=val;
}

/**
*	@desc: get formula of ExCell ( actual only for math based exCells )
*	@type: public
*/
dhtmlXGridCellObject.prototype.getMath=function(){
	if (this._val)
		return this.val;
	else
		return this.getValue();
}

/**
*	@desc: dhtmlxGrid cell editor constructor (base for all eXcells). Shouldn't be accessed directly
*	@returns: dhtmlxGrid cell editor object
*	@type: public
*/
function eXcell(){
	this.obj=null; //editor
	//this.cell = null//cell to get value from
	this.val=null; //current value (before edit)
	/**
	*	@desc: occures on space for example 
	*	@type: private
	*/
	this.changeState=function(){
		return false
	}
	/**
	*	@desc: opens editor
	*	@type: private
	*/
	this.edit=function(){
		this.val=this.getValue()
	} //
	/**
	*	@desc: return value to cell, closes editor
	*	@returns: if cell's value was changed (true) or not
	*	@type: private
	*/
	this.detach=function(){
		return false
	} //
	/**
	*	@desc: gets position (left-right) of element
	*	@param: oNode - element to get position of
	*	@type: private
	*	@topic: 8
	*/
	this.getPosition=function(oNode){
		var oCurrentNode = oNode;
		var iLeft = 0;
		var iTop = 0;

		while (oCurrentNode.tagName != "BODY"){
			iLeft+=oCurrentNode.offsetLeft;
			iTop+=oCurrentNode.offsetTop;
			oCurrentNode=oCurrentNode.offsetParent;
		}
		return new Array(iLeft, iTop);
	}
}
eXcell.prototype=new dhtmlXGridCellObject;


/**
*	@desc: simple text editor
*	@returns: dhtmlxGrid cell editor object
*	@type: public
*/
function eXcell_ed(cell){
	if (cell){
		this.cell=cell;
		this.grid=this.cell.parentNode.grid;
	}
	this.edit=function(){
		this.cell.atag=(!this.grid.multiLine) ? "INPUT" : "TEXTAREA";
		this.val=this.getValue();
		this.obj=document.createElement(this.cell.atag);
		this.obj.setAttribute("autocomplete", "off");
		this.obj.style.height=(this.cell.offsetHeight-(_isIE ? 4 : 4))+"px";
		this.obj.className="dhx_combo_edit";
		this.obj.wrap="soft";
		this.obj.style.textAlign=this.cell.style.textAlign;
		this.obj.onclick=function(e){
			(e||event).cancelBubble=true
		}
		this.obj.onmousedown=function(e){
			(e||event).cancelBubble=true
		}
		this.obj.value=this.val
		this.cell.innerHTML="";
		this.cell.appendChild(this.obj);

		this.obj.onselectstart=function(e){
			if (!e)
				e=event;
			e.cancelBubble=true;
			return true;
		};
		if (_isIE){
			this.obj.focus();
			this.obj.blur();
		}
		this.obj.focus();
	}
	this.getValue=function(){
		if ((this.cell.firstChild)&&((this.cell.atag)&&(this.cell.firstChild.tagName == this.cell.atag)))
			return this.cell.firstChild.value;

		if (this.cell._clearCell)
			return "";

		return this.cell.innerHTML.toString()._dhx_trim();
	}

	this.detach=function(){
		this.setValue(this.obj.value);
		return this.val != this.getValue();
	}
}
eXcell_ed.prototype=new eXcell;

/**
*	@desc: pure text editor ( HTML not supported )
*	@returns: dhtmlxGrid cell editor object
*	@type: public
*/
function eXcell_edtxt(cell){
	if (cell){
		this.cell=cell;
		this.grid=this.cell.parentNode.grid;
	}
	this.getValue=function(){
		if ((this.cell.firstChild)&&((this.cell.atag)&&(this.cell.firstChild.tagName == this.cell.atag)))
			return this.cell.firstChild.value;

		if (this.cell._clearCell)
			return "";

		return (_isIE ? this.cell.innerText : this.cell.textContent);
	}
	this.setValue=function(val){
		if (!val||val.toString()._dhx_trim() == ""){
			val=" ";
			this.cell._clearCell=true;
		} else
			this.cell._clearCell=false;
		this.setCTxtValue(val);
	}
}
eXcell_edtxt.prototype=new eXcell_ed;
//#__pro_feature:21092006{
/**
*	@desc: simple numeric text editor
*	@returns: dhtmlxGrid cell editor object
*	@type: public
*	@edition: professional
*/
function eXcell_edn(cell){
	if (cell){
		this.cell=cell;
		this.grid=this.cell.parentNode.grid;
	}
	this.getValue=function(){
		//this.grid.editStop();
		if ((this.cell.firstChild)&&(this.cell.firstChild.tagName == "TEXTAREA"))
			return this.cell.firstChild.value;

		if (this.cell._clearCell)
			return "";

		return this.cell._orig_value||this.grid._aplNFb(this.cell.innerHTML.toString()._dhx_trim(), this.cell._cellIndex);
	}

	this.detach=function(){
		var tv = this.obj.value;
		this.setValue(tv);
		return this.val != this.getValue();
	}
}
eXcell_edn.prototype=new eXcell_ed;
eXcell_edn.prototype.setValue=function(val){ 
	if (!val||val.toString()._dhx_trim() == ""){
		this.cell._clearCell=true;
		return this.setCValue("&nbsp;",0);
	} else {
		this.cell._clearCell=false;
		this.cell._orig_value = val;
	}
	this.setCValue(this.grid._aplNF(val, this.cell._cellIndex), val);
}
//#}

//#ch_excell:04062008{
/**
*	@desc: checkbox editor
*	@returns: dhtmlxGrid cell editor object
*	@type: public
*/
function eXcell_ch(cell){
	if (cell){
		this.cell=cell;
		this.grid=this.cell.parentNode.grid;
	}

	this.disabledF=function(fl){
		if ((fl == true)||(fl == 1))
			this.cell.innerHTML=this.cell.innerHTML.replace("item_chk0.", "item_chk0_dis.").replace("item_chk1.",
				"item_chk1_dis.");
		else
			this.cell.innerHTML=this.cell.innerHTML.replace("item_chk0_dis.", "item_chk0.").replace("item_chk1_dis.",
				"item_chk1.");
	}

	this.changeState=function(fromClick){
		//nb:
		if (fromClick===true && !this.grid.isActive) {
			if (window.globalActiveDHTMLGridObject != null && window.globalActiveDHTMLGridObject != this.grid && window.globalActiveDHTMLGridObject.isActive) window.globalActiveDHTMLGridObject.setActive(false);
			this.grid.setActive(true);
		}
		if ((!this.grid.isEditable)||(this.cell.parentNode._locked)||(this.isDisabled()))
			return;

		if (this.grid.callEvent("onEditCell", [
			0,
			this.cell.parentNode.idd,
			this.cell._cellIndex
		])){
			this.val=this.getValue()

			if (this.val == "1")
				this.setValue("0")
			else
				this.setValue("1")

			this.cell.wasChanged=true;
			//nb:
			this.grid.callEvent("onEditCell", [
				1,
				this.cell.parentNode.idd,
				this.cell._cellIndex
			]);

			this.grid.callEvent("onCheckbox", [
				this.cell.parentNode.idd,
				this.cell._cellIndex,
				(this.val != '1')
			]);

			this.grid.callEvent("onCheck", [
				this.cell.parentNode.idd,
				this.cell._cellIndex,
				(this.val != '1')
			]);
		} else { //preserve editing (not tested thoroughly for this editor)
			this.editor=null;
		}
	}
	this.getValue=function(){
		return this.cell.chstate ? this.cell.chstate.toString() : "0";
	}

	this.isCheckbox=function(){
		return true;
	}
	this.isChecked=function(){
		if (this.getValue() == "1")
			return true;
		else
			return false;
	}

	this.setChecked=function(fl){
		this.setValue(fl.toString())
	}
	this.detach=function(){
		return this.val != this.getValue();
	}
	this.edit=null;
}
eXcell_ch.prototype=new eXcell;
eXcell_ch.prototype.setValue=function(val){
	this.cell.style.verticalAlign="middle"; //nb:to center checkbox in line
	//val can be int
	if (val){
		val=val.toString()._dhx_trim();

		if ((val == "false")||(val == "0"))
			val="";
	}

	if (val){
		val="1";
		this.cell.chstate="1";
	} else {
		val="0";
		this.cell.chstate="0"
	}
	var obj = this;
	this.setCValue("<img src='"+this.grid.imgURL+"item_chk"+val
		+".gif' onclick='new eXcell_ch(this.parentNode).changeState(true); (arguments[0]||event).cancelBubble=true; '>",
		this.cell.chstate);
}
//#}
//#ra_excell:04062008{
/**
*	@desc: radio editor
*	@returns: dhtmlxGrid cell editor object
*	@type: public
*/
function eXcell_ra(cell){
	this.base=eXcell_ch;
	this.base(cell)
	this.grid=cell.parentNode.grid;

	this.disabledF=function(fl){
		if ((fl == true)||(fl == 1))
			this.cell.innerHTML=this.cell.innerHTML.replace("radio_chk0.", "radio_chk0_dis.").replace("radio_chk1.",
				"radio_chk1_dis.");
		else
			this.cell.innerHTML=this.cell.innerHTML.replace("radio_chk0_dis.", "radio_chk0.").replace("radio_chk1_dis.",
				"radio_chk1.");
	}

	this.changeState=function(mode){
		if (mode===false && this.getValue()==1) return;

		if ((!this.grid.isEditable)||(this.cell.parentNode._locked)||(this.isDisabled()))
			return;

		if (this.grid.callEvent("onEditCell", [
			0,
			this.cell.parentNode.idd,
			this.cell._cellIndex
		]) != false){
			this.val=this.getValue()

			if (this.val == "1")
				this.setValue("0")
			else
				this.setValue("1")
			this.cell.wasChanged=true;
			//nb:
			this.grid.callEvent("onEditCell", [
				1,
				this.cell.parentNode.idd,
				this.cell._cellIndex
			]);

			this.grid.callEvent("onCheckbox", [
				this.cell.parentNode.idd,
				this.cell._cellIndex,
				(this.val != '1')
			]);

			this.grid.callEvent("onCheck", [
				this.cell.parentNode.idd,
				this.cell._cellIndex,
				(this.val != '1')
			]);
		} else { //preserve editing (not tested thoroughly for this editor)
			this.editor=null;
		}
	}
	this.edit=null;
}
eXcell_ra.prototype=new eXcell_ch;
eXcell_ra.prototype.setValue=function(val){
	this.cell.style.verticalAlign="middle"; //nb:to center checkbox in line

	if (val){
		val=val.toString()._dhx_trim();

		if ((val == "false")||(val == "0"))
			val="";
	}

	if (val){
		if (!this.grid._RaSeCol)
			this.grid._RaSeCol=[];

		if (this.grid._RaSeCol[this.cell._cellIndex]){
			var z = this.grid.cells4(this.grid._RaSeCol[this.cell._cellIndex]);
			z.setValue("0")
			if (this.grid.rowsAr[z.cell.parentNode.idd])
			this.grid.callEvent("onEditCell", [
				1,
				z.cell.parentNode.idd,
				z.cell._cellIndex
			]);
		}

		this.grid._RaSeCol[this.cell._cellIndex]=this.cell;

		val="1";
		this.cell.chstate="1";
	} else {
		val="0";
		this.cell.chstate="0"
	}
	this.setCValue("<img src='"+this.grid.imgURL+"radio_chk"+val+".gif' onclick='new eXcell_ra(this.parentNode).changeState(false);'>",
		this.cell.chstate);
}
//#}
//#txt_excell:04062008{
/**
*	@desc: multilene popup editor
*	@returns: dhtmlxGrid cell editor object
*	@type: public
*/
function eXcell_txt(cell){
	if (cell){
		this.cell=cell;
		this.grid=this.cell.parentNode.grid;
	}
	this.edit=function(){
		this.val=this.getValue();
		this.obj=document.createElement("TEXTAREA");
		this.obj.className="dhx_textarea";
		this.obj.onclick=function(e){
			(e||event).cancelBubble=true
		};
		var arPos = this.grid.getPosition(this.cell); //,this.grid.objBox

		this.obj.value=this.val;

		this.obj.style.display="";
		this.obj.style.textAlign=this.cell.style.textAlign;

		document.body.appendChild(this.obj); //nb:

		this.obj.onkeydown=function(e){
			var ev = (e||event);

			if (ev.keyCode == 9){
				globalActiveDHTMLGridObject.entBox.focus();
				globalActiveDHTMLGridObject.doKey({
					keyCode: ev.keyCode,
					shiftKey: ev.shiftKey,
					srcElement: "0"
				});

				return false;
			}
		};

		this.obj.style.left=arPos[0]+"px";
		//this.obj.style.top=arPos[1]+this.cell.offsetHeight+"px";
		this.obj.style.top=arPos[1]+"px";

		var pw = (this.cell.offsetWidth < 160) ? 160 : this.cell.offsetWidth;
		this.obj.style.width=pw+"px";

		this.obj.focus();
	};

	this.detach=function(){
		var a_val = "";

		a_val=this.obj.value;

		this.cell._clearCell = a_val == "";
		this.setValue(a_val);
		document.body.removeChild(this.obj);
		this.obj=null;
		return this.val != this.getValue();
	};

	this.getValue=function(){
		if (this.obj){
			return this.obj.value;
		}

		if (this.cell._clearCell)
			return "";

		if (typeof this.cell._brval != "undefined") return this.cell._brval;

		if ((!this.grid.multiLine))
			return this.cell._brval||this.cell.innerHTML;
		else
			return this.cell._brval||this.cell.innerHTML.replace(/<br[^>]*>/gi, "\n")._dhx_trim(); //innerText;
	}
}

eXcell_txt.prototype=new eXcell;

/**
*	@desc: multiline text editor without HTML support
*	@returns: dhtmlxGrid cell editor object
*	@type: public
*/
function eXcell_txttxt(cell){
	if (cell){
		this.cell=cell;
		this.grid=this.cell.parentNode.grid;
	}
	this.getValue=function(){
		if ((this.cell.firstChild)&&(this.cell.firstChild.tagName == "TEXTAREA"))
			return this.cell.firstChild.value;

		if (this.cell._clearCell)
			return "";

		if ((!this.grid.multiLine)&&this.cell._brval)
			return this.cell._brval;

		return (_isIE ? this.cell.innerText : this.cell.textContent);
	}
	this.setValue=function(val){
		this.cell._brval=val;

		if (!val||val.toString()._dhx_trim() == ""){
			val=" ";
			this.cell._clearCell=true;
		} else
			this.cell._clearCell=false;
		this.setCTxtValue(val);
	}
}

eXcell_txttxt.prototype=new eXcell_txt;

eXcell_txt.prototype.setValue=function(val){
	this.cell._brval=val;

	if (!val||val.toString()._dhx_trim() == ""){
		val="&nbsp;"
		this.cell._clearCell=true;
	} else
		this.cell._clearCell=false;

	if ((!this.grid.multiLine) || this.cell._clearCell)
		this.setCValue(val, this.cell._brval);
	else
		this.setCValue(val.replace(/\n/g, "<br/>"), val);
}
//#}
//#co_excell:04062008{
/**
*	@desc: combobox editor
*	@returns: dhtmlxGrid cell editor object
*	@type: public
*/
function eXcell_co(cell){
	if (cell){
		this.cell=cell;
		this.grid=this.cell.parentNode.grid;
		this.combo=(this.cell._combo||this.grid.getCombo(this.cell._cellIndex));
		this.editable=true
	}
	this.shiftNext=function(){
		var z = this.list.options[this.list.selectedIndex+1];

		if (z)
			z.selected=true;
		this.obj.value=this.list.options[this.list.selectedIndex].text;

		return true;
	}
	this.shiftPrev=function(){
		if (this.list.selectedIndex != 0){
			var z = this.list.options[this.list.selectedIndex-1];

			if (z)
				z.selected=true;
			this.obj.value=this.list.options[this.list.selectedIndex].text;
		}

		return true;
	}

	this.edit=function(){
		this.val=this.getValue();
		this.text=this.getText()._dhx_trim();
		var arPos = this.grid.getPosition(this.cell) //,this.grid.objBox)

		this.obj=document.createElement("TEXTAREA");
		this.obj.className="dhx_combo_edit";

		this.obj.style.height=(this.cell.offsetHeight-(_isIE ? 4 : 4))+"px";

		this.obj.wrap="soft";
		this.obj.style.textAlign=this.cell.style.textAlign;
		this.obj.onclick=function(e){
			(e||event).cancelBubble=true
		}
		this.obj.onmousedown=function(e){
			(e||event).cancelBubble=true
		}
		this.obj.value=this.text
		this.obj.onselectstart=function(e){
			if (!e)
				e=event;
			e.cancelBubble=true;
			return true;
		};
		var editor_obj = this;
		this.obj.onkeyup=function(e){
			var key=(e||event).keyCode;
			if (key==38 || key==40 || key==9) return;
			var val = this.readonly ? String.fromCharCode(key) : this.value;
			
			var c = editor_obj.list.options;

			for (var i = 0; i < c.length; i++)
				if (c[i].text.indexOf(val) == 0)
					return c[i].selected=true;
		}
		this.list=document.createElement("SELECT");

		this.list.className='dhx_combo_select';
		this.list.style.width=this.cell.offsetWidth+"px";
		this.list.style.left=arPos[0]+"px";                       //arPos[0]
		this.list.style.top=arPos[1]+this.cell.offsetHeight+"px"; //arPos[1]+this.cell.offsetHeight;
		this.list.onclick=function(e){
			var ev = e||window.event;
			var cell = ev.target||ev.srcElement

			//tbl.editor_obj.val=cell.combo_val;
			if (cell.tagName == "OPTION")
				cell=cell.parentNode;
			//editor_obj.list.value = cell.value;
			editor_obj.editable=false;
			editor_obj.grid.editStop();
			ev.cancelBubble = true;
		}
		var comboKeys = this.combo.getKeys();
		var fl = false
		var selOptId = 0;

		for (var i = 0; i < comboKeys.length; i++){
			var val = this.combo.get(comboKeys[i])
			this.list.options[this.list.options.length]=new Option(val, comboKeys[i]);

			if (comboKeys[i] == this.val){
				selOptId=this.list.options.length-1;
				fl=true;
			}
		}

		if (fl == false){ //if no such value in combo list
			this.list.options[this.list.options.length]=new Option(this.text, this.val === null ? "" : this.val);
			selOptId=this.list.options.length-1;
		}
		document.body.appendChild(this.list) //nb:this.grid.objBox.appendChild(this.listBox);
		this.list.size="6";
		this.cstate=1;

		if (this.editable){
			this.cell.innerHTML="";
		}
		else {
			this.obj.style.width="1px";
			this.obj.style.height="1px";
		}
		this.cell.appendChild(this.obj);
		this.list.options[selOptId].selected=true;

		//fix for coro - FF scrolls grid in incorrect position
		if (this.editable){
			this.obj.focus();
			this.obj.focus();
		}

		if (!this.editable){
			this.obj.style.visibility="hidden";
			this.list.focus();
			this.list.onkeydown=function(e){
				e=e||window.event;
				editor_obj.grid.setActive(true)

				if (e.keyCode < 30)
					return editor_obj.grid.doKey({
						target: editor_obj.cell,
						keyCode: e.keyCode,
						shiftKey: e.shiftKey,
						ctrlKey: e.ctrlKey
						})
			}
		}
	}

	this.getValue=function(){
		return ((this.cell.combo_value == window.undefined) ? "" : this.cell.combo_value);
	}
	this.detach=function(){
		if (this.val != this.getValue()){
			this.cell.wasChanged=true;
		}

		if (this.list.parentNode != null){
			if (this.editable){
					var ind = this.list.options[this.list.selectedIndex]
					if (ind&&ind.text == this.obj.value)
						this.setValue(this.list.value)
					else{
						var combo=(this.cell._combo||this.grid.getCombo(this.cell._cellIndex));
						var val=combo.values._dhx_find(this.obj.value);
						if (val!=-1) this.setValue(combo.keys[val]);
						else this.setValue(this.cell.combo_value=this.obj.value);
					}
			}
			else
				this.setValue(this.list.value)
		}

		if (this.list.parentNode)
			this.list.parentNode.removeChild(this.list);

		if (this.obj.parentNode)
			this.obj.parentNode.removeChild(this.obj);

		return this.val != this.getValue();
	}
}
eXcell_co.prototype=new eXcell;
eXcell_co.prototype.getText=function(){
	return this.cell.innerHTML;
}
eXcell_co.prototype.setValue=function(val){
	if (typeof (val) == "object"){
		var optCol = dhx4.ajax.xpath("./option", val);

		if (optCol.length)
			this.cell._combo=new dhtmlXGridComboObject();

		for (var j = 0;
			j < optCol.length;
			j++)this.cell._combo.put(optCol[j].getAttribute("value"),
			optCol[j].firstChild
				? optCol[j].firstChild.data
				: "");
		val=val.firstChild.data;
	}

	if ((val||"").toString()._dhx_trim() == "")
		val=null
	this.cell.combo_value=val;
	
	if (val !== null){
		var label = (this.cell._combo||this.grid.getCombo(this.cell._cellIndex)).get(val);
		this.setCValue(label===null?val:label, val);
	}else
		this.setCValue("&nbsp;", val);

	
}
/**
*	@desc: selectbox editor
*	@returns: dhtmlxGrid cell editor object
*	@type: public
*/
function eXcell_coro(cell){
	this.base=eXcell_co;
	this.base(cell)
	this.editable=false;
}
eXcell_coro.prototype=new eXcell_co;

function eXcell_cotxt(cell){
	this.base=eXcell_co;
	this.base(cell)
}
eXcell_cotxt.prototype=new eXcell_co;
eXcell_cotxt.prototype.getText=function(){
	return (_isIE ? this.cell.innerText : this.cell.textContent);
}
eXcell_cotxt.prototype.setValue=function(val){
	if (typeof (val) == "object"){
		var optCol = dhx4.ajax.xpath("./option", val);

		if (optCol.length)
			this.cell._combo=new dhtmlXGridComboObject();

		for (var j = 0;
			j < optCol.length;
			j++)this.cell._combo.put(optCol[j].getAttribute("value"),
			optCol[j].firstChild
				? optCol[j].firstChild.data
				: "");
		val=val.firstChild.data;
	}

	if ((val||"").toString()._dhx_trim() == "")
		val=null

	if (val !== null)
		this.setCTxtValue((this.cell._combo||this.grid.getCombo(this.cell._cellIndex)).get(val)||val, val);
	else
		this.setCTxtValue(" ", val);

	this.cell.combo_value=val;
}

function eXcell_corotxt(cell){
	this.base=eXcell_co;
	this.base(cell)
	this.editable=false;
}
eXcell_corotxt.prototype=new eXcell_cotxt;
//#}

//#cp_excell:04062008{
/**
*	@desc: color picker editor
*	@returns: dhtmlxGrid cell editor object
*	@type: public
*/
function eXcell_cp(cell){
	try{
		this.cell=cell;
		this.grid=this.cell.parentNode.grid;
	}
	catch (er){}
	this.edit=function(){
		this.val=this.getValue()
		this.obj=document.createElement("SPAN");
		this.obj.style.border="1px solid black";
		this.obj.style.position="absolute";
		var arPos = this.grid.getPosition(this.cell); //,this.grid.objBox
		this.colorPanel(4, this.obj)
		document.body.appendChild(this.obj);          //this.grid.objBox.appendChild(this.obj);
		this.obj.style.left=arPos[0]+"px";
		this.obj.style.zIndex=1000;
		this.obj.style.top=arPos[1]+this.cell.offsetHeight+"px";
	}
	this.toolDNum=function(value){
		if (value.length == 1)
			value='0'+value;
		return value;
	}
	this.colorPanel=function(index, parent){
		var tbl = document.createElement("TABLE");
		parent.appendChild(tbl)
		tbl.cellSpacing=0;
		tbl.editor_obj=this;
		tbl.style.cursor="default";
		tbl.onclick=function(e){
			var ev = e||window.event
			var cell = ev.target||ev.srcElement;
			var ed = cell.parentNode.parentNode.parentNode.editor_obj
			ed.setValue(cell._bg)
			ed.grid.editStop();
		}
		var cnt = 256 / index;
		for (var j = 0; j <= (256 / cnt); j++){
			var r = tbl.insertRow(j);

			for (var i = 0; i <= (256 / cnt); i++){
				for (var n = 0; n <= (256 / cnt); n++){
					R=new Number(cnt*j)-(j == 0 ? 0 : 1)
					G=new Number(cnt*i)-(i == 0 ? 0 : 1)
					B=new Number(cnt*n)-(n == 0 ? 0 : 1)
					var rgb =
						this.toolDNum(R.toString(16))+""+this.toolDNum(G.toString(16))+""+this.toolDNum(B.toString(16));
					var c = r.insertCell(i);
					c.width="10px";
					c.innerHTML="&nbsp;"; //R+":"+G+":"+B;//
					c.title=rgb.toUpperCase()
					c.style.backgroundColor="#"+rgb
					c._bg="#"+rgb;

					if (this.val != null&&"#"+rgb.toUpperCase() == this.val.toUpperCase()){
						c.style.border="2px solid white"
					}
				}
			}
		}
	}
	this.getValue=function(){
		return this.cell.firstChild._bg||""; //this.getBgColor()
	}
	this.getRed=function(){
		return Number(parseInt(this.getValue().substr(1, 2), 16))
	}
	this.getGreen=function(){
		return Number(parseInt(this.getValue().substr(3, 2), 16))
	}
	this.getBlue=function(){
		return Number(parseInt(this.getValue().substr(5, 2), 16))
	}
	this.detach=function(){
		if (this.obj.offsetParent != null)
			document.body.removeChild(this.obj);
		//this.obj.removeNode(true)
		return this.val != this.getValue();
	}
}
eXcell_cp.prototype=new eXcell;
eXcell_cp.prototype.setValue=function(val){
    this.setCValue("<div style='width:100%;height:"+((this.grid.multiLine?"100%":23))+";background-color:"+(val||"")
		+";border:0px;'>&nbsp;</div>",
		val);
	this.cell.firstChild._bg=val;
}
//#}

//#img_excell:04062008{
/**
*	@desc: image editor
*	@returns: dhtmlxGrid cell editor object
*	@type: public
*/
/*
	The corresponding  cell value in XML should be a "^" delimited list of following values:
	1st - image src
	2nd - image alt text (optional)
	3rd - link (optional)
	4rd - target (optional, default is _self)
*/
function eXcell_img(cell){
	try{
		this.cell=cell;
		this.grid=this.cell.parentNode.grid;
	}
	catch (er){}
	this.getValue=function(){
		if (this.cell.firstChild.tagName == "IMG")
			return this.cell.firstChild.src+(this.cell.titFl != null
				? "^"+this.cell._brval
				: "");
			else if (this.cell.firstChild.tagName == "A"){
			var out = this.cell.firstChild.firstChild.src+(this.cell.titFl != null ? "^"+this.cell._brval : "");
			out+="^"+this.cell.lnk;

			if (this.cell.trg)
				out+="^"+this.cell.trg
			return out;
		}
	}
	this.isDisabled=function(){
		return true;
	}
}
eXcell_img.prototype=new eXcell;
eXcell_img.prototype.getTitle=function(){
	return this.cell._brval
}
eXcell_img.prototype.setValue=function(val){
	var title = val;

	if ((val||"").indexOf("^") != -1){
		var ar = val.split("^");
		val=ar[0]
		title=this.cell._attrs.title||ar[1];

		//link
		if (ar.length > 2){
			this.cell.lnk=ar[2]

			if (ar[3])
				this.cell.trg=ar[3]
		}
		this.cell.titFl="1";
	}
	this.setCValue("<img src='"+this.grid.iconURL+(val||"")._dhx_trim()+"' border='0'>", val);

	if (this.cell.lnk){
		this.cell.innerHTML="<a href='"+this.cell.lnk+"' target='"+this.cell.trg+"'>"+this.cell.innerHTML+"</a>"
	}
	this.cell._brval=title;
}
//#}

//#price_excell:04062008{
/**
*	@desc: text editor with price (USD) formatting
*	@returns: dhtmlxGrid cell editor object
*	@type: public
*/
function eXcell_price(cell){
	this.base=eXcell_ed;
	this.base(cell)
	this.getValue=function(){
		if (this.cell.childNodes.length > 1)
			return this.cell.childNodes[1].innerHTML.toString()._dhx_trim()
		else
			return "0";
	}
}

eXcell_price.prototype=new eXcell_ed;
eXcell_price.prototype.setValue=function(val){
	if (isNaN(parseFloat(val))){
		val=this.val||0;
	}
	var color = "green";

	if (val < 0)
		color="red";

	this.setCValue("<span>$</span><span style='padding-right:2px;color:"+color+";'>"+val+"</span>", val);
}
//#}

//#dyn_excells:04062008{
/**
*	@desc: text editor with additional formatting for positive and negative numbers (arrow down/up and color)
*	@returns: dhtmlxGrid cell editor object
*	@type: public
*/
function eXcell_dyn(cell){
	this.base=eXcell_ed;
	this.base(cell)
	this.getValue=function(){
		return this.cell.firstChild.childNodes[1].innerHTML.toString()._dhx_trim()
	}
}

eXcell_dyn.prototype=new eXcell_ed;
eXcell_dyn.prototype.setValue=function(val){
	if (!val||isNaN(Number(val))){
		if (val!=="")
			val=0;
	}

	if (val > 0){
		var color = "green";
		var img = "dyn_up.gif";
	} else if (val == 0){
		var color = "black";
		var img = "dyn_.gif";
	} else {
		var color = "red";
		var img = "dyn_down.gif";
	}
	this.setCValue("<div style='position:relative;padding-right:2px; width:100%;overflow:hidden; white-space:nowrap;'><img src='"+this.grid.imgURL+""+img
		+"' height='15' style='position:absolute;top:0px;left:0px;'><span style=' padding-left:20px; width:100%;color:"+color+";'>"+val
		+"</span></div>",
		val);
}
//#}

/**
*	@desc: readonly editor
*	@returns: dhtmlxGrid cell editor object
*	@type: public
*/
function eXcell_ro(cell){
	if (cell){
		this.cell=cell;
		this.grid=this.cell.parentNode.grid;
	}
	this.edit=function(){
	}

	this.isDisabled=function(){
		return true;
	}
	this.getValue=function(){
		return this.cell._clearCell?"":this.cell.innerHTML.toString()._dhx_trim();
	}
}
eXcell_ro.prototype=new eXcell;


window.eXcell_hidden = function(cell){
	if (cell){
		this.cell=cell;
		this.grid=this.cell.parentNode.grid;
	}
	this.edit=function(){
	}

	this.isDisabled=function(){
		return true;
	}
	this.getValue=function(){
		return this.cell.val;
	}
}
eXcell_hidden.prototype=new eXcell;
eXcell_hidden.prototype.setValue = function(value){
	this.cell.val = value;
}

function eXcell_ron(cell){
	this.cell=cell;
	this.grid=this.cell.parentNode.grid;
	this.edit=function(){
	}

	this.isDisabled=function(){
		return true;
	}
	this.getValue=function(){
		return this.cell._clearCell?"":this.grid._aplNFb(this.cell.innerHTML.toString()._dhx_trim(), this.cell._cellIndex).toString();
	}
}
eXcell_ron.prototype=new eXcell;
eXcell_ron.prototype.setValue=function(val){ 
	if (val === 0){}
	else if (!val||val.toString()._dhx_trim() == ""){
		this.setCValue("&nbsp;");
		return this.cell._clearCell=true;
	}
	this.cell._clearCell=false;
	this.setCValue(val?this.grid._aplNF(val, this.cell._cellIndex):"0");
}


/**
*	@desc: readonly pure text editor (without HTML support)
*	@returns: dhtmlxGrid cell editor object
*	@type: public
*/
function eXcell_rotxt(cell){
	this.cell=cell;
	this.grid=this.cell.parentNode.grid;
	this.edit=function(){
	}

	this.isDisabled=function(){
		return true;
	}
	this.setValue=function(val){
		if (!val){
			val=" ";
			this.cell._clearCell = true;
		}
		else
			this.cell._clearCell = false;
			
		this.setCTxtValue(val);
	}
	this.getValue=function(){
		if (this.cell._clearCell)
			return "";
		return (_isIE ? this.cell.innerText : this.cell.textContent);
	}	
}
eXcell_rotxt.prototype=new eXcell;

/**
	*	@desc: combobox object constructor (shouldn't be accessed directly - instead please use getCombo(...) method of the grid)
	*	@type: private
	*	@returns: combobox for dhtmlxGrid
	*/
function dhtmlXGridComboObject(){
	this.keys=new dhtmlxArray();
	this.values=new dhtmlxArray();
	/**
	*	@desc: puts new combination of key and value into combobox
	*	@type: public
	*	@param: key - object to use as a key (should be a string in the case of combobox)
	*	@param: value - object value of combobox line
	*/
	this.put=function(key, value){
		for (var i = 0; i < this.keys.length; i++){
			if (this.keys[i] == key){
				this.values[i]=value;
				return true;
			}
		}
		this.values[this.values.length]=value;
		this.keys[this.keys.length]=key;
	}
	/**
	*	@desc: gets value corresponding to the given key
	*	@type: public
	*	@param: key - object to use as a key (should be a string in the case of combobox)
	*	@returns: value correspond. to given key or null if no such key
	*/
	this.get=function(key){
		for (var i = 0; i < this.keys.length; i++){
			if (this.keys[i] == key){
				return this.values[i];
			}
		}
		return null;
	}
	/**
	*	@desc: clears combobox
	*	@type: public
	*/
	this.clear=function(){
		/*for(var i=0;i<this.keys.length;i++){
				this.keys._dhx_removeAt(i);
				this.values._dhx_removeAt(i);
		}*/
		this.keys=new dhtmlxArray();
		this.values=new dhtmlxArray();
	}
	/**
	*	@desc: remove pair of key-value from combobox with given key 
	*	@type: public
	*	@param: key - object to use as a key
	*/
	this.remove=function(key){
		for (var i = 0; i < this.keys.length; i++){
			if (this.keys[i] == key){
				this.keys._dhx_removeAt(i);
				this.values._dhx_removeAt(i);
				return true;
			}
		}
	}
	/**
	*	@desc: gets the size of combobox 
	*	@type: public
	*	@returns: current size of combobox
	*/
	this.size=function(){
		var j = 0;

		for (var i = 0; i < this.keys.length; i++){
			if (this.keys[i] != null)
				j++;
		}
		return j;
	}
	/**
	*	@desc: gets array of all available keys present in combobox
	*	@type: public
	*	@returns: array of all available keys
	*/
	this.getKeys=function(){
		var keyAr = new Array(0);

		for (var i = 0; i < this.keys.length; i++){
			if (this.keys[i] != null)
				keyAr[keyAr.length]=this.keys[i];
		}
		return keyAr;
	}

	/**
	*	@desc: save curent state
	*	@type: public
	*/
	this.save=function(){
		this._save=new Array();

		for (var i = 0; i < this.keys.length; i++)this._save[i]=[
			this.keys[i],
			this.values[i]
		];
	}


	/**
	*	@desc: restore saved state
	*	@type: public
	*/
	this.restore=function(){
		if (this._save){
			this.keys[i]=new Array();
			this.values[i]=new Array();

			for (var i = 0; i < this._save.length; i++){
				this.keys[i]=this._save[i][0];
				this.values[i]=this._save[i][1];
			}
		}
	}
	return this;
}

function Hashtable(){
	this.keys=new dhtmlxArray();
	this.values=new dhtmlxArray();
	return this;
}
Hashtable.prototype=new dhtmlXGridComboObject;

//(c)dhtmlx ltd. www.dhtmlx.com
if (typeof(window.dhtmlXCellObject) != "undefined") {
	
	dhtmlXCellObject.prototype.attachGrid = function() {
		
		var obj = document.createElement("DIV");
		obj.style.width = "100%";
		obj.style.height = "100%";
		obj.style.position = "relative";
		obj.style.overflow = "hidden";
		this._attachObject(obj);
		
		this.dataType = "grid";
		this.dataObj = new dhtmlXGridObject(obj);
		this.dataObj.setSkin(this.conf.skin);
		
		// keep border for window and remove for other
		if (this.conf.skin == "dhx_skyblue" && typeof(window.dhtmlXWindowsCell) != "undefined" && this instanceof window.dhtmlXWindowsCell) {
			this.dataObj.entBox.style.border = "1px solid #a4bed4";
			this.dataObj._sizeFix = 0;
		} else {
			this.dataObj.entBox.style.border = "0px solid white";
			this.dataObj._sizeFix = 2;
		}
		
		obj = null;
		
		this.callEvent("_onContentAttach",[]);
		
		/**
		 *  ����, ���� ��������
		 */
		this.dataObj.objBox.ontouchend = function(){
			try{
				this.hdrBox.scrollLeft=this.objBox.scrollLeft;
			}catch(e){}
		};
		
		return this.dataObj;
	};
	
}


/*
Product Name: dhtmlxSuite 
Version: 4.1.3 
Edition: Professional 
License: content of this file is covered by DHTMLX Commercial or Enterprise license. Usage without proper license is prohibited. To obtain it contact sales@dhtmlx.com
Copyright UAB Dinamenta http://www.dhtmlx.com
*/

/**
*     @desc: enable/disable drag-and-drop
*     @type: public
*     @param: mode - enabled/disabled [ can be true/false/temporary_disabled - last value mean that tree can be D-n-D can be switched to true later ]
*     @topic: 0
*/
   dhtmlXGridObject.prototype.enableDragAndDrop=function(mode){
        if  (mode=="temporary_disabled"){
            this.dADTempOff=false;
            mode=true;                  }
        else
            this.dADTempOff=true;

		this.dragAndDropOff=dhx4.s2b(mode);
		this._drag_validate=true;
		if (mode)
			this.objBox.ondragstart = function (e) {
				(e||event).cancelBubble = true;
				return false;
			}
       };

/**
*     @desc: set Drag-And-Drop behavior (child - drop as chils, sibling - drop as sibling
*     @type: public
*     @param: mode - behavior name (child,sibling,complex)
*     @topic: 0
*/
dhtmlXGridObject.prototype.setDragBehavior=function(mode){
        this.dadmodec=this.dadmodefix=0;
      switch (mode) {
         case "child": this.dadmode=0; this._sbmod=false;  break;
         case "sibling": this.dadmode=1; this._sbmod=false;  break;
         case "sibling-next": this.dadmode=1; this._sbmod=true; break;
         case "complex": this.dadmode=2; this._sbmod=false;  break;
         case "complex-next": this.dadmode=2; this._sbmod=true;  break;
      }    };


/**
*     @desc: switch to mode when draged item, droped in target location in same order as they was in source grid
*     @type: public
*     @param: mode - true/false to enable/disable mode
*     @topic: 0
*/
dhtmlXGridObject.prototype.enableDragOrder=function(mode){
        this._dndorder=dhx4.s2b(mode);
};


dhtmlXGridObject.prototype._checkParent=function(row,ids){
	var z=this._h2.get[row.idd].parent;
	if (!z.parent) return;
	for (var i=0; i<ids.length; i++) 
		if (ids[i]==z.id) return true;
		
	return this._checkParent(this.rowsAr[z.id],ids);
}

/**
*     @desc: create html element for dragging
*     @type: private
*     @param: htmlObject - html node object
*     @topic: 1
*/
dhtmlXGridObject.prototype._createDragNode=function(htmlObject,e){
	  this.editStop();
	  if (window.dhtmlDragAndDrop.dragNode) return null;
      if (!this.dADTempOff) return null;
      htmlObject.parentObject=new Object();
      htmlObject.parentObject.treeNod=this;

	var text=this.callEvent("onBeforeDrag",[htmlObject.parentNode.idd,htmlObject._cellIndex, e]);
	if (!text) return null;

      var z=new Array();
//#__pro_feature:21092006{
      z=this.getSelectedId();
	  z=(((z)&&(z!=""))?z.split(this.delim):[]);
      var exst=false;
      for (var i=0; i<z.length; i++)
        if (z[i]==htmlObject.parentNode.idd)  exst=true;
      if (!exst){
      	this.selectRow(this.rowsAr[htmlObject.parentNode.idd],false,e.ctrlKey,false);
      	if (!e.ctrlKey) {
      		z=[];
  		}
//#}
          z[this.selMultiRows?z.length:0]=htmlObject.parentNode.idd;
//#__pro_feature:21092006{
    }
//#}

	//remove child in case of treeGrid
	if (this.isTreeGrid()){
		for (var i=z.length-1; i>=0; i--) 
			if (this._checkParent(this.rowsAr[z[i]],z)) z.splice(i,1);
				
	}
	

	var self=this;
	if (z.length && this._dndorder)
		z.sort(function(a,b){ return (self.rowsAr[a].rowIndex>self.rowsAr[b].rowIndex?1:-1); });

     var el = this.getFirstParentOfType(_isIE?e.srcElement:e.target,"TD");
     if (el) this._dndExtra=el._cellIndex;
      this._dragged=new Array();
      for (var i=0; i<z.length; i++)
          if (this.rowsAr[z[i]]){
          this._dragged[this._dragged.length]=this.rowsAr[z[i]];
          this.rowsAr[z[i]].treeNod=this;
          }

      htmlObject.parentObject.parentNode=htmlObject.parentNode;

   var dragSpan=document.createElement('div');
   dragSpan.innerHTML=(text!==true?text:this.rowToDragElement(htmlObject.parentNode.idd));
   dragSpan.style.position="absolute";
   dragSpan.className="dragSpanDiv";
   return dragSpan;
}



/**
*   @desc:  create a drag visual marker
*   @type:  private
*/
dhtmlXGridObject.prototype._createSdrgc=function(){
    this._sdrgc=document.createElement("DIV");
    this._sdrgc.innerHTML="&nbsp;";
    this._sdrgc.className="gridDragLine";
    this.objBox.appendChild(this._sdrgc);
}











/**
*   @desc:  create a drag context object
*   @type:  private
*/
function dragContext(a,b,c,d,e,f,j,h,k,l){
    this.source=a||"grid";
    this.target=b||"grid";
    this.mode=c||"move";
    this.dropmode=d||"child";
    this.sid=e||0;
    this.tid=f;
    this.sobj=j||null;
    this.tobj=h||null;
   this.sExtra=k||null;
   this.tExtra=l||null;
    return this;
}
/**
*   @desc:  check is operation possible
*   @type:  private
*/
dragContext.prototype.valid=function(){
   if (this.sobj!=this.tobj) return true;
   if (this.sid==this.tid) return false;
   if (this.target=="treeGrid"){
      var z=this.tid
      while (z = this.tobj.getParentId(z) ){
         if (this.sid==z) return false;
         }
   }
   return true;
}
/**
*   @desc:  close context
*   @type:  private
*/
dragContext.prototype.close=function(){
    this.sobj=null;
    this.tobj=null;
}
/**
*   @desc:  return copy of context
*   @type:  private
*/
dragContext.prototype.copy=function(){
    return new dragContext(this.source,this.target,this.mode,this.dropmode,this.sid,this.tid,this.sobj,this.tobj,this.sExtra,this.tExtra);
}
/**
*   @desc:  set a lue of context attribute
*   @type:  private
*/
dragContext.prototype.set=function(a,b){
    this[a]=b;
    return this;
}
/**
*   @desc:  generate an Id for new node
*   @type:  private
*/
dragContext.prototype.uid=function(a,b){
    this.nid=this.sid;
    while (this.tobj.rowsAr[this.nid])
        this.nid=this.nid+((new Date()).valueOf());

    return this;
}
/**
*   @desc:  get data array for grid row
*   @type:  private
*/
dragContext.prototype.data=function(){
    if (this.sobj==this.tobj)
        return this.sobj._getRowArray(this.sobj.rowsAr[this.sid]);
    if (this.source=="tree")
        return this.tobj.treeToGridElement(this.sobj,this.sid,this.tid);
    else
        return this.tobj.gridToGrid(this.sid,this.sobj,this.tobj);
}
dragContext.prototype.attrs=function(){
    if (this.source=="tree")
        return {};
    else
        return this.sobj.rowsAr[this.sid]._attrs;
}
dragContext.prototype.childs=function(){
    if (this.source=="treeGrid")
		return this.sobj._h2.get[this.sid]._xml_await?this.sobj._h2.get[this.sid].has_kids:null;
	return null;
}

/**
*   @desc:  return parent id for row in context
*   @type:  private
*/
dragContext.prototype.pid=function(){
    if (!this.tid) return 0;
	if (!this.tobj._h2) return 0;
    if (this.target=="treeGrid")
        if (this.dropmode=="child")
            return this.tid;
        else{
			var z=this.tobj.rowsAr[this.tid];
			var apid=this.tobj._h2.get[z.idd].parent.id;
			if ((this.alfa)&&(this.tobj._sbmod)&&(z.nextSibling)){
				var zpid=this.tobj._h2.get[z.nextSibling.idd].parent.id;
				if (zpid==this.tid)
            		return this.tid;
				if (zpid!=apid)
            		return zpid;
			}
	        return apid;
	   }
}
/**
*   @desc:  get index of target position
*   @type:  private
*/
dragContext.prototype.ind=function(){ 
    if (this.tid==window.unknown) return this.tobj.rowsBuffer.length;
    if (this.target=="treeGrid"){
      if (this.dropmode=="child")
            this.tobj.openItem(this.tid);
      else
         this.tobj.openItem(this.tobj.getParentId(this.tid));
   }
    var ind=this.tobj.rowsBuffer._dhx_find(this.tobj.rowsAr[this.tid]);
	if ((this.alfa)&&(this.tobj._sbmod)&&(this.dropmode=="sibling")){
		var z=this.tobj.rowsAr[this.tid];
		if ((z.nextSibling)&&(this._h2.get[z.nextSibling.idd].parent.id==this.tid))
			return ind+1;
	}

    return (ind+1+((this.target=="treeGrid" && ind>=0 && this.tobj._h2.get[this.tobj.rowsBuffer[ind].idd].state=="minus")?this.tobj._getOpenLenght(this.tobj.rowsBuffer[ind].idd,0):0));
}
/**
*   @desc:  get row related image
*   @type:  private
*/
dragContext.prototype.img=function(){
    if ((this.target!="grid")&&(this.sobj._h2))
      return this.sobj.getItemImage(this.sid);
   else return null;
}

/**
*   @desc:  return list of rows in context
*   @type:  private
*/
dragContext.prototype.slist=function(){
    var res=new Array();
    for (var i=0; i<this.sid.length; i++)
        res[res.length]=this.sid[i][(this.source=="tree")?"id":"idd"];

    return res.join(",");
}


/**
*   @desc:  drag entry point
*   @type:  private
*/
dhtmlXGridObject.prototype._drag=function(sourceHtmlObject,dhtmlObject,targetHtmlObject,lastLanding){
   if (this._realfake) return this._fake._drag()	
   
   var z=(this.lastLanding)
    //close unfinished tasks
    if  (this._autoOpenTimer) window.clearTimeout(this._autoOpenTimer);

    //detect details
    var r1=targetHtmlObject.parentNode;
    var r2=sourceHtmlObject.parentObject;
    //drop on header
    if (!r1.idd) { r1.grid=this;    this.dadmodefix=0; }

    var c=new dragContext(0,0,0,((r1.grid.dadmode==1 || r1.grid.dadmodec)?"sibling":"child"));


    if (r2 && r2.childNodes)
        c.set("source","tree").set("sobj",r2.treeNod).set("sid",c.sobj._dragged);
    else{
    	if (!r2) return true;
        if (r2.treeNod.isTreeGrid && r2.treeNod.isTreeGrid())
        	c.set("source","treeGrid");
        c.set("sobj",r2.treeNod).set("sid",c.sobj._dragged);
        }

    if (r1.grid.isTreeGrid())
        c.set("target","treeGrid");
	else
		c.set("dropmode","sibling");
    c.set("tobj",r1.grid).set("tid",r1.idd);

//#__pro_feature:21092006{
    //complex drag mode - adjust tartget element
    if (((c.tobj.dadmode==2)&&(c.tobj.dadmodec==1))&&(c.tobj.dadmodefix<0))
       if (c.tobj.obj.rows[1].idd!=c.tid) c.tid=r1.previousSibling.idd;
       else c.tid=0;
//#}

   var el = this.getFirstParentOfType(lastLanding,"TD")
   if (el) c.set("tExtra",el._cellIndex);
   if (el) c.set("sExtra",c.sobj._dndExtra);

    if (c.sobj.dpcpy) c.set("mode","copy");
    
    if (c.tobj._realfake) c.tobj=c.tobj._fake;
    if (c.sobj._realfake) c.sobj=c.sobj._fake;
    
    c.tobj._clearMove();
    
	if (r2 && r2.treeNod && r2.treeNod._nonTrivialRow)
		r2.treeNod._nonTrivialRow(this,c.tid,c.dropmode,r2);
	else {
		c.tobj.dragContext=c;
	    if (!c.tobj.callEvent("onDrag",[c.slist(),c.tid,c.sobj,c.tobj,c.sExtra,c.tExtra]))  return  c.tobj.dragContext=null;
	
	   //all ready, start mantras
	   var result=new Array();
	   if (typeof(c.sid)=="object"){
	        var nc=c.copy();
	        for (var i=0; i<c.sid.length; i++){
	         if (!nc.set("alfa",(!i)).set("sid",c.sid[i][(c.source=="tree"?"id":"idd")]).valid()) continue;
	            nc.tobj._dragRoutine(nc);
	            if (nc.target=="treeGrid" && nc.dropmode == "child") nc.tobj.openItem(nc.tid);
	            result[result.length]=nc.nid;
	         nc.set("dropmode","sibling").set("tid",nc.nid);
	            }
	        nc.close();
	        }
	    else
	       c.tobj._dragRoutine(c);		

	   //finish math if any awaiting
	   if (c.tobj.laterLink) c.tobj.laterLink();
	   //destroy context
		c.tobj.callEvent("onDrop",[c.slist(),c.tid,result.join(","),c.sobj,c.tobj,c.sExtra,c.tExtra]);
	}

   c.tobj.dragContext=null;
   c.close();
}


/**
*   @desc:  context drag routine
*   @type:  private
*/
dhtmlXGridObject.prototype._dragRoutine=function(c){
      if ((c.sobj==c.tobj)&&(c.source=="grid")&&(c.mode=="move")&&!this._fake){
         //special case for moving rows in same grid
         if (c.sobj._dndProblematic) return;
         var fr=c.sobj.rowsAr[c.sid];
         var bind=c.sobj.rowsCol._dhx_find(fr);
         c.sobj.rowsCol._dhx_removeAt(c.sobj.rowsCol._dhx_find(fr));
         c.sobj.rowsBuffer._dhx_removeAt(c.sobj.rowsBuffer._dhx_find(fr));
         c.sobj.rowsBuffer._dhx_insertAt(c.ind(),fr);
         if (c.tobj._fake){
         	c.tobj._fake.rowsCol._dhx_removeAt(bind);
         	var tr=c.tobj._fake.rowsAr[c.sid];
         	tr.parentNode.removeChild(tr);
     	 }         
         c.sobj._insertRowAt(fr,c.ind());

         c.nid=c.sid;
         c.sobj.callEvent("onGridReconstructed",[]);
         return;
      }
      var new_row;
		if (this._h2 && typeof c.tid !="undefined" && c.dropmode=="sibling" && (this._sbmod || c.tid)){
			if (c.alfa && this._sbmod && this._h2.get[c.tid].childs.length){
				this.openItem(c.tid)
				new_row=c.uid().tobj.addRowBefore(c.nid,c.data(),this._h2.get[c.tid].childs[0].id,c.img(),c.childs());
			}
			else
			new_row=c.uid().tobj.addRowAfter(c.nid,c.data(),c.tid,c.img(),c.childs());
			}
		else
        	new_row=c.uid().tobj.addRow(c.nid,c.data(),c.ind(),c.pid(),c.img(),c.childs());

          new_row._attrs = c.attrs();
		
		
        if (c.source=="tree"){
        	this.callEvent("onRowAdded",[c.nid]);            
            var sn=c.sobj._globalIdStorageFind(c.sid);
            if (sn.childsCount){
                var nc=c.copy().set("tid",c.nid).set("dropmode",c.target=="grid"?"sibling":"child");
              for(var j=0;j<sn.childsCount;j++){
                    c.tobj._dragRoutine(nc.set("sid",sn.childNodes[j].id));
                    if (c.mode=="move") j--;
                    }
                nc.close();
                }
        }
        else{
            c.tobj._copyUserData(c);
			this.callEvent("onRowAdded",[c.nid]);            
			
            if ((c.source=="treeGrid")){
            	
            	if (c.sobj==c.tobj) new_row._xml=c.sobj.rowsAr[c.sid]._xml;
                var snc=c.sobj._h2.get[c.sid];
                if ((snc)&&(snc.childs.length)){
                    var nc=c.copy().set("tid",c.nid);
                    if(c.target=="grid")
                        nc.set("dropmode","sibling");
                    else {
                        if (!nc.tobj.kidsXmlFile)
                    	   nc.tobj.openItem(c.tid);
                        nc.set("dropmode","child");
                        }
					var l=snc.childs.length;
                    if (!nc.tobj.kidsXmlFile)
                    for(var j=0;j<l;j++){
                    	c.sobj.render_row_tree(null,snc.childs[j].id);
                        c.tobj._dragRoutine(nc.set("sid",snc.childs[j].id));
                        if (l!=snc.childs.length) {  j--; l=snc.childs.length; }
                        }
                    nc.close();
                    }
            }
        }

        if (c.mode=="move"){
           c.sobj[(c.source=="tree")?"deleteItem":"deleteRow"](c.sid);
           if ((c.sobj==c.tobj)&&(!c.tobj.rowsAr[c.sid])) {
               c.tobj.changeRowId(c.nid,c.sid);
            c.nid=c.sid;
         }
      }
}


/**
*   @desc: redefine this method in your code to define how grid row values should be used in another grid
*   @param: rowId - id of draged row
*   @param: sgrid - source grid object
*   @param: tgrid - target grid object
*   @returns: array of values for cells in target grid row
*   @type: public
*   @topic: 7
*/
dhtmlXGridObject.prototype.gridToGrid = function(rowId,sgrid,tgrid){
    var z=new Array();
    for (var i=0; i<sgrid.hdr.rows[0].cells.length; i++)
        z[i]=sgrid.cells(rowId,i).getValue();
   return z;
}

/**
*   @desc:  check if d-n-d is in allowed rules
*   @type:  private
*/
dhtmlXGridObject.prototype.checkParentLine=function(node,id){
    if ((!this._h2)||(!id)||(!node)) return false;
    if (node.id==id) return true;
    else return this.checkParentLine(node.parent,id);
}

/**
*   @desc:  called when drag moved over landing
*   @type:  private
*/
dhtmlXGridObject.prototype._dragIn=function(htmlObject,shtmlObject,x,y){
                    if (!this.dADTempOff) return 0;
                    var tree=this.isTreeGrid();
                    var obj=shtmlObject.parentNode.idd?shtmlObject.parentNode:shtmlObject.parentObject;
                    
					if (this._drag_validate){
                    	if(htmlObject.parentNode==shtmlObject.parentNode)
                        	return 0;
                        	
	                    if ((tree)&&(this==obj.grid)&&((this.checkParentLine(this._h2.get[htmlObject.parentNode.idd],shtmlObject.parentNode.idd))))
    	                    return 0;
    	            }
                    if (!this.callEvent("onDragIn",[obj.idd||obj.id,htmlObject.parentNode.idd,obj.grid||obj.treeNod,(htmlObject.grid||htmlObject.parentNode.grid)]))
                        return this._setMove(htmlObject,x,y,true);

                    this._setMove(htmlObject,x,y);

                  if ((tree)&&(htmlObject.parentNode.expand!="")){
                    var self = this;
                    this._autoOpenTimer=window.setTimeout(function(){
                      self._autoOpenItem(null, self);
                      self = null;
                    },1000);
                    this._autoOpenId=htmlObject.parentNode.idd;
                  }
                  else
                    if  (this._autoOpenTimer) window.clearTimeout(this._autoOpenTimer);

                    return htmlObject;
}
/**
*   @desc:  open item on timeout
*   @type:  private
*/
dhtmlXGridObject.prototype._autoOpenItem=function(e,gridObject){
	   gridObject.openItem(gridObject._autoOpenId);
}

/**
*   @desc:  called on onmouseout event , when drag out landing zone
*   @type:  private
*/
dhtmlXGridObject.prototype._dragOut=function(htmlObject){
                    this._clearMove();
                    var obj=htmlObject.parentNode.parentObject?htmlObject.parentObject.id:htmlObject.parentNode.idd;
                    this.callEvent("onDragOut",[obj]);
                    if  (this._autoOpenTimer) window.clearTimeout(this._autoOpenTimer);
}
/**
*   @desc:  set visual effect for moving row over landing
*   @type:  private
*/
dhtmlXGridObject.prototype._setMove=function(htmlObject,x,y,skip){
   if (!htmlObject.parentNode.idd) return;
   var a1=dhx4.absTop(htmlObject);
   var a2=dhx4.absTop(this.objBox);
   

   //scroll down
   if ( (a1-a2)>(parseInt(this.objBox.offsetHeight)-50) )
      this.objBox.scrollTop=parseInt(this.objBox.scrollTop)+20;
   //scroll top
   if ( (a1-a2+parseInt(this.objBox.scrollTop))<(parseInt(this.objBox.scrollTop)+30) )
      this.objBox.scrollTop=parseInt(this.objBox.scrollTop)-20;
      
   if (skip) return 0;
   
    if (this.dadmode==2)
    {

        var z=y-a1+(document.body.scrollTop||document.documentElement.scrollTop)-2-htmlObject.offsetHeight/2;
        if ((Math.abs(z)-htmlObject.offsetHeight/6)>0)
        {
        this.dadmodec=1;
      //sibbling zone
        if (z<0)  this.dadmodefix=-1; else   this.dadmodefix=1;
        }
        else this.dadmodec=0;
    }
    else
        this.dadmodec=this.dadmode;




    if (this.dadmodec){
      if (!this._sdrgc) this._createSdrgc();
      this._sdrgc.style.display="block";
      this._sdrgc.style.top=a1-a2+parseInt(this.objBox.scrollTop)+((this.dadmodefix>=0)?htmlObject.offsetHeight:0)+"px";
    }
    else{
      this._llSelD=htmlObject;
      if (htmlObject.parentNode.tagName=="TR")
      for (var i=0; i<htmlObject.parentNode.childNodes.length; i++)
      {
      var z= htmlObject.parentNode.childNodes[i];
	  z._bgCol=z.style.backgroundColor;
      z.style.backgroundColor="#FFCCCC";
      }
    }
}
/**
*   @desc:  remove all visual effects
*   @type:  private
*/
dhtmlXGridObject.prototype._clearMove=function(){
    if (this._sdrgc) this._sdrgc.style.display="none";
    if ((this._llSelD)&&(this._llSelD.parentNode.tagName=="TR")){
    	var coll = this._llSelD.parentNode.childNodes;
        for (var i=0; i<coll.length; i++)
           coll[i].style.backgroundColor=coll[i]._bgCol;
	}       

    this._llSelD=null;
}


/**
*   @desc: redefine this method in your code to define how grid row values should be displaied while draging
*   @param: gridRowId - id of grid row
*   @returns: html string representing dragging row 
*   @type: public
*   @topic: 7
*/
dhtmlXGridObject.prototype.rowToDragElement=function(gridRowId){
    var out=this.cells(gridRowId,0).getValue();
    return out;
}








/**
*   @desc:  copy user data for row
*   @type:  private
*/
dhtmlXGridObject.prototype._copyUserData = function(c){
			if(!c.tobj.UserData[c.nid] || c.tobj!=c.sobj)
            	c.tobj.UserData[c.nid] = new Hashtable();
            else return;

            var z1 = c.sobj.UserData[c.sid];
            var z2 = c.tobj.UserData[c.nid];
            if (z1) {
                z2.keys = z2.keys.concat(z1.keys);
                z2.values = z2.values.concat(z1.values);
            }
    }



/**
*     @desc: move row
*     @type:  public
*     @param: rowId - source row Id
*     @param: mode - moving mode (up,down,row_sibling)
*     @param: targetId - target row  in row_sibling mode
*     @param: targetGrid - used for moving between grids (optional)
*     @edition: Professional
*     @topic: 2
*/
dhtmlXGridObject.prototype.moveRow=function(rowId,mode,targetId,targetGrid){
      switch(mode){
      case "row_sibling":
                    this.moveRowTo(rowId,targetId,"move","sibling",this,targetGrid);
         break;
      case "up":
               this.moveRowUp(rowId);
         break;
      case "down":
               this.moveRowDown(rowId);
          break;
      }
}





//#__pro_feature:21092006{

/**
*   @desc: move rows from grid to tree
*   @param: tree - object of tree
*   @param: targetObject - target node of tree
*   @param: beforeNode - anchor node of tree
*   @param: itemObject - dragged node
*   @param: z2 - flag of recursion
*   @type:  private
*   @edition: Professional
*   @topic: 7
*/
dhtmlXGridObject.prototype._nonTrivialNode=function(tree,targetObject,beforeNode,itemObject,z2)
{
    if ((tree.callEvent)&&(!z2))
          if (!tree.callEvent("onDrag",[itemObject.idd,targetObject.id,(beforeNode?beforeNode.id:null),this,tree])) return false;

    var gridRowId = itemObject.idd;
    var treeNodeId = gridRowId;
    while (tree._idpull[treeNodeId]) treeNodeId+=(new Date()).getMilliseconds().toString();

   var img=(this.isTreeGrid()?this.getItemImage(gridRowId):"")
	if (beforeNode){
		for (i=0; i<targetObject.childsCount; i++)
		    if (targetObject.childNodes[i]==beforeNode) break;
		
		if (i!=0)
		    beforeNode=targetObject.childNodes[i-1];
		else{
		    st="TOP";
		    beforeNode="";
		    }
	}   
   var newone=tree._attachChildNode(targetObject,treeNodeId,this.gridToTreeElement(tree,treeNodeId,gridRowId),"",img,img,img,"","",beforeNode);
    if (this._h2){
      var akids=this._h2.get[gridRowId];
      if (akids.childs.length)
      for (var i=0; i<akids.childs.length; i++){
          this._nonTrivialNode(tree,newone,0,this.rowsAr[akids.childs[i].id],1);
          if (!this.dpcpy) i--;
      }
    }

    if (!this.dpcpy) this.deleteRow(gridRowId);

    if ((tree.callEvent)&&(!z2))
       tree.callEvent("onDrop",[treeNodeId,targetObject.id,(beforeNode?beforeNode.id:null),this,tree]);
}

/**
*   @desc: redefine this method in your code to define how grid row values should be used in tree (using input parameters you can change id of new tree node, set label, set userdata blocks etc.).
*   @param: treeObj - object of tree
*   @param: treeNodeId - id of node created in tree
*   @param: gridRowId - id of grid row
*   @returns: if true, then grid row will be moved to tree, else - copied
*   @type: public
*   @edition: Professional
*   @topic: 7
*/
dhtmlXGridObject.prototype.gridToTreeElement = function(treeObj,treeNodeId,gridRowId){
   return this.cells(gridRowId,0).getValue();
}

/**
*   @desc: redefine this method in your code to define how tree node values should be used in grid (using input parameters you can change id of new row, values for cells, userdata blocks etc.).
*   @param: treeObj - object of tree
*   @param: treeNodeId - id of node created in tree
*   @param: gridRowId - id of grid row
*   @returns: if true, then tree node should be moved to grid, else - copied
*   @type: public
*   @edition: Professional
*   @topic: 7
*/
dhtmlXGridObject.prototype.treeToGridElement = function(treeObj,treeNodeId,gridRowId){
    var w=new Array();
    var z=this.cellType._dhx_find("tree");
   if (z==-1) z=0;
   for(var i=0;i<this.getColumnCount();i++)
        w[w.length]=(i!=z)?(treeObj.getUserData(treeNodeId,this.getColumnId(i))||""):treeObj.getItemText(treeNodeId);
   return w;
}

/**
*     @desc: move row
*     @type:  public
*     @param: srowId - source row Id
*     @param: trowId - target row Id
*     @param: mode - move or copy
*     @param: dropmode - sibling or child
*     @param: sourceGrid - target row  in row_sibling mode
*     @param: targetGrid - used for moving between grids (optional)
*     @returns: moved item ID
*     @edition: Professional
*     @topic: 2
*/
dhtmlXGridObject.prototype.moveRowTo=function(srowId,trowId,mode,dropmode,sourceGrid,targetGrid){
    var c=new dragContext((sourceGrid||this).isTreeGrid()?"treeGrid":"grid",(targetGrid||this).isTreeGrid()?"treeGrid":"grid",mode,dropmode||"sibling",srowId,trowId,sourceGrid||this,targetGrid||this);
    c.tobj._dragRoutine(c);
    c.close();
    return c.nid;
}

/**
*     @desc: enable drag without removing (copy instead of move)
*     @beforeInit: 1
*     @param: mode - 1 - on, 0 - off;
*     @type: public
*     @edition:Professional
*     @topic: 0
*/
dhtmlXGridObject.prototype.enableMercyDrag=function(mode){ this.dpcpy=dhx4.s2b(mode); };
//#}
//(c)dhtmlx ltd. www.dhtmlx.com


/*
Product Name: dhtmlxSuite 
Version: 4.1.3 
Edition: Professional 
License: content of this file is covered by DHTMLX Commercial or Enterprise license. Usage without proper license is prohibited. To obtain it contact sales@dhtmlx.com
Copyright UAB Dinamenta http://www.dhtmlx.com
*/

//please beware that function started from _in_header_ must not be obfuscated



/**
*   @desc: filter grid by mask
*   @type: public
*   @param: column - {number} zero based index of column
*   @param: value - {string} filtering mask
*   @param: preserve - {bool} filter current or initial state ( false by default )
*	@edition: Professional
*   @topic: 0
*/
dhtmlXGridObject.prototype.filterBy=function(column, value, preserve){
	if (this.isTreeGrid()) return this.filterTreeBy(column, value, preserve);
	if (this._f_rowsBuffer){
		if (!preserve){
			this.rowsBuffer=dhtmlxArray([].concat(this._f_rowsBuffer));
			if (this._fake) this._fake.rowsBuffer=this.rowsBuffer;
		}
	} else
		this._f_rowsBuffer=[].concat(this.rowsBuffer);	//backup copy
	
		
	if (!this.rowsBuffer.length) return;
	var d=true;
	this.dma(true)
	if (typeof(column)=="object")
		for (var j=0; j<value.length; j++)
			this._filterA(column[j],value[j]);
	else
			this._filterA(column,value);
	this.dma(false)
	if (this.pagingOn && this.rowsBuffer.length/this.rowsBufferOutSize < (this.currentPage-1)) this.changePage(0);
	this._reset_view();
	this.callEvent("onGridReconstructed",[])
}
dhtmlXGridObject.prototype._filterA=function(column,value){ 
	if (value=="") return;
	var d=true;
	if (typeof(value)=="function") d=false;
	else value=(value||"").toString().toLowerCase();
	if (!this.rowsBuffer.length) return;
	
	for (var i=this.rowsBuffer.length-1; i>=0; i--)
		if (d?(this._get_cell_value(this.rowsBuffer[i],column).toString().toLowerCase().indexOf(value)==-1):(!value.call(this, this._get_cell_value(this.rowsBuffer[i],column),this.rowsBuffer[i].idd)))
			this.rowsBuffer.splice(i,1);//filter row
}

dhtmlXGridObject.prototype.getFilterElement=function(index){
	if (!this.filters) return;
	for (var i=0; i < this.filters.length; i++) {
		if (this.filters[i][1]==index)
			return (this.filters[i][0].combo||this.filters[i][0]);
	};
	return null;
}

/**
*   @desc: get all possible values in column
*   @type: public
*   @param: column - {number} zero based index of column
*   @returns: {array} array of all possible values in column
*	@edition: Professional
*   @topic: 0
*/
dhtmlXGridObject.prototype.collectValues=function(column){
	var evs = this.dhxevs.data.oncollectvalues;
	if (evs){
		var value = true;
		for (var key in evs)
			value = evs[key].call(this, column) || value;
		if (value !== true)
			return value;
	}
	
	if (this.isTreeGrid()) return this.collectTreeValues(column);
	this.dma(true)
	this._build_m_order();
	column=this._m_order?this._m_order[column]:column;
	var c={}; var f=[];
	var col=this._f_rowsBuffer||this.rowsBuffer;
	for (var i=0; i<col.length; i++){
		var val=this._get_cell_value(col[i],column);
		if (val && (!col[i]._childIndexes || col[i]._childIndexes[column]!=col[i]._childIndexes[column-1])) c[val]=true;
	}
	this.dma(false);
	var vals= (this.combos[column]||(this._col_combos?this._col_combos[column]:false));
	for (var d in c) 
		if (c[d]===true){
           if(vals){
               if(vals.get&&vals.get(d)){
                   d = vals.get(d);
               }
               else if(vals.getOption&&vals.getOption(d)){
                   d = vals.getOption(d).text;
               }

           }
           f.push(d);
        }
	
	return f.sort();			
}

dhtmlXGridObject.prototype._build_m_order=function(){
	if (this._c_order){
		this._m_order=[]
		for (var i=0; i < this._c_order.length; i++) {
			this._m_order[this._c_order[i]]=i;
		};
	}
}
/**
*   @desc: force grid filtering by registered inputs ( created by # starting shortcuts, or by makeFilter function )
*   @type: public
*	@edition: Professional
*   @topic: 0
*/
dhtmlXGridObject.prototype.filterByAll=function(){
	var a=[];
	var b=[];
	this._build_m_order();

	for (var i=0; i<this.filters.length; i++){
		var ind=this._m_order?this._m_order[this.filters[i][1]]:this.filters[i][1];
		if (ind >= this._cCount) continue;
		b.push(ind);

		var val=this.filters[i][0].old_value=this.filters[i][0].value;
		if (this.filters[i][0]._filter)
			val = this.filters[i][0]._filter();
		
		var vals;
		if (typeof val != "function" && (vals=(this.combos[ind]||(this._col_combos?this._col_combos[ind]:false)))){
            if(vals.values){
                ind=vals.values._dhx_find(val);
			    val=(ind==-1)?val:vals.keys[ind];
            }
			else if(vals.getOptionByLabel){
                val=(vals.getOptionByLabel(val)?vals.getOptionByLabel(val).value:val);
            }
		}
		a.push(val);
		
	}
	if (!this.callEvent("onFilterStart",[b,a])) return;
	this.filterBy(b,a);
	if (this._cssEven) this._fixAlterCss();
	this.callEvent("onFilterEnd",[this.filters]);

	if (this._f_rowsBuffer && this.rowsBuffer.length == this._f_rowsBuffer.length)
		this._f_rowsBuffer = null;
}

/**
*   @desc: create a filter from any input element (text filter), select (dropdown) or DIV (combobox based on dhtmlxCombo)
*   @type: public
*   @param: id - {string|object} input id or input html object
*   @param: column - {number} index of column
*   @param: preserve - {bool} filter current state or initial one ( false by default )
*	@edition: Professional
*   @topic: 0
*/
dhtmlXGridObject.prototype.makeFilter=function(id,column,preserve){
	if (!this.filters) this.filters=[];
	if (typeof(id)!="object")
		id=document.getElementById(id);
	if(!id) return;
	var self=this;
	
	if (!id.style.width) id.style.width = "90%";
		
	if (id.tagName=='SELECT'){
		this.filters.push([id,column]);
		this._loadSelectOptins(id,column);
		id.onchange=function(){
			self.filterByAll();
		}
		if(_isIE)
			id.style.marginTop="1px";
			
		this.attachEvent("onEditCell",function(stage,a,ind){ 
			this._build_m_order();
			if (stage==2 && this.filters && ( this._m_order?(ind==this._m_order[column]):(ind==column) ))
				this._loadSelectOptins(id,column);
			return true;
		});
	} 
	else if (id.tagName=='INPUT'){
		this.filters.push([id,column]);
		id.old_value = id.value='';
		id.onkeydown=function(){
			if (this._timer) window.clearTimeout(this._timer);
			this._timer=window.setTimeout(function(){
				if (id.value != id.old_value){
					self.filterByAll();
					id.old_value=id.value;
				}
			},500);
		};
	}
	else if (id.tagName=='DIV' && id.className=="combo"){
		this.filters.push([id,column]);
		id.style.padding="0px";id.style.margin="0px";
		if (!window.dhx_globalImgPath) window.dhx_globalImgPath=this.imgURL;
		var z=new dhtmlXCombo(id,"_filter","90%");
		z.filterSelfA=z.filterSelf;
		z.filterSelf=function(){
			if (this.getSelectedIndex()==0) this.setComboText("");
			this.filterSelfA.apply(this,arguments);
			this.optionsArr[0].hide(false);	
		}
         
         
		z.enableFilteringMode(true);
		id.combo=z;
		id.value="";
		
		this._loadComboOptins(id,column);
		z.attachEvent("onChange",function(){
			id.value=z.getSelectedValue();
			if (id.value === null) id.value = "";
			self.filterByAll();
		});
	}
	if (id.parentNode)
		id.parentNode.className+=" filter";
	
	this._filters_ready(); //set event handlers
}
	/**
	*   @desc: find cell in grid by value
	*   @param: value - search string
	*   @param: c_ind - index of column to search in (optional. if not specified, then search everywhere)
	*   @param: count - count of results to return
	*   @edition: Professional
	*   @returns: array each member of which contains array with row ID  and cell index
	*   @type:  public
	*/
	dhtmlXGridObject.prototype.findCell=function(value, c_ind, count, compare){ 
		var compare = compare || (function(master, check){
			return check.toString().toLowerCase().indexOf(master) != -1;
		});
		if (compare === true)
			compare = function(master, check){ return check.toString().toLowerCase() == master; };

		var res = new Array();
		value=value.toString().toLowerCase();
		if (typeof count != "number") count = count?1:0;
	
		if (!this.rowsBuffer.length)
			return res;
	
		for (var i = (c_ind||0); i < this._cCount; i++){
			if (this._h2)
				this._h2.forEachChild(0,function(el){
					if (count && res.length==count) return res;
					if (compare(value, this._get_cell_value(el.buff,i))){
						res.push([el.id,i]);
					}
				},this)
			else
				for (var j=0; j < this.rowsBuffer.length; j++) 
					if (compare(value, this._get_cell_value(this.rowsBuffer[j],i))){
						res.push([this.rowsBuffer[j].idd,i]);
						if (count && res.length==count) return res;
					}
						
			
		
			if (typeof (c_ind) != "undefined")
				return res;
		}
	
		return res;
	}
	
/**
*   @desc: create a search box (set selection to the row with found value) from any input
*   @type: public
*   @param: id - {string|object} input id or input html object
*   @param: column - {number} index of column
*	@edition: Professional
*   @topic: 0
*/
dhtmlXGridObject.prototype.makeSearch=function(id,column,strict){
	if (typeof(id)!="object")
		id=document.getElementById(id);
	if(!id) return;
	var self=this;
		
	if (id.tagName=='INPUT'){
		id.onkeypress=function(){
			if (this._timer) window.clearTimeout(this._timer);
			this._timer=window.setTimeout(function(){
				if (id.value=="") return;
				var z=self.findCell(id.value,column,true,strict);
				if (z.length){
					if (self._h2)
						self.openItem(z[0][0]);
					self.selectCell(self.getRowIndex(z[0][0]),(column||0))
				}
			},500);
		};
	}
	if (id.parentNode)
		id.parentNode.className+=" filter";
}
	
dhtmlXGridObject.prototype._loadSelectOptins=function(t,c){ 
		var l=this.collectValues(c);
		var v=t.value;
		t.innerHTML="";
		t.options[0]=new Option("","");
		var f=this._filter_tr?this._filter_tr[c]:null;
		for (var i=0; i<l.length; i++)
			t.options[t.options.length]=new Option(f?f(l[i]):l[i],l[i]);
		t.value=v;
}
dhtmlXGridObject.prototype.setSelectFilterLabel=function(ind,fun){ 
		if (!this._filter_tr) this._filter_tr=[];
		this._filter_tr[ind]=fun;
}

dhtmlXGridObject.prototype._loadComboOptins=function(t,c){
	if (!t.combo) return; // prevent calls from refreshFilters
	var l=this.collectValues(c);
	t.combo.clearAll();
	var opts = [["",""]];
	for (var i=0; i<l.length; i++) opts.push([l[i],l[i]]);
	t.combo.addOption(opts);
}

/**
*   @desc: refresh filtering ( can be used if data in grid changed and filters need to be updated )
*   @type: public
*	@edition: Professional
*   @topic: 0
*/
dhtmlXGridObject.prototype.refreshFilters=function(){
        if(!this.filters) return;
	for (var i=0; i<this.filters.length; i++){
		switch(this.filters[i][0].tagName.toLowerCase()){
			case "input":
				break;
			case "select":
				this._loadSelectOptins.apply(this,this.filters[i]);
				break;
			case "div":
				this._loadComboOptins.apply(this,this.filters[i]);
				break;
		}
	}
}

dhtmlXGridObject.prototype._filters_ready=function(fl,code){
	this.attachEvent("onXLE",this.refreshFilters);
	this.attachEvent("onRowCreated",function(id,r){
		if (this._f_rowsBuffer)
			for (var i=0; i<this._f_rowsBuffer.length; i++)
				if (this._f_rowsBuffer[i].idd == id)
					return this._f_rowsBuffer[i]=r;
	})
	this.attachEvent("onClearAll",function(){ 
	    this._f_rowsBuffer=null; 
		if (!this.hdr.rows.length)
			this.filters=[];
	});
	/*
	if (window.dhtmlXCombo)
		this.attachEvent("onScroll",dhtmlXCombo.prototype.closeAll);
	*/
	this.attachEvent("onSetSizes", this._filters_resize_combo);
	this.attachEvent("onResize", this._filters_resize_combo);
	
	this._filters_ready=function(){};
}

dhtmlXGridObject.prototype._filters_resize_combo=function(){
	if (!this.filters) return;
	for (var q=0; q<this.filters.length; q++) {
		if (this.filters[q][0].combo != null) {
			this.filters[q][0].combo.setSize(Math.round(this.filters[q][0].offsetWidth*90/100));
		}
	}
	return true;
}

dhtmlXGridObject.prototype._in_header_text_filter=function(t,i){
	t.innerHTML="<input type='text'>";
	t.onclick=t.onmousedown = function(e){ (e||event).cancelBubble=true; return true; }
	t.onselectstart=function(){ return (event.cancelBubble=true); }
	this.makeFilter(t.firstChild,i);
}

dhtmlXGridObject.prototype._in_header_text_filter_inc=function(t,i){
	t.innerHTML="<input type='text'>";
	t.onclick=t.onmousedown = function(e){ (e||event).cancelBubble=true; return true; }
	t.onselectstart=function(){ return (event.cancelBubble=true); }
	this.makeFilter(t.firstChild,i);
	t.firstChild._filter=function(){ 
		if (t.firstChild.value=="") return "";
		return function(val){
			return (val.toString().toLowerCase().indexOf(t.firstChild.value.toLowerCase())==0); 
		}
	}
	this._filters_ready();
}

dhtmlXGridObject.prototype._in_header_select_filter=function(t,i){
	t.innerHTML="<select></select>";
	t.onclick=function(e){ (e||event).cancelBubble=true; return false; }
	this.makeFilter(t.firstChild,i);
}

dhtmlXGridObject.prototype._in_header_select_filter_strict=function(t,i){
	t.innerHTML="<select style='width:90%; font-size:8pt; font-family:Tahoma;'></select>";
	t.onclick=function(e){ (e||event).cancelBubble=true; return false; }
	this.makeFilter(t.firstChild,i);
	var combos = this.combos;
	t.firstChild._filter=function(){ 
		var value = t.firstChild.value;
		if (!value) return "";
		if (combos[i])
            value = combos[i].keys[combos[i].values._dhx_find(value)];
       	value = value.toLowerCase();
            
		return function(val){
			return (val.toString().toLowerCase()==value); 
		};
	};
	this._filters_ready();
}

dhtmlXGridObject.prototype._in_header_combo_filter=function(t,i){
	t.innerHTML="<div style='width:100%; padding-left:2px; overflow:hidden; ' class='combo'></div>";
	t.onselectstart=function(){ return (event.cancelBubble=true); }
	t.onclick=t.onmousedown=function(e){ (e||event).cancelBubble=true; return true; }
	this.makeFilter(t.firstChild,i);
}

dhtmlXGridObject.prototype._search_common=function(t, i){
	t.innerHTML="<input type='text' style='width:90%; '>";
	t.onclick= t.onmousedown = function(e){ (e||event).cancelBubble=true; return true; }
	t.onselectstart=function(){ return (event.cancelBubble=true); }
}
dhtmlXGridObject.prototype._in_header_text_search=function(t,i, strict){
	this._search_common(t, i);
	this.makeSearch(t.firstChild,i);
}
dhtmlXGridObject.prototype._in_header_text_search_strict=function(t,i){
	this._search_common(t, i);
	this.makeSearch(t.firstChild,i, true);
}

dhtmlXGridObject.prototype._in_header_numeric_filter=function(t,i){
	this._in_header_text_filter.call(this,t,i);
	t.firstChild._filter=function(){
		var v=this.value;
		
		var r; var op="=="; var num=parseFloat(v.replace("=","")); var num2=null;
		
		if (v){
			if (v.indexOf("..")!=-1){
				v=v.split("..");
				num=parseFloat(v[0]);
				num2=parseFloat(v[1]);
				return function(v){
					if (v>=num && v<=num2) return true;
					return false;
					}
			}
			r=v.match(/>=|<=|>|</)
			if (r) {
				op=r[0];
				num=parseFloat(v.replace(op,""));
			}
			return Function("v"," if (v "+op+" "+num+" ) return true; return false;");
		}
		return "";
	};
}

dhtmlXGridObject.prototype._in_header_master_checkbox=function(t,i,c){
	t.innerHTML=c[0]+"<input type='checkbox' />"+c[1];
	var self=this;
	t.getElementsByTagName("input")[0].onclick=function(e){
		self._build_m_order();
		var j=self._m_order?self._m_order[i]:i;
		var val=this.checked?1:0;
		self.forEachRowA(function(id){
			var c=this.cells(id,j);
			if (c.isCheckbox()) {
				c.setValue(val);
				c.cell.wasChanged = true;
			}
			this.callEvent("onEditCell",[1,id,j,val]);
			this.callEvent("onCheckbox", [id, j, val]);
		});
		(e||event).cancelBubble=true;
	}
}

dhtmlXGridObject.prototype._in_header_stat_total=function(t,i,c){
	var calck=function(){
		var summ=0;
		this._build_m_order();
		var ii = this._m_order?this._m_order[i]:i;
		for (var j=0; j<this.rowsBuffer.length; j++){
			var v=parseFloat(this._get_cell_value(this.rowsBuffer[j],ii));
			summ+=isNaN(v)?0:v;
		}
		
		return this._maskArr[ii]?this._aplNF(summ,ii):(Math.round(summ*100)/100);
	}
	this._stat_in_header(t,calck,i,c,c);
}
dhtmlXGridObject.prototype._in_header_stat_multi_total=function(t,i,c){
	var cols=c[1].split(":"); c[1]="";
	for(var k = 0; k < cols.length;k++){
		cols[k]=parseInt(cols[k]);
	}
	var calck=function(){
		var summ=0;
		for (var j=0; j<this.rowsBuffer.length; j++){
			var v = 1;
			for(var k = 0; k < cols.length;k++){
				v *= parseFloat(this._get_cell_value(this.rowsBuffer[j],cols[k]))
			}
			summ+=isNaN(v)?0:v;
		}
		return this._maskArr[i]?this._aplNF(summ,i):(Math.round(summ*100)/100);
	}
	var track=[];
	for(var ind = 0; ind < cols.length;ind++){
		track[cols[ind]]=true;
	}
	this._stat_in_header(t,calck,track,c,c);
}
dhtmlXGridObject.prototype._in_header_stat_max=function(t,i,c){
	var calck=function(){
		this._build_m_order();
		var ii = this._m_order?this._m_order[i]:i;
		
		var summ=-999999999;
		if (this.getRowsNum()==0) return "&nbsp;";
		for (var j=0; j<this.rowsBuffer.length; j++)
			summ=Math.max(summ,parseFloat(this._get_cell_value(this.rowsBuffer[j],ii)));
		
		return this._maskArr[i]?this._aplNF(summ,i):summ;
	}
	this._stat_in_header(t,calck,i,c);
}
dhtmlXGridObject.prototype._in_header_stat_min=function(t,i,c){
	var calck=function(){
		this._build_m_order();
		var ii = this._m_order?this._m_order[i]:i;
		
		var summ=999999999;
		if (this.getRowsNum()==0) return "&nbsp;";
		for (var j=0; j<this.rowsBuffer.length; j++)
			summ=Math.min(summ,parseFloat(this._get_cell_value(this.rowsBuffer[j],ii)));
		return this._maskArr[i]?this._aplNF(summ,i):summ;
	}
	this._stat_in_header(t,calck,i,c);
}
dhtmlXGridObject.prototype._in_header_stat_average=function(t,i,c){
	var calck=function(){
		this._build_m_order();
		var ii = this._m_order?this._m_order[i]:i;
		
		var summ=0; var count=0;
		if (this.getRowsNum()==0) return "&nbsp;";
		for (var j=0; j<this.rowsBuffer.length; j++){
			var v=parseFloat(this._get_cell_value(this.rowsBuffer[j],ii));
			if (!isNaN(v)){
				summ+=v;
				count++;
			}
		}
		return this._maskArr[i]?this._aplNF(summ/count,i):(Math.round(summ/count*100)/100);
	}
	this._stat_in_header(t,calck,i,c);
}
dhtmlXGridObject.prototype._in_header_stat_count=function(t,i,c){
	var calck=function(){
		return this.getRowsNum();
	}
	this._stat_in_header(t,calck,i,c);
}

dhtmlXGridObject.prototype._stat_in_header=function(t,calck,i,c){
	var that=this;
	var f=function(){
		this.dma(true)
		t.innerHTML=(c[0]?c[0]:"")+calck.call(this)+(c[1]?c[1]:"");
		this.dma(false)
		this.callEvent("onStatReady",[])
	}
	if (!this._stat_events) {
		this._stat_events=[];
		this.attachEvent("onClearAll",function(){ 
			if (!this.hdr.rows[1]){
				for (var i=0; i<this._stat_events.length; i++)
					for (var j=0; j < 4; j++) 
						this.detachEvent(this._stat_events[i][j]);
				this._stat_events=[];	
			}
		})
	}
	
	this._stat_events.push([
	this.attachEvent("onGridReconstructed",f),
	this.attachEvent("onXLE",f),
	this.attachEvent("onFilterEnd",f),
	this.attachEvent("onEditCell",function(stage,id,ind){
		if (stage==2 && ( ind==i || ( i && i[ind]) ) ) f.call(this);
		return true;
		})]);
	t.innerHTML="";
}



//(c)dhtmlx ltd. www.dhtmlx.com

/*
Product Name: dhtmlxSuite 
Version: 4.1.3 
Edition: Professional 
License: content of this file is covered by DHTMLX Commercial or Enterprise license. Usage without proper license is prohibited. To obtain it contact sales@dhtmlx.com
Copyright UAB Dinamenta http://www.dhtmlx.com
*/

/**
*   @desc: load grid from CSV file
*   @param: path - path to file
*   @param: afterCall - function which will be called after xml loading
*   @type: public
*     @edition: Professional
*   @topic: 0
*/
dhtmlXGridObject.prototype.loadCSVFile = function(path,afterCall){
    this.load(path,afterCall,"csv")
}

/**
*   @desc: enable mode, where ID for rows loaded from CSV autogenerated
*   @param: mode - true/false
*   @type: public
*   @edition: Professional
*   @topic: 0
*/
dhtmlXGridObject.prototype.enableCSVAutoID = function(mode){
   this._csvAID=dhx4.s2b(mode);
}
/**
*   @desc: enable recognizing first row in CSV as header
*   @param: mode - true/false
*   @type: public
*   @edition: Professional
*   @topic: 0
*/
dhtmlXGridObject.prototype.enableCSVHeader = function(mode){
   this._csvHdr=dhx4.s2b(mode);
}

/**
*   @desc: load grid from CSV string
*   @param: str - delimer used in CSV operations, comma by default ( only single char delimeters allowed )
*   @type: public
*     @edition: Professional
*   @topic: 0
*/
dhtmlXGridObject.prototype.setCSVDelimiter = function(str){
   this.csv.cell=str;
}
dhtmlXGridObject.prototype._csvAID = true;

/**
*   @desc: load grid from CSV string
*   @param: str - CSV  string
*   @type: public
*     @edition: Professional
*   @topic: 0
*/
dhtmlXGridObject.prototype.loadCSVString = function(str){
   this.parse(str,"csv")
}

/**
*   @desc: serialize to CSV string
*   @type: public
*	@param: text only - force serialization of text values ( skip HTML elements ) )
*     @edition: Professional
*   @topic: 0
*/
dhtmlXGridObject.prototype.serializeToCSV = function(textmode){ 
    this.editStop()
    if (this._mathSerialization)
         this._agetm="getMathValue";
    else if (this._strictText || textmode)
    	this._agetm="getTitle";
    else this._agetm="getValue";

	var out=[];
	if (this._csvHdr){
		for (var j=1; j < this.hdr.rows.length; j++) {
			var a=[]; 
			for (var i=0; i<this._cCount; i++)
				if ((!this._srClmn)||(this._srClmn[i]))
					a.push(this.getColumnLabel(i,j-1));
    		out.push(this.csvParser.str(a,this.csv.cell, this.csv.row));
    	}
    }

    
    //rows collection
    var i=0;
    var leni=this.rowsBuffer.length;

   for(i; i<leni; i++){
		var temp=this._serializeRowToCVS(null,i)      	
		if (temp!="") out.push(temp);
  }

   return this.csvParser.block(out,this.csv.row);
}

/**
*   @desc: serialize TR to CSV
*   @param: r - TR or xml node (row)
*   @retruns: string - CSV representation of passed row
*   @type: private
*/
dhtmlXGridObject.prototype._serializeRowToCVS = function(r,i,start,end){
    var out = new Array();
    if (!r){
	    r=this.render_row(i)
	    if (this._fake && !this._fake.rowsAr[r.idd]) this._fake.render_row(i);
	}
    

    if (!this._csvAID)
       out[out.length]=r.idd;

	start = start||0;
	
    end = end||this._cCount;
    //cells
    var changeFl=false;
    var ind=start;
    //rowspans before block selection
    while (r.childNodes[start]._cellIndex>ind && start) start--; 
    
    
    for(var jj=start;ind<end;jj++){
    	if (!r.childNodes[jj]) break;
    	var real_ind=r.childNodes[jj]._cellIndex;
        if (((!this._srClmn)||(this._srClmn[real_ind])) && (!this._serialize_visible || !this._hrrar[real_ind])){
            var cvx=r.childNodes[jj];

            var zx=this.cells(r.idd,real_ind);
            while (ind!=real_ind){
            	ind++;
            	out.push("")
            	if (ind>=end) break;
            }
            if (ind>=end) break;
            ind++;
        /*	if (zx.getText)
        		zxVal=zx.getText();
        	else*/
            if (zx.cell)
				zxVal=zx[this._agetm]();
			else zxVal="";


		if ((this._chAttr)&&(zx.wasChanged()))
			changeFl=true;

            out[out.length]=((zxVal===null)?"":zxVal)
//#colspan:20092006{
            if ( this._ecspn && cvx.colSpan && cvx.colSpan >1 ){
                cvx=cvx.colSpan-1;
                for (var u=0; u<cvx; u++){
	                out[out.length] = "";
	                ind++;
                }
            }
//#}

 } else ind++;
    }
     if ((this._onlChAttr)&&(!changeFl)) return "";
      return this.csvParser.str(out,this.csv.cell, this.csv.row);
}

dhtmlXGridObject.prototype.toClipBoard=function(val){
    if (window.clipboardData)
      window.clipboardData.setData("Text",val);
   else
      (new Clipboard()).copy(val);

}
dhtmlXGridObject.prototype.fromClipBoard=function(){
   if (window.clipboardData)
      return window.clipboardData.getData("Text");
   else
      return (new Clipboard()).paste();
}

/**
*   @desc: copy value of cell to clipboard
*   @type: public
*   @param: rowId - id of row (optional, use selected row by default)
*   @param: cellInd - column index(optional, use selected cell by default)
*     @edition: Professional
*   @topic: 5
*/
dhtmlXGridObject.prototype.cellToClipboard = function(rowId,cellInd){
    if ((!rowId)||(!cellInd && cellInd !== 0)){
       if (!this.selectedRows[0]) return;
       rowId=this.selectedRows[0].idd;
       cellInd=this.cell._cellIndex;
   }
   
   	var ed=this.cells(rowId,cellInd);
    this.toClipBoard(((ed.getLabel?ed.getLabel():ed.getValue())||"").toString());
}

/**
*   @desc: set value of cell from clipboard
*   @type: public
*     @edition: Professional
*   @param: rowId - id of row (optional, use selected row by default)
*   @param: cellInd - column index(optional, use selected cell by default)
*   @topic: 5
*/
dhtmlXGridObject.prototype.updateCellFromClipboard = function(rowId,cellInd){
    if ((!rowId)||(!cellInd)){
       if (!this.selectedRows[0]) return;
       rowId=this.selectedRows[0].idd;
       cellInd=this.cell._cellIndex;
   }
   	var ed=this.cells(rowId,cellInd);
    ed[ed.setImage?"setLabel":"setValue"](this.fromClipBoard());
}

/**
*   @desc: copy value of row to clipboard
*   @type: public
*     @edition: Professional
*   @param: rowId - id of row (optional, use selected row by default)
*   @topic: 5
*/
dhtmlXGridObject.prototype.rowToClipboard = function(rowId){
	var out="";
	if (this._mathSerialization)
		this._agetm="getMathValue";
	else if (this._strictText)
		this._agetm="getTitle";
	else 
		this._agetm="getValue";
    
  this._serialize_visible = !this._fake;

	if (rowId)
		out=this._serializeRowToCVS(this.getRowById(rowId));
	else {
   		var data = [];
		for (var i=0; i<this.selectedRows.length; i++){
			data[data.length] = this._serializeRowToCVS(this.selectedRows[i]);
			out = this.csvParser.block(data, this.csv.row);
		}
	}

  this._serialize_visible = false;
	this.toClipBoard(out);
}

/**
*   @desc: set value of row from clipboard
*   @type: public
*     @edition: Professional
*   @param: rowId - id of row (optional, use selected row by default)
*   @topic: 5
*/
dhtmlXGridObject.prototype.updateRowFromClipboard = function(rowId){
	var csv=this.fromClipBoard();
	if (!csv) return;
	if (rowId)
		var r=this.getRowById(rowId);
	else
		var r=this.selectedRows[0];
	if (!r) return;
	
	var parser = this.csvParser;
	csv=parser.unblock(csv,this.csv.cell, this.csv.row)[0];
	if (!this._csvAID) csv.splice(0,1);
	for (var i=0; i<csv.length; i++){
		var ed=this.cells3(r,i);
		ed[ed.setImage?"setLabel":"setValue"](csv[i]);
	}
}

dhtmlXGridObject.prototype.csvParser={
	block:function(data,row){
		return data.join(row);
	},
	unblock:function(str,cell,row){
		var data = (str||"").split(row);	
		for (var i=0; i < data.length; i++)
			data[i]=(data[i]||"").split(cell);
    var last = data.length-1;
    if (data[last].length == 1 && data[last][0]=="")
      data.splice(last,1);
		return data;
	},
	str:function(data,cell,row){
		return data.join(cell);
	}
};
dhtmlXGridObject.prototype.csvExtParser={
	_quote:RegExp('"',"g"),
	_quote_esc:RegExp("\\\\\"","g"),
	block:function(data,row){
		return data.join(row);
	},
	unblock:function(str,cell,row){ 
		var out = [[]];
		var ind = 0;
		if (!str) return out;

		var quote_start = /^[ ]*"/;
		var quote_end   = /"[ ]*$/;
		var row_exp  = new RegExp(".*"+row+".*$");
		
		var data = str.split(cell);
		for (var i=0; i<data.length; i++){
			if (data[i].match(quote_start)){
				var buff = data[i].replace(quote_start, "");
				while (!data[i].match(quote_end)) {
					i++;
					buff+=data[i];
				}
				out[ind].push(buff.replace(quote_end, "").replace(this._quote_esc,'"'));
			} else if (data[i].match(row_exp)){
        var row_pos = data[i].indexOf(row);
				out[ind].push(data[i].substr(0, row_pos));
				ind++;
				out[ind] = [];
				data[i]=data[i].substr(row_pos+1); i--;
			} else {
				if (data[i] || i!=data.length-1)
					out[ind].push(data[i]);
			}
		}

    var last = out.length-1;
    if (last>0 && !out[last].length)
      out.splice(last,1);
    
		return out;	
	},
	str:function(data,cell,row){
		for (var i=0; i < data.length; i++)
			data[i] = '"'+data[i].replace(this._quote, "\\\"")+'"';
		return data.join(cell);
	}
};

/**
*   @desc: add new row from clipboard
*   @type: public
*     @edition: Professional
*   @topic: 5
*/
dhtmlXGridObject.prototype.addRowFromClipboard = function(){
   var csv=this.fromClipBoard();
   if (!csv) return;
   var z=this.csvParser.unblock(csv, this.csv.cell, this.csv.row);
   for (var i=0; i<z.length; i++)
      if (z[i]){
         csv=z[i];
         if (!csv.length) continue;
         if (this._csvAID)
         	this.addRow(this.getRowsNum()+2,csv);
         else{
         	if (this.rowsAr[csv[0]])
         		csv[0]=this.uid();
         	this.addRow(csv[0],csv.slice(1));
     		}
      }
}

/**
*   @desc: copy grid in CSV to clipboard
*   @type: public
*     @edition: Professional
*   @topic: 5
*/
dhtmlXGridObject.prototype.gridToClipboard = function(){
   this.toClipBoard(this.serializeToCSV());
}

/**
*   @desc: init grid from CSV stored in clipboard
*   @type: public
*     @edition: Professional
*   @topic: 5
*/
dhtmlXGridObject.prototype.gridFromClipboard = function(){
   var csv=this.fromClipBoard();
   if (!csv) return;
   this.loadCSVString(csv);
}

/**
*   @desc: get grid as XML - php required
*   @param: path - path to server side code,optional
*   @type: private
*   @edition: Professional
*   @topic: 5
*/
dhtmlXGridObject.prototype.getXLS = function(path){
   if (!this.xslform){
      this.xslform=document.createElement("FORM");
      this.xslform.action=(path||"")+"xls.php";
      this.xslform.method="post";
      this.xslform.target=(_isIE?"_blank":"");
      document.body.appendChild(this.xslform);
      var i1=document.createElement("INPUT");
      i1.type="hidden";
      i1.name="csv";
      this.xslform.appendChild(i1);
      var i2=document.createElement("INPUT");
      i2.type="hidden";
      i2.name="csv_header";
      this.xslform.appendChild(i2);
   }
      var cvs = this.serializeToCSV();
      this.xslform.childNodes[0].value = cvs;
        var cvs_header = [];
        var l = this._cCount;
        for (var i=0; i<l; i++) {
         cvs_header.push(this.getHeaderCol(i));
        }
      cvs_header = cvs_header.join(',');
      this.xslform.childNodes[1].value = cvs_header;
       this.xslform.submit();
}

/**
*   @desc: generate print friendly view
*   @type: public
*   @edition: Professional
*   @topic: 5
*/
dhtmlXGridObject.prototype.printView = function(before,after){
	  var html="<style>TD { font-family:Arial; text-align:center; padding-left:2px;padding-right:2px; } \n td.filter input, td.filter select { display:none; }	\n  </style>";
	  var st_hr=null;
	  if (this._fake) {
	  	st_hr=[].concat(this._hrrar); 
	  	for (var i=0; i<this._fake._cCount; i++)
	  		this._hrrar[i]=null;
	  }
	   html+="<base  href='"+document.location.href+"'></base>";
	   if (!this.parentGrid) html+=(before||"");
       html += '<table width="100%" border="2px" cellpadding="0" cellspacing="0">';
       var row_length = Math.max(this.rowsBuffer.length,this.rowsCol.length); //paging and smartrendering
       var col_length = this._cCount;
      var width = this._printWidth();
      html += '<tr class="header_row_1">';
        for (var i=0; i<col_length; i++){
        	if (this._hrrar && this._hrrar[i]) continue;
         var hcell=this.hdr.rows[1].cells[this.hdr.rows[1]._childIndexes?this.hdr.rows[1]._childIndexes[parseInt(i)]:i];
         var colspan=(hcell.colSpan||1);
         var rowspan=(hcell.rowSpan||1);
         
         for (var j=1; j<colspan; j++)
         	width[i]+=width[j];
    	html += '<td rowspan="'+rowspan+'" width="'+width[i]+'%" style="background-color:lightgrey;" colspan="'+colspan+'">'+this.getHeaderCol(i)+'</td>';
         i+=colspan-1;
        }
      html += '</tr>';

	  	for (var i=2; i<this.hdr.rows.length; i++){
	  		if (_isIE){
	  			html+="<tr style='background-color:lightgrey' class='header_row_"+i+"'>";
	  			var cells=this.hdr.rows[i].childNodes;
	  			for (var j=0; j < cells.length; j++) 
	  				if (!this._hrrar || !this._hrrar[cells[j]._cellIndex]){
	  					html+=cells[j].outerHTML;
	  				}
	  			html+="</tr>";
	  			}
	  		else
				html+="<tr class='header_row_"+i+"' style='background-color:lightgrey'>"+(this._fake?this._fake.hdr.rows[i].innerHTML:"")+this.hdr.rows[i].innerHTML+"</tr>";
		}

       for (var i=0; i<row_length; i++) {
         html += '<tr>';
           if (this.rowsCol[i] && this.rowsCol[i]._cntr){
           	  html+=this.rowsCol[i].innerHTML.replace(/<img[^>]*>/gi,"")+'</tr>';
           	  continue;
           }
           if (this.rowsCol[i] && this.rowsCol[i].style.display=="none") continue;
           
           var row_id
           if (this.rowsCol[i])
           		row_id=this.rowsCol[i].idd;
           	else if (this.rowsBuffer[i]) 
           		row_id=this.rowsBuffer[i].idd;
           	else continue; //dyn loading 
           	
           for (var j=0; j<col_length; j++) {
           	   if (this._hrrar && this._hrrar[j]) continue;
           	   if(this.rowsAr[row_id] && this.rowsAr[row_id].tagName=="TR") {
	           	   var c=this.cells(row_id, j);
	           	   if (c._setState) var value="";
	           	   else if (c.getContent) value = c.getContent();
	           	   else if (c.getImage || c.combo) var value=c.cell.innerHTML;
	           	   else var value = c.getValue();
           	   } else 
	           	  var value=this._get_cell_value(this.rowsBuffer[i],j);
               var color = this.columnColor[j]?'background-color:'+this.columnColor[j]+';':'';
            var align = this.cellAlign[j]?'text-align:'+this.cellAlign[j]+';':'';
            var cspan =  c.getAttribute("colspan");
            html += '<td style="'+color+align+'" '+(cspan?'colSpan="'+cspan+'"':'')+'>'+(value===""?"&nbsp;":value)+'</td>';
            if (cspan) j+=cspan-1;
           }
         html += '</tr>';
         if (this.rowsCol[i] && this.rowsCol[i]._expanded){
         	 var sub=this.cells4(this.rowsCol[i]._expanded.ctrl);
         	 if (sub.getSubGrid)
         	 	html += '<tr><td colspan="'+col_length+'">'+sub.getSubGrid().printView()+'</td></tr>';
         	 else
         	 	html += '<tr><td colspan="'+col_length+'">'+this.rowsCol[i]._expanded.innerHTML+'</td></tr>';
         }
       }

	   if (this.ftr)
	  	for (var i=1; i<this.ftr.childNodes[0].rows.length; i++)
	  		html+="<tr style='background-color:lightgrey'>"+((this._fake)?this._fake.ftr.childNodes[0].rows[i].innerHTML:"")+this.ftr.childNodes[0].rows[i].innerHTML+"</tr>";
        		

      html += '</table>';
      if (this.parentGrid) return html;
      
      html+=(after||"");
      var d = window.open('', '_blank');
      d.document.write(html);
      d.document.write("<script>window.onerror=function(){return true;}</script>");
      d.document.close();
      if (this._fake) {
	  	this._hrrar=st_hr;
	  }
}
dhtmlXGridObject.prototype._printWidth=function(){
      var width = [];
      var total_width = 0;
      for (var i=0; i<this._cCount; i++) {
         var w = this.getColWidth(i);
         width.push(w);
         total_width += w;
      }
      var percent_width = [];
      var total_percent_width = 0;
      for (var i=0; i<width.length; i++) {
         var p = Math.floor((width[i]/total_width)*100);
         total_percent_width += p;
            percent_width.push(p);
      }
      percent_width[percent_width.length-1] += 100-total_percent_width;
      return percent_width;
   }

/*
user_pref("signed.applets.codebase_principal_support", true);
*/
if (!window.clipboardData)
window.clipboardData={
	_make:function(){
	   
	   var clip = Components.classes['@mozilla.org/widget/clipboard;1'].createInstance(Components.interfaces.nsIClipboard);
	   if (!clip) return null;
		
	   var trans = Components.classes['@mozilla.org/widget/transferable;1'].createInstance(Components.interfaces.nsITransferable);
	   if (!trans) return null;
	   		
	   trans.addDataFlavor('text/unicode');


	   var str = Components.classes["@mozilla.org/supports-string;1"].createInstance(Components.interfaces.nsISupportsString);
	   		
	   this._p=[clip,trans,str];
	   		
	   return true;
	},
	setData:function(type,text){
		try{
		netscape.security.PrivilegeManager.enablePrivilege('UniversalXPConnect');
		} catch(e){ dhx4.callEvent("onClipboardError",["Access to clipboard denied",type,text]); return ""; }
		if (!this._make()) return false;
		
   this._p[2].data=text;
   this._p[1].setTransferData("text/unicode",this._p[2],text.length*2);
   var clipid=Components.interfaces.nsIClipboard;
   this._p[0].setData(this._p[1],null,clipid.kGlobalClipboard);

	},
	getData:function(type){ 
		try{
		netscape.security.PrivilegeManager.enablePrivilege('UniversalXPConnect');		
		} catch(e){ dhx4.callEvent("onClipboardError",["Access to clipboard denied",type]); return ""; }
		if (!this._make()) return false;


   this._p[0].getData(this._p[1],this._p[0].kGlobalClipboard);
   var strLength = new Object();
   var str = new Object();
   try{
   	this._p[1].getTransferData("text/unicode",str,strLength);
   } catch(e){
   	//empty clipboard in FF 
   	return "";
   }

	if (str) str = str.value.QueryInterface(Components.interfaces.nsISupportsString);
	if (str) return str.data.substring(0,strLength.value / 2);

	return "";

	}
}
//(c)dhtmlx ltd. www.dhtmlx.com



/*
Product Name: dhtmlxSuite 
Version: 4.1.3 
Edition: Professional 
License: content of this file is covered by DHTMLX Commercial or Enterprise license. Usage without proper license is prohibited. To obtain it contact sales@dhtmlx.com
Copyright UAB Dinamenta http://www.dhtmlx.com
*/

/**
*     @desc: enables block selection mode in grid
*     @type: public
*     @topic: 0
*/
dhtmlXGridObject.prototype.enableBlockSelection = function(mode)
{
	if (typeof this._bs_mode == "undefined"){
		var self = this;
		this.obj.onmousedown = function(e) {
			if (self._bs_mode) self._OnSelectionStart((e||event),this); return true;
		}
		this._CSVRowDelimiter = this.csv.row;
		this.attachEvent("onResize", function() {self._HideSelection(); return true;});
		this.attachEvent("onGridReconstructed", function() {self._HideSelection(); return true;});
		this.attachEvent("onFilterEnd",this._HideSelection);
	}
	if (mode===false){
		this._bs_mode=false;
		return this._HideSelection();
	} else this._bs_mode=true;

	if (!window.dhx4.isIPad){
		var area = this._clip_area = document.createElement("textarea");
		area.style.cssText = "position:absolute; width:1px; height:1px; overflow:hidden; color:transparent; background-color:transparent; bottom:1px; right:1px; border:none;";

		area.onkeydown=function(e){
	            e=e||event;
	            if (e.keyCode == 86 && (e.ctrlKey || e.metaKey))
					self.pasteBlockFromClipboard()
		};
	    document.body.insertBefore(this._clip_area,document.body.firstChild);

	    dhtmlxEvent(this.entBox,"click",function(){
	        if (!self.editor)
	            self._clip_area.select();
	    });
	}
}
/**
*     @desc:  affect block selection, so it will copy|paste only visible text , not values behind
*	  @param: mode - true/false
*     @type: public
*     @topic: 0
*/
dhtmlXGridObject.prototype.forceLabelSelection = function(mode)
{
	this._strictText = dhx4.s2b(mode)
}

dhtmlXGridObject.prototype._OnSelectionStart = function(event, obj)
{

	var self = this;
	if (event.button == 2) return;
	var src = event.srcElement || event.target;
	if (this.editor){
		if (src.tagName && (src.tagName=="INPUT" || src.tagName=="TEXTAREA"))   return;
		this.editStop();
	}
	
	self.setActive(true);
	var pos = this.getPosition(this.obj);
	var x = event.clientX - pos[0] + (document.body.scrollLeft||(document.documentElement?document.documentElement.scrollLeft:0));
	var y = event.clientY - pos[1] + (document.body.scrollTop||(document.documentElement?document.documentElement.scrollTop:0));
	this._CreateSelection(x-4, y-4);

	if (src == this._selectionObj) {
		this._HideSelection();
		this._startSelectionCell = null;
	} else {
	    while (src && (!src.tagName || src.tagName.toLowerCase() != 'td'))
	        src = src.parentNode;
	    this._startSelectionCell = src;
	}
	
	if (this._startSelectionCell){
		if (!this.callEvent("onBeforeBlockSelected",[this._startSelectionCell.parentNode.idd, this._startSelectionCell._cellIndex]))
			return this._startSelectionCell = null;
	}
	
	    //this._ShowSelection();
	    this.obj.onmousedown = null;
		this.obj[_isIE?"onmouseleave":"onmouseout"] = function(e){ if (self._blsTimer) window.clearTimeout(self._blsTimer); };	    
		this.obj.onmmold=this.obj.onmousemove;
		this._init_pos=[x,y];
	    this._selectionObj.onmousemove = this.obj.onmousemove = function(e) {e = e||event; if (e.preventDefault) e.preventDefault(); else e.returnValue = false;  self._OnSelectionMove(e);}
	    
	    
	    this._oldDMP=document.body.onmouseup;
	    document.body.onmouseup = function(e) {e = e||event; self._OnSelectionStop(e, this); return true; }
	this.callEvent("onBeforeBlockSelection",[]);
	document.body.onselectstart = function(){return false};//avoid text select	    
}

dhtmlXGridObject.prototype._getCellByPos = function(x,y){
	x=x;//+this.objBox.scrollLeft;
	if (this._fake)
		x+=this._fake.objBox.scrollWidth;
	y=y;//+this.objBox.scrollTop;
	var _x=0;
	for (var i=0; i < this.obj.rows.length; i++) {
		y-=this.obj.rows[i].offsetHeight;
		if (y<=0) {
			_x=this.obj.rows[i];
			break;
		}
	}
	if (!_x || !_x.idd) return null;
	for (var i=0; i < this._cCount; i++) {
		x-=this.getColWidth(i);
		if (x<=0) {
			while(true){
				if (_x._childIndexes && _x._childIndexes[i+1]==_x._childIndexes[i])
					_x=_x.previousSibling;
				else {
					return this.cells(_x.idd,i).cell;
				}
				
			}
		}
	}
	return null;
}

dhtmlXGridObject.prototype._OnSelectionMove = function(event)
{ 
	
	var self=this;
	this._ShowSelection();
	var pos = this.getPosition(this.obj);
	var X = event.clientX - pos[0] + (document.body.scrollLeft||(document.documentElement?document.documentElement.scrollLeft:0));
	var Y = event.clientY - pos[1] + (document.body.scrollTop||(document.documentElement?document.documentElement.scrollTop:0));

	if ((Math.abs(this._init_pos[0]-X)<5) && (Math.abs(this._init_pos[1]-Y)<5)) return this._HideSelection();
	
	var temp = this._endSelectionCell;
	if(this._startSelectionCell==null)
 		this._endSelectionCell  = this._startSelectionCell = this.getFirstParentOfType(event.srcElement || event.target,"TD");		
	else
		if (event.srcElement || event.target) {
			if ((event.srcElement || event.target).className == "dhtmlxGrid_selection")
				this._endSelectionCell=(this._getCellByPos(X,Y)||this._endSelectionCell);
			else {
				var t = this.getFirstParentOfType(event.srcElement || event.target,"TD");
				if (t.parentNode.idd) this._endSelectionCell = t;
			}
		}
		
	if (this._endSelectionCell){
		if (!this.callEvent("onBeforeBlockSelected",[this._endSelectionCell.parentNode.idd, this._endSelectionCell._cellIndex]))
			this._endSelectionCell = temp;
	}
	
		/*
	//window.status = pos[0]+'+'+pos[1];
	var prevX = this._selectionObj.startX;
	var prevY = this._selectionObj.startY;
	var diffX = X - prevX;
	var diffY = Y - prevY;
	
	if (diffX < 0) {
        this._selectionObj.style.left = this._selectionObj.startX + diffX + 1+"px";
        diffX = 0 - diffX;
	} else {
		this._selectionObj.style.left = this._selectionObj.startX - 3+"px";
	}
	if (diffY < 0) {
		this._selectionObj.style.top = this._selectionObj.startY + diffY + 1+"px";
        diffY = 0 - diffY;
	} else {
		this._selectionObj.style.top = this._selectionObj.startY - 3+"px";
	}
    this._selectionObj.style.width = (diffX>4?diffX-4:0) + 'px';
    this._selectionObj.style.height = (diffY>4?diffY-4:0) + 'px';


/* AUTO SCROLL */
	var BottomRightX = this.objBox.scrollLeft + this.objBox.clientWidth;
	var BottomRightY = this.objBox.scrollTop + this.objBox.clientHeight;
	var TopLeftX = this.objBox.scrollLeft;
	var TopLeftY = this.objBox.scrollTop;

	var nextCall=false;
	if (this._blsTimer) window.clearTimeout(this._blsTimer);	
	
	if (X+20 >= BottomRightX) {
		this.objBox.scrollLeft = this.objBox.scrollLeft+20;
		nextCall=true;
	} else if (X-20 < TopLeftX) {
		this.objBox.scrollLeft = this.objBox.scrollLeft-20;
		nextCall=true;
	}
	if (Y+20 >= BottomRightY && !this._realfake) {
		this.objBox.scrollTop = this.objBox.scrollTop+20;
		nextCall=true;
	} else if (Y-20 < TopLeftY && !this._realfake) {
		this.objBox.scrollTop = this.objBox.scrollTop-20;
		nextCall=true;		
	}
	this._selectionArea = this._RedrawSelectionPos(this._startSelectionCell, this._endSelectionCell);
	

	if (nextCall){ 
		var a=event.clientX;
		var b=event.clientY;
		this._blsTimer=window.setTimeout(function(){self._OnSelectionMove({clientX:a,clientY:b})},100);
	}
	
}

dhtmlXGridObject.prototype._OnSelectionStop = function(event)
{
	var self = this;
	if (this._blsTimer) window.clearTimeout(this._blsTimer);	
	this.obj.onmousedown = function(e) {if (self._bs_mode)  self._OnSelectionStart((e||event), this); return true;}
	this.obj.onmousemove = this.obj.onmmold||null;
	this._selectionObj.onmousemove = null;
	document.body.onmouseup = this._oldDMP||null;
	if ( parseInt( this._selectionObj.style.width ) < 2 && parseInt( this._selectionObj.style.height ) < 2) {
		this._HideSelection();
	} else {
	    var src = this.getFirstParentOfType(event.srcElement || event.target,"TD");
	    if ((!src) || (!src.parentNode.idd)){
	    	src=this._endSelectionCell;
    		}
	    while (src && (!src.tagName || src.tagName.toLowerCase() != 'td'))
	        src = src.parentNode;
	    if (!src) 
	    	return this._HideSelection();
	    this._stopSelectionCell = src;
	    this._selectionArea = this._RedrawSelectionPos(this._startSelectionCell, this._stopSelectionCell);
		this.callEvent("onBlockSelected",[]);
	}
	document.body.onselectstart = function(){};//avoid text select
}

dhtmlXGridObject.prototype._RedrawSelectionPos = function(LeftTop, RightBottom)
{

	if (LeftTop.parentNode.grid != RightBottom.parentNode.grid)
		return this._selectionArea;

//	td._cellIndex
//
//	getRowIndex
	var pos = {};
	pos.LeftTopCol = LeftTop._cellIndex;
	pos.LeftTopRow = this.getRowIndex( LeftTop.parentNode.idd );
	pos.RightBottomCol = RightBottom._cellIndex;
	pos.RightBottomRow = this.getRowIndex( RightBottom.parentNode.idd );

	var LeftTop_width = LeftTop.offsetWidth;
	var LeftTop_height = LeftTop.offsetHeight;
	LeftTop = this.getPosition(LeftTop, this.obj);

	var RightBottom_width = RightBottom.offsetWidth;
	var RightBottom_height = RightBottom.offsetHeight;
	RightBottom = this.getPosition(RightBottom, this.obj);

    if (LeftTop[0] < RightBottom[0]) {
		var Left = LeftTop[0];
		var Right = RightBottom[0] + RightBottom_width;
    } else {
    	var foo = pos.RightBottomCol;
        pos.RightBottomCol = pos.LeftTopCol;
        pos.LeftTopCol = foo;
		var Left = RightBottom[0];
		var Right = LeftTop[0] + LeftTop_width;
    }

    if (LeftTop[1] < RightBottom[1]) {
		var Top = LeftTop[1];
		var Bottom = RightBottom[1] + RightBottom_height;
    } else {
    	var foo = pos.RightBottomRow;
        pos.RightBottomRow = pos.LeftTopRow;
        pos.LeftTopRow = foo;
		var Top = RightBottom[1];
		var Bottom = LeftTop[1] + LeftTop_height;
    }

    var Width = Right - Left;
    var Height = Bottom - Top;

	this._selectionObj.style.left = Left + 'px';
	this._selectionObj.style.top = Top + 'px';
	this._selectionObj.style.width =  Width  + 'px';
	this._selectionObj.style.height = Height + 'px';
	return pos;
}

dhtmlXGridObject.prototype._CreateSelection = function(x, y)
{
	if (this._selectionObj == null) {
		var div = document.createElement('div');
		div.style.position = 'absolute';
        div.style.display = 'none';
        div.className = 'dhtmlxGrid_selection';
		this._selectionObj = div;
		this._selectionObj.onmousedown = function(e){
			e=e||event;
			if (e.button==2 || (_isMacOS&&e.ctrlKey))
				return this.parentNode.grid.callEvent("onBlockRightClick", ["BLOCK",e]);
		}
		this._selectionObj.oncontextmenu=function(e){(e||event).cancelBubble=true;return false;}
		this.objBox.appendChild(this._selectionObj);
	}
    //this._selectionObj.style.border = '1px solid #83abeb';
    this._selectionObj.style.width = '0px';
    this._selectionObj.style.height = '0px';
    //this._selectionObj.style.border = '0px';
	this._selectionObj.style.left = x + 'px';
	this._selectionObj.style.top  = y + 'px';
    this._selectionObj.startX = x;
    this._selectionObj.startY = y;
}

dhtmlXGridObject.prototype._ShowSelection = function()
{
	if (this._selectionObj)
	    this._selectionObj.style.display = '';
}

dhtmlXGridObject.prototype._HideSelection = function()
{
	
	if (this._selectionObj)
	    this._selectionObj.style.display = 'none';
    this._selectionArea = null;
    if (this._clip_area){
    	this._clip_area.value="";
    	this._clip_area.blur();
    }
}
/**
*     @desc: copy content of block selection into clipboard in csv format (delimiter as set for csv serialization)
*     @type: public
*     @topic: 0
*/
dhtmlXGridObject.prototype.copyBlockToClipboard = function()
{
	if (!this._clip_area) return;

	if ( this._selectionArea != null ) {
		var serialized = new Array();
	if (this._mathSerialization)
         this._agetm="getMathValue";
    else if (this._strictText)
    	this._agetm="getTitle";
    else this._agetm="getValue";

    this._serialize_visible = true;

		for (var i=this._selectionArea.LeftTopRow; i<=this._selectionArea.RightBottomRow; i++) {
			var data = this._serializeRowToCVS(this.rowsBuffer[i], null,  this._selectionArea.LeftTopCol, this._selectionArea.RightBottomCol+1);
			if (!this._csvAID)
				serialized[serialized.length] = data.substr( data.indexOf( this.csv.cell ) + 1 );	//remove row ID and add to array
			else
				serialized[serialized.length] = data;
		}
		serialized = serialized.join(this._CSVRowDelimiter);
		
		this._clip_area.value = serialized;
        this._clip_area.select();

	this._serialize_visible = false;
	}
}
/**
*     @desc: paste content of clipboard into block selection of grid
*     @type: public
*     @topic: 0
*/
dhtmlXGridObject.prototype.pasteBlockFromClipboard = function(){
	if (!this._clip_area) return;

	this._clip_area.select();
    var self = this;
    window.setTimeout(function(){
        self._pasteBlockFromClipboard();
        self=null;
    },1);
}
dhtmlXGridObject.prototype._pasteBlockFromClipboard = function()
{
	var serialized = this._clip_area.value;
    if (this._selectionArea != null) {
        var startRow = this._selectionArea.LeftTopRow;
        var startCol = this._selectionArea.LeftTopCol;
    } else if (this.cell != null && !this.editor) {
        var startRow = this.getRowIndex( this.cell.parentNode.idd );
        var startCol = this.cell._cellIndex;
    } else {
        return false;
    }

	serialized = this.csvParser.unblock(serialized, this.csv.cell, this.csv.row);
   // if ((serialized.length >1)&&(serialized[serialized.length-1]==""))
   // serialized.splice(serialized.length-1,1);
     
   //	if (serialized[serialized.length-1]=="") serialized.pop();
 /*   for (var i=0; i<serialized.length; i++) {
        serialized[i] = serialized[i].split(this.csv.cell);
    }*/
    var endRow = startRow+serialized.length;
    var endCol = startCol+serialized[0].length;
    if (endCol > this._cCount)
		endCol = this._cCount;
    var k = 0;
    for (var i=startRow; i<endRow; i++) {
        var row = this.render_row(i);
        if (row==-1) continue;
        var l = 0;
        for (var j=startCol; j<endCol; j++) {
        	if (this._hrrar[j] && !this._fake){
        		endCol = Math.max(endCol+1, this._cCount);
        		continue;
        	}
        	var ed = this.cells3(row, j);
        	if (ed.isDisabled()) {
        	    l++;
        	    continue;
        	}
        	if (this._onEditUndoRedo)
        		this._onEditUndoRedo(2, row.idd, j, serialized[ k ][ l ], ed.getValue());
        	if (ed.combo){
				var comboVa = ed.combo.values;
				for(var n=0; n<comboVa.length; n++)
					if (serialized[ k ][ l ] == comboVa[n]){
						ed.setValue( ed.combo.keys[ n ]);
						comboVa=null;
						break;
					}
				if (comboVa!=null && ed.editable) ed.setValue( serialized[ k ][ l++ ] );
				else l++;
        	}else
        		ed[ ed.setImage ? "setLabel" : "setValue" ]( serialized[ k ][ l++ ] );
        	ed.cell.wasChanged=true;
        }
        this.callEvent("onRowPaste",[row.idd])
        k++;
    }
}

dhtmlXGridObject.prototype.getSelectedBlock = function() {
	// if block selection exists
	if (this._selectionArea)
		return this._selectionArea;
	else if (this.getSelectedRowId() !== null){
		// if one cell is selected
			return {
				LeftTopRow: this.getSelectedRowId(),
				LeftTopCol: this.getSelectedCellIndex(),
				RightBottomRow: this.getSelectedRowId(),
				RightBottomCol: this.getSelectedCellIndex()
			};
		} else
			return null;
};
//(c)dhtmlx ltd. www.dhtmlx.com


/*
Product Name: dhtmlxSuite 
Version: 4.1.3 
Edition: Professional 
License: content of this file is covered by DHTMLX Commercial or Enterprise license. Usage without proper license is prohibited. To obtain it contact sales@dhtmlx.com
Copyright UAB Dinamenta http://www.dhtmlx.com
*/

/**
*   @desc: enable smart rendering mode
*   @type: public
*   @param: mode - true|false - enable|disable mode
*   @param: buffer - has sense only in dynamic loading mode, count of rows requrested from server by single operation, optional
*   @topic: 0
*/
dhtmlXGridObject.prototype.enableSmartRendering=function(mode,buffer,reserved){
	if (arguments.length>2){
		if (buffer && !this.rowsBuffer[buffer-1]) this.rowsBuffer[buffer-1]=0;
		buffer=reserved;
	}
	this._srnd=dhx4.s2b(mode);
	this._srdh=this._srdh||20;
	this._dpref=buffer||0;
	
};
/**
*   @desc: allows to pre-render rows during scrolling, make scrolling more smooth, but with small drop in overall perfomance
*   @type: public
*   @param: buffer - count of rows, which will be prerendered
*   @topic: 0
*/
dhtmlXGridObject.prototype.enablePreRendering=function(buffer){
	this._srnd_pr=parseInt(buffer||50);
};
/**
*   @desc: force grid in dyn. srnd mode fully load itself from server side
*   @type: public
*   @param: buffer - how much rows grid can request from server side in one operation
*   @topic: 0
*/
dhtmlXGridObject.prototype.forceFullLoading=function(buffer, callback){
	for (var i=0; i<this.rowsBuffer.length; i++)
		if (!this.rowsBuffer[i]){
			var usedbuffer = buffer || (this.rowsBuffer.length-i);
			if (this.callEvent("onDynXLS",[i,usedbuffer])){
				var self=this;
				this.load(this.xmlFileUrl+dhtmlx.url(this.xmlFileUrl)+"posStart="+i+"&count="+usedbuffer, function(){
					window.setTimeout(function(){	self.forceFullLoading(buffer, callback); },100); 
				}, this._data_type);
			}
			return;
		}
	if (callback) callback.call(this);
};

/**
*   @desc: set height which will be used in smart rendering mode for row calculation, function need to be used if you use custom skin for grid which changes default row height
*   @type: public
   @param: {int} height - awaited height of row
*   @returns: void
*   @topic: 0
*/      
dhtmlXGridObject.prototype.setAwaitedRowHeight = function(height) {
   this._srdh=parseInt(height);
};

dhtmlXGridObject.prototype._get_view_size=function(){
	return Math.floor(parseInt(this.entBox.offsetHeight)/this._srdh)+2;
};
dhtmlXGridObject.prototype._add_filler=function(pos,len,fil,rsflag){
	if (!len) return null;
	var id="__filler__";
	var row=this._prepareRow(id);
	row.firstChild.style.width="1px";
	row.firstChild.style.padding = row.firstChild.style.margin ="0px";
	for (var i=1; i<row.childNodes.length; i++)
	    row.childNodes[i].style.display='none';
 	row.firstChild.style.height=len*this._srdh+"px";
 	fil=fil||this.rowsCol[pos];
 	if (fil && fil.nextSibling) 
 		fil.parentNode.insertBefore(row,fil.nextSibling);
 	else
 		if (_isKHTML)
 			this.obj.appendChild(row);
 		else
 			this.obj.rows[0].parentNode.appendChild(row);
 			
 	this.callEvent("onAddFiller",[pos,len,row,fil,rsflag]);
 	return [pos,len,row];
};
dhtmlXGridObject.prototype._update_srnd_view=function(){
	    var min=Math.floor(this.objBox.scrollTop/this._srdh);
        var max=min+this._get_view_size();
        if (this.multiLine) {
        // Calculate the min, by Stephane Bernard
            var pxHeight = this.objBox.scrollTop;
            min = 0;
            while(pxHeight > 0) {
                pxHeight-=this.rowsCol[min]?this.rowsCol[min].offsetHeight:this._srdh;
                min++;
            }
            // Calculate the max
            max=min+this._get_view_size();
            if (min>0) min--;
        }        
        max+=(this._srnd_pr||0);//pre-rendering
        if (max>this.rowsBuffer.length) max=this.rowsBuffer.length;

        for (var j=min; j<max; j++){ 
            if (!this.rowsCol[j]){
				var res=this._add_from_buffer(j);
				if (res==-1){
					if (this.xmlFileUrl){
						if (this._dpref && this.rowsBuffer[max-1]){
							//we have last row in sett, assuming that we in scrolling up process
							var rows_count = this._dpref?this._dpref:(max-j)
							var start_pos = Math.max(0, Math.min(j, max - this._dpref));
							this._current_load=[start_pos, max-start_pos];
						} else 
							this._current_load=[j,(this._dpref?this._dpref:(max-j))];
						if (this.callEvent("onDynXLS",this._current_load))
							this.load(this.xmlFileUrl+dhtmlx.url(this.xmlFileUrl)+"posStart="+this._current_load[0]+"&count="+this._current_load[1], this._data_type);
					}
					return;
				} else {
	               	if (this._tgle){
	               		this._updateLine(this._h2.get[this.rowsBuffer[j].idd],this.rowsBuffer[j]);
	               		this._updateParentLine(this._h2.get[this.rowsBuffer[j].idd],this.rowsBuffer[j]);
	           		}
					if (j && j==(this._realfake?this._fake:this)["_r_select"]){
						this.selectCell(j, this.cell?this.cell._cellIndex:0, true);
					}
				}
            }
		}
	if (this._fake && !this._realfake && this.multiLine) 
		this._fake.objBox.scrollTop = this.objBox.scrollTop;		
}
dhtmlXGridObject.prototype._add_from_buffer=function(ind){
	    var row=this.render_row(ind);
	    if (row==-1) return -1;
	    if (row._attrs["selected"] || row._attrs["select"]){
			this.selectRow(row,false,true);
			row._attrs["selected"]=row._attrs["select"]=null;
		}
						
	    if (!this._cssSP){ 
		    if (this._cssEven && ind%2 == 0 )
				row.className=this._cssEven+((row.className.indexOf("rowselected") != -1)?" rowselected ":" ")+(row._css||"");
			else if (this._cssUnEven && ind%2 == 1 )
			    row.className=this._cssUnEven+((row.className.indexOf("rowselected") != -1)?" rowselected ":" ")+(row._css||"");				
			} else if (this._h2) {
				var x=this._h2.get[row.idd];
				row.className+=" "+((x.level%2)?(this._cssUnEven+" "+this._cssUnEven):(this._cssEven+" "+this._cssEven))+"_"+x.level+(this.rowsAr[x.id]._css||"");
			}
			

	    //now we need to get location of node
	    for (var i=0; i<this._fillers.length; i++){
	    	var f=this._fillers[i];
	    	if (f && f[0]<=ind && (f[0]+f[1])>ind ){
	    		//filler found
	    		var pos=ind-f[0];
	    		if (pos==0){
	    			//start
	    			this._insert_before(ind,row,f[2]);
	    			this._update_fillers(i,-1,1);
	    		} else if (pos == f[1]-1){
	    			this._insert_after(ind,row,f[2]);
	    			this._update_fillers(i,-1,0);
	    		} else {
	    			this._fillers.push(this._add_filler(ind+1,f[1]-pos-1,f[2],1));
	    			this._insert_after(ind,row,f[2]);
	    			this._update_fillers(i,-f[1]+pos,0);
	    		}
	    		return;
	    	}
	    }
}
dhtmlXGridObject.prototype._update_fillers=function(ind,right,left){
	var f=this._fillers[ind];
	f[1]=f[1]+right;
	f[0]=f[0]+left;
	if (!f[1]){
		this.callEvent("onRemoveFiller",[f[2]]);
		f[2].parentNode.removeChild(f[2]);
		this._fillers.splice(ind,1);
	} else {
		f[2].firstChild.style.height=parseFloat(f[2].firstChild.style.height)+right*this._srdh+"px";	
		this.callEvent("onUpdateFiller",[f[2]]);
	}
}
dhtmlXGridObject.prototype._insert_before=function(ind,row,fil){
	fil.parentNode.insertBefore(row,fil);
	this.rowsCol[ind]=row;
	this.callEvent("onRowInserted",[row,null,fil,"before"]);
}
dhtmlXGridObject.prototype._insert_after=function(ind,row,fil){
	if (fil.nextSibling)
		fil.parentNode.insertBefore(row,fil.nextSibling);
	else
		fil.parentNode.appendChild(row);
	this.rowsCol[ind]=row;
	this.callEvent("onRowInserted",[row,null,fil,"after"]);
}


/*
Product Name: dhtmlxSuite 
Version: 4.1.3 
Edition: Professional 
License: content of this file is covered by DHTMLX Commercial or Enterprise license. Usage without proper license is prohibited. To obtain it contact sales@dhtmlx.com
Copyright UAB Dinamenta http://www.dhtmlx.com
*/

//all purpose set of rules, based on http://code.google.com/p/validation-js
dhtmlxValidation=function(){};
dhtmlxValidation.prototype={
	trackInput:function(el,rule,callback_error,callback_correct){
			dhtmlxEvent(el,"keyup",function(e){ 
				if (dhtmlxValidation._timer) {
					window.clearTimeout(dhtmlxValidation._timer);
					dhtmlxValidation._timer = null;
				}
				dhtmlxValidation._timer = window.setTimeout(function(){

					if (!dhtmlxValidation.checkInput(el,rule)){
						if(!callback_error || callback_error(el,el.value,rule))
							el.className+=" dhtmlx_live_validation_error";
					} else {
						el.className=el.className.replace(/[ ]*dhtmlx_live_validation_error/g,"");
						if (callback_correct)
							callback_correct(el,el.value,rule);
					}
				
				},250);
			});
	},
	checkInput:function(input,rule){
		return this.checkValue(input.value,rule);
	},
	checkValue:function(value,rule){
		if (typeof rule=="string")
			rule = rule.split(",");
			
		var final_res=true;
		for (var i=0; i<rule.length; i++){
			if (!this["is"+rule[i]])
				alert("Incorrect validation rule: "+rule[i]);
			else
				final_res=final_res&&this["is"+rule[i]](value);;
		}
		return final_res;
	},
	isEmpty: function(value) {
		return value == '';
	},
	isNotEmpty: function(value) {
		return (value instanceof Array?value.length>0:!value == ''); // array in case of multiselect
	},
	isValidBoolean: function(value) {
		return !!value.toString().match(/^(0|1|true|false)$/);
	},
	isValidEmail: function(value) {
		return !!value.toString().match(/(^[a-z0-9]([0-9a-z\-_\.]*)@([0-9a-z_\-\.]*)([.][a-z]{3})$)|(^[a-z]([0-9a-z_\.\-]*)@([0-9a-z_\-\.]*)(\.[a-z]{2,4})$)/i); 
	},
	isValidInteger: function(value) {
		return !!value.toString().match(/(^-?\d+$)/);
	},
	isValidNumeric: function(value) {
		return !!value.toString().match(/(^-?\d\d*[\.|,]\d*$)|(^-?\d\d*$)|(^-?[\.|,]\d\d*$)/);
	},
	isValidAplhaNumeric: function(value) {
		return !!value.toString().match(/^[_\-a-z0-9]+$/gi);
	},
	// 0000-00-00 00:00:00 to 9999:12:31 59:59:59 (no it is not a "valid DATE" function)
	isValidDatetime: function(value) {
		var dt = value.toString().match(/^(\d{4})-(\d{2})-(\d{2})\s(\d{2}):(\d{2}):(\d{2})$/);
		return dt && !!(dt[1]<=9999 && dt[2]<=12 && dt[3]<=31 && dt[4]<=59 && dt[5]<=59 && dt[6]<=59) || false;
	},
	// 0000-00-00 to 9999-12-31
	isValidDate: function(value) {
		var d = value.toString().match(/^(\d{4})-(\d{2})-(\d{2})$/);
		return d && !!(d[1]<=9999 && d[2]<=12 && d[3]<=31) || false;
	},
	// 00:00:00 to 59:59:59
	isValidTime: function(value) {
		var t = value.toString().match(/^(\d{1,2}):(\d{1,2}):(\d{1,2})$/);
		return t && !!(t[1]<=24 && t[2]<=59 && t[3]<=59) || false;
	},
	// 0.0.0.0 to 255.255.255.255
	isValidIPv4: function(value) { 
		var ip = value.toString().match(/^(\d{1,3})\.(\d{1,3})\.(\d{1,3})\.(\d{1,3})$/);
		return ip && !!(ip[1]<=255 && ip[2]<=255 && ip[3]<=255 && ip[4]<=255) || false;
	},
	isValidCurrency: function(value) { // Q: Should I consider those signs valid too ? : ¢|€|₤|₦|¥
		return value.toString().match(/^\$?\s?\d+?([\.,\,]?\d+)?\s?\$?$/) && true || false;
	},
	// Social Security Number (999-99-9999 or 999999999)
	isValidSSN: function(value) {
		return value.toString().match(/^\d{3}\-?\d{2}\-?\d{4}$/) && true || false;
	},
	// Social Insurance Number (999999999)
	isValidSIN: function(value) {
		return value.toString().match(/^\d{9}$/) && true || false;
	}	
};
dhtmlxValidation=new dhtmlxValidation();
//extension for the grid
dhtmlXGridObject.prototype.enableValidation=function(mode,live){
	mode=dhx4.s2b(mode);
	if (mode){
		this._validators={ data:[] };
	}else
		this._validators=false;
		
	if (arguments.length>1)
		this._validators._live=live;
	if (!this._validators._event)
		this._validators._event=this.attachEvent("onEditCell",this.validationEvent);
		
	};
dhtmlXGridObject.prototype.setColValidators=function(vals){
	if (!this._validators) this.enableValidation(true);
	if (typeof vals == "string") vals=vals.split(this.delim);
	this._validators.data=vals;
};
dhtmlXGridObject.prototype.validationEvent=function(stage,id,ind,newval,oldval){
	var v=this._validators; 
	if (!v) return true; // validators disabled
	var rule=(v.data[ind]||this.cells(id,ind).getAttribute("validate"))||"";
	
	if (stage==1 && rule){
		var ed = this.editor||(this._fake||{}).editor;
		if (!ed) return true; //event was trigered by checkbox
		ed.cell.className=ed.cell.className.replace(/[ ]*dhtmlx_validation_error/g,"");
		if (v._live){
			var grid=this;
			dhtmlxValidation.trackInput(ed.getInput(),rule,function(element,value,rule){
				return grid.callEvent("onLiveValidationError",[id,ind,value,element,rule]);
			},function(element,value,rule){
				return grid.callEvent("onLiveValidationCorrect",[id,ind,value,element,rule]);
			});
		}
	}

	if (stage==2)
		this.validateCell(id,ind,rule,newval);
	
	return true;
};

dhtmlXGridObject.prototype.validateCell=function(id,ind,rule,value){
	rule=rule||(this._validators.data[ind]||this.cells(id,ind).getAttribute("validate"));
	value=value||this.cells(id,ind).getValue();
	if (!rule) return;
	var cell = this.cells(id,ind).cell;

	var result = true;
	if (typeof rule == "string")
		rule = rule.split(this.delim);
		
	for (var i=0; i < rule.length; i++) {
		if (!dhtmlxValidation.checkValue(value,rule[i])){
			if (this.callEvent("onValidationError",[id,ind,value,rule[i]]))
				cell.className+=" dhtmlx_validation_error";
			result = false;
		}
	}
	if (result){
		this.callEvent("onValidationCorrect",[id,ind,value,rule]);
		cell.className=cell.className.replace(/[ ]*dhtmlx_validation_error/g,"");		
	}
	return result;
};

/*
Product Name: dhtmlxSuite 
Version: 4.1.3 
Edition: Professional 
License: content of this file is covered by DHTMLX Commercial or Enterprise license. Usage without proper license is prohibited. To obtain it contact sales@dhtmlx.com
Copyright UAB Dinamenta http://www.dhtmlx.com
*/


function eXcell_stree(cell){
	if (cell){
		this.cell = cell;
    	this.grid = this.cell.parentNode.grid;
    
    	if (!this.grid._sub_trees) return;
    	this._sub=this.grid._sub_trees[cell._cellIndex];
    	if (!this._sub) return;
    	this._sub=this._sub[0];
    }
	
	this.getValue = function(){
		return this.cell._val;
	}
	this.setValue = function(val){
		this.cell._val=val;
		val = this._sub.getItemText(this.cell._val);
		this.setCValue((val||"&nbsp;"),val);
	}
	this.edit = function(){
		this._sub.parentObject.style.display='block';
		var arPos = this.grid.getPosition(this.cell);//,this.grid.objBox
		this._sub.parentObject.style.top=arPos[1]+"px";
		this._sub.parentObject.style.left=arPos[0]+"px";
		this._sub.parentObject.style.position="absolute";
		
		var a=this.grid.editStop;
		this.grid.editStop=function(){};
		
		this.grid.editStop=a;
	}
	this.detach=function(){
		this._sub.parentObject.style.display='none';
		if (this.grid._sub_id != null) {
			var old=this.cell._val;
			this.setValue(this._sub.getSelectedItemId());
			this.grid._sub_id = null;
			return this.cell._val!=old;
		}
	}
}
eXcell_stree.prototype = new eXcell;


dhtmlXGridObject.prototype.setSubTree=function(tree,s_index){
		if (!this._sub_trees) 
			this._sub_trees=[];
		this._sub_trees[s_index]=[tree];
		tree.parentObject.style.display="none";
		var that=this;
		tree.parentObject.onclick = function(event) {(event || window.event).cancelBubble = true;return false;}
		tree.ev_onDblClick=null;
		tree.attachEvent("onDblClick",function(id){
			that._sub_id = id;
			that.editStop();
			return true;
		});
		tree._chRRS=true;
};
//(c)dhtmlx ltd. www.dhtmlx.com


/*
Product Name: dhtmlxSuite 
Version: 4.1.3 
Edition: Professional 
License: content of this file is covered by DHTMLX Commercial or Enterprise license. Usage without proper license is prohibited. To obtain it contact sales@dhtmlx.com
Copyright UAB Dinamenta http://www.dhtmlx.com
*/


/*
HTML Link eXcell v.1.0  for dhtmlxGrid 
(c)DHTMLX LTD. 2005


The corresponding  cell value in XML should be a "^" delimited list of following values:
1st - Link Text 
2nd - URL (optional)
3rd - target (optional, default is _blank)

Samples:
<cell>Stephen King</cell>
<cell>Stephen King^http://www.stephenking.com/</cell>
<cell>Stephen King^http://www.stephenking.com/^_self</cell>
*/

/**
*	@desc: link editor
*	@returns: dhtmlxGrid cell editor object
*	@type: public
*/

function eXcell_link(cell){
	this.cell = cell;
    this.grid = this.cell.parentNode.grid;
    this.isDisabled=function(){return true;}
	this.edit = function(){}
	this.getValue = function(){
		if(this.cell.firstChild.getAttribute){
			var target = this.cell.firstChild.getAttribute("target")
			return this.cell.firstChild.innerHTML+"^"+this.cell.firstChild.getAttribute("href")+(target?("^"+target):"");
		}

		else
			return "";
	}
	this.setValue = function(val){
		if((typeof(val)!="number") && (!val || val.toString()._dhx_trim()=="")){		
			this.setCValue("&nbsp;",valsAr);			
			return (this.cell._clearCell=true);
		}
		var valsAr = val.split("^");
		if(valsAr.length==1)
			valsAr[1] = "";
		else{
			if(valsAr.length>1){
				valsAr[1] = "href='"+valsAr[1]+"'";
				if(valsAr.length==3)
					valsAr[1]+= " target='"+valsAr[2]+"'";
				else
					valsAr[1]+= " target='_blank'";
			}
		}

		this.setCValue("<a "+valsAr[1]+" onclick='(_isIE?event:arguments[0]).cancelBubble = true;'>"+valsAr[0]+"</a>",valsAr);
	}
}

eXcell_link.prototype = new eXcell;
eXcell_link.prototype.getTitle=function(){
	var z=this.cell.firstChild;
	return ((z&&z.tagName)?z.getAttribute("href"):"");
}
eXcell_link.prototype.getContent=function(){
	var z=this.cell.firstChild;
	return ((z&&z.tagName)?z.innerHTML:"");
}
//(c)dhtmlx ltd. www.dhtmlx.com


/*
Product Name: dhtmlxSuite 
Version: 4.1.3 
Edition: Professional 
License: content of this file is covered by DHTMLX Commercial or Enterprise license. Usage without proper license is prohibited. To obtain it contact sales@dhtmlx.com
Copyright UAB Dinamenta http://www.dhtmlx.com
*/

function eXcell_grid(cell){
	if (cell){
		this.cell = cell;
    	this.grid = this.cell.parentNode.grid;
    
    	if (!this.grid._sub_grids) return;
    	this._sub=this.grid._sub_grids[cell._cellIndex];
    	if (!this._sub) return;
    	this._sindex=this._sub[1];
    	this._sub=this._sub[0];
    }
	
	this.getValue = function(){
		return this.cell.val;
	}
	this.setValue = function(val){
		this.cell.val=val;
		
		if (this._sub.getRowById(val)) {
			val=this._sub.cells(val,this._sindex);
		if (val) val=val.getValue();
		else val="";
	 } 
		
		this.setCValue((val||"&nbsp;"),val);
		
	}
	this.edit = function(){ 
		this.val = this.cell.val;
		
		this._sub.entBox.style.display='block';
		var arPos = this.grid.getPosition(this.cell);//,this.grid.objBox
		this._sub.entBox.style.top=arPos[1]+"px";
		this._sub.entBox.style.left=arPos[0]+"px";
		this._sub.entBox.style.position="absolute";
		this._sub.setSizes();
		
		var a=this.grid.editStop;
		this.grid.editStop=function(){};
		if (this._sub.getRowById(this.cell.val)) 
			this._sub.setSelectedRow(this.cell.val);
		this._sub.setActive(true)
		
		this.grid.editStop=a;
	}
	this.detach=function(){
		var old=this.cell.val;
		this._sub.entBox.style.display='none';
		if (this._sub.getSelectedId()===null) return false;
		this.setValue(this._sub.getSelectedId());
		this.grid.setActive(true)
		return this.cell.val!=old;
	}
}
eXcell_grid.prototype = new eXcell;


dhtmlXGridObject.prototype.setSubGrid=function(grid,s_index,t_index){
		if (!this._sub_grids) 
			this._sub_grids=[];
		this._sub_grids[s_index]=[grid,t_index];
		grid.entBox.style.display="none";
		var that=this;
		
		grid.attachEvent("onRowSelect",function(id){
			that.editStop();
			return true;
		});
		grid._chRRS=false;
};
//(c)dhtmlx ltd. www.dhtmlx.com

/*
Product Name: dhtmlxSuite 
Version: 4.1.3 
Edition: Professional 
License: content of this file is covered by DHTMLX Commercial or Enterprise license. Usage without proper license is prohibited. To obtain it contact sales@dhtmlx.com
Copyright UAB Dinamenta http://www.dhtmlx.com
*/

function eXcell_dhxCalendar(cell) {
	if (cell) {
		this.cell = cell;
		this.grid = this.cell.parentNode.grid;
		
		if (!this.grid._grid_calendarA) {
			
			var cal = this.grid._grid_calendarA = new dhtmlxCalendarObject();
			this.grid.callEvent("onDhxCalendarCreated", [cal]);
			
			var sgrid = this.grid;
			cal.attachEvent("onClick",function(){
                    		this._last_operation_calendar=true;
                    		window.setTimeout(function(){sgrid.editStop()},1);
                    		return true;
                    	});
                    	
                    	var zFunc = function(e){ (e||event).cancelBubble=true; }
                    	dhtmlxEvent(cal.base, "click", zFunc);
                    	cal = null;
                }
	}
}
eXcell_dhxCalendar.prototype = new eXcell;

eXcell_dhxCalendar.prototype.edit = function() {
	
	var arPos = this.grid.getPosition(this.cell);
	this.grid._grid_calendarA._show(false, false);
	this.grid._grid_calendarA.setPosition(arPos[0],arPos[1]+this.cell.offsetHeight);
	this.grid._grid_calendarA._last_operation_calendar = false;
	
	
	this.grid.callEvent("onCalendarShow", [this.grid._grid_calendarA, this.cell.parentNode.idd, this.cell._cellIndex]);
	//var arPos = this.grid.getPosition(this.cell);
	//var pval=this._date2str2(this.cell.val||new Date());
	//window._grid_calendar.render(arPos[0],arPos[1]+this.cell.offsetHeight,this,pval);
	this.cell._cediton = true;
	this.val = this.cell.val;
	this._val = this.cell.innerHTML;
	// alert(this.cell.val);
	var t = this.grid._grid_calendarA.draw;
	this.grid._grid_calendarA.draw = function(){};
	this.grid._grid_calendarA.setDateFormat((this.grid._dtmask||"%d/%m/%Y"));
	this.grid._grid_calendarA.setDate(this.val||(new Date()));
	this.grid._grid_calendarA.draw = t;
	
	//this.grid._grid_calendarA.draw();
}
eXcell_dhxCalendar.prototype.getDate = function() {
	if (this.cell.val) return this.cell.val;
	return null;
}

eXcell_dhxCalendar.prototype.getValue = function() {
	if (this.cell._clearCell) return "";
	if (this.grid._dtmask_inc && this.cell.val) return this.grid._grid_calendarA.getFormatedDate(this.grid._dtmask_inc, this.cell.val).toString();
	return this.cell.innerHTML.toString()._dhx_trim()
}

eXcell_dhxCalendar.prototype.detach = function() {
	if (!this.grid._grid_calendarA) return;
	this.grid._grid_calendarA.hide();
	if (this.cell._cediton) this.cell._cediton = false; else return;
	
	if (this.grid._grid_calendarA._last_operation_calendar) {
		var z1=this.grid._grid_calendarA.getFormatedDate((this.grid._dtmask||"%d/%m/%Y"));
		var z2=this.grid._grid_calendarA.getDate();
		this.cell.val=new Date(z2);
		this.setCValue(z1,z2);
		this.cell._clearCell = !z1;
		var t = this.val;
		this.val = this._val;
		return (this.cell.val.valueOf()!=t);
	}
	return false;
}


eXcell_dhxCalendar.prototype.setValue = function(val) {
	
	if (val && typeof val == "object") {
		this.cell.val=val;
		this.cell._clearCell=false;
		this.setCValue(this.grid._grid_calendarA.getFormatedDate((this.grid._dtmask||"%d/%m/%Y"),val).toString(),this.cell.val);
		return;
	}
	
	
	if (!val || val.toString()._dhx_trim()=="") {
		val="&nbsp";
		this.cell._clearCell=true;
		this.cell.val="";
	} else{
		this.cell._clearCell=false;
		this.cell.val=new Date(this.grid._grid_calendarA.setFormatedDate((this.grid._dtmask_inc||this.grid._dtmask||"%d/%m/%Y"),val.toString(),null,true));
		if (this.grid._dtmask_inc)
			val = this.grid._grid_calendarA.getFormatedDate((this.grid._dtmask||"%d/%m/%Y"),this.cell.val);
	}
	
	if ((this.cell.val=="NaN")||(this.cell.val=="Invalid Date")) {
		this.cell._clearCell=true;
		this.cell.val=new Date();
		this.setCValue("&nbsp;",0);
	} else {
		this.setCValue((val||"").toString(),this.cell.val);
	}
}


function eXcell_dhxCalendarA(cell) {
	if (cell) {
		this.cell = cell;
		this.grid = this.cell.parentNode.grid;
		
		if (!this.grid._grid_calendarA) {
			
			var cal = this.grid._grid_calendarA = new dhtmlxCalendarObject();
			this.grid.callEvent("onDhxCalendarCreated",[cal]);
			
			var sgrid=this.grid;
			cal.attachEvent("onClick",function() {
				this._last_operation_calendar=true;
				window.setTimeout(function() {sgrid.editStop()},1);
				return true;
                    	});
                    	
                    	var zFunc=function(e) { (e||event).cancelBubble=true;  }
                    	dhtmlxEvent(cal.base,"click",zFunc);
                }      
	}
}
eXcell_dhxCalendarA.prototype = new eXcell;

eXcell_dhxCalendarA.prototype.edit = function() {
	var arPos = this.grid.getPosition(this.cell);
	
	this.grid._grid_calendarA._show(false, false);
	this.grid._grid_calendarA.setPosition(arPos[0]*1+this.cell.offsetWidth,arPos[1]*1);
	this.grid.callEvent("onCalendarShow",[this.grid._grid_calendarA,this.cell.parentNode.idd,this.cell._cellIndex]);
	this.grid._grid_calendarA._last_operation_calendar=false;
	
	this.cell._cediton=true;
	this.val=this.cell.val;
	this._val=this.cell.innerHTML;
	
	var t=this.grid._grid_calendarA.draw; this.grid._grid_calendarA.draw=function() {};
	this.grid._grid_calendarA.setDateFormat((this.grid._dtmask||"%d/%m/%Y"));
	this.grid._grid_calendarA.setDate(this.val);
	this.grid._grid_calendarA.draw=t;
	
	this.cell.atag=((!this.grid.multiLine)&&(_isKHTML||_isMacOS||_isFF))?"INPUT":"TEXTAREA";
	
	this.obj = document.createElement(this.cell.atag);
	this.obj.style.height = (this.cell.offsetHeight-4)+"px";
	this.obj.className="dhx_combo_edit";
	this.obj.wrap = "soft";
	this.obj.style.textAlign = this.cell.align;
	this.obj.onclick = function(e) {(e||event).cancelBubble = true}
	this.obj.onmousedown = function(e) {(e||event).cancelBubble = true}
	this.obj.value = this.getValue();
	this.cell.innerHTML = "";
	this.cell.appendChild(this.obj);
	if (window.dhx4.isIE) {
		this.obj.style.overflow = "visible";
		if ((this.grid.multiLine)&&(this.obj.offsetHeight>=18)&&(this.obj.offsetHeight<40)) {
			this.obj.style.height = "36px";
			this.obj.style.overflow = "scroll";
		}
	}
	this.obj.onselectstart=function(e) {
		if (!e) e=event;
		e.cancelBubble = true;
		return true;
	};
	this.obj.focus()
	this.obj.focus()
	
}

eXcell_dhxCalendarA.prototype.getDate = function() {
	if (this.cell.val) return this.cell.val;
	return null;
}

eXcell_dhxCalendarA.prototype.getValue = function() {
	if (this.cell._clearCell) return "";
	if (this.grid._dtmask_inc && this.cell.val)
		return this.grid._grid_calendarA.getFormatedDate(this.grid._dtmask_inc, this.cell.val).toString();
	return this.cell.innerHTML.toString()._dhx_trim()
}

eXcell_dhxCalendarA.prototype.detach = function() {
	if (!this.grid._grid_calendarA) return;
	this.grid._grid_calendarA.hide();
	if (this.cell._cediton) this.cell._cediton=false; else return;
	if (this.grid._grid_calendarA._last_operation_calendar) {
		this.grid._grid_calendarA._last_operation_calendar=false;
		var z1=this.grid._grid_calendarA.getFormatedDate(this.grid._dtmask||"%d/%m/%Y");
		var z2=this.grid._grid_calendarA.getDate();
		this.cell.val=new Date(z2);
		this.setCValue(z1,z2);
		this.cell._clearCell = !z1;
		var t = this.val;
		this.val=this._val;
		return (this.cell.val.valueOf()!=(t|"").valueOf());
	}
	this.setValue(this.obj.value);
	var t = this.val;
	this.val = this._val;
	return (this.cell.val.valueOf()!=(t||"").valueOf());
}

eXcell_dhxCalendarA.prototype.setValue = function(val) {
	if (val && typeof val == "object") {
		this.cell.val=val;
		this.cell._clearCell=false;
		this.setCValue(this.grid._grid_calendarA.getFormatedDate((this.grid._dtmask||"%d/%m/%Y"),val).toString(),this.cell.val);
		return;
	}
	
	if (!val || val.toString()._dhx_trim()=="") {
		val="&nbsp";
		this.cell._clearCell=true;
		this.cell.val="";
	} else {
		this.cell._clearCell = false;
		this.cell.val = new Date(this.grid._grid_calendarA.setFormatedDate((this.grid._dtmask_inc||this.grid._dtmask||"%d/%m/%Y"),val.toString(),null,true));
		if (this.grid._dtmask_inc)
			val = this.grid._grid_calendarA.getFormatedDate((this.grid._dtmask||"%d/%m/%Y"),this.cell.val);
	}
	
	if ((this.cell.val=="NaN")||(this.cell.val=="Invalid Date")) {
		this.cell.val=new Date();
		this.cell._clearCell=true;
		this.setCValue("&nbsp;",0);
	} else {
		this.setCValue((val||"").toString(),this.cell.val);
	}
}


/*
Product Name: dhtmlxSuite 
Version: 4.1.3 
Edition: Professional 
License: content of this file is covered by DHTMLX Commercial or Enterprise license. Usage without proper license is prohibited. To obtain it contact sales@dhtmlx.com
Copyright UAB Dinamenta http://www.dhtmlx.com
*/

/**
*	@desc: auto counter editor
*	@returns: dhtmlxGrid cell editor object
*	@type: public
*/
function eXcell_cntr(cell){
	this.cell = cell;
    this.grid = this.cell.parentNode.grid;
	if (!this.grid._ex_cntr_ready && !this._realfake){
		this.grid._ex_cntr_ready=true;
		if (this.grid._h2)
			this.grid.attachEvent("onOpenEn",function(id){
				this.resetCounter(cell._cellIndex);
			});
		var fix_cnt = function(){ 
			var that=this;
			window.setTimeout(function(){ 
				if (!that.resetCounter) return;
				if (that._fake && !that._realfake && cell._cellIndex<that._fake._cCount) 
					that._fake.resetCounter(cell._cellIndex); 
				else
				    that.resetCounter(cell._cellIndex);
			},1);
			return true;
		};

		this.grid.attachEvent("onBeforeSorting", fix_cnt);
		this.grid.attachEvent("onFilterEnd", fix_cnt);
	}
	
	

	this.edit = function(){}
	this.getValue = function(){
		return this.cell.innerHTML;
	}
	this.setValue = function(val){
		this.cell.style.paddingRight = "2px";
		var cell=this.cell;
		
		window.setTimeout(function(){
			if (!cell.parentNode) return;
			var val=cell.parentNode.rowIndex;
			if (cell.parentNode.grid.currentPage || val<0 || cell.parentNode.grid._srnd) val=cell.parentNode.grid.rowsBuffer._dhx_find(cell.parentNode)+1;
			if (val<=0) return;
			cell.innerHTML = val;
			if (cell.parentNode.grid._fake && cell._cellIndex<cell.parentNode.grid._fake._cCount && cell.parentNode.grid._fake.rowsAr[cell.parentNode.idd]) cell.parentNode.grid._fake.cells(cell.parentNode.idd,cell._cellIndex).setCValue(val);
			cell=null;
		},100);
	}
}
dhtmlXGridObject.prototype.resetCounter=function(ind){
	if (this._fake && !this._realfake && ind < this._fake._cCount) this._fake.resetCounter(ind,this.currentPage);
	var i=arguments[0]||0;
	if (this.currentPage)
		i=(this.currentPage-1)*this.rowsBufferOutSize;
	for (i=0; i<this.rowsBuffer.length; i++)
		if (this.rowsBuffer[i] && this.rowsBuffer[i].tagName == "TR" && this.rowsAr[this.rowsBuffer[i].idd])
			this.rowsAr[this.rowsBuffer[i].idd].childNodes[ind].innerHTML=i+1;
}
eXcell_cntr.prototype = new eXcell;
//(c)dhtmlx ltd. www.dhtmlx.com


/*
Product Name: dhtmlxSuite 
Version: 4.1.3 
Edition: Professional 
License: content of this file is covered by DHTMLX Commercial or Enterprise license. Usage without proper license is prohibited. To obtain it contact sales@dhtmlx.com
Copyright UAB Dinamenta http://www.dhtmlx.com
*/

/**
*	@desc: skined checkbox editor 
*	@returns: dhtmlxGrid cell editor object
*	@type: public
*/
function eXcell_acheck(cell){
	try{
		this.cell = cell;
		this.grid = this.cell.parentNode.grid;
		this.cell.obj = this;
	}catch(er){}
	this.changeState = function(){
					//nb:
					    if ((!this.grid.isEditable)||(this.cell.parentNode._locked)||(this.isDisabled())) return;
						if(this.grid.callEvent("onEditCell",[0,this.cell.parentNode.idd,this.cell._cellIndex])!=false){
							this.val = this.getValue()
							if(this.val=="1")
								this.setValue("<checkbox state='false'>")
							else
								this.setValue("<checkbox state='true'>")
								
							this.cell.wasChanged=true;								
							//nb:
							this.grid.callEvent("onEditCell",[1,this.cell.parentNode.idd,this.cell._cellIndex]);
							this.grid.callEvent("onCheck",[this.cell.parentNode.idd,this.cell._cellIndex,(this.val!='1')]);
                            this.grid.callEvent("onCheckbox",[this.cell.parentNode.idd,this.cell._cellIndex,(this.val!='1')]);

						}else{//preserve editing (not tested thoroughly for this editor)
							this.editor=null;
						}
				}
	this.getValue = function(){
						try{
							return this.cell.chstate.toString();
						}catch(er){
							return null;
						}
					}

	this.isCheckbox = function(){
						return true;
					}
	this.isChecked = function(){
						if(this.getValue()=="1")
							return true;
						else
							return false;
					}
	this.setChecked = function(fl){
	this.setValue(fl.toString())
	}
	this.detach = function(){
						return this.val!=this.getValue();
					}
    this.drawCurrentState=function(){
        if (this.cell.chstate==1)
            return "<div  onclick='(new eXcell_acheck(this.parentNode)).changeState(); (arguments[0]||event).cancelBubble=true;'  style='cursor:pointer; font-weight:bold; text-align:center; '><span style='height:8px; width:8px; background:green; display:inline-block;'></span>&nbsp;Yes</div>";
        else
            return "<div  onclick='(new eXcell_acheck(this.parentNode)).changeState(); (arguments[0]||event).cancelBubble=true;' style='cursor:pointer;  text-align:center; '><span style='height:8px; width:8px; background:red; display:inline-block;'></span>&nbsp;No</div>";
    }
}
eXcell_acheck.prototype = new eXcell;
eXcell_acheck.prototype.setValue = function(val){
                        //val can be int
                        val=(val||"").toString();
						if(val.indexOf("1")!=-1 || val.indexOf("true")!=-1){
							val = "1";
							this.cell.chstate = "1";
						}else{
							val = "0";
							this.cell.chstate = "0"
						}
						var obj = this;
						this.setCValue(this.drawCurrentState(),this.cell.chstate);
					}

//(c)dhtmlx ltd. www.dhtmlx.com

/*
Product Name: dhtmlxSuite 
Version: 4.1.3 
Edition: Professional 
License: content of this file is covered by DHTMLX Commercial or Enterprise license. Usage without proper license is prohibited. To obtain it contact sales@dhtmlx.com
Copyright UAB Dinamenta http://www.dhtmlx.com
*/

function eXcell_context(cell){
	if (cell){
		this.cell = cell;
    	this.grid = this.cell.parentNode.grid;
    
    	if (!this.grid._sub_context) return;
    	this._sub=this.grid._sub_context[cell._cellIndex];
    	if (!this._sub) return;
    	this._sindex=this._sub[1];
    	this._sub=this._sub[0];
    }
	
	this.getValue = function(){
		return _isIE?this.cell.innerText:this.cell.textContent;
	}
	this.setValue = function(val){
		this.cell._val=val;
		var item  = this._sub.itemPull[this._sub.idPrefix+this.cell._val];
		val = item?item.title:val;
		this.setCValue((val||"&nbsp;"),val);
	}
	this.edit = function(){
		var arPos = this.grid.getPosition(this.cell);//,this.grid.objBox
		
		this._sub.showContextMenu(arPos[0]+this.cell.offsetWidth,arPos[1]);
		var a=this.grid.editStop;
		this.grid.editStop=function(){};
		this.grid.editStop=a;
	}
	this.detach=function(){
		if (this.grid._sub_id != null) {
			var old=this.cell._val;
			this.setValue(this.grid._sub_id);
			this.grid._sub_id = null;
			return this.cell._val!=old;
		}
		this._sub.hideContextMenu();
	}
}
eXcell_context.prototype = new eXcell;


dhtmlXGridObject.prototype.setSubContext=function(ctx,s_index,t_index){
	var that=this;
	ctx.attachEvent("onClick",function(id,value){
		that._sub_id = id;
		that.editStop();
		ctx.hideContextMenu();
		return true;
	});
	if (!this._sub_context) 
		this._sub_context=[];
	this._sub_context[s_index]=[ctx,t_index];
	ctx.hideContextMenu();
};
//(c)dhtmlx ltd. www.dhtmlx.com

/*
Product Name: dhtmlxSuite 
Version: 4.1.3 
Edition: Professional 
License: content of this file is covered by DHTMLX Commercial or Enterprise license. Usage without proper license is prohibited. To obtain it contact sales@dhtmlx.com
Copyright UAB Dinamenta http://www.dhtmlx.com
*/

function dhtmlXGridFromTable(obj,init){
      if(typeof(obj)!='object')
         obj = document.getElementById(obj);
            var w=document.createElement("DIV");
            w.setAttribute("width",obj.getAttribute("gridWidth")||(obj.offsetWidth?(obj.offsetWidth+"px"):0)||(window.getComputedStyle?window.getComputedStyle(obj,null)["width"]:(obj.currentStyle?obj.currentStyle["width"]:0)));
            w.setAttribute("height",obj.getAttribute("gridHeight")||(obj.offsetHeight?(obj.offsetHeight+"px"):0)||(window.getComputedStyle?window.getComputedStyle(obj,null)["height"]:(obj.currentStyle?obj.currentStyle["height"]:0)));
			w.className = obj.className;
			obj.className="";
			if (obj.id) w.id = obj.id;

            var mr=obj;
            var drag=obj.getAttribute("dragAndDrop");
            mr.parentNode.insertBefore(w,mr);
            var f=mr.getAttribute("name")||("name_"+(new Date()).valueOf());

            var windowf=new dhtmlXGridObject(w);
            window[f]=windowf;

            var acs=mr.getAttribute("onbeforeinit");
            var acs2=mr.getAttribute("oninit");

			if (acs) eval(acs);

        	windowf.setImagePath(windowf.imgURL||(mr.getAttribute("imgpath")|| mr.getAttribute("image_path") ||""));
			var skin = mr.getAttribute("skin");
			if (skin) windowf.setSkin(skin);

        	if (init) init(windowf);

            var hrow=mr.rows[0];
            var za="";
            var zb="";
            var zc="";
            var zd="";
            var ze="";

            for (var i=0; i<hrow.cells.length; i++){
                za+=(za?",":"")+hrow.cells[i].innerHTML;
                var width=hrow.cells[i].getAttribute("width")||hrow.cells[i].offsetWidth||(window.getComputedStyle?window.getComputedStyle(hrow.cells[i],null)["width"]:(hrow.cells[i].currentStyle?hrow.cells[i].currentStyle["width"]:0));
                zb+=(zb?",":"")+(width=="*"?width:parseInt(width));
                zc+=(zc?",":"")+(hrow.cells[i].getAttribute("align")||"left");
                zd+=(zd?",":"")+(hrow.cells[i].getAttribute("type")||"ed");
                ze+=(ze?",":"")+(hrow.cells[i].getAttribute("sort")||"str");
            	var f_a=hrow.cells[i].getAttribute("format");
            	if (f_a)
            		if(hrow.cells[i].getAttribute("type").toLowerCase().indexOf("calendar")!=-1) 
            			windowf._dtmask=f_a;
            		else
            			windowf.setNumberFormat(f_a,i);
            }

        	windowf.setHeader(za);
        	windowf.setInitWidths(zb)
        	windowf.setColAlign(zc)
        	windowf.setColTypes(zd);
        	windowf.setColSorting(ze);
			if (obj.getAttribute("gridHeight")=="auto")
		    	windowf.enableAutoHeigth(true);

			if (obj.getAttribute("multiline")) windowf.enableMultiline(true);

			var lmn=mr.getAttribute("lightnavigation");
			if (lmn) windowf.enableLightMouseNavigation(lmn);

			var evr=mr.getAttribute("evenrow");
			var uevr=mr.getAttribute("unevenrow");

			if (evr||uevr) windowf.enableAlterCss(evr,uevr);
			if (drag) windowf.enableDragAndDrop(true);

            windowf.init();
            if (obj.getAttribute("split")) windowf.splitAt(obj.getAttribute("split"));

            //adding rows
            windowf._process_inner_html(mr,1);
            
			if (acs2) eval(acs2);            
			if (obj.parentNode && obj.parentNode.removeChild)
				obj.parentNode.removeChild(obj);
     return windowf;

            }
dhtmlXGridObject.prototype._process_html=function(xml){
	if (xml.tagName && xml.tagName == "TABLE") return this._process_inner_html(xml,0);
	var temp=document.createElement("DIV");
	temp.innerHTML=xml.xmlDoc.responseText;
	var mr = temp.getElementsByTagName("TABLE")[0];
	this._process_inner_html(mr,0);
}
dhtmlXGridObject.prototype._process_inner_html=function(mr,start){
	var n_l=mr.rows.length;
	for (var j=start; j<n_l; j++){
		var id=mr.rows[j].getAttribute("id")||j;
		this.rowsBuffer.push({ idd:id, data:mr.rows[j], _parser: this._process_html_row, _locator:this._get_html_data });
	}
	this.render_dataset();
	this.setSizes();
}
   
dhtmlXGridObject.prototype._process_html_row=function(r,xml){
	var cellsCol = xml.getElementsByTagName('TD');
    var strAr = [];
    
	r._attrs=this._xml_attrs(xml);
	
	//load cell data
    for(var j=0;j<cellsCol.length;j++){
    	var cellVal=cellsCol[j];
        var exc=cellVal.getAttribute("type");
        if (r.childNodes[j]){
        	if (exc)
        		r.childNodes[j]._cellType=exc;
       		r.childNodes[j]._attrs=this._xml_attrs(cellsCol[j]);
   		}
       
		if (cellVal.firstChild)
		    strAr.push(cellVal.innerHTML);
		else strAr.push("");
        
        if (cellVal.colSpan>1){
            r.childNodes[j]._attrs["colspan"]=cellVal.colSpan;		
            for (var k=1; k<cellVal.colSpan; k++){
                strAr.push("")
            }
        }
		
}
	for(j<cellsCol.length; j<r.childNodes.length; j++)
        r.childNodes[j]._attrs={};

        
    //back to common code
	this._fillRow(r,(this._c_order?this._swapColumns(strAr):strAr));
    return r;
}
dhtmlXGridObject.prototype._get_html_data=function(data,ind){
	data=data.firstChild;
	while (true){
		if (!data) return "";
		if (data.tagName=="TD") ind--;
		if (ind<0) break;
		data=data.nextSibling;
	}
  return (data.firstChild?data.firstChild.data:"");
}



dhtmlxEvent(window,"load",function(){
    var z=document.getElementsByTagName("table");
    for (var a=0; a<z.length; a++)
        if (z[a].className=="dhtmlxGrid"){
            dhtmlXGridFromTable(z[a]);
            //we have found IT!
        }
});


//(c)dhtmlx ltd. www.dhtmlx.com


/*
Product Name: dhtmlxSuite 
Version: 4.1.3 
Edition: Professional 
License: content of this file is covered by DHTMLX Commercial or Enterprise license. Usage without proper license is prohibited. To obtain it contact sales@dhtmlx.com
Copyright UAB Dinamenta http://www.dhtmlx.com
*/

dhtmlXGridObject.prototype._process_xmlA=function(xml){ 
	this._parsing=true;
	var top=dhx4.ajax.xmltop(this.xml.top, xml);
	//#config_from_xml:20092006{
	this._parseHead(top);
	//#}
	var rows=dhx4.ajax.xpath(this.xml.row,top)
	var cr=parseInt(top.getAttribute("pos")||0);
	var total=parseInt(top.getAttribute("total_count")||0);
	if (total && !this.rowsBuffer[total-1]) this.rowsBuffer[total-1]=null;
	
	if (this.isTreeGrid()){
		this._get_xml_data = this._get_xml_dataA;
		this._process_xml_row = this._process_xml_rowA;
		return this._process_tree_xml(xml);
	}
	
	for (var i=0; i < rows.length; i++) {
		if (this.rowsBuffer[i+cr]) continue;
		var id=rows[i].getAttribute("id")||this.uid();
		this.rowsBuffer[i+cr]={ idd:id, data:rows[i], _parser: this._process_xml_rowA, _locator:this._get_xml_dataA };
		this.rowsAr[id]=rows[i];
		//this.callEvent("onRowCreated",[r.idd]);
	}
	this.render_dataset();
	this._parsing=false;
}

dhtmlXGridObject.prototype._process_xmlB=function(xml){
    
    this._parsing=true;
	var top=dhx4.ajax.xmltop(this.xml.top, xml);
	//#config_from_xml:20092006{
	this._parseHead(top);
	//#}
	var rows=dhx4.ajax.xpath(this.xml.row,top)
	var cr=parseInt(top.getAttribute("pos")||0);
	var total=parseInt(top.getAttribute("total_count")||0);
	if (total && !this.rowsBuffer[total-1]) this.rowsBuffer[total-1]=null;
	
	if (this.isTreeGrid()){
		this._get_xml_data = this._get_xml_dataB;
		this._process_xml_row = this._process_xml_rowB;
		return this._process_tree_xml(xml);
	}
			
	for (var i=0; i < rows.length; i++) {
		if (this.rowsBuffer[i+cr]) continue;
		var id=rows[i].getAttribute("id")||this.uid();
		this.rowsBuffer[i+cr]={ idd:id, data:rows[i], _parser: this._process_xml_rowB, _locator:this._get_xml_dataB };
		this.rowsAr[id]=rows[i];
		//this.callEvent("onRowCreated",[r.idd]);
	}
	this.render_dataset();
	this._parsing=false;
}

dhtmlXGridObject.prototype._process_xml_rowA=function(r,xml){
	var strAr = [];
	r._attrs=this._xml_attrs(xml);
	
	//load cell data
    for(var j=0;j<this.columnIds.length;j++){
    	var cid=this.columnIds[j];
    	var cellVal=r._attrs[cid]||"";
        if (r.childNodes[j])
       		r.childNodes[j]._attrs={};
   		
		strAr.push(cellVal);
	}
	    
    //back to common code
	this._fillRow(r,(this._c_order?this._swapColumns(strAr):strAr));
    return r;
}
dhtmlXGridObject.prototype._get_xml_dataA=function(data,ind){
	return data.getAttribute(this.getColumnId(ind));
}

dhtmlXGridObject.prototype._process_xml_rowB=function(r,xml){
	var strAr = [];
	r._attrs=this._xml_attrs(xml);
	
	//load userdata
	if (this._ud_enabled){	
		var udCol = dhx4.ajax.xpath("./userdata",xml);
    	for (var i = udCol.length - 1; i >= 0; i--)
    		this.setUserData(udCol[i].getAttribute("name"),udCol[i].firstChild?udCol[i].firstChild.data:"");
	}
	
	//load cell data
	
	for (var jx=0; jx < xml.childNodes.length; jx++) {
		var cellVal=xml.childNodes[jx];
    	if (!cellVal.tagName) continue;
    	var j=this.getColIndexById(cellVal.tagName);
    	if (isNaN(j)) continue;
    		
        var exc=cellVal.getAttribute("type");
        if (exc)
        	r.childNodes[j]._cellType=exc;
       	r.childNodes[j]._attrs=this._xml_attrs(cellVal);
   		
		if (cellVal.getAttribute("xmlcontent"))
		{}
		else if (cellVal.firstChild)
			cellVal=cellVal.firstChild.data;
		else cellVal="";
        
		strAr[j]=cellVal;
	}
	for (var i=0; i < r.childNodes.length; i++) {
		if (!r.childNodes[i]._attrs) r.childNodes[i]._attrs={};
	};
            
    //back to common code
	this._fillRow(r,strAr);
    return r;
}
dhtmlXGridObject.prototype._get_xml_dataB=function(data,ind){
	var id=this.getColumnId(ind);
	data=data.firstChild;
	while (true){
		if (!data) return "";
		if (data.tagName==id) return (data.firstChild?data.firstChild.data:"")
		data=data.nextSibling;
	}
  return "";
}

/*
Product Name: dhtmlxSuite 
Version: 4.1.3 
Edition: Professional 
License: content of this file is covered by DHTMLX Commercial or Enterprise license. Usage without proper license is prohibited. To obtain it contact sales@dhtmlx.com
Copyright UAB Dinamenta http://www.dhtmlx.com
*/

   //next function switch grid between fast and normal operation modes
   //limitation - will not work for paging|smart_rendering|dynamic|split modes, most events will not be generated
   
/**
*   @desc: start fast operation mode, in such mode events are not generated, some time consuming actions applied only once, which allow to increase performance
*   @type: public
*   @topic: 0
*/   
   dhtmlXGridObject.prototype.startFastOperations   =    function(){
   		this._disF=["setSizes","callEvent","_fixAlterCss","cells4","forEachRow", "_correctMonolite"];
   		this._disA=[];
   		for (var i = this._disF.length - 1; i >= 0; i--){
   			this._disA[i]=this[this._disF[i]]; this[this._disF[i]]=function(){return true};
   		};
   		
   		this._cellCache=[];
   		this.cells4=function(cell){
   			var c=this._cellCache[cell._cellIndex]
   			if (!c){
   				c=this._cellCache[cell._cellIndex]=this._disA[3].apply(this,[cell]);
	   			c.destructor=function(){return true;}
   				c.setCValue=function(val){c.cell.innerHTML=val;}
   			}
   			
   			c.cell=cell;
   			c.combo=cell._combo||this.combos[cell._cellIndex];
   			return c;
   		}
   		
   }
/**
*   @desc: turn off fast operation mode, need to be executed to normalize view.
*   @type: public
*   @topic: 0
*/      
   dhtmlXGridObject.prototype.stopFastOperations   =    function(){
   		if (!this._disF) return;
   		for (var i = this._disF.length - 1; i >= 0; i--){
   			this[this._disF[i]]=this._disA[i];
   		};

         if (this._correctMonolite)  		
            this._correctMonolite();
   		this.setSizes();
   		this.callEvent("onGridReconstructed",[]);
   }
   
   //(c)dhtmlx ltd. www.dhtmlx.com

/*
Product Name: dhtmlxSuite 
Version: 4.1.3 
Edition: Professional 
License: content of this file is covered by DHTMLX Commercial or Enterprise license. Usage without proper license is prohibited. To obtain it contact sales@dhtmlx.com
Copyright UAB Dinamenta http://www.dhtmlx.com
*/

dhtmlXGridObject.prototype._in_header_number_filter=function(t,i){
	this._in_header_text_filter.call(this,t,i);
	var self = this;
	t.firstChild._filter=function(){
		var filters = self._get_filters(this.value, 'num');
		return function(value) {
			var result = filters.length > 0 ? false : true;
			for (var i = 0; i < filters.length; i++)
				result = result || filters[i](value);
			return result;
		}
	};
}


dhtmlXGridObject.prototype._in_header_string_filter=function(t,i){
	this._in_header_text_filter.call(this,t,i);
	var self = this;
	t.firstChild._filter=function(){
		var filters = self._get_filters(this.value, 'str');
		return function(value) {
			var result = filters.length > 0 ? false : true;
			for (var i = 0; i < filters.length; i++)
				result = result || filters[i](value);
			return result;
		}
	};
}


dhtmlXGridObject.prototype._get_filters=function(value, type) {
	var fs = value.split(',');
	var filters = [];
	
	for (var i = 0; i < fs.length; i++) {
		if (fs[i] == '') continue;
		var f = this['_get_' + type + '_filter'](fs[i]);
		filters.push(f);
	}
	return filters;
}


dhtmlXGridObject.prototype._get_str_filter=function(value) {
	// empty, null
	if (value == 'null' || value == 'empty') {
		return new Function('value', 'if (value == null || value == "") return true; return false;');
	}
	
	// not empty, not null
	if (value == '!null' || value == '!empty') {
		return new Function('value', 'if (value == null || value == "") return false; return true;');
	}
	// not equals
	if (value.substr(0, 1) === '!') {
		var substr = value.substr(1);
		return new Function('value', 'if (value !== "' + substr + '") return true; return false;');
	}
	// contains
	if (value.substr(0, 1) === '~') {
		var substr = value.substr(1);
		return new Function('value', 'if (value.indexOf("' + substr + '") !== -1) return true; return false;');
	}
	// ^keyword& 
	if (value.substr(0, 1) === '^' && value.substr(value.length - 1, 1) === '&') {
		value = '=' + value.substr(1, value.length - 2);
	}
	// start with
	if (value.substr(0, 1) === '^') {
		var substr = value.substr(1);
		return new Function('value', 'if (value.substr(0, ' + substr.length + ') === "' + substr + '") return true; return false;');
	}
	// end with
	if (value.substr(value.length - 1, 1) === '&') {
		var substr = value.substr(0, value.length - 1);
		return new Function('value', 'if (value.substr(value.length - ' + substr.length + ') === "' + substr + '") return true; return false;');
	}
	// equals
	if (value.substr(0, 1) === '=')
		var substr = value.substr(1);
	else
		var substr = value;
	return new Function('value', 'if (value === "' + substr + '") return true; return false;');
}


dhtmlXGridObject.prototype._get_num_filter=function(value) {
	// empty, null
	if (value == 'null' || value == 'empty') {
		return new Function('value', 'if (value == null || value == "") return true; return false;');
	}

	// not empty, not null
	if (value == '!null' || value == '!empty') {
		return new Function('value', 'if (value == null || value == "") return false; return true;');
	}
	// in range
	var range = value.split('..');
	if (range.length == 2) {
		var num1 = parseFloat(range[0]);
		var num2 = parseFloat(range[1]);
		return new Function('value', 'if (value >= ' + num1 + ' && value <= ' + num2 + ') return true; return false;');
	}
	var r = value.match(/<>|>=|<=|>|<|=/);
	if (r) {
		var op = r[0];
		var num = parseFloat(value.replace(op, ""));
	} else {
		var op = '==';
		num = parseFloat(value);
	}
	if (op == '<>') op = '!=';
	if (op == '=') op = '==';
	return new Function("value"," if (value " + op + " " + num + " ) return true; return false;");
}

/*
Product Name: dhtmlxSuite 
Version: 4.1.3 
Edition: Professional 
License: content of this file is covered by DHTMLX Commercial or Enterprise license. Usage without proper license is prohibited. To obtain it contact sales@dhtmlx.com
Copyright UAB Dinamenta http://www.dhtmlx.com
*/

dhtmlXGridObject.prototype.attachHeaderA=dhtmlXGridObject.prototype.attachHeader;
dhtmlXGridObject.prototype.attachHeader=function()
{
	this.attachHeaderA.apply(this,arguments);
	if (this._realfake) return true;
	this.formAutoSubmit();
	if (typeof(this.FormSubmitOnlyChanged)=="undefined")
		this.submitOnlyChanged(true);
		
	if (typeof(this._submitAR)=="undefined")
		this.submitAddedRows(true);
		
	var that=this;
	
	this._added_rows=[];
	this._deleted_rows=[];
	
	this.attachEvent("onRowAdded",function(id){ 
		that._added_rows.push(id);
		that.forEachCell(id,function(a){ a.cell.wasChanged=true; })
		return true;
	});
	this.attachEvent("onBeforeRowDeleted",function(id){
		that._deleted_rows.push(id);
		return true;
	});
	
	this.attachHeader=this.attachHeaderA;
}

dhtmlXGridObject.prototype.formAutoSubmit = function()
{
	this.parentForm = this.detectParentFormPresent();
	if (this.parentForm === false) {
		return false;
	}
	if (this.formEventAttached)
		return;
    this.formInputs = new Array();
	var self = this;
	dhtmlxEvent(this.parentForm, 'submit', function() {if (self.entBox) self.parentFormOnSubmit();});
	this.formEventAttached = true;
}

dhtmlXGridObject.prototype.parentFormOnSubmit = function()
{
	this.formCreateInputCollection();
	if (!this.callEvent("onBeforeFormSubmit",[])) return false;
}

/**
*   @desc: include only changed rows in form submit
*   @type: public
*   @param: mode - {boolean}  enable|disable mode
*   @topic: 0
*/
dhtmlXGridObject.prototype.submitOnlyChanged = function(mode)
{
	this.FormSubmitOnlyChanged = dhx4.s2b(mode);
}

dhtmlXGridObject.prototype.submitColumns=function(names){
	if (typeof names == "string") names=names.split(this.delim);
	this._submit_cols=names;	
}

/**
*   @desc: allows to define input name which will be used for data sending, name may contain next auto-replaced elements - GRID_ID - ID of grids container, ROW_ID - ID of row, ROW_INDEX - index of row, COLUMN_ID - id of column, COLUMN_INDEX - index of column
*   @type: public
*   @param: name - input name mask
*   @topic: 0
*/
dhtmlXGridObject.prototype.setFieldName=function(mask){
	mask=mask.replace(/\{GRID_ID\}/g,"'+a1+'");
	mask=mask.replace(/\{ROW_ID\}/g,"'+a2+'");
	mask=mask.replace(/\{ROW_INDEX\}/g,"'+this.getRowIndex(a2)+'");
	mask=mask.replace(/\{COLUMN_INDEX\}/g,"'+a3+'");
	mask=mask.replace(/\{COLUMN_ID\}/g,"'+this.getColumnId(a3)+'");
	this._input_mask=Function("a1","a2","a3","return '"+mask+"';");
}
 
   
/**
*   @desc: include serialized grid as part of form submit
*   @type: public
*   @param: mode - {boolean}  enable|disable mode
*   @topic: 0
*/
dhtmlXGridObject.prototype.submitSerialization = function(mode)
{
	this.FormSubmitSerialization = dhx4.s2b(mode);
}

/**
*   @desc: include additional data with info about which rows was added and which deleted, enabled by default
*   @type: public
*   @param: mode - {boolean}  enable|disable mode
*   @topic: 0
*/
dhtmlXGridObject.prototype.submitAddedRows = function(mode)
{
	this._submitAR = dhx4.s2b(mode);
}




/**
*   @desc: include only selected rows in form submit
*   @type: public
*   @param: mode - {boolean}  enable|disable mode
*   @topic: 0
*/
dhtmlXGridObject.prototype.submitOnlySelected = function(mode)
{
	this.FormSubmitOnlySelected = dhx4.s2b(mode);
}


/**
*   @desc: include only  row's IDS in form submit
*   @type: public
*   @param: mode - {boolean}  enable|disable mode
*   @topic: 0
*/
dhtmlXGridObject.prototype.submitOnlyRowID = function(mode)
{
	this.FormSubmitOnlyRowID = dhx4.s2b(mode);
}


dhtmlXGridObject.prototype.createFormInput = function(name,value){
    var input = document.createElement('input');
    input.type = 'hidden';
    if (this._input_mask && (typeof name != "string"))
    	input.name=this._input_mask.apply(this,name);
    else
    	input.name =((this.globalBox||this.entBox).id||'dhtmlXGrid')+'_'+name;
    input.value = value;
    this.parentForm.appendChild(input);
    this.formInputs.push(input);
}

dhtmlXGridObject.prototype.createFormInputRow = function(r){ 
	var id=(this.globalBox||this.entBox).id;
	for (var j=0; j<this._cCount; j++){
		var foo_cell = this.cells3(r, j);
		if (((!this.FormSubmitOnlyChanged) || foo_cell.wasChanged()) && (!this._submit_cols || this._submit_cols[j]))
			this.createFormInput(this._input_mask?[id,r.idd,j]:(r.idd+'_'+j),foo_cell.getValue());
	}
}


dhtmlXGridObject.prototype.formCreateInputCollection = function()
{
	if (this.parentForm == false) {
		return false;
	}
	for (var i=0; i<this.formInputs.length; i++) {
		this.parentForm.removeChild(this.formInputs[i]);
	}
    this.formInputs = new Array();
    
    if (this.FormSubmitSerialization){
    	this.createFormInput("serialized",this.serialize());
    } else if (this.FormSubmitOnlySelected){
    	//submit selected
    	if (this.FormSubmitOnlyRowID)
    		this.createFormInput("selected",this.getSelectedId());
    	else
    		for(var i=0;i<this.selectedRows.length;i++)
    			this.createFormInputRow(this.selectedRows[i]);
    	}
    else{
    	//submit all
    		if (this._submitAR){
    			if (this._added_rows.length)
    				this.createFormInput("rowsadded",this._added_rows.join(","));
    			if (this._deleted_rows.length)
    				this.createFormInput("rowsdeleted",this._deleted_rows.join(","));
	    		}
    		this.forEachRow(function(id){
    			 if (this.getRowById(id) !== -1)
    				this.createFormInputRow(this.rowsAr[id]);
			})
    		
    	}
}

dhtmlXGridObject.prototype.detectParentFormPresent = function()
{
	var parentForm = false;
	var parent = this.entBox;
	while(parent && parent.tagName && parent != document.body) {
		if (parent.tagName.toLowerCase() == 'form') {
			parentForm = parent;
			break;
		} else {
        	parent = parent.parentNode;
		}
	}
	return parentForm;
}
//(c)dhtmlx ltd. www.dhtmlx.com


/*
Product Name: dhtmlxSuite 
Version: 4.1.3 
Edition: Professional 
License: content of this file is covered by DHTMLX Commercial or Enterprise license. Usage without proper license is prohibited. To obtain it contact sales@dhtmlx.com
Copyright UAB Dinamenta http://www.dhtmlx.com
*/

dhtmlXGridObject.prototype.unGroup=function(){ 
	if (!this._groups) return;
	this._dndProblematic=false;
	
	delete this._groups;
	delete this._gIndex;	
	if (this._fake)	this._mirror_rowsCol();
	this.forEachRow(function(id){
		this.rowsAr[id].style.display='';
	})
	this._reset_view();
	this.callEvent("onGridReconstructed",[])
	this.callEvent("onUnGroup",[]);
}

dhtmlXGridObject.prototype._mirror_rowsCol=function(){ 
	this._fake._groups=this._groups;
	this._fake._gIndex=this._gIndex;
	this.rowsBuffer=dhtmlxArray(); 
	for (var i=0; i<this.rowsCol.length; i++)
		if (!this.rowsCol[i]._cntr)
			this.rowsBuffer.push(this.rowsCol[i]);
	this._fake.rowsBuffer=dhtmlxArray(); 
	for (var i=0; i<this._fake.rowsCol.length; i++)
		if (!this._fake.rowsCol[i]._cntr)
			this._fake.rowsBuffer.push(this._fake.rowsCol[i]);
	
}
/**
*	@desc: group grid content by values of specified column
*	@param: ind - column index to group by
*	@edition: Professional
*	@type: public
*/
dhtmlXGridObject.prototype.groupBy=function(ind,mask){
		
	if (this._groups) this.unGroup();
	this._dndProblematic=true;
	this._groups={};
	if (!mask) {
		mask=["#title"];
		for (var i=1; i<this._cCount; i++) mask.push("#cspan");
	}
	this._gmask=document.createElement("TR");
	this._gmask.origin = mask;
	var ltd,rindex=0;
	for (var i=0; i<mask.length; i++){
		if (mask[i]=="#cspan") 
			ltd.colSpan=(parseInt(ltd.colSpan)||1)+1
		else {
			ltd=document.createElement("TD");
			ltd._cellIndex=i;
			if (this._hrrar[i]) ltd.style.display="none";
			ltd.className="group_row";
			ltd.innerHTML="&nbsp;";
			if (mask[i]=="#title") this._gmask._title=rindex;
			else ltd.align=this.cellAlign[i]||"left";
			this._gmask.appendChild(ltd);
			if (mask[i].indexOf("#stat")==0){
				this._gmask._math=true;
				ltd._counter=[this["_g_"+mask[i].replace("#","")],i,rindex];
			}
			rindex++;
		}
	}
	for (var a in this._groups) this._groups[a]=this.undefined;
	this._gIndex=ind;
	
	if (this._fake &&!this._realfake){
		this._fake._groups=[];
		this._fake._gIndex=this._gIndex;
	}
	
	//keyboard commands
	this._nextRow=function(ind,dir){
		var r=this.rowsCol[ind+dir];
		if (r && ( r.style.display=="none" || r._cntr)) return this._nextRow(ind+dir,dir);
		return r;	
	}
	
	if (!this.__sortRowsBG){
		this._key_events=dhtmlx.extend({},this._key_events)
		this._key_events.k38_0_0=function(){
			if (this.editor && this.editor.combo)
				this.editor.shiftPrev();
			else{
				var rowInd = this.row.rowIndex;
				if (!rowInd) return;
				var nrow=this._nextRow(rowInd-1,-1);
				if (nrow)
	        		this.selectCell(nrow,this.cell._cellIndex,true);
			}
		}
		this._key_events.k13_1_0=this._key_events.k13_0_1=function(){};
	this._key_events.k40_0_0=function(){
		if (this.editor && this.editor.combo)
			this.editor.shiftNext();
		else{
			var rowInd = this.row.rowIndex;
			if (!rowInd) return;
			var nrow=this._nextRow(rowInd-1,1);
			if (nrow)
        		this.selectCell(nrow,this.cell._cellIndex,true);
		}
	}	
	
		this.attachEvent("onFilterStart",function(){
			if (this._groups) this._groups=this.undefined;
			return true;
		});
		this.attachEvent("onFilterEnd",function(){
			if (typeof this._gIndex != "undefined") this.groupBy(this._gIndex,this._gmask.origin);
		});
		this.sortRows_bg=this.sortRows;
		this.sortRows=function(ind,type,dir){
			if (typeof(this._groups)=="undefined") 
				return this.sortRows_bg.apply(this,arguments);

			type = type || "str";
			dir = dir || "asc";
			if (this.callEvent("onBeforeSorting",[ind, type, dir])){
				if (typeof(this._groups)=="undefined") return true;
				if (ind==this._gIndex) this._sortByGroup(ind,type,dir);
				else this._sortInGroup(ind,type,dir);
				this.setSortImgState(true,ind,dir)
				if (this._fake){ 
					this._mirror_rowsCol();
					this._fake._groups=[];
					this._fake._reset_view();
				}
				this.setSortImgState(true,ind,dir);
				this.callEvent("onAfterSorting",[ind,type,dir]);
			}
			return false;
		};
		this.attachEvent("onClearAll",function(){ this.unGroup(); });
		this.attachEvent("onBeforeRowDeleted",function(id){ 
			if (!this._groups) return true;
			if (!this.rowsAr[id]) return true;
			var val=this.cells(id,this._gIndex).getValue();
			if (val==="") val=" ";
			var z=this._groups[val];
			this._dec_group(z);
			return true;
			});
		this.attachEvent("onAfterRowDeleted",function(id){ 
			this.updateGroups();
			});			
		this.attachEvent("onCheckbox",function(id,index,value){
			this.callEvent("onEditCell",[2,id,index,(value?1:0),(value?0:1)]);
		});
		this.attachEvent("onXLE",this.updateGroups);
		this.attachEvent("onColumnHidden",this.hideGroupColumn);
		this.attachEvent("onEditCell",function(stage,id,ind,val,oldval){
			if (!this._groups) return true;
			if (stage==2 && val!=oldval && ind==this._gIndex){
				if (oldval==="") oldval=" ";
				this._dec_group(this._groups[oldval]);
				var r=this.rowsAr[id];
				var i=this.rowsCol._dhx_find(r)
				var ni=this._inc_group(val);
				var n=this.rowsCol[ni];
				if (r==n) n=n.nextSibling;
					
				
				var p=r.parentNode;
				var o=r.rowIndex;
				
				p.removeChild(r);
				if (n)
					p.insertBefore(r,n);
				else
					p.appendChild(r);
				this.rowsCol._dhx_insertAt(ni,r);
				if (ni<i) i++;
				this.rowsCol._dhx_removeAt(i,r);
				this._fixAlterCss();
			} else if (stage==2 && val!=oldval) {
				this.updateGroups();
				this._updateGroupView(this._groups[this.cells(id,this._gIndex).getValue()||" "]);
				}
			return true;
			})
		this.__sortRowsBG=true;
	}
	
	
	this._groupExisting();	
	if (this._hrrar)
		for (var i=0; i<this._hrrar.length; i++)
			if (this._hrrar[i])
				this.hideGroupColumn(i,true);
	this.callEvent("onGroup",[]);
	if (this._ahgr || this._awdth) this.setSizes();
}
dhtmlXGridObject.prototype._sortInGroup=function(col,type,order){
	var b=this._groups_get();
	b.reverse();

	for (var i=0; i<b.length; i++){
		var c=b[i]._cntr._childs; var a={};
		for (var j=0; j<c.length; j++){
			var cell = this.cells3(c[j],col);
			a[c[j].idd]=cell.getDate?cell.getDate():cell.getValue();
		}
			
		this._sortCore(col,type,order,a,c);
	}
	//add|delete|edit|ungroup
	this._groups_put(b);
	this.setSizes();
	this.callEvent("onGridReconstructed",[])
}

dhtmlXGridObject.prototype._sortByGroup=function(col,type,order){ 
	var b=this._groups_get();
	var a=[];
	for (var i=0; i<b.length; i++){
		b[i].idd="_sort_"+i;
		a["_sort_"+i]=b[i]._cntr.text;
	}
		
	this._sortCore(col,type,order,a,b);
	//add|delete|edit|ungroup
	this._groups_put(b);
	this.callEvent("onGridReconstructed",[])
	this.setSizes();
}
dhtmlXGridObject.prototype._inc_group=function(val,hidden,skip){
	if (val==="") val=" ";
	if (!this._groups[val]){ 
		this._groups[val]={text:val,row:this._addPseudoRow(),count:0,state:hidden?"plus":"minus"}; }
	var z=this._groups[val];
	//this._fixAlterCss();
	z.row._cntr=z;
		
	 
	var ind=this.rowsCol._dhx_find(z.row)+z.count+1;
	z.count++;
	
	if (!skip) {
	this._updateGroupView(z);
		this.updateGroups();
	}
	return ind;
}
dhtmlXGridObject.prototype._dec_group=function(z){
	if (!z) return;
	z.count--;
	if (z.count==0){
		z.row.parentNode.removeChild(z.row);
		this.rowsCol._dhx_removeAt(this.rowsCol._dhx_find(z.row));
		delete this._groups[z.text];
	}
	else
		this._updateGroupView(z);
	if (this._fake && !this._realfake)
		this._fake._dec_group(this._fake._groups[z.text]);
	this.updateGroups();
	return true;	
	}
dhtmlXGridObject.prototype._insertRowAt_gA=dhtmlXGridObject.prototype._insertRowAt;
dhtmlXGridObject.prototype._insertRowAt=function(r,ind,skip){
	if (typeof(this._groups)!="undefined"){
		if (this._realfake)
			var val=this._fake._bfs_cells(r.idd,this._gIndex).getValue();
		else
			if (this._bfs_cells3)
				var val=this._bfs_cells3(r,this._gIndex).getValue();
			else
				var val=this.cells3(r,this._gIndex).getValue();
			if (!val) val=" ";
			ind=this._inc_group(val,r.style.display=="none");		
	}
	var res=this._insertRowAt_gA(r,ind,skip);
	if (typeof(this._groups)!="undefined"){	
		this.expandGroup(val);
		this._updateGroupView(this._groups[val]);
		this.updateGroups();
	}
	return res;
}

dhtmlXGridObject.prototype._updateGroupView=function(z){ 
	if (this._fake && !this._realfake) return z.row.firstChild.innerHTML="&nbsp;";
	var mask = this._gmask||this._fake._gmask;
	var html="<img style='margin-bottom:-4px' src='"+this.imgURL+z.state+".gif'> ";
	if (this.customGroupFormat) html+=this.customGroupFormat(z.text,z.count);
	else html+=z.text+" ( "+z.count+" ) ";
	z.row.childNodes[mask._title].innerHTML=html;
}
dhtmlXGridObject.prototype._addPseudoRow=function(skip){
	
	var mask = this._gmask||this._fake._gmask;
	var r=mask.cloneNode(true)
	//cloneNode ignores custom attributes
	for (var i=0; i<r.childNodes.length; i++) {
		r.childNodes[i]._cellIndex=mask.childNodes[i]._cellIndex;
		if (this._realfake) r.childNodes[i].style.display="";
	}
	var that=this;
	
	r.onclick=function(e){ 
		if (!that.callEvent("onGroupClick",[this._cntr.text]))
			return;

		if (that._fake && that._realfake) 
			that._fake._switchGroupState(that._fake._groups[this._cntr.text].row); 
		else
			that._switchGroupState(this);
		(e||event).cancelBubble="true"; }
	r.ondblclick=function(e){ (e||event).cancelBubble="true"; }
	
	if (!skip){
		if (_isKHTML)
			this.obj.appendChild(r)
		else
			this.obj.firstChild.appendChild(r)
		this.rowsCol.push(r);
	}
	return r;
}

dhtmlXGridObject.prototype._groups_get=function(){
	var b=[];
	this._temp_par=this.obj.parentNode;
	this._temp_par.removeChild(this.obj);
	var a=[];
	for (var i=this.rowsCol.length-1; i>=0; i--){
		if (this.rowsCol[i]._cntr){
			this.rowsCol[i]._cntr._childs=a;
			a=[];
			b.push(this.rowsCol[i]);
		} else a.push(this.rowsCol[i]);
		this.rowsCol[i].parentNode.removeChild(this.rowsCol[i]);
	}
  return b;
}

dhtmlXGridObject.prototype._groups_put=function(b){ 
	var sts = this.rowsCol.stablesort;
	this.rowsCol=new dhtmlxArray(0);
	this.rowsCol.stablesort = sts;
	
	for (var i=0; i<b.length; i++){
		var gr=b[i]._cntr;
		this.obj.firstChild.appendChild(gr.row);
		this.rowsCol.push(gr.row)
		gr.row.idd=null;
		for (var j=0; j<gr._childs.length; j++){
			this.obj.firstChild.appendChild(gr._childs[j]);
			this.rowsCol.push(gr._childs[j])
		}
		delete gr._childs;
	}
	this._temp_par.appendChild(this.obj);
}
dhtmlXGridObject.prototype._groupExisting=function(b){ 
	if (!this.getRowsNum()) return;
	var b=[];
	this._temp_par=this.obj.parentNode;
	this._temp_par.removeChild(this.obj);
	var a=[];
	
	var mlen=this.rowsCol.length;
	for (var i=0; i<mlen; i++){
		var val=this.cells4(this.rowsCol[i].childNodes[this._gIndex]).getValue();
		this.rowsCol[i].style.display = "";
		if (!val) val=" ";
		
		if (!this._groups[val]){
			this._groups[val]={text:val,row:this._addPseudoRow(true),count:0,state:"minus"};
			var z=this._groups[val];
			z.row._cntr=z;
			this._groups[val]._childs=[];
			b.push(z.row)
		}
		
		this._groups[val].count++;
		this._groups[val]._childs.push(this.rowsCol[i]);
		this.rowsCol[i].parentNode.removeChild(this.rowsCol[i]);
	}
  for (var i=0; i<b.length; i++)
 	this._updateGroupView(b[i]._cntr)
  this._groups_put(b);
  if (this._fake && !this._realfake) {
  	this._mirror_rowsCol();
  	this._fake._groups=[];
  	this._fake._reset_view();
  }
  this.callEvent("onGridReconstructed",[])
  this.updateGroups();
}

dhtmlXGridObject.prototype._switchGroupState=function(row){
	var z=row._cntr;
	if (this._fake && !this._realfake) {
		z.state=this._fake._groups[row._cntr.text].row._cntr.state;
		this._fake._switchGroupState(this._fake._groups[row._cntr.text].row)
	}
	
	var ind=this.rowsCol._dhx_find(z.row)+1;
	z.state=z.state=="minus"?"plus":"minus";
	var st=z.state=="plus"?"none":"";
	
	while(this.rowsCol[ind] && !this.rowsCol[ind]._cntr){
		this.rowsCol[ind].style.display=st;
		ind++;
	}

	this._updateGroupView(z);
	this.callEvent("onGroupStateChanged",[z.text, (z.state=="minus")]);
	this.setSizes();
}
/**
*	@desc: expand group of rows
*	@param: val - value to use to determine what group to expand (in other words this should be value common for all of them)
*	@edition: Professional
*	@type: public
*/
dhtmlXGridObject.prototype.expandGroup=function(val){
	if (this._groups[val].state=="plus")
		this._switchGroupState(this._groups[val].row);
}
/**
*	@desc: collapse group of rows
*	@param: val - value to use to determine what group to collapse (in other words this should be value common for all of them)
*	@edition: Professional
*	@type: public
*/
dhtmlXGridObject.prototype.collapseGroup=function(val){
	if (this._groups[val].state=="minus")
		this._switchGroupState(this._groups[val].row);
}
/**
*	@desc: expand all groups
*	@edition: Professional
*	@type: public
*/
dhtmlXGridObject.prototype.expandAllGroups=function(){
	for(var i in this._groups)
		if (this._groups[i] && this._groups[i].state=="plus")
			this._switchGroupState(this._groups[i].row);
}
/**
*	@desc: collapse all groups
*	@edition: Professional
*	@type: public
*/
dhtmlXGridObject.prototype.collapseAllGroups=function(){
	for(var i in this._groups)
		if (this._groups[i] && this._groups[i].state=="minus")
			this._switchGroupState(this._groups[i].row);
}

dhtmlXGridObject.prototype.hideGroupColumn=function(ind,state){
	if (this._fake) return;
	var rind=-1;
	var row = this._gmask.childNodes;
	for (var i=0; i<row.length; i++)
		if (row[i]._cellIndex==ind) {
			rind = i;
			break;
	}
	if (rind == -1) return;
	for (var a in this._groups)
		this._groups[a].row.childNodes[rind].style.display=state?"none":"";
};
dhtmlXGridObject.prototype.groupStat=function(name,ind,math){
	math = this["_g_"+(math||"stat_total")];
	var summ=0; var index=0;
	this.forEachRowInGroup(name,function(id){
		summ=math(summ,this.cells(id,ind).getValue()*1,index)
		index++;
	})
	return summ;
}
dhtmlXGridObject.prototype.forEachRowInGroup=function(name,code){
	var row=this._groups[name].row.nextSibling;
	if (row){
		while (row && !row._cntr) {
			code.call(this,row.idd);
			row=row.nextSibling;
		}
	} else {
		var cs=this._groups[name]._childs;
		if (cs)
			for (var i=0; i<cs.length; i++)
				code.call(this,cs[i].idd);
	}
};
dhtmlXGridObject.prototype.updateGroups=function(){
	if (!this._gmask || !this._gmask._math || this._parsing) return;
	var r=this._gmask.childNodes;
	for (var i=0; i<r.length; i++)
		if (r[i]._counter) this._b_processing.apply(this,r[i]._counter)
}
dhtmlXGridObject.prototype._b_processing=function(a,ind,rind){
	var c=0,j=0; 
	//put editor in cache, so it can be used for custom html containers - can be moved in cells5(?)
	if (!this._ecache[this.cellType[ind]]) this.cells5({parentNode:{grid:this}},this.cellType[ind]);
	for (var i=this.rowsCol.length-1; i>=0; i--){
		if (!this.rowsCol[i]._cntr){
			c=a(c,this.cells3(this.rowsCol[i],ind).getValue()*1,j);
			j++;
		} else {
			this.cells5(this.rowsCol[i].childNodes[rind],this.cellType[ind]).setValue(c);
			j=c=0;
		}
	}
}

dhtmlXGridObject.prototype._g_stat_total=function(c,n,i){
	return c+n;
}
dhtmlXGridObject.prototype._g_stat_min=function(c,n,i){
	if (!i) c=Infinity;
	return Math.min(c,n);
}
dhtmlXGridObject.prototype._g_stat_max=function(c,n,i){
	if (!i) c=-Infinity;
	return Math.max(c,n);
}
dhtmlXGridObject.prototype._g_stat_average=function(c,n,i){
	return (c*i+n)/(i+1);
}
dhtmlXGridObject.prototype._g_stat_count=function(c,n,i){
	return c++;
}
	
//(c)dhtmlx ltd. www.dhtmlx.com


/*
Product Name: dhtmlxSuite 
Version: 4.1.3 
Edition: Professional 
License: content of this file is covered by DHTMLX Commercial or Enterprise license. Usage without proper license is prohibited. To obtain it contact sales@dhtmlx.com
Copyright UAB Dinamenta http://www.dhtmlx.com
*/

dhtmlXGridObject.prototype._in_header_collapse=function(t,i,c){
	var rt=t.tagName=="TD"?t:t.parentNode;
	i=rt._cellIndexS;
	if (!this._column_groups) this._column_groups=[];
	var cols=c[1].split(":")
	var cols=c[1].split(":");
	cols = [cols.shift(), cols.join(':')];
	var count = parseInt(cols[0]); 
	t.innerHTML=c[0]+"<img src='"+this.imgURL+"minus.gif' style='padding-right:10px;height:16px'/><span style='position:relative; top:-6px;'>"+(cols[1]||"")+"<span>";
	t.style.paddingBottom='0px';
	var self = this;
	this._column_groups[i]=t.getElementsByTagName("IMG")[0];
	this._column_groups[i].onclick=function(e){
		(e||event).cancelBubble=true;
		this._cstate=!this._cstate;
		for (var j=i+1; j<(i+count); j++)
			self.setColumnHidden(j,this._cstate)
		if (this._cstate){
			if (rt.colSpan && rt.colSpan>0) {
				rt._exp_colspan=rt.colSpan;
				var delta=Math.max(1,rt.colSpan-count)
				if (!_isFF) //create additional cells to compensate colspan
				for (var z=0; z<rt.colSpan-delta; z++){
					var td=document.createElement("TD");
					if (rt.nextSibling)
						rt.parentNode.insertBefore(td,rt.nextSibling);
					else
						rt.parentNode.appendChild(td);
				}	
				rt.colSpan=delta;
			}
            self.callEvent("onColumnCollapse",[i,this._cstate]);
		} else 
			if (rt._exp_colspan){
				rt.colSpan=rt._exp_colspan;
				if (!_isFF)
				for (var z=1; z<rt._exp_colspan; z++)
					rt.parentNode.removeChild(rt.nextSibling);
                self.callEvent("onColumnCollapse",[i,this._cstate]);
			}
		this.src=self.imgURL+(this._cstate?"plus.gif":"minus.gif");
		
		if (self.sortImg.style.display!="none")
			self.setSortImgPos();		
	}	
}
dhtmlXGridObject.prototype.collapseColumns = function (ind) {
    if (!this._column_groups[ind] || this._column_groups[ind]._cstate) return;
    this._column_groups[ind].onclick({});
}
dhtmlXGridObject.prototype.expandColumns = function (ind) {
    if (!this._column_groups[ind] || !this._column_groups[ind]._cstate) return;
    this._column_groups[ind].onclick({});
}


/*
Product Name: dhtmlxSuite 
Version: 4.1.3 
Edition: Professional 
License: content of this file is covered by DHTMLX Commercial or Enterprise license. Usage without proper license is prohibited. To obtain it contact sales@dhtmlx.com
Copyright UAB Dinamenta http://www.dhtmlx.com
*/

/**
*	@desc: enable pop up menu which allows hidding/showing columns
*	@edition: Professional
*	@type: public
*/
dhtmlXGridObject.prototype.enableHeaderMenu=function(columns)
{
	if (!window.dhtmlXMenuObject)
		return dhtmlx.message("You need to include DHTMLX Menu");

	if (!this._header_menu){
		var menu = this._header_menu = new dhtmlXMenuObject();
		menu.renderAsContextMenu();

		var that=this;
		menu.attachEvent("onBeforeContextMenu", function(){
			that._showHContext(columns);
			return true;
		});
		menu.attachEvent("onClick", function(id){
			var checked = this.getCheckboxState(id);

			var row = that.hdr.rows[1];
			for (var j=0; j<row.cells.length; j++){
				var c = row.cells[j];
				if (c._cellIndexS == id){
					var len = c.colSpan || 1;
					for (var i=0; i<len; i++)
						that.setColumnHidden(id*1+i,!checked);
				}
			}
		});

		this.attachEvent("onInit",function(){
			menu.addContextZone(this.hdr);
		});
		if (this.hdr.rows.length) this.callEvent("onInit",[]);
	}
};

dhtmlXGridObject.prototype.getHeaderMenu=function(columns)
{
	return this._header_menu;
};

dhtmlXGridObject.prototype._hideHContext=function(){
	if (this._header_menu)
		this._header_menu.hide();
};

dhtmlXGridObject.prototype._showHContext=function(columns)
{
	if (typeof columns == "string")
		columns = columns.split(this.delim);
	
	var true_ind = 0;
	var j = 0;
	this._header_menu.clearAll();

	for (var i=0; i<this.hdr.rows[1].cells.length; i++){
		var c = this.hdr.rows[1].cells[i];
		if (!columns || (columns[true_ind] &&  columns[true_ind] != "false")){
			if (c.firstChild && c.firstChild.tagName=="DIV") var val=c.firstChild.innerHTML;
			else var val = c.innerHTML;
			val = val.replace(/<[^>]*>/gi,"");
			var visible = !(this.isColumnHidden(true_ind) || (this.getColWidth(true_ind)==0));
			this._header_menu.addCheckbox("child", this._header_menu.topId, j, true_ind, val, visible);
			j++;
		}
		true_ind+=(c.colSpan||1);
	}	
}
//(c)dhtmlx ltd. www.dhtmlx.com


/*
Product Name: dhtmlxSuite 
Version: 4.1.3 
Edition: Professional 
License: content of this file is covered by DHTMLX Commercial or Enterprise license. Usage without proper license is prohibited. To obtain it contact sales@dhtmlx.com
Copyright UAB Dinamenta http://www.dhtmlx.com
*/

dhtmlXGridObject.prototype._process_json_row=function(r, data){
	r._attrs=data;
	for (var j = 0; j < r.childNodes.length; j++)r.childNodes[j]._attrs={
	};
	if (data.userdata)
		for (var a in data.userdata)
			this.setUserData(r.idd,a,data.userdata[a]);
			
	data = this._c_order?this._swapColumns(data.data):data.data;

	for (var i=0; i<data.length; i++)
		if (typeof data[i] == "object" && data[i] != null){
			r.childNodes[i]._attrs=data[i];
			if (data[i].type) r.childNodes[i]._cellType=data[i].type;
			data[i]=data[i].value;
		}
	this._fillRow(r, data);
	return r;
};


dhtmlXGridObject.prototype._process_js_row=function(r, data){
	r._attrs=data;
	for (var j = 0; j < r.childNodes.length; j++)
		r.childNodes[j]._attrs={};

	if (data.userdata)
		for (var a in data.userdata)
			this.setUserData(r.idd,a,data.userdata[a]);
			
	var arr = [];
	for (var i=0; i<this.columnIds.length; i++){
		arr[i] = data[this.columnIds[i]];
		if (typeof arr[i] == "object" && arr[i] != null){
			r.childNodes[i]._attrs=arr[i];
			if (arr[i].type) r.childNodes[i]._cellType=arr[i].type;
			arr[i]=arr[i].value;
		}
		if (!arr[i] && arr[i]!==0)
			arr[i]="";
	}

	this._fillRow(r, arr);
	return r;
};

dhtmlXGridObject.prototype.updateFromJSON = function(url, insert_new, del_missed, afterCall){
	if (typeof insert_new == "undefined")
		insert_new=true;
	this._refresh_mode=[
		true,
		insert_new,
		del_missed
	];
	
	this.load(url,afterCall,"json");
},
dhtmlXGridObject.prototype._refreshFromJSON = function(data){
		if (this._f_rowsBuffer) this.filterBy(0,"");
		reset = false;
		if (window.eXcell_tree){
			eXcell_tree.prototype.setValueX=eXcell_tree.prototype.setValue;
			eXcell_tree.prototype.setValue=function(content){
				var r=this.grid._h2.get[this.cell.parentNode.idd]
				if (r && this.cell.parentNode.valTag){
					this.setLabel(content);
				} else
					this.setValueX(content);
			};
		}
	
		var tree = this.cellType._dhx_find("tree");
		var pid = data.parent||0;
	
		var del = {
		};
	
		if (this._refresh_mode[2]){
			if (tree != -1)
				this._h2.forEachChild(pid, function(obj){
					del[obj.id]=true;
				}, this);
			else
				this.forEachRow(function(id){
					del[id]=true;
				});
		}
	
		var rows = data.rows;
	
		for (var i = 0; i < rows.length; i++){
			var row = rows[i];
			var id = row.id;
			del[id]=false;
	
			if (this.rowsAr[id] && this.rowsAr[id].tagName!="TR"){
				if (this._h2)
					this._h2.get[id].buff.data=row;
				else
					this.rowsBuffer[this.getRowIndex(id)].data=row;
				this.rowsAr[id]=row;
			} else if (this.rowsAr[id]){
					this._process_json_row(this.rowsAr[id], row, -1);
					this._postRowProcessing(this.rowsAr[id],true)
				} else if (this._refresh_mode[1]){
					var dadd={
						idd: id,
						data: row,
						_parser: this._process_json_row,
						_locator: this._get_json_data
					};
					
					var render_index = this.rowsBuffer.length;
					if (this._refresh_mode[1]=="top"){
						this.rowsBuffer.unshift(dadd);
						render_index = 0;
					} else
						this.rowsBuffer.push(dadd);
						
					if (this._h2){ 
						reset=true;
						(this._h2.add(id,pid)).buff=this.rowsBuffer[this.rowsBuffer.length-1];
					}
						
					this.rowsAr[id]=row;
					row=this.render_row(render_index);
					this._insertRowAt(row,render_index?-1:0)
				}
		}
				
		if (this._refresh_mode[2])
			for (id in del){
				if (del[id]&&this.rowsAr[id])
					this.deleteRow(id);
			}
	
		this._refresh_mode=null;
		if (window.eXcell_tree)
			eXcell_tree.prototype.setValue=eXcell_tree.prototype.setValueX;
			
		if (reset) this._renderSort();
		if (this._f_rowsBuffer) {
			this._f_rowsBuffer = null;
			this.filterByAll();
		}
	},

	dhtmlXGridObject.prototype._process_js=function(data){
		return this._process_json(data, "js");
	},

	dhtmlXGridObject.prototype._parseHeadJson=function(json){
		if (!json.head || !json.head.length) return;

		var headCol = json.head;
		var settings = json.settings;

		var awidthmet = "setInitWidths";
		var split = false;

		if (settings && settings.colwidth == "%")
			awidthmet="setInitWidthsP";
	
		if (settings && settings.splitat == "%")
			split=settings.splitat;

		//drop existing grid here, to prevent loss of initialization parameters
	    if (this.hdr.rows.length > 0) 
	    	this.clearAll(true);

		var sets = [
			[],
			[],
			[],
			[],
			[],
			[],
			[]
		];
	
		var attrs = ["value", "width", "type", "align", "sort","hidden", "id"];
		var calls = ["", awidthmet, "setColTypes", "setColAlign", "setColSorting", 
					"", "setColumnIds"];
	
		for (var i = 0; i < headCol.length; i++)
			for (var j = 0; j < attrs.length; j++)
				sets[j].push(headCol[i][attrs[j]]);

		this.setHeader(sets[0]);
		for (var i = 0; i < calls.length; i++)
			if (calls[i])
				this[calls[i]](sets[i].join(this.delim));
	
		for (var i = 0; i < headCol.length; i++){
			var options = headCol[i].options
			if (headCol[i].options)
				if (this.cellType[i] == "clist"){
					this.registerCList(i, options);
				} else {
					var combo = this.getCombo(i);
					for (var j = 0; j < options.length; j++)
						combo.put(options[j].id, options[j].value);
				}
		}
			
	
		this.init();

        var param=sets[5].join(this.delim);
        //preserving state of hidden columns, if not specified directly
		if (this.setColHidden && param.replace(/,/g,"")!="")
			this.setColHidden(param);

		if ((split)&&(this.splitAt))
			this.splitAt(split);
	};

	dhtmlXGridObject.prototype._process_json=function(data, mode){
		this._parsing=true;
		try {
			var data = data.responseText || data;
			if (typeof data == "string"){
				eval("dhtmlx.temp="+data+";");
				data = dhtmlx.temp;
			}
		} catch(e){
				dhx4.callEvent("onLoadXMLError", ["Incorrect JSON",
					(data.xmlDoc||data),
					this
				]);
				data = {rows:[]};
		}
			
		if (this._refresh_mode) return this._refreshFromJSON(data);				

		if (data.head)
			this._parseHeadJson(data);

		var cr = parseInt(data.pos||0);
		var total = parseInt(data.total_count||0);
		
		var reset = false;
		if (total){
			if (!this.rowsBuffer[total-1]){
				if (this.rowsBuffer.length)
					reset=true;
			this.rowsBuffer[total-1]=null;
			} 
			if (total<this.rowsBuffer.length){
				this.rowsBuffer.splice(total, this.rowsBuffer.length - total);
				reset = true;
			}
		}
			
		for (var key in data){
			if (key!="rows")
				this.setUserData("",key, data[key]);
		}

		if (mode == "js" && data.collections){
			for (var colkey in data.collections){
				var index = this.getColIndexById(colkey);
				var colrecs = data.collections[colkey];
				if (index !== window.undefined){
					if (this.cellType[index] == "clist"){
						colplaindata=[];
						for (var j=0; j<colrecs.length; j++)
							colplaindata.push(colrecs[j].label);
						this.registerCList(index, colplaindata);
					} else {
						var combo = this.getCombo(index);
						for (var j = 0; j < colrecs.length; j++)
							combo.put(colrecs[j].value, colrecs[j].label);
					}
				}
			}
		}
		
		if (this.isTreeGrid())
			return this._process_tree_json(data, null, null, mode);
			
		if (mode == "js"){
			if (data.data)
				data = data.data;
			for (var i = 0; i < data.length; i++){
				if (this.rowsBuffer[i+cr])
					continue;

				var row = data[i];
				var id  = row.id||(i+1);
				this.rowsBuffer[i+cr]={
					idd: id,
					data: row,
					_parser: this._process_js_row,
					_locator: this._get_js_data
				};

				this.rowsAr[id]=data[i];
			}
		} else {
			for (var i = 0; i < data.rows.length; i++){
				if (this.rowsBuffer[i+cr])
					continue;
				var id = data.rows[i].id;
				this.rowsBuffer[i+cr]={
					idd: id,
					data: data.rows[i],
					_parser: this._process_json_row,
					_locator: this._get_json_data
				};
	
				this.rowsAr[id]=data.rows[i];
			}
		}
		
		this.callEvent("onDataReady", []);
		if (reset && this._srnd){
			var h = this.objBox.scrollTop;
			this._reset_view();
			this.objBox.scrollTop = h;
		} else {
			this.render_dataset();
		}
		
		this._parsing=false;
}

dhtmlXGridObject.prototype._get_json_data=function(data, ind){
	if (typeof data.data[ind] == "object")
		return data.data[ind].value;
	else
		return data.data[ind];
};

dhtmlXGridObject.prototype._process_tree_json=function(data,top,pid,mode){
	this._parsing=true;
	var main=false;
	if (!top){
		this.render_row=this.render_row_tree;
		main=true;
		top=data;
		pid=top.parent||0;
		if (pid=="0") pid=0;
		if (!this._h2)	 this._h2=new dhtmlxHierarchy();
		if (this._fake) this._fake._h2=this._h2;
	} 
	
	if (mode == "js"){
		if (top.data && !pid) 
			data = top.data;
		if (top.rows)
			top = top.rows;
		for (var i = 0; i < top.length; i++){
			var id = top[i].id;
			var row=this._h2.add(id,pid);
			row.buff={ idd:id, data:top[i], _parser: this._process_js_row, _locator:this._get_js_data };

			if (top[i].open)
			    row.state="minus";
				
			this.rowsAr[id]=row.buff;
		    this._process_tree_json(top[i],top[i],id,mode);
		}
	} else {
		if (top.rows) {
			for (var i = 0; i < top.rows.length; i++){
					var id = top.rows[i].id;
					var row=this._h2.add(id,pid);
					row.buff={ idd:id, data:top.rows[i], _parser: this._process_json_row, _locator:this._get_json_data };
					if (top.rows[i].open)
					    row.state="minus";
					
					this.rowsAr[id]=row.buff;
				    this._process_tree_json(top.rows[i],top.rows[i],id,mode);
			}
		}
	}
		
	if (main){ 
		
		if (pid!=0) this._h2.change(pid,"state","minus")
		this._updateTGRState(this._h2.get[pid]);
		this._h2_to_buff();
		
		this.callEvent("onDataReady", []);
		if (pid!=0 && (this._srnd || this.pagingOn))
			this._renderSort();
		else
			this.render_dataset();
		
		
	
		if (this._slowParse===false){
			this.forEachRow(function(id){
				this.render_row_tree(0,id)
			})
		}
		this._parsing=false;

		if (pid!=0 && !this._srnd)
		   this.callEvent("onOpenEnd",[pid,1]);	
	}
}	


/*
Product Name: dhtmlxSuite 
Version: 4.1.3 
Edition: Professional 
License: content of this file is covered by DHTMLX Commercial or Enterprise license. Usage without proper license is prohibited. To obtain it contact sales@dhtmlx.com
Copyright UAB Dinamenta http://www.dhtmlx.com
*/

  /**
  *   @desc: sets marked cells support to enabled or disabled state
  *   @type: public
  *   @param: state - true or false
  */
 dhtmlXGridObject.prototype.enableMarkedCells = function(fl){
  	this.markedRowsArr = new dhtmlxArray(0);
	this.markedCellsArr = new Array(0);
	this.lastMarkedRow = null;
	this.lastMarkedColumn = null;
 	this.markedCells = true;
	this.lastMarkMethod = 0;
	if(arguments.length>0){
		if(!dhx4.s2b(fl))
			this.markedCells = false;
	}
 };
  /**
  *   @desc: occures on cell click
  *   @type: private
  *   @param: [el] - cell to click on
  *   @param: [markMethod] - 0 - simple click, 1 - shift, 2 - ctrl
  */
 dhtmlXGridObject.prototype.doMark = function(el,markMethod){ 

				var _rowId = el.parentNode.idd;
				this.setActive(true);
				if (!_rowId) return;
				this.editStop();
				this.cell=el;
				this.row=el.parentNode;
				var _cellIndex = el._cellIndex;				
				
				if(!markMethod) markMethod = 0;
				
           	    if(markMethod==0){
                    this.unmarkAll() ;	 
                }
				else if(markMethod==1){
					
					if(this.lastMarkedRow) {
						var r_start = Math.min(this.getRowIndex(_rowId),this.getRowIndex(this.lastMarkedRow));
						var r_end = Math.max(this.getRowIndex(_rowId),this.getRowIndex(this.lastMarkedRow));
						
						var c_start = Math.min(_cellIndex,this.lastMarkedColumn);
						var c_end = Math.max(_cellIndex,this.lastMarkedColumn);
					
						for(var i = r_start; i < r_end+1; i++){
							for(var j = c_start; j < c_end+1; j++){
								this.mark(this.getRowId(i),j,true);
								
							}
						}
					}
				}
				else if(markMethod==2){
					if(this.markedRowsArr._dhx_find(_rowId)!=-1){ 
						for(var ci = 0; ci < this.markedCellsArr[_rowId].length; ci++){
							if(this.markedCellsArr[_rowId][ci]==_cellIndex){
								this.mark(_rowId,_cellIndex,false);
								return true;
							}
						}
						
					}
					
				}
				
				if(!this.markedCellsArr[_rowId]) 
					this.markedCellsArr[_rowId] = new dhtmlxArray(0);
				
				if(markMethod!=1) 
					this.mark(_rowId,_cellIndex);
					
				this.moveToVisible(this.cells(_rowId,_cellIndex).cell);
				this.lastMarkedRow = _rowId;
				this.lastMarkedColumn = _cellIndex;
				this.lastMarkMethod = markMethod;
				
 }
/**
  	*   @desc: sets selection or removes selection from specified cell
    *   @param: r - row object or row index
    *   @param: cInd - cell index
    *   @param: state - true or false 
	*   @type: public
 */
dhtmlXGridObject.prototype.mark = function(rid,cindex,fl){
	if(arguments.length>2){
		if(!dhx4.s2b(fl)){
			this.cells(rid,cindex).cell.className = this.cells(rid,cindex).cell.className.replace(/cellselected/g,"");
			if(this.markedRowsArr._dhx_find(rid)!=-1){
				var ci = this.markedCellsArr[rid]._dhx_find(cindex);
				if(ci!=-1){
					this.markedCellsArr[rid]._dhx_removeAt(ci);
					if(this.markedCellsArr[rid].length==0){
						this.markedRowsArr._dhx_removeAt(this.markedRowsArr._dhx_find(rid));
					}
					this.callEvent("onCellUnMarked",[rid,cindex]);
				}
			}
			return true;
		}
	}
	this.cells(rid,cindex).cell.className+= " cellselected";
	
	if(this.markedRowsArr._dhx_find(rid)==-1) 
		this.markedRowsArr[this.markedRowsArr.length] = rid;
		
	if(!this.markedCellsArr[rid]) 
		this.markedCellsArr[rid] = new dhtmlxArray(0);
	if(this.markedCellsArr[rid]._dhx_find(cindex)==-1){
		this.markedCellsArr[rid][this.markedCellsArr[rid].length] = cindex;
		this.callEvent("onCellMarked",[rid,cindex]);
	}
	
}
/**
  	*   @desc: removes selection from all marked cell
   	*   @type: public
 */
dhtmlXGridObject.prototype.unmarkAll = function(){
	if(this.markedRowsArr){
		for(var ri = 0; ri < this.markedRowsArr.length; ri++){
			var rid = this.markedRowsArr[ri];
			if (this.rowsAr[rid])
				for(var ci = 0; ci < this.markedCellsArr[rid].length; ci++){
					this.callEvent("onCellUnMarked",[rid,this.markedCellsArr[rid][ci]])
					this.cells(rid,this.markedCellsArr[rid][ci]).cell.className = this.cells(rid,this.markedCellsArr[rid][ci]).cell.className.replace(/cellselected/g,"");
				}
		} 
		this.markedRowsArr = new dhtmlxArray(0);
		this.markedCellsArr = new Array(0);
	}
	return true;
}
/**
  	*   @desc: gets marked cells
   	*   @returns: the array of marked cells	(pairs of row id and column index)
	*   @type: public
 */
dhtmlXGridObject.prototype.getMarked = function(){
	var marked = new Array();
	if(this.markedRowsArr)
	for(var ri = 0; ri < this.markedRowsArr.length; ri++){
		var rid = this.markedRowsArr[ri];
		for(var ci = 0; ci < this.markedCellsArr[rid].length; ci++){
			marked[marked.length] = [rid,this.markedCellsArr[rid][ci]];
		}
	} 
	return marked;		
}


/*
Product Name: dhtmlxSuite 
Version: 4.1.3 
Edition: Professional 
License: content of this file is covered by DHTMLX Commercial or Enterprise license. Usage without proper license is prohibited. To obtain it contact sales@dhtmlx.com
Copyright UAB Dinamenta http://www.dhtmlx.com
*/

/**
*	@desc: cell with support for math formulas
*	@param: cell - cell object
*	@type:  private
*   @edition: Professional
*/
function eXcell_math(cell){
	if (cell){
		this.cell = cell;
    	this.grid = this.cell.parentNode.grid;
	}
	this.edit = function(){
		this.grid.editor = new eXcell_ed(this.cell);
		this.grid.editor.fix_self=true;
		this.grid.editor.getValue=this.cell.original?(function(){ return this.cell.original}):this.getValue;
		this.grid.editor.setValue=this.setValue;
		this.grid.editor.edit();
	}
	this.isDisabled = function(){ return !this.grid._mathEdit; }
	this.setValue = function(val){
				val=this.grid._compileSCL(val,this.cell,this.fix_self);
                if (this.grid._strangeParams[this.cell._cellIndex])
    				this.grid.cells5(this.cell,this.grid._strangeParams[this.cell._cellIndex]).setValue(val);
                else{
                    this.setCValue(val);
    	            this.cell._clearCell=false;
	            }
    }
    this.getValue = function(){
        if (this.grid._strangeParams[this.cell._cellIndex])
			return this.grid.cells5(this.cell,this.grid._strangeParams[this.cell._cellIndex]).getValue();
        
        return this.cell.innerHTML;
    }
}
eXcell_math.prototype = new eXcell;

dhx4.attachEvent("onGridCreated", function(grid){
	grid._mat_links={};
	grid._aggregators=[];
	grid.attachEvent("onClearAll",function(){
		this._mat_links={};
		this._aggregators=[];
	})
	grid.attachEvent("onCellChanged",function(id,ind){
		if (this._mat_links[id]){ 
			var cell=this._mat_links[id][ind];
			if (cell){ 
				for (var i=0; i<cell.length; i++)
          if (cell[i].parentNode)
            this.cells5(cell[i]).setValue(this._calcSCL(cell[i]));
			}
		}
		if (!this._parsing && this._aggregators[ind]){
			var pid=this._h2.get[id].parent.id;
			if (pid!=0){
				var ed=this.cells(pid,ind);
				ed.setValue(this._calcSCL(ed.cell));
			}
		}
	})
	grid.attachEvent("onAfterRowDeleted",function(id,pid){ //will be called for each delete operation, may be optimized
		if (pid!=0)
			if (!this._parsing && this._aggregators.length){
				for (var ind=0; ind < this._aggregators.length; ind++) {
					if (this._aggregators[ind]){
							var ed=this.cells(pid,ind);
							ed.setValue(this._calcSCL(ed.cell));
					}
				};
			}
		return true;
	})
	grid.attachEvent("onXLE",function(){
		for (var i=0; i < this._aggregators.length; i++) {
			if (this._aggregators[i])
				this._h2.forEachChild(0,function(el){
					if (el.childs.length!=0){
						var ed=this.cells(el.id,i);
						ed.setValue(this._calcSCL(ed.cell));
					}
				},this);
		};
	})

});

/**
*	@desc: enable/disable serialization of math formulas
*	@param: status - true/false
*	@type:  public
*   @edition: Professional
*/
dhtmlXGridObject.prototype.enableMathSerialization=function(status){
    this._mathSerialization=dhx4.s2b(status);
}
/**
*	@desc: enable/disable rounding while math calculations
*	@param: digits - set hom many digits must be rounded, set 0 for disabling
*	@type:  public
*   @edition: Professional
*/
dhtmlXGridObject.prototype.setMathRound=function(digits){
	this._roundDl=digits;
    this._roundD=Math.pow(10,digits);
}
/**
*	@desc: enable/disable editing of math cells
*	@param: status - true/false
*	@type:  public
*   @edition: Professional
*/
dhtmlXGridObject.prototype.enableMathEditing=function(status){
    this._mathEdit=dhx4.s2b(status);
}

/**
*	@desc: calculate value of math cell
*	@param: cell - math cell
*	@returns: cell value
*	@type:  private
*   @edition: Professional
*/
dhtmlXGridObject.prototype._calcSCL=function(cell){ 
    if (!cell._code) return this.cells5(cell).getValue();
    try{
    	dhtmlx.agrid=this;
    	var z=eval(cell._code);
    } catch(e){ return ("#SCL"); }
    if (this._roundD)
        { 
        	var pre=Math.abs(z)<1?"0":"";
         	if (z<0) pre="-"+pre;
            z=Math.round(Math.abs(z)*this._roundD).toString();
            if (z==0) return 0;
            if (this._roundDl>0){
            	var n=z.length-this._roundDl;
            	if (n<0) {
            		z=("000000000"+z).substring(9+n);
            		n=0;
            	}
            	return (pre+z.substring(0,n)+"."+z.substring(n,z.length));
            }
          return pre+z;
      }
    return z;      
}

dhtmlXGridObject.prototype._countTotal=function(row,cell){ 
	var b=0;
	var z=this._h2.get[row];
	for (var i=0; i<z.childs.length; i++){
		if (!z.childs[i].buff) return b;	// dnd of item with childs, item inserted in hierarchy but not fully processed
		if (z.childs[i].buff._parser){
			this._h2.forEachChild(row,function(el){
				if (el.childs.length==0){
          var value = parseFloat(this._get_cell_value(el.buff,cell),10);
          if (value)
					 b += value;
        }
			},this)
			return b;
		}
    var value = parseFloat(this._get_cell_value(z.childs[i].buff,cell),10);
    if (value)
		  b += value;
	}
	return b;
}

/**
*	@desc: compile pseudo code to correct javascript
*	@param: code - pseudo code
*	@param: cell - math cell
*	@returns: valid js code
*	@type:  private
*   @edition: Professional
*/
dhtmlXGridObject.prototype._compileSCL=function(code,cell,fix){ 
		if (code === null || code === window.undefined) return code;
        code=code.toString();
        if (code.indexOf("=")!=0 || !cell.parentNode) {
        	this._reLink([],cell);
        	if (fix) cell._code = cell.original = null;
            return code;
        }
        cell.original=code;
        
        var linked=null;
        code=code.replace("=","");
        if (code.indexOf("sum")!=-1){ 
            code=code.replace("sum","(dhtmlx.agrid._countTotal('"+cell.parentNode.idd+"',"+cell._cellIndex+"))");
            if (!this._aggregators) this._aggregators=[];
            this._aggregators[cell._cellIndex]="sum";
            cell._code=code;
        	return  this._parsing?"":this._calcSCL(cell);
        }
        if (code.indexOf("[[")!=-1){
          var test = /(\[\[([^\,]*)\,([^\]]*)]\])/g;
          dhtmlx.agrid=this;
          linked=linked||(new Array());
          code=code.replace(test,
              function ($0,$1,$2,$3){
                  if ($2=="-")
                      $2=cell.parentNode.idd;
                  if ($2.indexOf("#")==0)
                      $2=dhtmlx.agrid.getRowId($2.replace("#",""));
                      linked[linked.length]=[$2,$3];
                  return "(parseFloat(dhtmlx.agrid.cells(\""+$2+"\","+$3+").getValue(),10))";
              }
          );
        }
        
        if (code.indexOf(":")!=-1){ 
          var test = /:(\w+)/g;
          dhtmlx.agrid=this;
          var id=cell.parentNode.idd;
          linked=linked||(new Array());
          code=code.replace(test,
              function ($0,$1,$2,$3){
                  linked[linked.length]=[id,dhtmlx.agrid.getColIndexById($1)];
                  return '(parseFloat(dhtmlx.agrid.cells("'+id+'",dhtmlx.agrid.getColIndexById("'+$1+'")).getValue(),10))';
              }
          );
        }
        else{
          var test = /c([0-9]+)/g;
          dhtmlx.agrid=this;
          var id=cell.parentNode.idd;
          linked=linked||(new Array());
          code=code.replace(test,
              function ($0,$1,$2,$3){
                  linked[linked.length]=[id,$1];
                  return "(parseFloat(dhtmlx.agrid.cells(\""+id+"\","+$1+").getValue(),10))";
              }
          );
        }
        
        this._reLink(linked,cell);
        cell._code=code;
        return this._calcSCL(cell);
    }

/**
*	@desc: link math cells to it source cells
*	@param: ar - array of nodes for linking
*	@param: cell - math cell
*	@type:  private
*   @edition: Professional
*/
dhtmlXGridObject.prototype._reLink=function(ar,cell){
		if (!ar.length) return; // basically it would be good to clear unused math links, but it will require a symetric structure 
		for (var i=0; i<ar.length; i++){ 
			if (!this._mat_links[ar[i][0]]) this._mat_links[ar[i][0]]={};
			var t=this._mat_links[ar[i][0]];
			if (!t[ar[i][1]]) t[ar[i][1]]=[];
			t[ar[i][1]].push(cell);
		}
}

if (_isKHTML){
// replace callback support for safari.
 (function(){
   var default_replace = String.prototype.replace;
   String.prototype.replace = function(search,replace){
 // replace is not function
 if(typeof replace != "function"){
 return default_replace.apply(this,arguments)
 }
 var str = "" + this;
 var callback = replace;
 // search string is not RegExp
 if(!(search instanceof RegExp)){
 var idx = str.indexOf(search);
 return (
 idx == -1 ? str :
 default_replace.apply(str,[search,callback(search, idx, str)])
 )
 }
 var reg = search;
 var result = [];
 var lastidx = reg.lastIndex;
 var re;
 while((re = reg.exec(str)) != null){
 var idx  = re.index;
 var args = re.concat(idx, str);
 result.push(
 str.slice(lastidx,idx),
 callback.apply(null,args).toString()
 );
 if(!reg.global){
 lastidx += RegExp.lastMatch.length;
 break
 }else{
 lastidx = reg.lastIndex;
 }
 }
 result.push(str.slice(lastidx));
 return result.join("")
   }
 })();
 }
//(c)dhtmlx ltd. www.dhtmlx.com

/*
Product Name: dhtmlxSuite 
Version: 4.1.3 
Edition: Professional 
License: content of this file is covered by DHTMLX Commercial or Enterprise license. Usage without proper license is prohibited. To obtain it contact sales@dhtmlx.com
Copyright UAB Dinamenta http://www.dhtmlx.com
*/

/**
*   @desc: add new column to the grid. Can be used after grid was initialized. At least one column should be in grid
*   @param: ind - index of column
*   @param: header - header content of column
*   @param: type - type of column
*   @param: width - width of column
*   @param: sort - sort type of column
*   @param: align - align of column
*   @param: valign - vertical align of column
*   @param: reserved - not used for now
*   @param: columnColor - background color of column
*   @type: public
*   @edition: Professional
*   @topic: 3
*/
dhtmlXGridObject.prototype.insertColumn=function(ind,header,type,width,sort,align,valign,reserved,columnColor){
	ind=parseInt(ind);
	if (ind>this._cCount) ind=this._cCount;
	if (!this._cMod) this._cMod=this._cCount;
	this._processAllArrays(this._cCount,ind-1,[(header||"&nbsp;"),(width||100),(type||"ed"),(align||"left"),(valign||""),(sort||"na"),(columnColor||""),"",this._cMod,(width||100)]);
	this._processAllRows("_addColInRow",ind);

	if (typeof(header)=="object")
		for (var i=1; i < this.hdr.rows.length; i++) {
			if (header[i-1]=="#rspan"){
         		var pind=i-1;
         		var found=false;
         		var pz=null;
         		while(!found){
            		var pz=this.hdr.rows[pind];
            		for (var j=0; j<pz.cells.length; j++)
               			if (pz.cells[j]._cellIndex==ind) {
                  			found=j;
                  			break;
		      		}
            		pind--;
	        	}
	        this.hdr.rows[pind+1].cells[j].rowSpan=(this.hdr.rows[pind].cells[j].rowSpan||1)+1;
			}
			else				
			this.setHeaderCol(ind,(header[i-1]||"&nbsp;"),i);
		}
	else
		this.setHeaderCol(ind,(header||"&nbsp;"));
	this.hdr.rows[0].cells[ind]
	this._cCount++;
	this._cMod++;
	this._master_row=null;
	this.setSizes();
}
/**
*   @desc: delete column
*   @param: ind - index of column
*   @type: public
*   @edition: Professional
*   @topic: 0
*/
dhtmlXGridObject.prototype.deleteColumn=function(ind){
	ind=parseInt(ind);
	if (this._cCount==0) return;
	if (!this._cMod) this._cMod=this._cCount;
	if (ind>=this._cCount) return;
	this._processAllArrays(ind,this._cCount-1,[null,null,null,null,null,null,null,null,null,null,null]);
	this._processAllRows("_deleteColInRow",ind);
	this._cCount--;
	this._master_row=null;
	this.setSizes();

}

/**
*   @desc: call method for all rows in all collections
*   @type: private
*   @topic: 0
*/
dhtmlXGridObject.prototype._processAllRows = function(method,oldInd,newInd){
	this[method](this.obj.rows[0],oldInd,newInd,0);

	var z=this.hdr.rows.length;
    for (var i=0; i<z; i++)
		this[method](this.hdr.rows[i],oldInd,newInd,i);
		
	if (this.ftr){
		var z=this.ftr.firstChild.rows.length;
	    for (var i=0; i<z; i++)
			this[method](this.ftr.firstChild.rows[i],oldInd,newInd,i);
	}

	this.forEachRow(function(id){
		if (this.rowsAr[id] && this.rowsAr[id].tagName=="TR")
			this[method](this.rowsAr[id],oldInd,newInd,-1);
	});			
	
}

/**
*   @desc: shift data in all arrays
*   @type: private
*   @topic: 0
*/
dhtmlXGridObject.prototype._processAllArrays = function(oldInd,newInd,vals){
	var ars=["hdrLabels","initCellWidth","cellType","cellAlign","cellVAlign","fldSort","columnColor","_hrrar","_c_order"];
	if (this.cellWidthPX.length) ars.push("cellWidthPX");
	if (this.cellWidthPC.length) ars.push("cellWidthPC");
	if (this._col_combos) ars.push("_col_combos");
    if (this._mCols) ars[ars.length]="_mCols";
    if (this.columnIds) ars[ars.length]="columnIds";
    if (this._maskArr) ars.push("_maskArr");
    if (this._drsclmW) ars.push("_drsclmW");
    if (this._RaSeCol) ars.push("_RaSeCol");
    if (this._hm_config) ars.push("_hm_config");
    if (this._drsclmn) ars.push("_drsclmn");

    if (this.clists) ars.push("clists");
    if (this._validators && this._validators.data) ars.push(this._validators.data);
    
    ars.push("combos");
    if (this._customSorts) ars.push("_customSorts");
    if (this._aggregators)  ars.push("_aggregators");
    var mode=(oldInd<=newInd);

	if (!this._c_order) {
		this._c_order=new Array();
		var l=this._cCount;
		for (var i=0; i<l; i++)
			this._c_order[i]=i;
	}

	for (var i=0; i<ars.length; i++)
		{
			var t=this[ars[i]]||ars[i];
			if (t){
				if (mode){
					var val=t[oldInd];
					for (var j=oldInd; j<newInd; j++)
						t[j]=t[j+1];
					t[newInd]=val;
				} else {
					var val=t[oldInd];
					for (var j=oldInd; j>(newInd+1); j--)
						t[j]=t[j-1];
					t[newInd+1]=val;
				}
				if (vals)
					t[newInd+(mode?0:1)]=vals[i];
			}
		}
}


/**
*   @desc: moves column of specified index to new position
*   @param: oldInd - current index of column
*   @param: newInd - new index of column
*   @type: public
*   @edition: Professional
*   @topic: 0
*/
dhtmlXGridObject.prototype.moveColumn = function(oldInd,newInd){
	newInd--;
    oldInd=parseInt(oldInd); newInd=parseInt(newInd);
	if (newInd<oldInd) var tInd=newInd+1;
	else var tInd=newInd;
	

	if (!this.callEvent("onBeforeCMove",[oldInd,tInd]))  return false;
	if (oldInd==tInd) return;

	
	//replace data
	this.editStop();
    this._processAllRows("_moveColInRow",oldInd,newInd);
    this._processAllArrays(oldInd,newInd);

	//sorting image
	if (this.fldSorted)
		this.setSortImgPos(this.fldSorted._cellIndex);

  /*	for (var i=0; i<this.hdrLabels.length; i++)
		this._c_revers[this._c_order[i]]=i;*/
	this.callEvent("onAfterCMove",[oldInd,tInd]);
};


/**
*   @desc: swap columns in collection
*   @param: cols - collection of collumns
*   @type: private
*   @topic: 0
*/
dhtmlXGridObject.prototype._swapColumns = function(cols){
	var z=new Array();
	for (var i=0; i<this._cCount; i++){
		var n=cols[this._c_order[i]];
		if (typeof(n)=="undefined") n="";
		z[i]=n;
		}
	return z;
}

/**
*   @desc: move data in the row
*   @param: row - row object
*   @param: oldInd - current index of column
*   @param: newInd - new index of column
*   @type: private
*   @topic: 0
*/
dhtmlXGridObject.prototype._moveColInRow = function(row,oldInd,newInd){


	var c=row.childNodes[oldInd];
	var ci=row.childNodes[newInd+1];
	if (!c) return;
	if (ci)
		row.insertBefore(c,ci);
	else
		row.appendChild(c);

	for (var i=0; i<row.childNodes.length; i++)
		row.childNodes[i]._cellIndex=row.childNodes[i]._cellIndexS=i;

};
/**
*   @desc: add column in row
*   @param: row - row object
*   @param: ind - current index of column
*   @type: private
*   @topic: 0
*/
dhtmlXGridObject.prototype._addColInRow = function(row,ind,old,mod){
	var cind=ind;
	if (row._childIndexes){
		if (row._childIndexes[ind-1]==row._childIndexes[ind] || !row.childNodes[row._childIndexes[ind-1]]){
			for (var i=row._childIndexes.length; i>=ind; i--)
			row._childIndexes[i]=i?(row._childIndexes[i-1]+1):0;
			row._childIndexes[ind]--;
			}
		else
		for (var i = row._childIndexes.length; i >= ind; i--)
			row._childIndexes[i]=i?(row._childIndexes[i-1]+1):0;
		var cind=row._childIndexes[ind];
	}
	var c=row.childNodes[cind];
	var z=document.createElement((mod)?"TD":"TH");
	if (mod) { z._attrs={}; } //necessary for code compressor
	else z.style.width=(parseInt(this.cellWidthPX[ind])||"100")+"px";
	if (c)
		row.insertBefore(z,c);
	else
		row.appendChild(z);

	if (this.dragAndDropOff && row.idd) this.dragger.addDraggableItem(row.childNodes[cind],this);
	
	for (var i=cind+1; i<row.childNodes.length; i++){
		row.childNodes[i]._cellIndex=row.childNodes[i]._cellIndexS=row.childNodes[i]._cellIndex+1;
	}
		
	if (row.childNodes[cind]) row.childNodes[cind]._cellIndex=row.childNodes[cind]._cellIndexS=ind;

	if (row.idd || typeof(row.idd)!="undefined"){
		this.cells3(row,ind).setValue("");
		z.align=this.cellAlign[ind];
		z.style.verticalAlign=this.cellVAlign[ind];
		z.bgColor=this.columnColor[ind];
		}
	else if (z.tagName=="TD"){
		if (!row.idd && this.forceDivInHeader) z.innerHTML="<div class='hdrcell'>&nbsp;</div>";
		else	z.innerHTML="&nbsp;";
	} 
};
/**
*   @desc: delete columns from row
*   @param: row - row object
*   @param: ind - current index of column
*   @type: private
*   @topic: 0
*/
dhtmlXGridObject.prototype._deleteColInRow = function(row,ind){
	var aind = ind; //logical index
	if (row._childIndexes) ind=row._childIndexes[ind];
	var c=row.childNodes[ind];
	if (!c) return;
	if (c.colSpan && c.colSpan>1 && c.parentNode.idd){
		var t=c.colSpan-1;
		var v=this.cells4(c).getValue();
		this.setColspan(c.parentNode.idd,c._cellIndex,1)
		if (t>1){
			var cind=c._cellIndex*1;
			this.setColspan(c.parentNode.idd,cind+1,t)
			this.cells(c.parentNode.idd,c._cellIndex*1+1).setValue(v)
			row._childIndexes.splice(cind,1)
			for (var i=cind; i < row._childIndexes.length; i++) 
				row._childIndexes[i]-=1;
				
		}
	} else if (row._childIndexes){
	    row._childIndexes.splice(aind,1);
	    for (var i=aind; i<row._childIndexes.length; i++) row._childIndexes[i]--;
	}
	if (c)
		row.removeChild(c);

	for (var i=ind; i<row.childNodes.length; i++)
		row.childNodes[i]._cellIndex=row.childNodes[i]._cellIndexS=row.childNodes[i]._cellIndex-1;
};


/**
*   @desc: enable move column functionality
*   @param: mode - true/false
*   @param: columns - list of true/false values, optional
*   @type: public
*   @edition: Professional
*   @topic: 0
*/
dhtmlXGridObject.prototype.enableColumnMove = function(mode,columns){
	this._mCol=dhx4.s2b(mode);
	if (typeof(columns)!="undefined")
		this._mCols=columns.split(",");
	if (!this._mmevTrue){
		dhtmlxEvent(this.hdr,"mousedown",this._startColumnMove);
		dhtmlxEvent(document.body,"mousemove",this._onColumnMove);
		dhtmlxEvent(document.body,"mouseup",this._stopColumnMove);
		this._mmevTrue=true;
	}
};

dhtmlXGridObject.prototype._startColumnMove = function(e){
	e=e||event;
	var el = e.target||e.srcElement;
//	var grid=globalActiveDHTMLGridObject;
	   	var zel=el;
	   	while(zel.tagName!="TABLE") zel=zel.parentNode;
		var grid=zel.grid;
		if (!grid) return; //somehow grid not found
		grid.setActive();
	if (!grid._mCol || e.button==2) return;
	
	el = grid.getFirstParentOfType(el,"TD")
    if(el.style.cursor!="default") return true;
	if ((grid)&&(!grid._colInMove)){
		grid.resized = null;
		if ((!grid._mCols)||(grid._mCols[el._cellIndex]=="true"))
	    	grid._colInMove=el._cellIndex+1;
	}
	return true;
};
dhtmlXGridObject.prototype._onColumnMove = function(e){
	e=e||event;
	var grid=window.globalActiveDHTMLGridObject;
	if ((grid)&&(grid._colInMove)){
		if (grid._hideHContext) grid._hideHContext();
    	if (typeof(grid._colInMove)!="object"){
        	var z=document.createElement("DIV");
			z._aIndex=(grid._colInMove-1);
			z._bIndex=null;
			z.innerHTML=grid.getHeaderCol(z._aIndex);
			z.className="dhx_dragColDiv";
			z.style.position="absolute";
			document.body.appendChild(z);
            grid._colInMove=z;
		}
		
		var cor=[];
		cor[0]=(document.body.scrollLeft||document.documentElement.scrollLeft);
		cor[1]=(document.body.scrollTop||document.documentElement.scrollTop);
		
		
		grid._colInMove.style.left=e.clientX+cor[0]+8+"px";
		grid._colInMove.style.top=e.clientY+cor[1]+8+"px";
		
        var el = e.target||e.srcElement;
		while ((el)&&(typeof(el._cellIndexS)=="undefined"))
			el=el.parentNode;

		if (grid._colInMove._oldHe){
			grid._colInMove._oldHe.className=grid._colInMove._oldHe.className.replace(/columnTarget(L|R)/g,"");
			grid._colInMove._oldHe=null;
			grid._colInMove._bIndex=null;
			}
		if (el) {
			if (grid.hdr.rows[1]._childIndexes)
				var he=grid.hdr.rows[1].cells[grid.hdr.rows[1]._childIndexes[el._cellIndexS]];
			else
				var he=grid.hdr.rows[1].cells[el._cellIndexS];
			var z=e.clientX-(dhx4.absLeft(he)-grid.hdrBox.scrollLeft);
            if (z/he.offsetWidth>0.5){
				he.className+=" columnTargetR";
				grid._colInMove._bIndex=el._cellIndexS;
				}
			else {
				he.className+=" columnTargetL";
				grid._colInMove._bIndex=el._cellIndexS-1;
			}
			if (he.offsetLeft<(grid.objBox.scrollLeft+20))
				grid.objBox.scrollLeft=Math.max(0,he.offsetLeft-20);

			if ((he.offsetLeft+he.offsetWidth-grid.objBox.scrollLeft)>(grid.objBox.offsetWidth-20))
				grid.objBox.scrollLeft=Math.min(grid.objBox.scrollLeft+he.offsetWidth+20,grid.objBox.scrollWidth-grid.objBox.offsetWidth);	
				
            grid._colInMove._oldHe=he;
		}
		//prevent selection, or other similar reactions while column draged
		e.cancelBubble = true;  
        return false;  
	}
	return true;
};
dhtmlXGridObject.prototype._stopColumnMove = function(e){
	e=e||event;
	var grid=window.globalActiveDHTMLGridObject;
	if ((grid)&&(grid._colInMove)){
		if (typeof(grid._colInMove)=="object"){
			grid._colInMove.parentNode.removeChild(grid._colInMove);
			if (grid._colInMove._bIndex!=null)
				grid.moveColumn(grid._colInMove._aIndex,grid._colInMove._bIndex+1);

			if (grid._colInMove._oldHe)
				grid._colInMove._oldHe.className=grid._colInMove._oldHe.className.replace(/columnTarget(L|R)/g,"");
			grid._colInMove._oldHe=null;
			grid._colInMove.grid=null;
			grid.resized = true;
			}
        grid._colInMove=0;
	}
	return true;
};



//(c)dhtmlx ltd. www.dhtmlx.com



/*
Product Name: dhtmlxSuite 
Version: 4.1.3 
Edition: Professional 
License: content of this file is covered by DHTMLX Commercial or Enterprise license. Usage without proper license is prohibited. To obtain it contact sales@dhtmlx.com
Copyright UAB Dinamenta http://www.dhtmlx.com
*/

dhtmlXGridObject.prototype.mouseOverHeader=function(func){
		var self=this;
		dhtmlxEvent(this.hdr,"mousemove",function(e){
				e=e||window.event;
				var el=e.target||e.srcElement;
            	if(el.tagName!="TD")
                	el = self.getFirstParentOfType(el,"TD")				
                if (el && (typeof(el._cellIndex)!="undefined"))
					func(el.parentNode.rowIndex,el._cellIndex);
		});
}
dhtmlXGridObject.prototype.mouseOver=function(func){
		var self=this;	
		dhtmlxEvent(this.obj,"mousemove",function(e){
				e=e||window.event;
				var el=e.target||e.srcElement;
            	if(el.tagName!="TD")
                	el = self.getFirstParentOfType(el,"TD")				
                if (el && (typeof(el._cellIndex)!="undefined"))
					func(el.parentNode.rowIndex,el._cellIndex);
		});
}
//(c)dhtmlx ltd. www.dhtmlx.com

/*
Product Name: dhtmlxSuite 
Version: 4.1.3 
Edition: Professional 
License: content of this file is covered by DHTMLX Commercial or Enterprise license. Usage without proper license is prohibited. To obtain it contact sales@dhtmlx.com
Copyright UAB Dinamenta http://www.dhtmlx.com
*/

/**
*  @desc: enable smart paging mode
*  @type: public
*  @param: fl - true|false - enable|disable mode
*  @param: pageSize - count of rows per page
*  @param: pagesInGrp - count of visible page selectors
*  @param: parentObj - ID or container which will be used for showing paging controls
*  @param: showRecInfo - true|false - enable|disable showing of additional info about paging state
*  @param: recInfoParentObj - ID or container which will be used for showing paging state
*  @edition: Professional
*  @topic: 0
*/
dhtmlXGridObject.prototype.enablePaging = function(fl,pageSize,pagesInGrp,parentObj,showRecInfo,recInfoParentObj){
	this._pgn_parentObj = typeof(parentObj)=="string" ? document.getElementById(parentObj) : parentObj;
	this._pgn_recInfoParentObj = typeof(recInfoParentObj)=="string" ? document.getElementById(recInfoParentObj) : recInfoParentObj;
	
	this.pagingOn = fl;
	this.showRecInfo = showRecInfo;
	this.rowsBufferOutSize = parseInt(pageSize);
	this.currentPage = 1;
	this.pagesInGroup = parseInt(pagesInGrp);
	this._init_pgn_events()
	this.setPagingSkin("default");
}
/**
*  @desc: allow to configure settings of dynamical paging
*  @type: public
*  @param: filePath - path which will be used for requesting data ( parth from load command used by default )
*  @param: buffer -  count of rows requrested from server by single operation, optional
*  @edition: Professional
*  @topic: 0
*/
dhtmlXGridObject.prototype.setXMLAutoLoading = function(filePath,bufferSize){
	this.xmlFileUrl = filePath;
	this._dpref = bufferSize;
}
/**
*  @desc: change current page in grid
*  @type: public
*  @param: ind - correction ( -1,1,2  etc) to current active page
*  @edition: Professional
*  @topic: 0
*/
dhtmlXGridObject.prototype.changePageRelative = function(ind){ 
	this.changePage(this.currentPage+ind);
}
/**
*  @desc: change current page in grid
*  @type: public
*  @param: pageNum -  new active page
*  @edition: Professional
*  @topic: 0
*/
dhtmlXGridObject.prototype.changePage = function(pageNum){ 
	if (arguments.length==0) pageNum=this.currentPage||0;
	pageNum=parseInt(pageNum);
	pageNum=Math.max(1,Math.min(pageNum,Math.ceil(this.rowsBuffer.length/this.rowsBufferOutSize)));
	
	if(!this.callEvent("onBeforePageChanged",[this.currentPage,pageNum]))
		return;
	
	this.currentPage = parseInt(pageNum);
	this._reset_view();
	this._fixAlterCss();			
	this.callEvent("onPageChanged",this.getStateOfView());
}
/**
*  @desc: allows to set custom paging skin
*  @param: name - skin name (default,toolbar,bricks)
*  @type:  public
*/
dhtmlXGridObject.prototype.setPagingSkin = function(name){
	this._pgn_skin=this["_pgn_"+name];
	if (name=="toolbar") this._pgn_skin_tlb=arguments[1];
}
/**
*  @desc: allows to set paging templates for default skin
*  @param: a - template for zone A
*  @param: b - template for zone B
*  @type:  public
*/
dhtmlXGridObject.prototype.setPagingTemplates = function(a,b){
	this._pgn_templateA=this._pgn_template_compile(a);
	this._pgn_templateB=this._pgn_template_compile(b);
	this._page_skin_update();
}
dhtmlXGridObject.prototype._page_skin_update = function(name){
	if (!this.pagesInGroup) this.pagesInGroup=Math.ceil(Math.min(5,this.rowsBuffer.length/this.rowsBufferOutSize));
	var totalPages=Math.ceil(this.rowsBuffer.length/this.rowsBufferOutSize);
	if (totalPages && totalPages<this.currentPage)
		return this.changePage(totalPages);
	if (this.pagingOn && this._pgn_skin) this._pgn_skin.apply(this,this.getStateOfView());
}
dhtmlXGridObject.prototype._init_pgn_events = function(name){
	this.attachEvent("onXLE",this._page_skin_update)
	this.attachEvent("onClearAll",this._page_skin_update)
	this.attachEvent("onPageChanged",this._page_skin_update)
	this.attachEvent("onGridReconstructed",this._page_skin_update)
	
	this._init_pgn_events=function(){};
}

// default paging
dhtmlXGridObject.prototype._pgn_default=function(page,start,end){
	if (!this.pagingBlock){
		this.pagingBlock = document.createElement("DIV");
		this.pagingBlock.className = "pagingBlock";
		this.recordInfoBlock = document.createElement("SPAN");
		this.recordInfoBlock.className = "recordsInfoBlock";
		if (!this._pgn_parentObj) return;
		this._pgn_parentObj.appendChild(this.pagingBlock)
		if(this._pgn_recInfoParentObj && this.showRecInfo)
			this._pgn_recInfoParentObj.appendChild(this.recordInfoBlock)
		
		//this._pgn_template="{prev:} {current:-1},{current},{current:+1} {next:>}"
		if (!this._pgn_templateA){
			this._pgn_templateA=this._pgn_template_compile("[prevpages:&lt;:&nbsp;] [currentpages:,&nbsp;] [nextpages:&gt;:&nbsp;]");
			this._pgn_templateB=this._pgn_template_compile("Results <b>[from]-[to]</b> of <b>[total]</b>");
		}
	}
	
	var details=this.getStateOfView();
	this.pagingBlock.innerHTML = this._pgn_templateA.apply(this,details);
	this.recordInfoBlock.innerHTML = this._pgn_templateB.apply(this,details);
	this._pgn_template_active(this.pagingBlock);
	this._pgn_template_active(this.recordInfoBlock);
	
	this.callEvent("onPaging",[]);
}

dhtmlXGridObject.prototype._pgn_block=function(sep){ 
	var start=Math.floor((this.currentPage-1)/this.pagesInGroup)*this.pagesInGroup;
	var max=Math.min(Math.ceil(this.rowsBuffer.length/this.rowsBufferOutSize),start+this.pagesInGroup);
	var str=[];
	for (var i=start+1; i<=max; i++)
		if (i==this.currentPage)
		str.push("<a class='dhx_not_active'><b>"+i+"</b></a>");
	else
		str.push("<a onclick='this.grid.changePage("+i+"); return false;'>"+i+"</a>");
	return str.join(sep);
}
dhtmlXGridObject.prototype._pgn_link=function(mode,ac,ds){
	if (mode=="prevpages" || mode=="prev"){
		if (this.currentPage==1) return ds;
		return '<a onclick=\'this.grid.changePageRelative(-1*'+(mode=="prev"?'1':'this.grid.pagesInGroup')+'); return false;\'>'+ac+'</a>'
	}
	
	if (mode=="nextpages" || mode=="next"){
		if (this.rowsBuffer.length/this.rowsBufferOutSize <= this.currentPage ) return ds;
		if (this.rowsBuffer.length/(this.rowsBufferOutSize*(mode=="next"?'1':this.pagesInGroup)) <= 1 ) return ds;
		return '<a onclick=\'this.grid.changePageRelative('+(mode=="next"?'1':'this.grid.pagesInGroup')+'); return false;\'>'+ac+'</a>'
	}
	
	if (mode=="current"){
		var i=this.currentPage+(ac?parseInt(ac):0);
		if (i<1 || Math.ceil(this.rowsBuffer.length/this.rowsBufferOutSize) < i ) return ds;
		return '<a '+(i==this.currentPage?"class='dhx_active_page_link' ":"")+'onclick=\'this.grid.changePage('+i+'); return false;\'>'+i+'</a>'
	}
	return ac;
}

dhtmlXGridObject.prototype._pgn_template_active=function(block){
	var tags=block.getElementsByTagName("A");
	if (tags)
	for (var i=0; i < tags.length; i++) {
		tags[i].grid=this;
	};
}
dhtmlXGridObject.prototype._pgn_template_compile=function(template){
	/*
	[prev],[next]
	[currentpages]
	[from],[to],[total]
	*/
	template=template.replace(/\[([^\]]*)\]/g,function(a,b){
			b=b.split(":");
			switch (b[0]){
			case "from": 
				return '"+(arguments[1]*1+(arguments[2]*1?1:0))+"';
			case "total":
				return '"+arguments[3]+"';
			case "to":
				return '"+arguments[2]+"';
			case "current":
			case "prev":
			case "next":
			case "prevpages":
			case "nextpages":
				return '"+this._pgn_link(\''+b[0]+'\',\''+b[1]+'\',\''+b[2]+'\')+"'
			case "currentpages":
				return '"+this._pgn_block(\''+b[1]+'\')+"'
			}
			//do it here
	})
	return new Function('return "'+template+'";')
}

dhtmlXGridObject.prototype.i18n.paging={
	results:"Результаты",
	records:"Записи с ",
	to:" по ",
	page:"Страница ",
	perpage:"строк на страницу",
	first:"К первой строке",
	previous:"Предыдущая тсраница",
	found:"Найдено записей",
	next:"Следующая страница",
	last:"К последней странице",
	of:" из ",
	notfound:"Записей не найдено"
}
/**
*  @desc: configure paging with toolbar mode ( must be called BEFORE enablePaging)
*  @param: navButtons - enable/disable navigation buttons
*  @param: navLabel - enable/disable navigation label
*  @param: pageSelect - enable/disable page selector
*  @param: perPageSelect - an array of "per page" select options ([5,10,15,20,25,30] by default)
*  @type: public
*  @edition: Professional
*/
dhtmlXGridObject.prototype.setPagingWTMode = function(navButtons,navLabel,pageSelect,perPageSelect){
	this._WTDef=[navButtons,navLabel,pageSelect,perPageSelect];
}
/**
*  @desc: Bricks skin for paging
*/
dhtmlXGridObject.prototype._pgn_bricks = function(page, start, end){
	//set class names depending on grid skin
	var tmp = (this.skin_name||"").split("_")[1];
	var sfx="";
	if(tmp=="light" || tmp=="modern" || tmp=="skyblue")
		sfx = "_"+tmp;
	
	this.pagerElAr = new Array();
	this.pagerElAr["pagerCont"] = document.createElement("DIV");
	this.pagerElAr["pagerBord"] = document.createElement("DIV");
	this.pagerElAr["pagerLine"] = document.createElement("DIV");
	this.pagerElAr["pagerBox"] = document.createElement("DIV");
	this.pagerElAr["pagerInfo"] = document.createElement("DIV");
	this.pagerElAr["pagerInfoBox"] = document.createElement("DIV");
	var se = (this.globalBox||this.objBox);
	this.pagerElAr["pagerCont"].style.width = se.clientWidth+"px";
	this.pagerElAr["pagerCont"].style.overflow = "hidden";
	this.pagerElAr["pagerCont"].style.clear = "both";
	this.pagerElAr["pagerBord"].className = "dhx_pbox"+sfx;
	this.pagerElAr["pagerLine"].className = "dhx_pline"+sfx;
	this.pagerElAr["pagerBox"].style.clear = "both";
	this.pagerElAr["pagerInfo"].className = "dhx_pager_info"+sfx;
	
	//create structure
	this.pagerElAr["pagerCont"].appendChild(this.pagerElAr["pagerBord"]);
	this.pagerElAr["pagerCont"].appendChild(this.pagerElAr["pagerLine"]);
	this.pagerElAr["pagerCont"].appendChild(this.pagerElAr["pagerInfo"]);
	this.pagerElAr["pagerLine"].appendChild(this.pagerElAr["pagerBox"]);
	this.pagerElAr["pagerInfo"].appendChild(this.pagerElAr["pagerInfoBox"]);
	this._pgn_parentObj.innerHTML = "";
	this._pgn_parentObj.appendChild(this.pagerElAr["pagerCont"]);
	
	
	
	
	if(this.rowsBuffer.length>0){
		var lineWidth = 20;
		var lineWidthInc = 22;
		
		//create left arrow if needed
		if(page>this.pagesInGroup){
			var pageCont = document.createElement("DIV");
			var pageBox = document.createElement("DIV");
			pageCont.className = "dhx_page"+sfx;
			pageBox.innerHTML = "&larr;";
			pageCont.appendChild(pageBox);
			this.pagerElAr["pagerBox"].appendChild(pageCont);
			var self = this;
			pageCont.pgnum = (Math.ceil(page/this.pagesInGroup)-1)*this.pagesInGroup;
			pageCont.onclick = function(){
				self.changePage(this.pgnum);
			}
			lineWidth +=lineWidthInc;
		}
		//create pages
		for(var i=1;i<=this.pagesInGroup;i++){
			var pageCont = document.createElement("DIV");
			var pageBox = document.createElement("DIV");
			pageCont.className = "dhx_page"+sfx;
			pageNumber = ((Math.ceil(page/this.pagesInGroup)-1)*this.pagesInGroup)+i;
			if(pageNumber>Math.ceil(this.rowsBuffer.length/this.rowsBufferOutSize))
				break;
			pageBox.innerHTML = pageNumber;
			pageCont.appendChild(pageBox);
			if(page==pageNumber){
				pageCont.className += " dhx_page_active"+sfx;
				pageBox.className = "dhx_page_active"+sfx;
			}else{
				var self = this;
				pageCont.pgnum = pageNumber;
				pageCont.onclick = function(){
					self.changePage(this.pgnum);
				}
			}
			lineWidth +=(parseInt(lineWidthInc/3)*pageNumber.toString().length)+15;
			pageBox.style.width = (parseInt(lineWidthInc/3)*pageNumber.toString().length)+8+"px";
			this.pagerElAr["pagerBox"].appendChild(pageCont);
		}
		//create right arrow if needed
		if(Math.ceil(page/this.pagesInGroup)*this.pagesInGroup<Math.ceil(this.rowsBuffer.length/this.rowsBufferOutSize)){
			var pageCont = document.createElement("DIV");
			var pageBox = document.createElement("DIV");
			pageCont.className = "dhx_page"+sfx;
			pageBox.innerHTML = "&rarr;";
			pageCont.appendChild(pageBox);
			this.pagerElAr["pagerBox"].appendChild(pageCont);
			var self = this;
			pageCont.pgnum = (Math.ceil(page/this.pagesInGroup)*this.pagesInGroup)+1;
			pageCont.onclick = function(){
				self.changePage(this.pgnum);
			}
			lineWidth +=lineWidthInc;
		}
		
		this.pagerElAr["pagerLine"].style.width = lineWidth+"px";
	}
	
	//create page info
	if(this.rowsBuffer.length>0 && this.showRecInfo)
		this.pagerElAr["pagerInfoBox"].innerHTML = this.i18n.paging.records+(start+1)+this.i18n.paging.to+end+this.i18n.paging.of+this.rowsBuffer.length;
	else if(this.rowsBuffer.length==0){
		this.pagerElAr["pagerLine"].parentNode.removeChild(this.pagerElAr["pagerLine"]);
		this.pagerElAr["pagerInfoBox"].innerHTML = this.i18n.paging.notfound;
	}
	//add whitespaces where necessary
	this.pagerElAr["pagerBox"].appendChild(document.createElement("SPAN")).innerHTML = "&nbsp;";
	this.pagerElAr["pagerBord"].appendChild(document.createElement("SPAN")).innerHTML = "&nbsp;";
	this.pagerElAr["pagerCont"].appendChild(document.createElement("SPAN")).innerHTML = "&nbsp;";
	this.callEvent("onPaging",[]);			
}


/**
*  @desc: web toolbar skin for paging
*/
dhtmlXGridObject.prototype._pgn_toolbar = function(page, start, end){
	if (!this.aToolBar) this.aToolBar = this._pgn_createToolBar();
		var totalPages=Math.ceil(this.rowsBuffer.length/this.rowsBufferOutSize);

		if (this._WTDef[0]){
			this.aToolBar.enableItem("right");
			this.aToolBar.enableItem("rightabs");
			this.aToolBar.enableItem("left");
			this.aToolBar.enableItem("leftabs");
			if(this.currentPage>=totalPages){
				this.aToolBar.disableItem("right");
				this.aToolBar.disableItem("rightabs");
			}
			if(this.currentPage==1){
				this.aToolBar.disableItem("left");
				this.aToolBar.disableItem("leftabs");
			}
		}
		if (this._WTDef[2]){
			var that = this;
			this.aToolBar.forEachListOption("pages", function(id){
				that.aToolBar.removeListOption("pages", id);
			});
			var w = {dhx_skyblue: 4, dhx_web: 0, dhx_terrace: 14}[this.aToolBar.conf.skin];
			for (var i=0; i<totalPages; i++) {
				this.aToolBar.addListOption("pages", "pages_"+(i+1), NaN, "button", "<span style='padding: 0px "+w+"px 0px 0px;'>"+this.i18n.paging.page+(i+1)+"</span>", "paging_page.gif");
			}
			this.aToolBar.setItemText("pages", this.i18n.paging.page+page);
		}

		if (this._WTDef[1]){
			if (!this.getRowsNum())
				this.aToolBar.setItemText('results',this.i18n.paging.notfound);
			else
				this.aToolBar.setItemText('results',"<div style='width:100%; text-align:center'>"+
				this.i18n.paging.records+(start+1)+
				this.i18n.paging.to+end+
				this.i18n.paging.of+this.rowsBuffer.length+"</div>");
		}
		if (this._WTDef[3])
			this.aToolBar.setItemText("perpagenum", this.rowsBufferOutSize.toString()+" "+this.i18n.paging.perpage);

		this.callEvent("onPaging",[]);
}
dhtmlXGridObject.prototype._pgn_createToolBar = function(){
	this.aToolBar = new dhtmlXToolbarObject({
		parent: this._pgn_parentObj,
		skin: (this._pgn_skin_tlb||this.skin_name),
		icons_path: this.imgURL
	});
	if (!this._WTDef) this.setPagingWTMode(true, true, true, true);
	var self = this;
	this.aToolBar.attachEvent("onClick", function(val){
		val = val.split("_");
		switch (val[0]){
			case "leftabs":
				self.changePage(1);
				break;
			case "left":
				self.changePage(self.currentPage-1);
				break;
			case "rightabs":
				self.changePage(99999);
				break;
			case "right":
				self.changePage(self.currentPage+1);
				break;
			case "perpagenum":
				if (val[1]===this.undefined) return;
				self.rowsBufferOutSize = parseInt(val[1]);
				self.changePage();
				self.aToolBar.setItemText("perpagenum", val[1]+" "+self.i18n.paging.perpage);
				break;
			case "pages":
				if (val[1]===this.undefined) return;
				self.changePage(val[1]);
				self.aToolBar.setItemText("pages", self.i18n.paging.page+val[1]);
				break;
		}
	});
	// add buttons
	if (this._WTDef[0]) {
		this.aToolBar.addButton("leftabs", NaN, null, "ar_left_abs.gif", "ar_left_abs_dis.gif");
		this.aToolBar.addButton("left", NaN, null, "ar_left.gif", "ar_left_dis.gif");
	}
	if (this._WTDef[1]) {
		this.aToolBar.addText("results", NaN, this.i18n.paging.results);
		this.aToolBar.setWidth("results", "150");
		this.aToolBar.disableItem("results");
	}
	if (this._WTDef[0]) {
		this.aToolBar.addButton("right", NaN, null, "ar_right.gif", "ar_right_dis.gif");
		this.aToolBar.addButton("rightabs", NaN, null, "ar_right_abs.gif", "ar_right_abs_dis.gif");
	}
	if (this._WTDef[2]) {
		if (this.aToolBar.conf.skin == "dhx_terrace") this.aToolBar.addSeparator();
		this.aToolBar.addButtonSelect("pages", NaN, "select page", [], "paging_pages.gif", null, false, true);
	}
	var arr;
	if (arr = this._WTDef[3]) {
		if (this.aToolBar.conf.skin == "dhx_terrace") this.aToolBar.addSeparator();
		this.aToolBar.addButtonSelect("perpagenum", NaN, "select size", [], "paging_rows.gif", null, false, true);
		if (typeof arr != "object") arr = [5,10,15,20,25,30];
		var w = {dhx_skyblue: 4, dhx_web: 0, dhx_terrace: 18}[this.aToolBar.conf.skin];
		for (var k=0; k<arr.length; k++) {
			this.aToolBar.addListOption("perpagenum", "perpagenum_"+arr[k], NaN, "button", "<span style='padding: 0px "+w+"px 0px 0px;'>"+arr[k]+" "+this.i18n.paging.perpage+"</span>", "paging_page.gif");
		}
	}
	
	//var td = document.createElement("TD"); td.width = "5"; this.aToolBar.tr.appendChild(td);
	//var td = document.createElement("TD"); td.width = "100%"; this.aToolBar.tr.appendChild(td);
	
	return this.aToolBar;
}

/*
Product Name: dhtmlxSuite 
Version: 4.1.3 
Edition: Professional 
License: content of this file is covered by DHTMLX Commercial or Enterprise license. Usage without proper license is prohibited. To obtain it contact sales@dhtmlx.com
Copyright UAB Dinamenta http://www.dhtmlx.com
*/

	dhtmlXGridObject.prototype.post = function(url, post, call, type){
		this.callEvent("onXLS", [this]);
		if (arguments.length == 2 && typeof call != "function"){
			type=call;
			call=null;
		}
		type=type||"xml";
	
		if (!this.xmlFileUrl)
			this.xmlFileUrl=url;
		this._data_type=type;

		this.xmlLoader = this.doLoadDetails;

		var that = this;
		this.xmlLoader = function(xml){
			if (!that.callEvent) return;
			that["_process_"+type](xml.xmlDoc);
			if (!that._contextCallTimer)
				that.callEvent("onXLE", [that,0,0,xml.xmlDoc]);
	
			if (call){
				call();
				call=null;
			}
		};
		dhx4.ajax.post(url, (post||""), this.xmlLoader);
	}

/*
Product Name: dhtmlxSuite 
Version: 4.1.3 
Edition: Professional 
License: content of this file is covered by DHTMLX Commercial or Enterprise license. Usage without proper license is prohibited. To obtain it contact sales@dhtmlx.com
Copyright UAB Dinamenta http://www.dhtmlx.com
*/

/**
*   @desc: set rowspan with specified length starting from specified cell
*   @param: rowID - row Id
*	@param: colInd - column index
*	@param: length - length of rowspan
*	@edition: professional
*   @type:  public
*/
dhtmlXGridObject.prototype.setRowspan=function(rowID,colInd,length){
    var c=this[this._bfs_cells?"_bfs_cells":"cells"](rowID,colInd).cell;    
   var r=this.rowsAr[rowID];

   if (c.rowSpan && c.rowSpan!=1){
		var ur=r.nextSibling;   
		for (var i=1; i<c.rowSpan; i++){
			var tc=ur.childNodes[ur._childIndexes[c._cellIndex+1]]
			var ti=document.createElement("TD"); 
			ti.innerHTML="&nbsp;"; 
			ti._cellIndex=c._cellIndex;
			ti._clearCell=true;
			if (tc)
				tc.parentNode.insertBefore(ti,tc);
			else
				ur.parentNode.appendChild(ti);
			this._shiftIndexes(ur,c._cellIndex,-1);
	    	ur=ur.nextSibling;
	    }
    }

    c.rowSpan=length;
    if (!this._h2)
		r=r.nextSibling||this.rowsCol[this.rowsCol._dhx_find(r)+1];
	else
		r=this.rowsAr[ this._h2.get[r.idd].parent.childs[this._h2.get[r.idd].index+1].id ];
		
	var kids=[];
	for (var i=1; i<length; i++){
	    var ct=null;
		if (this._fake && !this._realfake)
		    ct=this._bfs_cells3(r,colInd).cell;
		else
		    ct=this.cells3(r,colInd).cell;
		
		

		this._shiftIndexes(r,c._cellIndex,1);
		if (ct)
    	ct.parentNode.removeChild(ct);
    	kids.push(r);
    	
    	if (!this._h2)
			r=r.nextSibling||this.rowsCol[this.rowsCol._dhx_find(r)+1];
		else { 
			var r=this._h2.get[r.idd].parent.childs[this._h2.get[r.idd].index+1];
			if (r) r=this.rowsAr[ r.id ];
		}
    }
    
    this.rowsAr[rowID]._rowSpan=this.rowsAr[rowID]._rowSpan||{};
    this.rowsAr[rowID]._rowSpan[colInd]=kids;
    if (this._fake && !this._realfake && colInd<this._fake._cCount) 
        this._fake.setRowspan(rowID,colInd,length)
}


dhtmlXGridObject.prototype._shiftIndexes=function(r,pos,ind){
		if (!r._childIndexes){
    	r._childIndexes=new Array();
        for (var z=0; z<r.childNodes.length; z++)
            r._childIndexes[z]=z;
		}
		
		for (var z=0; z<r._childIndexes.length; z++)
			if (z>pos)
            	r._childIndexes[z]=r._childIndexes[z]-ind;
				
}

/**
*   @desc: enable rowspan in grid
*   @type:  public
*	@edition: professional
*/
dhtmlXGridObject.prototype.enableRowspan=function(){
    this._erspan=true;
	this.enableRowspan=function(){};
	this.attachEvent("onAfterSorting",function(){
		if (this._dload) return; //can't be helped
		for (var i=1; i<this.obj.rows.length; i++)	
		  if (this.obj.rows[i]._rowSpan){
		  	var master=this.obj.rows[i];
		  	for (var kname in master._rowSpan){
			  	var row=master;
				var kids=row._rowSpan[kname];
			  	for (var j=0; j < kids.length; j++) {
			  		if(row.nextSibling)
			  			row.parentNode.insertBefore(kids[j],row.nextSibling);
			  		else 
			  			row.parentNode.appendChild(kids[j]);
			  		if (this._fake){ // split mode
			  		    var frow=this._fake.rowsAr[row.idd];
			  		    var fkid=this._fake.rowsAr[kids[j].idd];
			  		    if(frow.nextSibling)
			  		  	    frow.parentNode.insertBefore(fkid,frow.nextSibling);
			  		    else 
			  			  frow.parentNode.appendChild(fkid);
			  			 this._correctRowHeight(row.idd);
			  		}
			 		row=row.nextSibling;
			  	}
		    }
	  }
	  var t = this.rowsCol.stablesort;
	  this.rowsCol=new dhtmlxArray();
	  this.rowsCol.stablesort=t;
	  
	  for (var i=1; i<this.obj.rows.length; i++)	
	  	this.rowsCol.push(this.obj.rows[i]);
	  
	}) 
	
	this.attachEvent("onXLE",function(a,b,c,xml){
		for (var i=0; i<this.rowsBuffer.length; i++){
			var row = this.render_row(i);
			var childs = row.childNodes;
			for (var j=0; j<childs.length; j++){
				if (childs[j]._attrs["rowspan"]){
					this.setRowspan(row.idd, childs[j]._cellIndex, childs[j]._attrs["rowspan"]);
				}
			}
		}
	});
}


/*
Product Name: dhtmlxSuite 
Version: 4.1.3 
Edition: Professional 
License: content of this file is covered by DHTMLX Commercial or Enterprise license. Usage without proper license is prohibited. To obtain it contact sales@dhtmlx.com
Copyright UAB Dinamenta http://www.dhtmlx.com
*/

/*
    Limitation:
        a) Width of column in px
        b) Grid not autoresizable
        c) Initialize grid in visible state
*/

dhx4.attachEvent("onGridCreated", function(grid){
    if (grid._split_later)
        grid.splitAt(grid._split_later);
});


/**
*   @desc:  split grid in two parts, with separate scrolling
*   @param:  ind - index of column to split after
*   @edition: Professional
*   @type:  public$
*/
dhtmlXGridObject.prototype.splitAt=function(ind){
    if (!this.obj.rows[0]) return this._split_later=ind;
    ind=parseInt(ind);
    
    var leftBox=document.createElement("DIV");
    this.entBox.appendChild(leftBox);
    var rightBox=document.createElement("DIV");
    this.entBox.appendChild(rightBox);
    
    for (var i=this.entBox.childNodes.length-3; i>=0; i--)
    	rightBox.insertBefore(this.entBox.childNodes[i],rightBox.firstChild);
    
    this.entBox.style.position="relative";	
    this.globalBox=this.entBox;
    this.entBox=rightBox; rightBox.grid=this;
    

    leftBox.style.cssText+="border:0px solid red !important;";
    rightBox.style.cssText+="border:0px solid red !important;";
    
	rightBox.style.top="0px";
    rightBox.style.position="absolute";
        
    leftBox.style.position="absolute";
    leftBox.style.top="0px";
    leftBox.style.left="0px";
    leftBox.style.zIndex=11;
        
    rightBox.style.height=leftBox.style.height=this.globalBox.clientHeight;
    
    
    this._fake=new dhtmlXGridObject(leftBox);
    
    this.globalBox=this._fake.globalBox=this.globalBox;
    this._fake._fake=this;
    this._fake._realfake=true;
    
	//copy properties    
    this._treeC=this.cellType._dhx_find("tree");
    this._fake.delim=this.delim;
    this._fake.customGroupFormat=this.customGroupFormat;
    
    this._fake.setImagesPath(this._imgURL);
    this._fake.iconURL = this.iconURL;
    this._fake._customSorts=this._customSorts;
	this._fake.noHeader=this.noHeader;
	this._fake._enbTts=this._enbTts;
	this._fake._drsclmW = this._drsclmW;
	this._fake._htkebl = this._htkebl;
	this._fake.clists = this.clists;
    this._fake.fldSort=new Array();
    this._fake.selMultiRows=this.selMultiRows;
    this._fake.multiLine=this.multiLine;
    this._fake.smartTabOrder = this.smartTabOrder;
    
    if (this.multiLine || this._erspan){
    	this.attachEvent("onCellChanged",this._correctRowHeight);
    	this.attachEvent("onRowAdded",this._correctRowHeight);
    	var corrector=function(){
    		this.forEachRow(function(id){
    			this._correctRowHeight(id);
			})
		};
		this.attachEvent("onPageChanged",corrector);
    	this.attachEvent("onXLE",corrector);
    	this.attachEvent("onResizeEnd",corrector);
    	if (!this._ads_count) //in case of distribute parsing - use special event instead
    		this.attachEvent("onAfterSorting",corrector);
        if (this._srnd)
            this.attachEvent("onFilterEnd", corrector);
    	this.attachEvent("onDistributedEnd",corrector);
		
    	//this._fake.attachEvent("onCellChanged",this._correctRowHeight);
    	}
    this.attachEvent("onGridReconstructed",function(){
    	this._fake.objBox.scrollTop = this.objBox.scrollTop;
	})
    
	this._fake.loadedKidsHash=this.loadedKidsHash;
	if (this._h2) this._fake._h2=this._h2;
	this._fake._dInc=this._dInc;
	
	//collect grid configuraton
    var b_ha=[[],[],[],[],[],[],[]];
    var b_ar=["hdrLabels","initCellWidth","cellType","cellAlign","cellVAlign","fldSort","columnColor"];
    var b_fu=["setHeader","setInitWidths","setColTypes","setColAlign","setColVAlign","setColSorting","setColumnColor"];

    this._fake.callEvent=function(){
    	var result = true;
    	this._fake._split_event=true;
    	var hidden = (arguments[0] == "onScroll");
    	if (arguments[0]=="onGridReconstructed" || hidden)
    		this._fake.callEvent.apply(this,arguments);
    	
    	if (!hidden) result = this._fake.callEvent.apply(this._fake,arguments);
    	this._fake._split_event=false;	
    	return result;
    }
    	
    if (this._elmn)
		this._fake.enableLightMouseNavigation(true);

    if (this.__cssEven||this._cssUnEven)
        this._fake.attachEvent("onGridReconstructed",function(){
            this._fixAlterCss();
        });

	this._fake._cssEven=this._cssEven;
	this._fake._cssUnEven=this._cssUnEven;
	this._fake._cssSP=this._cssSP;
	this._fake.isEditable=this.isEditable;
	this._fake._edtc=this._edtc;
	if (this._sst) this._fake.enableStableSorting(true);

	this._fake._sclE=this._sclE;
	this._fake._dclE=this._dclE;
	this._fake._f2kE=this._f2kE;
	this._fake._maskArr=this._maskArr;
	this._fake._dtmask=this._dtmask;
	this._fake.combos=this.combos;

    var width=0;

	var m_w=this.globalBox.offsetWidth;
    for (var i=0; i<ind; i++){
        for (var j=0; j<b_ar.length; j++){
            if (this[b_ar[j]])
                b_ha[j][i]=this[b_ar[j]][i];
            if (typeof b_ha[j][i] == "string") b_ha[j][i]=b_ha[j][i].replace(new RegExp("\\"+this.delim,"g"),"\\"+this.delim);
        }
        if (_isFF) b_ha[1][i]=b_ha[1][i]*1;
		if ( this.cellWidthType == "%"){
			b_ha[1][i]=Math.round(parseInt(this[b_ar[1]][i])*m_w/100);
			width+=b_ha[1][i];
		} else
	        width+=parseInt(this[b_ar[1]][i]);
        	this.setColumnHidden(i,true);
        }


    for (var j=0; j<b_ar.length; j++){
        var str=b_ha[j].join(this.delim);
       
	if (b_fu[j]!="setHeader"){
		if (str!="")
    		this._fake[b_fu[j]](str);
	} else
	    this._fake[b_fu[j]](str,null,this._hstyles);
    }


	this._fake._strangeParams=this._strangeParams;
    this._fake._drsclmn=this._drsclmn;

	width = Math.min(this.globalBox.offsetWidth, width);
    rightBox.style.left=width+"px";    leftBox.style.width=width+"px";
    rightBox.style.width=Math.max(this.globalBox.offsetWidth-width,0);

    if (this._ecspn) this._fake._ecspn=true;

//    this._fake.setNoHeader(true);
    this._fake.init();
    if (this.dragAndDropOff)
		this.dragger.addDragLanding(this._fake.entBox, this);
		
    this._fake.objBox.style.overflow="hidden";
    if (!dhtmlx.$customScroll)
    	this._fake.objBox.style.overflowX="scroll";
	else    
		this._fake.objBox._custom_scroll_mode = "";

   	this._fake._srdh=this._srdh||20;
   	this._fake._srnd=this._srnd;


   	var selfmaster = this;
	function _on_wheel(e){
		var dir  = e.wheelDelta/-40;
		if (e.wheelDelta === window.undefined)
			dir = e.detail;
		var cont = selfmaster.objBox;
		cont.scrollTop += dir*40;
		if (e.preventDefault)
			e.preventDefault();
	}
	dhtmlxEvent(this._fake.objBox,"mousewheel",_on_wheel);
	dhtmlxEvent(this._fake.objBox,"DOMMouseScroll",_on_wheel);


//inner methods

	
		function change_td(a,b){ 
			b.style.whiteSpace="";
			var c=b.nextSibling;
			var cp=b.parentNode;
			a.parentNode.insertBefore(b,a);
			if (!c)
				cp.appendChild(a);
			else
				cp.insertBefore(a,c);
			var z=a.style.display;
			a.style.display=b.style.display;
			b.style.display=z;
				}
		function proc_hf(i,rows,mode,frows){
			var temp_header=(new Array(ind)).join(this.delim);
			var temp_rspan=[];
			if (i==2)
				for (var k=0; k<ind; k++){
					var r=rows[i-1].cells[rows[i-1]._childIndexes?rows[i-1]._childIndexes[k]:k];
					if (r.rowSpan && r.rowSpan>1){
						temp_rspan[r._cellIndex]=r.rowSpan-1;
						frows[i-1].cells[frows[i-1]._childIndexes?frows[i-1]._childIndexes[k]:k].rowSpan=r.rowSpan;
						r.rowSpan=1;
					}
				}
				
				for (i; i<rows.length; i++){
					this._fake.attachHeader(temp_header,null,mode);
					frows=frows||this._fake.ftr.childNodes[0].rows;
					var max_ind=ind;
					var r_cor=0;
					for (var j=0; j<max_ind; j++){
						
						if (temp_rspan[j]) { 
							temp_rspan[j]=temp_rspan[j]-1;
							if (_isIE || _isOpera) {
								var td=document.createElement("TD");
								if (_isFF) td.style.display="none";
								rows[i].insertBefore(td,rows[i].cells[0])
							}
							
							r_cor++;
							continue;
						}

						var a=frows[i].cells[j-r_cor];
						var b=rows[i].cells[j-(_isIE?0:r_cor)];
						var t=b.rowSpan;
						j += (b.colSpan - 1) || 0;
						
						change_td(a,b);
						if (t>1){ 
							temp_rspan[j]=t-1;
							b.rowSpan=t;
						}
						if (frows[i].cells[j].colSpan>1){
							rows[i].cells[j].colSpan=frows[i].cells[j].colSpan;
							max_ind-=frows[i].cells[j].colSpan-1;
							for (var k=1; k < frows[i].cells[j].colSpan; k++) 
								frows[i].removeChild(frows[i].cells[j+1]);
				}
		}
	}
		}
		
		if (this.hdr.rows.length>2)
			proc_hf.call(this,2,this.hdr.rows,"_aHead",this._fake.hdr.rows);
		if (this.ftr){
			proc_hf.call(this,1,this.ftr.childNodes[0].rows,"_aFoot");
			this._fake.ftr.parentNode.style.bottom=(_isFF?2:1)+"px";
		}
		

        if (this.saveSizeToCookie){
		   this.saveSizeToCookie=function(name,cookie_param){
		   		if (this._realfake)
					return this._fake.saveSizeToCookie.apply(this._fake,arguments);

				if (!name) name=this.entBox.id;
				var z=new Array();
				var n="cellWidthPX";
		
				for (var i=0; i<this[n].length; i++)
					if (i<ind)
						z[i]=this._fake[n][i];
					else
						z[i]=this[n][i];
				z=z.join(",")
				this.setCookie(name,cookie_param,0,z);
				var z=(this.initCellWidth||(new  Array)).join(",");
				this.setCookie(name,cookie_param,1,z);

			    return true;
			}
		this.loadSizeFromCookie=function(name){
			if (!name) name=this.entBox.id;
			var z=this._getCookie(name,1);

			if (!z) return
			this.initCellWidth=z.split(",");
			var z=this._getCookie(name,0);
			var n="cellWidthPX";
			this.cellWidthType="px";
			
            var summ2=0;
			if ((z)&&(z.length)){
				z=z.split(",");
				for (var i=0; i<z.length; i++)
					if (i<ind){
					   this._fake[n][i]=z[i];
					   summ2+=z[i]*1;
					   }
					else
					   this[n][i]=z[i];
			}

    		this._fake.entBox.style.width=summ2+"px";
    		this._fake.objBox.style.width=summ2+"px";
   			var pa=this.globalBox.childNodes[1];
			    pa.style.left=summ2-(_isFF?0:0)+"px";
			if (this.ftr)
	    		this.ftr.style.left=summ2-(_isFF?0:0)+"px";
    			pa.style.width=this.globalBox.offsetWidth-summ2+"px";

			this.setSizes();
		    return true;
		}
		   	this._fake.onRSE=this.onRSE;
		}


			this.setCellTextStyleA=this.setCellTextStyle;
			this.setCellTextStyle=function(row_id,i,styleString){
				if  (i<ind) this._fake.setCellTextStyle(row_id,i,styleString);
				this.setCellTextStyleA(row_id,i,styleString);
			}
			this.setRowTextBoldA=this.setRowTextBold;
   			this.setRowTextBold = function(row_id){
				this.setRowTextBoldA(row_id);
				this._fake.setRowTextBold(row_id);
            }
            
            this.setRowColorA=this.setRowColor;
   			this.setRowColor = function(row_id,color){
				this.setRowColorA(row_id,color);
				this._fake.setRowColor(row_id,color);
            } 
                       
			this.setRowHiddenA=this.setRowHidden;
   			this.setRowHidden = function(id,state){
				this.setRowHiddenA(id,state);
				this._fake.setRowHidden(id,state);
            }

			this.setRowTextNormalA=this.setRowTextNormal;
   			this.setRowTextNormal = function(row_id){
				this.setRowTextNormalA(row_id);
				this._fake.setRowTextNormal(row_id);
            }


			this.getChangedRows = function(and_added){
				var res = new Array();
				function test(row){
						for (var j = 0; j < row.childNodes.length; j++) 
							if (row.childNodes[j].wasChanged)
								return res[res.length]=row.idd;
				}
				this.forEachRow(function(id){
					var row = this.rowsAr[id];
					var frow = this._fake.rowsAr[id];
					if (row.tagName!="TR" || !frow || frow.tagName!="TR") return;
					if (and_added && row._added)
						res[res.length]=row.idd;
					else{
						if (!test(row)) test(frow);
					}
				});
				return res.join(this.delim);
			};
			this.setRowTextStyleA=this.setRowTextStyle;
   			this.setRowTextStyle = function(row_id,styleString){
				this.setRowTextStyleA(row_id,styleString);
				if (this._fake.rowsAr[row_id])
				this._fake.setRowTextStyle(row_id,styleString);
            }

			this.lockRowA = this.lockRow;
			this.lockRow = function(id,mode){ this.lockRowA(id,mode); this._fake.lockRow(id,mode); }
			
			this.getColWidth = function(i){
				if  (i<ind) return parseInt(this._fake.cellWidthPX[i]);
				else return parseInt(this.cellWidthPX[i]);
            };
            this.getColumnLabel = function(i){
            	return this._fake.getColumnLabel.apply(((i<ind)?this._fake:this) ,arguments);
            };
			this.setColWidthA=this._fake.setColWidthA=this.setColWidth;
			this.setColWidth = function(i,value){
				i=i*1;
				if  (i<ind) this._fake.setColWidthA(i,value);
				else this.setColWidthA(i,value);
				if ((i+1)<=ind) this._fake._correctSplit(Math.min(this._fake.objBox.offsetWidth,this._fake.obj.offsetWidth));
            }
			this.adjustColumnSizeA=this.adjustColumnSize;
			this.setColumnLabelA=this.setColumnLabel;
			this.setColumnLabel=function(a,b,c,d){
				var that  = this;
				if (a<ind) that = this._fake;
				return this.setColumnLabelA.apply(that,[a,b,c,d]);
			}
			this.adjustColumnSize=function(aind,c){
				if  (aind<ind) {
					if (_isIE) this._fake.obj.style.tableLayout="";
					this._fake.adjustColumnSize(aind,c);
					if (_isIE) this._fake.obj.style.tableLayout="fixed";
				    this._fake._correctSplit();
					}
				else return this.adjustColumnSizeA(aind,c);
			}

            var zname="cells";
            this._bfs_cells=this[zname];
            this[zname]=function(){
                    if (arguments[1]<ind){
                        return this._fake.cells.apply(this._fake,arguments);
                    } else
                        return this._bfs_cells.apply(this,arguments);
                    }
            
            this._bfs_isColumnHidden=this.isColumnHidden;        
            this.isColumnHidden=function(){
				if (parseInt(arguments[0])<ind)
					return this._fake.isColumnHidden.apply(this._fake,arguments);
				else
					return this._bfs_isColumnHidden.apply(this,arguments);
            }                    


            this._bfs_setColumnHidden=this.setColumnHidden;        
            this.setColumnHidden=function(){
                    if (parseInt(arguments[0])<ind){
                        this._fake.setColumnHidden.apply(this._fake,arguments);
                        return this._fake._correctSplit();
            		}
                    else
                        return this._bfs_setColumnHidden.apply(this,arguments);
                    }                    

            var zname="cells2";
            this._bfs_cells2=this[zname];
            this[zname]=function(){
                    if (arguments[1]<ind)
                        return this._fake.cells2.apply(this._fake,arguments);
                    else
                        return this._bfs_cells2.apply(this,arguments);
                    }

            var zname="cells3";
            this._bfs_cells3=this[zname];
            this[zname]=function(a,b){
                    if (arguments[1]<ind && this._fake.rowsAr[arguments[0].idd]){
                        //fall back for totally rowspanned row
                        if (this._fake.rowsAr[a.idd] && this._fake.rowsAr[a.idd].childNodes.length==0)  return this._bfs_cells3.apply(this,arguments);
                        arguments[0]=arguments[0].idd;
                        return this._fake.cells.apply(this._fake,arguments);
                        }
                    else
                        return this._bfs_cells3.apply(this,arguments);
                    }

            var zname="changeRowId";
            this._bfs_changeRowId=this[zname];
            this[zname]=function(){
                this._bfs_changeRowId.apply(this,arguments);
                if (this._fake.rowsAr[arguments[0]])
                	this._fake.changeRowId.apply(this._fake,arguments);
            }
            this._fake.getRowById=function(id){
            	var row = this.rowsAr[id];
            	if (!row && this._fake.rowsAr[id]) row=this._fake.getRowById(id);
				
			
				if (row){
					if (row.tagName != "TR"){
						for (var i = 0; i < this.rowsBuffer.length; i++)
							if (this.rowsBuffer[i] && this.rowsBuffer[i].idd == id)
								return this.render_row(i);
						if (this._h2) return this.render_row(null,row.idd);
					}
					return row;
				}
				return null;
			}

            if (this.collapseKids){
				//tree grid
	            this._fake["_bfs_collapseKids"]=this.collapseKids;
				this._fake["collapseKids"]=function(){
					return this._fake["collapseKids"].apply(this._fake,[this._fake.rowsAr[arguments[0].idd]]);
				}
				
	            this["_bfs_collapseKids"]=this.collapseKids;
				this["collapseKids"]=function(){
					var z=this["_bfs_collapseKids"].apply(this,arguments);
					this._fake._h2syncModel();
					if (!this._cssSP) this._fake._fixAlterCss();
				}				
				
				
	            this._fake["_bfs_expandKids"]=this.expandKids;
				this._fake["expandKids"]=function(){
					this._fake["expandKids"].apply(this._fake,[this._fake.rowsAr[arguments[0].idd]]);
					if (!this._cssSP) this._fake._fixAlterCss();
				}
				

				this["_bfs_expandAll"]=this.expandAll;
				this["expandAll"]=function(){
					this._bfs_expandAll();
					this._fake._h2syncModel();
					if (!this._cssSP) this._fake._fixAlterCss();
				}

				this["_bfs_collapseAll"]=this.collapseAll;
				this["collapseAll"]=function(){
					this._bfs_collapseAll();
					this._fake._h2syncModel();
					if (!this._cssSP) this._fake._fixAlterCss();
				}								
				
	            this["_bfs_expandKids"]=this.expandKids;
				this["expandKids"]=function(){
					var z=this["_bfs_expandKids"].apply(this,arguments);
					this._fake._h2syncModel();
					if (!this._cssSP) this._fake._fixAlterCss();
				}				
				
				this._fake._h2syncModel=function(){
					if (this._fake.pagingOn) this._fake._renderSort();
					else this._renderSort();
				}
				this._updateTGRState=function(a){
					return this._fake._updateTGRState(a);
				}
			}



				//split


      if (this._elmnh){
			this._setRowHoverA=this._fake._setRowHoverA=this._setRowHover;
			this._unsetRowHoverA=this._fake._unsetRowHoverA=this._unsetRowHover;
			this._setRowHover=this._fake._setRowHover=function(){
				var that=this.grid;
				that._setRowHoverA.apply(this,arguments);
				var z=(_isIE?event.srcElement:arguments[0].target);
				z=that._fake.rowsAr[that.getFirstParentOfType(z,'TD').parentNode.idd];
				if (z){
					that._fake._setRowHoverA.apply(that._fake.obj,[{target:z.childNodes[0]},arguments[1]]);
				   	}
			};
			this._unsetRowHover=this._fake._unsetRowHover=function(){
				if (arguments[1]) var that=this;
				else	var that=this.grid;
				that._unsetRowHoverA.apply(this,arguments);
				that._fake._unsetRowHoverA.apply(that._fake.obj,arguments);
			};
		  		this._fake.enableRowsHover(true,this._hvrCss);
		  		this.enableRowsHover(false);
		  		this.enableRowsHover(true,this._fake._hvrCss);
			}

			this._updateTGRState=function(z){ 
				if (!z.update || z.id==0) return;
				if (this.rowsAr[z.id].imgTag)
					this.rowsAr[z.id].imgTag.src=this.iconTree+z.state+".gif";
				if (this._fake.rowsAr[z.id] && this._fake.rowsAr[z.id].imgTag)
					this._fake.rowsAr[z.id].imgTag.src=this.iconTree+z.state+".gif";
				z.update=false;
			}
			this.copy_row=function(row){
				    var x=row.cloneNode(true);
                    x._skipInsert=row._skipInsert;
                    var r_ind=ind;
                    x._attrs={};
                    x._css = row._css;
                    
                    if (this._ecspn){
                    	r_ind=0;
                    	for (var i=0; (r_ind<x.childNodes.length && i<ind); i+=(x.childNodes[r_ind].colSpan||1))
                    		r_ind++;
                    }
                                
                    while (x.childNodes.length>r_ind)
                        x.removeChild(x.childNodes[x.childNodes.length-1]);
                        var zm=r_ind;
                    for (var i=0; i<zm; i++){
                    	
						if (this.dragAndDropOff)
							this.dragger.addDraggableItem(x.childNodes[i], this);                        
                        x.childNodes[i].style.display=(this._fake._hrrar?(this._fake._hrrar[i]?"none":""):"");
                        x.childNodes[i]._cellIndex=i;
                        //TODO - more universal solution
                        x.childNodes[i].combo_value=arguments[0].childNodes[i].combo_value;
                        x.childNodes[i]._clearCell=arguments[0].childNodes[i]._clearCell;
                        x.childNodes[i]._cellType=arguments[0].childNodes[i]._cellType;
						x.childNodes[i]._brval=arguments[0].childNodes[i]._brval;
						x.childNodes[i].val =arguments[0].childNodes[i].val;
						x.childNodes[i]._combo =arguments[0].childNodes[i]._combo;
						x.childNodes[i]._attrs=arguments[0].childNodes[i]._attrs;
						x.childNodes[i].chstate=arguments[0].childNodes[i].chstate;
						if (row._attrs['style']) x.childNodes[i].style.cssText+=";"+row._attrs['style'];
						

                        if(x.childNodes[i].colSpan>1) 
                            this._childIndexes=this._fake._childIndexes;
                            }
                    
                    if (this._h2 && this._treeC < ind){
						var trow=this._h2.get[arguments[0].idd];
                		x.imgTag=x.childNodes[this._treeC].childNodes[0].childNodes[trow.level];
						x.valTag=x.childNodes[this._treeC].childNodes[0].childNodes[trow.level+2];
                        }

					
                        x.idd=row.idd;
                        x.grid=this._fake;
                        
                	return x;
                        	}
                    	
            var zname="_insertRowAt";
            this._bfs_insertRowAt=this[zname];
            this[zname]=function(){ 
                        var r=this["_bfs_insertRowAt"].apply(this,arguments);
                        arguments[0]=this.copy_row(arguments[0]);

                        var r2=this._fake["_insertRowAt"].apply(this._fake,arguments);
                        if (r._fhd){
							r2.parentNode.removeChild(r2);
                            this._fake.rowsCol._dhx_removeAt(this._fake.rowsCol._dhx_find(r2));
							r._fhd=false;
						}

						return r;
            }
            /*
var quirks = (_isIE && document.compatMode=="BackCompat");
		
		var isVScroll = this.parentGrid?false:(this.objBox.scrollHeight > this.objBox.offsetHeight);
		var isHScroll = this.parentGrid?false:(this.objBox.scrollWidth > this.objBox.offsetWidth); 
		var scrfix = _isFF?20:18;
		
		var outerBorder=(this.entBox.offsetWidth-this.entBox.clientWidth)/2;
				
		var gridWidth=this.entBox.clientWidth;
		var gridHeight=this.entBox.clientHeight;
		*/
            this._bfs_setSizes=this.setSizes;
            this.setSizes=function(){
            		if (this._notresize) return;
                	this._bfs_setSizes(this,arguments);
                	
					this.sync_headers()
					if (this.sync_scroll() && this._ahgr) this.setSizes(); //if scrolls was removed - check once more to correct auto-height
					
					var height = this.dontSetSizes ? (this.entBox.offsetHeight+"px") : this.entBox.style.height;
					this._fake.entBox.style.height = height;

                    this._fake.objBox.style.height=this.objBox.style.height;
                    this._fake.hdrBox.style.height=this.hdrBox.style.height;
                    
                    this._fake.objBox.scrollTop=this.objBox.scrollTop;
                    
                    this._fake.setColumnSizes(this._fake.entBox.clientWidth);
                    
                    this.globalBox.style.width=parseInt(this.entBox.style.width)+parseInt(this._fake.entBox.style.width);
                    if (!this.dontSetSizes)
                    	this.globalBox.style.height = height;
                    
            }
            
            this.sync_scroll=this._fake.sync_scroll=function(end){
            		var old=this.objBox.style.overflowX;
            	    if (this.obj.offsetWidth<=this.objBox.offsetWidth)
                    {
                    	if (!end) return this._fake.sync_scroll(true);
                        this.objBox.style.overflowX="hidden";
                        this._fake.objBox.style.overflowX="hidden";
                    }
                    else if (!dhtmlx.$customScroll){
                        this.objBox.style.overflowX="scroll";
                        this._fake.objBox.style.overflowX="scroll";
                    }
                    return old!=this.objBox.style.overflowX;
        	}
            this.sync_headers=this._fake.sync_headers=function(){
            	if (this.noHeader || (this._fake.hdr.scrollHeight==this.hdr.offsetHeight)) return;
            //	if (this.hdr.rows.length!=2){
            		for (var i=1; i<this.hdr.rows.length; i++){
            			var td = ind;
            			while (!this.hdr.rows[i].childNodes[td]) td--;
            			var ha=Math.min(this.hdr.rows[i].childNodes[td].scrollHeight+2, this.hdr.rows[i].scrollHeight);
						var hb=this._fake.hdr.rows[i].scrollHeight;
						if (ha!=hb)
							this._fake.hdr.rows[i].style.height=this.hdr.rows[i].style.height=Math.max(ha,hb)+"px";
						if (window._KHTMLrv) 
							this._fake.hdr.rows[i].childNodes[0].style.height=this.hdr.rows[i].childNodes[td].style.height=Math.max(ha,hb)+"px";
					}
					this._fake.sync_headers;
			//	} else this._fake.hdr.style.height=this.hdr.offsetHeight+"px";
        	}
        	this._fake._bfs_setSizes=this._fake.setSizes;
            this._fake.setSizes=function(){
            		if (this._fake._notresize) return;
            		this._fake.setSizes();
            }

            var zname="_doOnScroll";
            this._bfs__doOnScroll=this[zname];
            this[zname]=function(){
                    this._bfs__doOnScroll.apply(this,arguments);
                    this._fake.objBox.scrollTop=this.objBox.scrollTop = this.objBox.scrollTop+0.1;
                    this._fake["_doOnScroll"].apply(this._fake,arguments);
            }
            
            var zname="selectAll";
            this._bfs__selectAll=this[zname];
            this[zname]=function(){
                    this._bfs__selectAll.apply(this,arguments);
                    this._bfs__selectAll.apply(this._fake,arguments);
            }
            
            



            var zname="doClick";
            this._bfs_doClick=this[zname];
            this[zname]=function(){
                    this["_bfs_doClick"].apply(this,arguments);
                        if (arguments[0].tagName=="TD"){
                            var fl=(arguments[0]._cellIndex>=ind);
							if (!arguments[0].parentNode.idd) return;
							if (!fl)
                            	arguments[0].className=arguments[0].className.replace(/cellselected/g,"");
                            //item selected but it left part not rendered yet
							if (!this._fake.rowsAr[arguments[0].parentNode.idd])
								this._fake.render_row(this.getRowIndex(arguments[0].parentNode.idd));
                            arguments[0]=this._fake.cells(arguments[0].parentNode.idd,(fl?0:arguments[0]._cellIndex)).cell;
                            if (fl) this._fake.cell=null;
                            this._fake["_bfs_doClick"].apply(this._fake,arguments);
                            if (fl) this._fake.cell=this.cell;
                            else this.cell=this._fake.cell;
                            if (this._fake.onRowSelectTime) clearTimeout(this._fake.onRowSelectTime)
                            if (fl) {
                                arguments[0].className=arguments[0].className.replace(/cellselected/g,"");
                                globalActiveDHTMLGridObject=this;
                                this._fake.cell=this.cell;                                
                                }
                            else{
                                this.objBox.scrollTop=this._fake.objBox.scrollTop;
	                            }
                        }
            }
            this._fake._bfs_doClick=this._fake[zname];
            this._fake[zname]=function(){
                    this["_bfs_doClick"].apply(this,arguments);
                        if (arguments[0].tagName=="TD"){
                            var fl=(arguments[0]._cellIndex<ind);
							if (!arguments[0].parentNode.idd) return;
                            arguments[0]=this._fake._bfs_cells(arguments[0].parentNode.idd,(fl?ind:arguments[0]._cellIndex)).cell;
                            this._fake.cell=null;
this._fake["_bfs_doClick"].apply(this._fake,arguments);
							this._fake.cell=this.cell;
                            if (this._fake.onRowSelectTime) clearTimeout(this._fake.onRowSelectTime)
                            if (fl) {
                                arguments[0].className=arguments[0].className.replace(/cellselected/g,"");
                                globalActiveDHTMLGridObject=this;
								this._fake.cell=this.cell;                                
								this._fake.objBox.scrollTop=this.objBox.scrollTop;
                                }
                        }
            }


this.clearSelectionA = this.clearSelection;
this.clearSelection = function(mode){
    if (mode) this._fake.clearSelection();
    this.clearSelectionA();
}


this.moveRowUpA = this.moveRowUp;
this.moveRowUp = function(row_id){
	if (!this._h2)
    	this._fake.moveRowUp(row_id);
    this.moveRowUpA(row_id);
    if (this._h2) this._fake._h2syncModel();
}
this.moveRowDownA = this.moveRowDown;
this.moveRowDown = function(row_id){
	if (!this._h2)
    	this._fake.moveRowDown(row_id);
    this.moveRowDownA(row_id);
    if (this._h2) this._fake._h2syncModel();
}



this._fake.getUserData=function(){	return this._fake.getUserData.apply(this._fake,arguments); }
this._fake.setUserData=function(){	return this._fake.setUserData.apply(this._fake,arguments); }

this.getSortingStateA=this.getSortingState;
this.getSortingState = function(){
	var z=this.getSortingStateA();
	if (z.length!=0) return z;
	return this._fake.getSortingState();
}

this.setSortImgStateA=this._fake.setSortImgStateA=this.setSortImgState;
this.setSortImgState = function(a,b,c,d){
	this.setSortImgStateA(a,b,c,d);
	if (b*1<ind) {
		this._fake.setSortImgStateA(a,b,c,d);
		this.setSortImgStateA(false);
	} else 
		this._fake.setSortImgStateA(false);
}


this._fake.doColResizeA = this._fake.doColResize;
this._fake.doColResize = function(ev,el,startW,x,tabW){ 
    var a=-1;
    var z=0;
    if (arguments[1]._cellIndex==(ind-1)){
            a = this._initalSplR + (ev.clientX-x);
            if (!this._initalSplF) this._initalSplF=arguments[3]+this.objBox.scrollWidth-this.objBox.offsetWidth;
            if (this.objBox.scrollWidth==this.objBox.offsetWidth && (this._fake.alter_split_resize || (ev.clientX-x)>0 )){
            	arguments[3]=(this._initalSplF||arguments[3]);
            	z=this.doColResizeA.apply(this,arguments);
            } 
            else
            	z=this.doColResizeA.apply(this,arguments);
    }
    else{
        if (this.obj.offsetWidth<this.entBox.offsetWidth)
    		a=this.obj.offsetWidth;
    	z=this.doColResizeA.apply(this,arguments);
	}
	
	if (z !== false){
		this._correctSplit(a);
		this.resized=this._fake.resized=1;
	}
    return z;
}

		this._fake.changeCursorState = function(ev){
                     var el = ev.target||ev.srcElement;
                     if(el.tagName!="TD")
                           el = this.getFirstParentOfType(el,"TD")
                           if ((el.tagName=="TD")&&(this._drsclmn)&&(!this._drsclmn[el._cellIndex])) return;
                           var check = (ev.layerX||0)+(((!_isIE)&&(ev.target.tagName=="DIV"))?el.offsetLeft:0);
                           var pos = parseInt(this.getPosition(el,this.hdrBox)); 
                           
                           if(((el.offsetWidth - (ev.offsetX||(pos-check)*-1))<(_isOpera?20:10))||((this.entBox.offsetWidth - (ev.offsetX?(ev.offsetX+el.offsetLeft):check) + this.objBox.scrollLeft - 0)<(_isOpera?20:10))){
                              el.style.cursor = "E-resize";
                           }else
                              el.style.cursor = "default";
                       if (_isOpera) this.hdrBox.scrollLeft = this.objBox.scrollLeft;
                        }
			
		this._fake.startColResizeA = this._fake.startColResize;
		this._fake.startColResize = function(ev){
                                    var z=this.startColResizeA(ev);
                                    this._initalSplR=this.entBox.offsetWidth;
                                    this._initalSplF=null;
                                    if (this.entBox.onmousemove){
                                        var m=this.entBox.parentNode;   
                                        if (m._aggrid) return z;
										m._aggrid=m.grid;   m.grid=this;
                                        this.entBox.parentNode.onmousemove=this.entBox.onmousemove;
                                        this.entBox.onmousemove=null;
                                        }
                                    return z;
								}

		this._fake.stopColResizeA = this._fake.stopColResize;
		this._fake.stopColResize = function(ev){
                                    if (this.entBox.parentNode.onmousemove){
                                        var m=this.entBox.parentNode;   m.grid=m._aggrid;   m._aggrid=null;
                                        this.entBox.onmousemove=this.entBox.parentNode.onmousemove;
                                        this.entBox.parentNode.onmousemove=null;
                                        if (this.obj.offsetWidth<this.entBox.offsetWidth)
                                        	this._correctSplit(this.obj.offsetWidth);
                                        }
                                    return this.stopColResizeA(ev);
								}



this.doKeyA = this.doKey;
this._fake.doKeyA = this._fake.doKey;

function inner_runner(index, rindex, master, ev){
	var dir = ev.shiftKey ? -1 : 1;
	var end = ev.shiftKey ? -1 : master._cCount;
	var next = false;

	for (var i=index+dir; i!=end; i+=dir){
		if (master.smartTabOrder){
			next = master.cells2(rindex, i).isDisabled() ? false : i;
		} else 
			next = i;

		if (next !== false){
			master.selectCell( rindex, next, false, false, true, true);
			ev.cancelBubble = true;
			if (ev.preventDefault) ev.preventDefault();
			return true;
		}
	}
}

this._fake.doKey=this.doKey=function(ev){
                            if (!ev) return true;
                            if (this._htkebl) return true;
		if ((ev.target||ev.srcElement).value !== window.undefined){
			var zx = (ev.target||ev.srcElement);

			if ((!zx.parentNode)||(zx.parentNode.className.indexOf("editable") == -1))
				return true;
		}
		                            
    switch (ev.keyCode){
        case 9:
        	var master = this._realfake ? this._fake : this;
        	if (!master.callEvent("onTab",[true])) return true;

                    if (this.cell){
        		var index = this.cell._cellIndex;
							
				var rindex = master.getRowIndex(this.cell.parentNode.idd);
				while (!inner_runner(index, rindex, master, ev)){
					rindex += (ev.shiftKey ? -1 : 1);
					if (rindex < 0 || rindex >= master.rowsBuffer.length) return;
					index = ev.shiftKey ? master._cCount : -1;					
                }
				return;
            }
       break;
    }
    return  this.doKeyA(ev);
}


this.editCellA=this.editCell;
this.editCell=function(){
	if (this.cell && this.cell.parentNode.grid != this) return this._fake.editCell();
	return this.editCellA();
}

this.deleteRowA = this.deleteRow;
this.deleteRow=function(row_id,node){
/*	if (!this._realfake)
		this._fake.loadedKidsHash=this.loadedKidsHash;*/

    if (this.deleteRowA(row_id,node)===false) return false;
    if (this._fake.rowsAr[row_id])
    	this._fake.deleteRow(row_id);
}

this.clearAllA = this.clearAll;
this.clearAll=function(){
    this.clearAllA();
    this._fake.clearAll();
}
this.editStopA = this.editStop;
this.editStop=function(mode){
	if (this._fake.editor)
		this._fake.editStop(mode);
	else 
    	this.editStopA(mode);
};


this.attachEvent("onAfterSorting",function(i,b,c){
	if (i>=ind) 
		this._fake.setSortImgState(false)
});



this._fake.sortField = function(a,b,c){ 
	this._fake.sortField.call(this._fake,a,b,this._fake.hdr.rows[0].cells[a]);
	if (this.fldSort[a]!="na" && this._fake.fldSorted){
		var mem = this._fake.getSortingState()[1];
		this._fake.setSortImgState(false);
		this.setSortImgState(true,arguments[0],mem)
	}
}

this.sortTreeRowsA = this.sortTreeRows;
this._fake.sortTreeRowsA = this._fake.sortTreeRows;
this.sortTreeRows=this._fake.sortTreeRows=function(col,type,order,ar){
    if (this._realfake) return this._fake.sortTreeRows(col,type,order,ar)

    this.sortTreeRowsA(col,type,order,ar);
    this._fake._h2syncModel();

                this._fake.setSortImgStateA(false);
	this._fake.fldSorted=null;
    }

/* SRND mode */
this._fake._fillers=[];
this._fake.rowsBuffer=this.rowsBuffer;
this.attachEvent("onClearAll",function(){
	this._fake.rowsBuffer=this.rowsBuffer;	
})
this._add_filler_s=this._add_filler;
this._add_filler=function(a,b,c,e){
	if (!this._fake._fillers) this._fake._fillers=[];
	if (this._realfake || !e){
		var d;
		if (c && c.idd) d=this._fake.rowsAr[c.idd];
		else if (c && c.nextSibling) {
			d = {};
			d.nextSibling=this._fake.rowsAr[c.nextSibling.idd];
			d.parentNode=d.nextSibling.parentNode;
		} else if (this._fake._fillers.length){
			d = this._fake._fillers[this._fake._fillers.length-1][2];
		}
		this._fake._fillers.push(this._fake._add_filler(a,b,d));	
	}
	
	return this._add_filler_s.apply(this,arguments);
}
this._add_from_buffer_s=this._add_from_buffer;
this._add_from_buffer=function() { 
	var res=this._add_from_buffer_s.apply(this,arguments);
	if (res!=-1){
		this._fake._add_from_buffer.apply(this._fake,arguments);
		if (this.multiLine) this._correctRowHeight(this.rowsBuffer[arguments[0]].idd);
	}
	return res;
    }
this._fake.render_row=function(ind){
	var row=this._fake.render_row(ind);

	if (row == -1) return -1;
	if (row) {
		return this.rowsAr[row.idd]=this.rowsAr[row.idd]||this._fake.copy_row(row);
    }
	return null;
        }
this._reset_view_s=this._reset_view;
this._reset_view=function(){
	this._fake._reset_view(true);
	this._fake._fillers=[];
	this._reset_view_s();
    }

this.moveColumn_s=this.moveColumn;
this.moveColumn=function(a,b){
	if (b>=ind) return this.moveColumn_s(a,b);
}

    
this.attachEvent("onCellChanged",function(id,i,val){
	if (this._split_event && i<ind && this.rowsAr[id]){
		
		var cell=this._fake.rowsAr[id];
		if (!cell) return;
		if (cell._childIndexes)
			cell=cell.childNodes[cell._childIndexes[i]];
		else
			cell=cell.childNodes[i];
		var tcell = this.rowsAr[id].childNodes[i];
	
		if (tcell._treeCell && tcell.firstChild.lastChild)
			tcell.firstChild.lastChild.innerHTML = val;
		else
			tcell.innerHTML=cell.innerHTML;
		tcell._clearCell=false;
		tcell.combo_value = cell.combo_value;
		tcell.chstate=cell.chstate;	//TODO - more universal solution
	}
})





    this._fake.combos=this.combos;
	this.setSizes();
	if (this.rowsBuffer[0]) this._reset_view();
	this.attachEvent("onXLE",function(){this._fake._correctSplit()})
	this._fake._correctSplit();
}

dhtmlXGridObject.prototype._correctSplit=function(a){ 
    a=a||(this.obj.scrollWidth-this.objBox.scrollLeft);
    a=Math.min(this.globalBox.offsetWidth, a);
    if (a>-1){
	    this.entBox.style.width=a+"px";
	    this.objBox.style.width=a+"px";
	
		var outerBorder=(this.globalBox.offsetWidth-this.globalBox.clientWidth)/2;
	    this._fake.entBox.style.left=a+"px";
	    this._fake.entBox.style.width=Math.max(0,this.globalBox.offsetWidth-a-(this.quirks?0:2)*outerBorder)+"px";
	    if (this._fake.ftr)
	    	this._fake.ftr.parentNode.style.width=this._fake.entBox.style.width;
	    if (_isIE){
		    var quirks=_isIE && !window.xmlHttpRequest;
			var outerBorder=(this.globalBox.offsetWidth-this.globalBox.clientWidth);
			this._fake.hdrBox.style.width=this._fake.objBox.style.width=Math.max(0,this.globalBox.offsetWidth-(quirks?outerBorder:0)-a)+"px";
		}
	}
}

dhtmlXGridObject.prototype._correctRowHeight=function(id,ind){
	if (!this.rowsAr[id] || !this._fake.rowsAr[id]) return;

	var h=this.rowsAr[id].offsetHeight;
	var h2=this._fake.rowsAr[id].offsetHeight;
	var max = Math.max(h,h2) - (this.rowsAr[id].delta_fix || 0);
	if (!max) return;
	this.rowsAr[id].style.height=this._fake.rowsAr[id].style.height=Math.round(max+1)+"px";
	this.rowsAr[id].delta_fix = 1;
	if (window._KHTMLrv) {
		var j = this._fake._cCount;
		var td;
		while (!td && j>=0){
			td = this.rowsAr[id].childNodes[j];
			j-=1;
		}
		var td2 = this._fake.rowsAr[id].firstChild;
		if (td && td2){
			td.style.height=td2.style.height=max+"px";
			td.style.boxSizing=td2.style.boxSizing="border-box";
		}
	}
}
//(c)dhtmlx ltd. www.dhtmlx.com


/*
Product Name: dhtmlxSuite 
Version: 4.1.3 
Edition: Professional 
License: content of this file is covered by DHTMLX Commercial or Enterprise license. Usage without proper license is prohibited. To obtain it contact sales@dhtmlx.com
Copyright UAB Dinamenta http://www.dhtmlx.com
*/

/**
*   @desc: enable automatic size saving to cookie
*   @param: name - optional, cookie name
*   @param: cookie_param - additional parameters added to cookie
*   @type: public
*     @edition: Professional
*   @topic: 0
*/
dhtmlXGridObject.prototype.enableAutoSizeSaving = function(name,cookie_param){
		this.attachEvent("onResizeEnd",function(){ this.saveSizeToCookie(name,cookie_param) });
}

/**
*   @desc: store opene state of TreeGrid in cookie
*   @param: name - optional, cookie name
*   @param: cookie_param - additional parameters added to cookie
*   @type: public
*   @edition: Professional
*   @topic: 0
*/
dhtmlXGridObject.prototype.saveOpenStates = function(name,cookie_param){
	if (!name) name=this.entBox.id;
	var t=[];
	this._h2.forEachChild(0,function(el){
		if (el.state=="minus") t.push(el.id);
	});
	var str = "gridOpen"+(name||"") + "=" + t.join("|") +  (cookie_param?("; "+cookie_param):"");
	document.cookie = str;
}


/**
*   @desc: load open state of TreeGrid in cookie
*   @param: name - optional, cookie name
*   @param: cookie_param - additional parameters added to cookie
*   @type: public
*   @edition: Professional
*   @topic: 0
*/
dhtmlXGridObject.prototype.loadOpenStates = function(name,cookie_param){
	var val=this.getCookie(name,"gridOpen");
	if (!val) return;
	val=val.split("|");
	for (var i = 0; i < val.length; i++) {
		var pid = this.getParentId(val[i]);
		if (!this.getOpenState(pid)) continue;
		this.openItem(val[i]);
	}
}

/**
*   @desc: enable automatic saving column state ( hidden | shown )
*   @param: name - optional, cookie name
*   @param: cookie_param - additional parameters added to cookie
*   @type: public
*     @edition: Professional
*   @topic: 0
*/
dhtmlXGridObject.prototype.enableAutoHiddenColumnsSaving = function(name,cookie_param){
		this.attachEvent("onColumnHidden",function(){ 
				this.saveHiddenColumnsToCookie(name,cookie_param); 
		});
}

/**
*   @desc: enable automatic sorting state saving to cookie
*   @param: name - optional, cookie name
*   @param: cookie_param - additional parameters added to cookie
*   @type: public
*     @edition: Professional
*   @topic: 0
*/
dhtmlXGridObject.prototype.enableSortingSaving = function(name,cookie_param){
	this.attachEvent("onBeforeSorting",function(){ 
		var that=this;
		window.setTimeout(function(){
			that.saveSortingToCookie(name,cookie_param);
			},1);
		return true;
		});	
}

/**
*   @desc: enable automatic column order saving to cookie
*   @param: name - optional, cookie name
*   @param: cookie_param - additional parameters added to cookie
*   @type: public
*     @edition: Professional
*   @topic: 0
*/
dhtmlXGridObject.prototype.enableOrderSaving = function(name,cookie_param){
	this.attachEvent("onAfterCMove",function(){ 
		this.saveOrderToCookie(name,cookie_param);  
		this.saveSizeToCookie(name,cookie_param);
	});
}

/**
*   @desc: enable automatic saving of all possible params
*   @param: name - optional, cookie name
*   @param: cookie_param - additional parameters added to cookie
*   @type: public
*     @edition: Professional
*   @topic: 0
*/
dhtmlXGridObject.prototype.enableAutoSaving = function(name,cookie_param){
		this.enableOrderSaving(name,cookie_param);
		this.enableAutoSizeSaving(name,cookie_param);
		this.enableSortingSaving(name,cookie_param);
}


/**   @desc: save grid layout to cookie
*     @type: public
*     @param: name - optional, cookie name
*     @param: cookie_param - additional parameters added to cookie
*     @edition: Professional
*     @topic: 2
*/
dhtmlXGridObject.prototype.saveSizeToCookie=function(name,cookie_param){
	if (this.cellWidthType=='px')
		var z=this.cellWidthPX.join(",");
	else
		var z=this.cellWidthPC.join(",");
	var z2=(this.initCellWidth||(new  Array)).join(",");
	this.setCookie(name,cookie_param,0,z);
	this.setCookie(name,cookie_param,1,z2);
}

/**   @desc: save hidden columns to cookie
*     @type: public
*     @param: name - optional, cookie name
*     @param: cookie_param - additional parameters added to cookie
*     @edition: Professional
*     @topic: 2
*/
dhtmlXGridObject.prototype.saveHiddenColumnsToCookie=function(name,cookie_param){

    var hs=[].concat(this._hrrar||[]);
    if (this._fake && this._fake._hrrar)
        for (var i=0; i < this._fake._cCount; i++)
            hs[i]=this._fake._hrrar[i]?"1":"";
	this.setCookie(name,cookie_param,4,hs.join(",").replace(/display:none;/g,"1"));
}

/**   @desc: load sorting order from cookie
*     @type: public
*     @param: name - optional,cookie name
*     @edition: Professional
*     @topic: 2
*/
dhtmlXGridObject.prototype.loadHiddenColumnsFromCookie=function(name){
	var z=this._getCookie(name,4);
	var ar=(z||"").split(",");
	for (var i=0; i < this._cCount; i++) 
		this.setColumnHidden(i,(ar[i]?true:false));
}



/**   @desc: save sorting order to cookie
*     @type: public
*     @param: name - optional, cookie name
*     @param: cookie_param - additional parameters added to cookie
*     @edition: Professional
*     @topic: 2
*/
dhtmlXGridObject.prototype.saveSortingToCookie=function(name,cookie_param){
	this.setCookie(name,cookie_param,2,(this.getSortingState()||[]).join(","));
}


/**   @desc: load sorting order from cookie
*     @type: public
*     @param: name - optional,cookie name
*     @edition: Professional
*     @topic: 2
*/
dhtmlXGridObject.prototype.loadSortingFromCookie=function(name){
	var z=this._getCookie(name,2);
	z=(z||"").split(",");
	if (z.length>1 && z[0]<this._cCount){
		this.sortRows(z[0],null,z[1]);
		this.setSortImgState(true,z[0],z[1]);
	}
}



/**   @desc: save sorting order to cookie
*     @type: public
*     @param: name - optional, cookie name
*     @param: cookie_param - additional parameters added to cookie
*     @edition: Professional
*     @topic: 2
*/
dhtmlXGridObject.prototype.saveOrderToCookie=function(name,cookie_param){
	if (!this._c_order) {
		this._c_order=[];
		var l=this._cCount;
		for (var i=0; i<l; i++)
			this._c_order[i]=i;
	}
	this.setCookie(name,cookie_param,3,((this._c_order||[]).slice(0,this._cCount)).join(","));
	this.saveSortingToCookie();
}


/**   @desc: load sorting order from cookie
*     @type: public
*     @param: name - optional,cookie name
*     @edition: Professional
*     @topic: 2
*/
dhtmlXGridObject.prototype.loadOrderFromCookie=function(name){
	var z=this._getCookie(name,3);
	z=(z||"").split(",");
	if (z.length>1 && z.length<=this._cCount){
			//code below probably may be optimized
			for (var i=0; i<z.length; i++)
				if ((!this._c_order && z[i]!=i)||(this._c_order && z[i]!=this._c_order[i])){
					var t=z[i];
					if (this._c_order)
						for (var j=0; j<this._c_order.length; j++) {
							if (this._c_order[j]==z[i]) {
								t=j; break;
								}
						}
					this.moveColumn(t*1,i);
				}
	}
}


/**   @desc: load grid layout from cookie
*     @type: public
*     @param: name - optional,cookie name
*     @edition: Professional
*     @topic: 2
*/
dhtmlXGridObject.prototype.loadSizeFromCookie=function(name){ 
	var z=this._getCookie(name,1);
	if (z)
		this.initCellWidth=z.split(",");
	var z=this._getCookie(name,0);
	if ((z)&&(z.length)){
		if (!this._fake && this._hrrar) 
			for (var i=0; i<z.length; i++) 
				if ( this._hrrar[i]) z[i]=0;
		if (this.cellWidthType=='px')
			this.cellWidthPX=z.split(",");
		else
			this.cellWidthPC=z.split(",");
		}
	this.setSizes();
    return true;
}

/**   @desc: clear cookie with grid config details
*     @type: public
*     @param: name - optional,cookie name
*     @edition: Professional
*     @topic: 2
*/
dhtmlXGridObject.prototype.clearConfigCookie=function(name){
	if (!name) name=this.entBox.id;
	var str = "gridSettings"+name + "=||||";
	document.cookie = str;
}
dhtmlXGridObject.prototype.clearSizeCookie=dhtmlXGridObject.prototype.clearConfigCookie;


/**   @desc: save cookie
*     @type: private
*     @param: name - cookie name
*     @param: value - cookie value
*     @param: cookie_param - additional parameters added to cookie
*     @edition: Professional
*     @topic: 0
*/

dhtmlXGridObject.prototype.setCookie=function(name,cookie_param,pos,value) {
	if (!name) name=this.entBox.id;
	var t=this.getCookie(name);
	t=(t||"||||").split("|");
	t[pos]=value;
	var str = "gridSettings"+name + "=" + t.join("|").replace(/,/g,"-") +  (cookie_param?("; "+cookie_param):"");
//	console.log("save",str)
	document.cookie = str;
}

/**   @desc: get cookie
*     @type: private
*     @param: name - cookie name
*     @edition: Professional
*     @topic: 0
*/
dhtmlXGridObject.prototype.getCookie=function(name,surname) { 
	if (!name) name=this.entBox.id;
	name=(surname||"gridSettings")+name;
	var search = name + "=";
	if (document.cookie.length > 0) {
		var offset = document.cookie.indexOf(search);
		if (offset != -1) {
			offset += search.length;
			var end = document.cookie.indexOf(";", offset);
			if (end == -1)
				end = document.cookie.length;
			return document.cookie.substring(offset, end);
						}		}
};
dhtmlXGridObject.prototype._getCookie=function(name,pos) {
//	console.log("get",this.getCookie(name))
	return ((this.getCookie(name)||"||||").replace(/-/g,",").split("|"))[pos];
}
//(c)dhtmlx ltd. www.dhtmlx.com

/*
Product Name: dhtmlxSuite 
Version: 4.1.3 
Edition: Professional 
License: content of this file is covered by DHTMLX Commercial or Enterprise license. Usage without proper license is prohibited. To obtain it contact sales@dhtmlx.com
Copyright UAB Dinamenta http://www.dhtmlx.com
*/

/**
*	@desc: enable Undo/Redo functionality in grid
*	@type: public
*	@edition: Professional
*/
dhtmlXGridObject.prototype.enableUndoRedo = function()
{ 
	var self = this;
	var func = function() {return self._onEditUndoRedo.apply(self,arguments);}
	this.attachEvent("onEditCell", func);
	var func2 = function(a,b,c) {return self._onEditUndoRedo.apply(self,[2,a,b,(c?1:0),(c?0:1)]);}		
	this.attachEvent("onCheckbox", func2);
	this._IsUndoRedoEnabled = true;
	this._UndoRedoData = [];
	this._UndoRedoPos = -1;
}
/**
*	@desc: disable Undo/Redo functionality in grid
*	@type: public
*	@edition: Professional
*/
dhtmlXGridObject.prototype.disableUndoRedo = function()
{
	this._IsUndoRedoEnabled = false;
	this._UndoRedoData = [];
	this._UndoRedoPos = -1;
}

dhtmlXGridObject.prototype._onEditUndoRedo = function(stage, row_id, cell_index, new_value, old_value)
{
	if (this._IsUndoRedoEnabled && stage == 2 && old_value != new_value) {
	    if (this._UndoRedoPos !== -1 && this._UndoRedoPos != ( this._UndoRedoData.length-1 ) ) {
	        this._UndoRedoData = this._UndoRedoData.slice(0, this._UndoRedoPos+1);
	    } else if (this._UndoRedoPos === -1 && this._UndoRedoData.length > 0) {
	        this._UndoRedoData = [];
	    }

	    var obj = { old_value:old_value,
	                new_value:new_value,
	                row_id:row_id,
	                cell_index:cell_index
	    };
	    this._UndoRedoData.push(obj);
	    this._UndoRedoPos++;
	}
	return true;
}
/**
*	@desc: UnDo
*	@type: public
*	@edition: Professional
*/
dhtmlXGridObject.prototype.doUndo = function()
{
	if (this._UndoRedoPos === -1)
		return false;
	var obj = this._UndoRedoData[this._UndoRedoPos--];
	var c=this.cells(obj.row_id, obj.cell_index);
	if (this.getColType(obj.cell_index)=="tree")
		c.setLabel(obj.old_value);
	else
		c.setValue(obj.old_value);

	this.callEvent("onUndo", [obj.row_id]);
}
/**
*	@desc: ReDo
*	@type: public
*	@edition: Professional
*/
dhtmlXGridObject.prototype.doRedo = function()
{
	if (this._UndoRedoPos == this._UndoRedoData.length-1)
		return false;
	var obj = this._UndoRedoData[++this._UndoRedoPos];
	this.cells(obj.row_id, obj.cell_index).setValue(obj.new_value);

	this.callEvent("onUndo", [obj.row_id]);
}
/**
*	@desc: get length of available ReDo operations
*	@type: public
*	@edition: Professional
*/
dhtmlXGridObject.prototype.getRedo = function()
{
	if (this._UndoRedoPos == this._UndoRedoData.length-1)
		return [];
	return this._UndoRedoData.slice(this._UndoRedoPos+1);
}
/**
*	@desc: get length of available UnDo operations
*	@type: public
*	@edition: Professional
*/
dhtmlXGridObject.prototype.getUndo = function()
{
	if (this._UndoRedoPos == -1)
		return [];
	return this._UndoRedoData.slice(0, this._UndoRedoPos+1);
}
//(c)dhtmlx ltd. www.dhtmlx.com

/*
Product Name: dhtmlxSuite 
Version: 4.1.3 
Edition: Professional 
License: content of this file is covered by DHTMLX Commercial or Enterprise license. Usage without proper license is prohibited. To obtain it contact sales@dhtmlx.com
Copyright UAB Dinamenta http://www.dhtmlx.com
*/

dhtmlXGridObject.prototype.enableAccessKeyMap = function(){
/*
	keymap like MS Access offers
*/
this._select_ifpossible=function(){
	if (this.editor && this.editor.obj && this.editor.obj.select) this.editor.obj.select();
};
this._key_events={
			//ctrl-enter
			k13_1_0:function(){
				this.editStop();
			},
			//shift-enter
			k13_0_1:function(){
				this._key_events.k9_0_1.call(this);
			},
			//enter
			k13_0_0:function(){
				this._key_events.k9_0_0.call(this);
            },
            //tab
            k9_0_0:function(){
					this.editStop();
				if (!this.callEvent("onTab",[true])) return true;
				var z=this._getNextCell(null,1);
				if (z) {
					if (this.pagingOn) this.showRow(z.parentNode.idd);
					this.selectCell(z.parentNode,z._cellIndex,(this.row!=z.parentNode),false,true);
					this._still_active=true;
				}
				this._select_ifpossible();
            },
            //shift-tab
			k9_0_1:function(){
				this.editStop();
				if (!this.callEvent("onTab",[false])) return true;
				var z=this._getNextCell(null,-1);
				if (z) {
					this.selectCell(z.parentNode,z._cellIndex,(this.row!=z.parentNode),false,true);
					this._still_active=true;
				}
				this._select_ifpossible();
            },
            //f2 key
            k113_0_0:function(){
            	if (this._f2kE) this.editCell();
            },
            //space
            k32_0_0:function(){
            	var c=this.cells4(this.cell);
            	if (!c.changeState || (c.changeState()===false)) return false;
            },
            //escape
            k27_0_0:function(){
            	this.editStop(true);
            },
            //pageUp
            k33_0_0:function(){
            	if(this.pagingOn)
            		this.changePage(this.currentPage-1);
            	else this.scrollPage(-1);            		
	        },
	        //pageDown
			k34_0_0:function(){
            	if(this.pagingOn)
            		this.changePage(this.currentPage+1);
            	else this.scrollPage(1);
	        },
	        //left
			k37_0_0:function(){
				if (this.editor) return false;
            	if(this.isTreeGrid())
            		this.collapseKids(this.row);
            	else this._key_events.k9_0_1.call(this);
	        },
	        //right
			k39_0_0:function(){
				if (this.editor) return false;
				if(!this.editor && this.isTreeGrid())
            		this.expandKids(this.row);
            	else this._key_events.k9_0_0.call(this);
            },
            //ctrl left
			k37_1_0:function(){
				if (this.editor) return false;
				this.selectCell(this.row,0,false,false,true);
				this._select_ifpossible();
	        },
	        //ctrl right
			k39_1_0:function(){
				if (this.editor) return false;
				this.selectCell(this.row,this._cCount-1,false,false,true);
				this._select_ifpossible();
            },
            //ctrl up
			k38_1_0:function(){
			
				this.selectCell(this.rowsCol[0],this.cell._cellIndex,true,false,true);
				this._select_ifpossible();
	        },
	        //ctrl down
			k40_1_0:function(){
				this.selectCell(this.rowsCol[this.rowsCol.length-1],this.cell._cellIndex,true,false,true);
				this._select_ifpossible();
            },
            //shift up
			k38_0_1:function(){
				var rowInd = this.getRowIndex(this.row.idd);
				var nrow=this._nextRow(rowInd,-1);
				if (!nrow || nrow._sRow || nrow._rLoad) return false;
                this.selectCell(nrow,this.cell._cellIndex,true,false,true);
				this._select_ifpossible();
	        },
	        //shift down
			k40_0_1:function(){
				var rowInd = this.getRowIndex(this.row.idd);
				var nrow=this._nextRow(rowInd,1);
				if (!nrow || nrow._sRow || nrow._rLoad) return false;
                this.selectCell(nrow,this.cell._cellIndex,true,false,true);
                this._select_ifpossible();
            },   
            //ctrl shift up  
			k38_1_1:function(){
				var rowInd = this.getRowIndex(this.row.idd);
				for (var i = rowInd; i >= 0; i--){
					this.selectCell(this.rowsCol[i],this.cell._cellIndex,true,false,true);
				}
	        },
	        //ctrl shift down
			k40_1_1:function(){
				var rowInd = this.getRowIndex(this.row.idd);
				for (var i = rowInd+1; i <this.rowsCol.length; i++){
					this.selectCell(this.rowsCol[i],this.cell._cellIndex,true,false,true);
				}
            },    
            //down               
			k40_0_0:function(){
				if (this.editor && this.editor.combo)
					this.editor.shiftNext();
				else{
					if (!this.row.idd) return;
					var rowInd = rowInd=this.getRowIndex(this.row.idd)+1;
					if (this.rowsBuffer[rowInd]){
						var nrow=this._nextRow(rowInd-1,1);
						if (this.pagingOn && nrow) this.showRow(nrow.idd);
						this._Opera_stop=0;
                        this.selectCell(nrow,this.cell._cellIndex,true,false,true);
                    }
                    else {
                    	if (!this.callEvent("onLastRow", [])) return false;
                    	this._key_events.k34_0_0.apply(this,[]);
                	}
				}
				this._still_active=true;								
            },
            //home
            k36_0_0:function(){ 
            	return this._key_events.k37_1_0.call(this);
            },
            //end
            k35_0_0:function(){ 
            	return this._key_events.k39_1_0.call(this);
            },            
            //ctrl-home
            k36_1_0:function(){ 
            	if (this.editor || !this.rowsCol.length) return false;
				this.selectCell(this.rowsCol[0],0,true,false,true);
				this._select_ifpossible();
            },
            //ctrl-end
            k35_1_0:function(){ 
            	if (this.editor || !this.rowsCol.length) return false;
				this.selectCell(this.rowsCol[this.rowsCol.length-1],this._cCount-1,true,false,true);
				this._select_ifpossible();
            },  
            //padeup
            k33_0_0:function(){
            	if(this.pagingOn)
            		this.changePage(this.currentPage-1);
            	else this.scrollPage(-1);            		
	        },
	        //pagedown
			k34_0_0:function(){
            	if(this.pagingOn)
            		this.changePage(this.currentPage+1);
            	else this.scrollPage(1);
	        },  
	        //up                                
			k38_0_0:function(){
				if (this.editor && this.editor.combo)
					this.editor.shiftPrev();
				else{
				
					if (!this.row.idd) return;
					var rowInd = rowInd=this.getRowIndex(this.row.idd)+1;
					if (rowInd!=-1){
						var nrow=this._nextRow(rowInd-1,-1);
                        this._Opera_stop=0;
                        if (this.pagingOn && nrow) this.showRow(nrow.idd);
                        this.selectCell(nrow,this.cell._cellIndex,true,false,true);
                    }
					else this._key_events.k33_0_0.apply(this,[]);
				}
				this._still_active=true;
            }
		};

};
dhtmlXGridObject.prototype.enableExcelKeyMap = function(){
/*
	keymap like MS Excel offers
*/
dhtmlXGridObject.prototype._key_events={
			k13_1_0:function(){
				this.editStop();
			},
			k13_0_1:function(){
				this.editStop();
				this._key_events.k38_0_0.call(this);
			},
			k13_0_0:function(){
				this.editStop();
				this.callEvent("onEnter",[(this.row?this.row.idd:null),(this.cell?this.cell._cellIndex:null)]);
				this._still_active=true;
				this._key_events.k40_0_0.call(this);
            },
            k9_0_0:function(){
				this.editStop();
				if (!this.callEvent("onTab",[true])) return true;
				if (this.cell && (this.cell._cellIndex+1)>=this._cCount) return;
				var z=this._getNextCell(null,1);
				if (z && this.row==z.parentNode){
					this.selectCell(z.parentNode,z._cellIndex,true);
					this._still_active=true;
				}
			},
			k9_0_1:function(){
				this.editStop();
				if (!this.callEvent("onTab",[false])) return true;
				if (this.cell && (this.cell._cellIndex==0)) return;
				var z=this._getNextCell(null,-1);
				if (z && this.row==z.parentNode) {
					this.selectCell(z.parentNode,z._cellIndex,true);
					this._still_active=true;
				}
            },
            k113_0_0:function(){
            	if (this._f2kE) this.editCell();
            },
            k32_0_0:function(){
            	var c=this.cells4(this.cell);
            	if (!c.changeState || (c.changeState()===false)) return false;
            },
            k27_0_0:function(){
            	this.editStop(true);
            	this._still_active=true;
            },
            k33_0_0:function(){
            	if(this.pagingOn)
            		this.changePage(this.currentPage-1);
            	else this.scrollPage(-1);            		
	        },
			k34_0_0:function(){
            	if(this.pagingOn)
            		this.changePage(this.currentPage+1);
            	else this.scrollPage(1);
	        },
			k37_0_0:function(){
				if (this.editor) return false;
            	if(this.isTreeGrid())
            		this.collapseKids(this.row);
            	else this._key_events.k9_0_1.call(this);
	        },
			k39_0_0:function(){
				if (this.editor) return false;
				if(!this.editor && this.isTreeGrid())
            		this.expandKids(this.row);
            	else this._key_events.k9_0_0.call(this);
            },
			k37_1_0:function(){
				if (this.editor) return false;
				this.selectCell(this.row,0,true);
	        },
			k39_1_0:function(){
				if (this.editor) return false;
				this.selectCell(this.row,this._cCount-1,true);
            }, 
			k38_1_0:function(){
				if (this.editor || !this.rowsCol.length) return false;
				this.selectCell(this.rowsCol[0],this.cell._cellIndex,true);
	        },
			k40_1_0:function(){
				if (this.editor || !this.rowsCol.length) return false;
				this.selectCell(this.rowsCol[this.rowsCol.length-1],this.cell._cellIndex,true);
            },
			k38_0_1:function(){
				if (this.editor || !this.rowsCol.length) return false;
				var rowInd = this.row.rowIndex;
				var nrow=this._nextRow(rowInd-1,-1);
				if (!nrow || nrow._sRow || nrow._rLoad) return false;
                this.selectCell(nrow,this.cell._cellIndex,true,true);
	        },
			k40_0_1:function(){
				if (this.editor || !this.rowsCol.length) return false;
				var rowInd = this.row.rowIndex;
				var nrow=this._nextRow(rowInd-1,1);
				if (!nrow || nrow._sRow || nrow._rLoad) return false;
                this.selectCell(nrow,this.cell._cellIndex,true,true);
            },     
			k38_1_1:function(){
				if (this.editor || !this.rowsCol.length) return false;
				var rowInd = this.row.rowIndex;
				for (var i = rowInd - 1; i >= 0; i--){
					this.selectCell(this.rowsCol[i],this.cell._cellIndex,true,true);
				}
	        },
			k40_1_1:function(){
				if (this.editor || !this.rowsCol.length) return false;
				var rowInd = this.row.rowIndex;
				for (var i = rowInd; i <this.rowsCol.length; i++){
					this.selectCell(this.rowsCol[i],this.cell._cellIndex,true,true);
				}
            },                   
			k40_0_0:function(){
				var master = this._realfake?this._fake:this;
				if (this.editor && this.editor.combo)
					this.editor.shiftNext();
				else{
					if (this.editor) return false;
					var rowInd = Math.max((master._r_select||0),this.getRowIndex(this.row.idd));
					var row = this._nextRow(rowInd, 1);

					if (row){
						master._r_select=null;
						this.selectCell(row, this.cell._cellIndex, true);
						if (master.pagingOn) master.showRow(row.idd);
					} else {
                    	if (!this.callEvent("onLastRow", [])) return false;
                    	this._key_events.k34_0_0.apply(this,[]);
                	}
				}
            },
            k36_0_0:function(){ //home
            	return this._key_events.k37_1_0.call(this);
            },
            k35_0_0:function(){ //ctrl-home
            	return this._key_events.k39_1_0.call(this);
            },            
            k36_1_0:function(){ //home
            	if (this.editor || !this.rowsCol.length) return false;
				this.selectCell(this.rowsCol[0],0,true);
            },
            k35_1_0:function(){ //ctrl-end
            	if (this.editor || !this.rowsCol.length) return false;
				this.selectCell(this.rowsCol[this.rowsCol.length-1],this._cCount-1,true);
            },  
            k33_0_0:function(){
            	if(this.pagingOn)
            		this.changePage(this.currentPage-1);
            	else this.scrollPage(-1);            		
	        },
			k34_0_0:function(){
            	if(this.pagingOn)
            		this.changePage(this.currentPage+1);
            	else this.scrollPage(1);
	        },                                  
			k38_0_0:function(){	
				var master = this._realfake?this._fake:this;
				if (this.editor && this.editor.combo)
					this.editor.shiftPrev();
				else{
					if (this.editor) return false;
					if (!this.row.idd) return;
					var rowInd = this.getRowIndex(this.row.idd)+1;
					if (rowInd != -1 && (!this.pagingOn || (rowInd!=1))){
						var nrow = this._nextRow(rowInd-1, -1);
						this.selectCell(nrow, this.cell._cellIndex, true);
						if (master.pagingOn && nrow) master.showRow(nrow.idd);
					} else {
						this._key_events.k33_0_0.apply(this,[]);
					}
				}
            },
            k_other:function(ev){ 
            	if (this.editor) return false;
            	if (!ev.ctrlKey && ev.keyCode>=40 && (ev.keyCode < 91 || (ev.keyCode >95 && ev.keyCode <111) || ev.keyCode > 187))
            		if (this.cell){
            			var c=this.cells4(this.cell);
            			if (c.isDisabled()) return false;
            			var t=c.getValue();
            			if (c.editable!==false) c.setValue("");
            			this.editCell();
            			if (this.editor) {
            				this.editor.val=t;
            				if (this.editor.obj && this.editor.obj.select)
            					this.editor.obj.select();
        				}
            			else c.setValue(t);
            		}
            }
		};

};

/*
Product Name: dhtmlxSuite 
Version: 4.1.3 
Edition: Professional 
License: content of this file is covered by DHTMLX Commercial or Enterprise license. Usage without proper license is prohibited. To obtain it contact sales@dhtmlx.com
Copyright UAB Dinamenta http://www.dhtmlx.com
*/

function eXcell_time(cell){

		this.base = eXcell_ed;
		this.base(cell)
		this.getValue = function(){
				return this.cell.innerHTML.toString();
		}
		this.setValue = function(val){
		var re = new RegExp(" ","i")
		val = val.replace(re,":")
		if((val=="")) val = "00:00"
		else
		{
			var re = new RegExp("[a-zA-Z]","i")
			var res = val.match(re)
			
			if(res) val = "00:00";
			else{
				var re = new RegExp("[0-9]+[\\.\\/;\\-,_\\]\\[\\?\\: ][0-9]+","i")
				var res = val.search(re)
				if(res!=-1){
					var re = new RegExp("[\\./\\;\\-\\,\\_\\]\\[ \\?]","i")
					val = val.replace(re,":")
				}
				else
				{
					var re = new RegExp("[^0-9]","i")
					res1 = val.search(re)
					if(res = val.match(re) ) { val = "00:00";}
					else
					{
					if(val.length == 1)
					{
						val = "00:0"+val;
					}
					else
					{
						if(parseInt(val) < 60) val = "00:"+val;
						else
						if(val.length < 5)
						{
							var minutes = parseInt(val);
							var hours =  Math.floor(minutes/60);
							minutes = minutes - 60*hours;
							var hours = hours.toString();
							var minutes = minutes.toString();
							while(hours.length < 2){
								hours = "0" + hours;
							}
							while(minutes.length < 2){
								minutes = "0" + minutes;
							}
							val = hours+":"+minutes;
						}
					}
					}
						
				}
			}
		}
		this.cell.innerHTML = val;
		}

		
	}
	   eXcell_time.prototype = new eXcell_ed;
	   //(c)dhtmlx ltd. www.dhtmlx.com

/*
Product Name: dhtmlxSuite 
Version: 4.1.3 
Edition: Professional 
License: content of this file is covered by DHTMLX Commercial or Enterprise license. Usage without proper license is prohibited. To obtain it contact sales@dhtmlx.com
Copyright UAB Dinamenta http://www.dhtmlx.com
*/

function eXcell_sub_row(cell){
	if (cell){
		this.cell = cell;
    	this.grid = this.cell.parentNode.grid;
	}
	
	this.getValue = function(){
		return this.grid.getUserData(this.cell.parentNode.idd,"__sub_row");
	}
	this._setState = function(m,v){
		(v||this.cell).innerHTML="<img src='"+this.grid.imgURL+m+"' width='18' height='18' />";
		(v||this.cell).firstChild.onclick=this.grid._expandMonolite;
	}
	this.open = function (){
		this.cell.firstChild.onclick(null,true)
	}
	this.close = function (){
		this.cell.firstChild.onclick(null,false,true)
	}
	this.isOpen = function(){
		return !!this.cell.parentNode._expanded;
	}
	this.setValue = function(val){
		if (val)
			this.grid.setUserData(this.cell.parentNode.idd,"__sub_row",val);
		this._setState(val?"plus.gif":"blank.gif");
	}
	this.setContent = function(val){
		if (this.cell.parentNode._expanded){
			this.cell.parentNode._expanded.innerHTML=val;
			this.resize();
		}
		else{
			this.cell._previous_content=null;
			this.setValue(val);
			this.cell._sub_row_type=null
		}
			
	}
	this.resize = function(){
		this.grid._detectHeight(this.cell.parentNode._expanded,this.cell,this.cell.parentNode._expanded.scrollHeight);
	},
	this.isDisabled = function(){ return true; }
	this.getTitle = function(){ return this.grid.getUserData(this.cell.parentNode.idd,"__sub_row")?"click to expand|collapse":""; }
}
eXcell_sub_row.prototype = new eXcell;

function eXcell_sub_row_ajax(cell){
	this.base=eXcell_sub_row;
	this.base(cell);
	
	this.setValue = function(val){
		if (val)
			this.grid.setUserData(this.cell.parentNode.idd,"__sub_row",val);
			this.cell._sub_row_type="ajax";
			this.cell._previous_content = null;
		this._setState(val?"plus.gif":"blank.gif");
	}
}
eXcell_sub_row_ajax.prototype = new eXcell_sub_row;

function eXcell_sub_row_grid(cell){
	this.base=eXcell_sub_row;
	this.base(cell);
	
	this.setValue = function(val){
		if (val)
			this.grid.setUserData(this.cell.parentNode.idd,"__sub_row",val);
			this.cell._sub_row_type="grid";
		this._setState(val?"plus.gif":"blank.gif");
	}
	this.getSubGrid = function(){
		if (!cell._sub_grid) return null;
		return cell._sub_grid;
	}
}
eXcell_sub_row_grid.prototype = new eXcell_sub_row;

dhtmlXGridObject.prototype._expandMonolite=function(n,show,hide){
	var td=this.parentNode;
	var row=td.parentNode;
	var that=row.grid;
	
	if (n||window.event){
		if (!hide && !row._expanded) that.editStop();
		(n||event).cancelBubble=true;
	}
	
	var c=that.getUserData(row.idd,"__sub_row");
	
	if (!that._sub_row_editor)
    	that._sub_row_editor=new eXcell_sub_row(td);
	
	if (!c) return;
	
	if (row._expanded && !show){
		that._sub_row_editor._setState("plus.gif",td);
		td._previous_content=row._expanded;
		that.objBox.removeChild(row._expanded);
		row._expanded=false;
		row.style.height=(row.oldHeight||20)+"px";
		td.style.height=(row.oldHeight||20)+"px";	
		
		if (that._fake){
			that._fake.rowsAr[row.idd].style.height=(row.oldHeight||20)+"px";
			that._fake.rowsAr[row.idd].firstChild.style.height=(row.oldHeight||20)+"px";
		}
			
		for (var i=0; i<row.cells.length; i++)
			row.cells[i].style.verticalAlign="middle";
			
		delete that._flow[row.idd];
		that._correctMonolite();
		row._expanded.ctrl=null;
	}else if (!row._expanded && !hide){
		that._sub_row_editor._setState("minus.gif",td);
		row.oldHeight=td.offsetHeight-4;
		if (td._previous_content){
			var d=td._previous_content;
			d.ctrl=td;
			that.objBox.appendChild(d);
			that._detectHeight(d,td,parseInt(d.style.height))	
		}
		else {
			var d=document.createElement("DIV");
			d.ctrl=td;
			if (td._sub_row_type)
				that._sub_row_render[td._sub_row_type](that,d,td,c);
			else
				d.innerHTML=c;
			d.style.cssText="position:absolute; left:0px; top:0px; overflow:auto; font-family:Tahoma; font-size:8pt; margin-top:2px; margin-left:4px;";
			d.className="dhx_sub_row";
			that.objBox.appendChild(d);
			that._detectHeight(d,td)			
		}
		

			
		
		if (!that._flow) {
			that.attachEvent("onGridReconstructed",function(){ 
				if ((this.pagingOn && !this.parentGrid) || this._srnd) this._collapsMonolite();
				else this._correctMonolite(); 
			});
			that.attachEvent("onResizeEnd",function(){ this._correctMonolite(true); });
			that.attachEvent("onAfterCMove",function(){ this._correctMonolite(true); });
			that.attachEvent("onDrop",function(){ this._correctMonolite(true); });
			that.attachEvent("onBeforePageChanged",function(){ this._collapsMonolite(); return true; });
			that.attachEvent("onGroupStateChanged",function(){ this._correctMonolite(); return true; });
			that.attachEvent("onFilterEnd",function(){ this._collapsMonolite(); });
			that.attachEvent("onUnGroup",function(){ this._collapsMonolite(); });
			that.attachEvent("onPageChanged",function(){ this._collapsMonolite(); });
			
			that.attachEvent("onXLE",function(){ this._collapsMonolite(); });
			that.attachEvent("onClearAll",function(){ for (var i in this._flow) {
				if (this._flow[i] && this._flow[i].parentNode) this._flow[i].parentNode.removeChild(this._flow[i]);
			}; this._flow=[]; });
			that.attachEvent("onEditCell",function(a,b,c){  if ((a!==2) && this._flow[b] && this.cellType[c]!="ch" && this.cellType[c]!="ra") this._expandMonolite.apply(this._flow[b].ctrl.firstChild,[0,false,true]);  return true; });
			that.attachEvent("onCellChanged",function(id,ind){ if (!this._flow[id]) return; 
				var c=this.cells(id,ind).cell;
				c.style.verticalAlign="top";
			});
			
			that._flow=[];
		}
		that._flow[row.idd]=d;
		that._correctMonolite();
		//d.style.top=row.offsetTop+20+"px";
		
		var padtop = that._srdh > 30 ? 11:3;
		if (that.multiLine) padtop = 0;

		for (var i=0; i<row.cells.length; i++)
			row.cells[i].style.verticalAlign="top";
		if (that._fake){
			var frow=that._fake.rowsAr[row.idd];
			for (var i=0; i<frow.cells.length; i++){
				frow.cells[i].style.verticalAlign="top";
			}
		}
		row._expanded=d;
	}
	if (that._ahgr)
		that.setSizes()
	if (that.parentGrid)
		that.callEvent("onGridReconstructed",[]);
	that.callEvent("onSubRowOpen",[row.idd,(!!row._expanded)]);
}
dhtmlXGridObject.prototype._sub_row_render={
    "ajax":function(that,d,td,c){
        d.innerHTML="Loading...";
        //d.innerHTML=that.i18n.loading;
        dhx4.ajax.get(c, function(xml){
            d.innerHTML=xml.xmlDoc.responseText;
            var z=xml.xmlDoc.responseText.match(/<script[^>]*>([^\f]+?)<\/script>/g);
            if (z)
                for (var i=0; i<z.length; i++)
                    eval(z[i].replace(/<([\/]{0,1})s[^>]*>/g,""));

			that._detectHeight(d,td)
			that._correctMonolite();
			that.setUserData(td.parentNode.idd,"__sub_row",xml.xmlDoc.responseText);
			td._sub_row_type=null;
			if (that._ahgr)
				that.setSizes()
			that.callEvent("onSubAjaxLoad",[td.parentNode.idd,xml.xmlDoc.responseText]);
		});
	},
	"grid":function(that,d,td,c){
		   td._sub_grid= new dhtmlXGridObject(d);
		   if (that.skin_name)
				td._sub_grid.setSkin(that.skin_name);
				
		   td._sub_grid.parentGrid=that;
		   td._sub_grid.imgURL = that.imgURL;
		   td._sub_grid.iconURL = that.iconURL;
		   td._sub_grid.enableAutoHeight(true);
		   td._sub_grid._delta_x = td._sub_grid._delta_y = null;
		   td._sub_grid.attachEvent("onGridReconstructed",function(){
		   		that._detectHeight(d,td,td._sub_grid.objBox.scrollHeight+td._sub_grid.hdr.offsetHeight+(this.ftr?this.ftr.offsetHeight:0));
		   		that._correctMonolite();
		   		this.setSizes();
		   		if (that.parentGrid) that.callEvent("onGridReconstructed",[]);
	   	   })
		   if (!that.callEvent("onSubGridCreated",[td._sub_grid,td.parentNode.idd,td._cellIndex,c])){
		   		td._sub_grid.objBox.style.overflow="hidden";
				td._sub_row_type=null;
		   } else {
			   td._sub_grid.loadXML(c,function(){
					that._detectHeight(d,td,td._sub_grid.objBox.scrollHeight+td._sub_grid.hdr.offsetHeight+(td._sub_grid.ftr?td._sub_grid.ftr.offsetHeight:0));
					td._sub_grid.objBox.style.overflow="hidden";
					that._correctMonolite();
					td._sub_row_type=null;
					if (!that.callEvent("onSubGridLoaded",[td._sub_grid,td.parentNode.idd,td._cellIndex,c])) return;
					if (that._ahgr) that.setSizes();
			  	});		   
			}
	}
}

dhtmlXGridObject.prototype._detectHeight=function(d,td,h){
	var l=td.offsetLeft+td.offsetWidth;
		d.style.left=l+"px";
		d.style.width=Math.max(0,td.parentNode.offsetWidth-l-4)+"px"
		var h=h||d.scrollHeight;
		d.style.overflow="hidden";
		d.style.height=h+"px";		
		var row=td.parentNode;
		td.parentNode.style.height=(row.oldHeight||20)+h*1+"px";	
		td.style.height=(row.oldHeight||20)+h*1+"px";	
		if (this._fake){
			var tr=this._fake.rowsAr[td.parentNode.idd];
			tr.style.height=(row.oldHeight||20)+h*1+"px";	
			tr.firstChild.style.height=(row.oldHeight||20)+h*1+"px";	
		}
}
dhtmlXGridObject.prototype._correctMonolite=function(mode){
	if (this._in_correction) return;
	this._in_correction=true;
	
	for (var a in this._flow)
		if (this._flow[a] && this._flow[a].tagName=="DIV")
			if (this.rowsAr[a]){			
				if (this.rowsAr[a].style.display=="none") {
					this.cells4(this._flow[a].ctrl).close();
					continue;
				}
				this._flow[a].style.top=this.rowsAr[a].offsetTop+(this.rowsAr[a].oldHeight||20)+"px";
				if (mode) {
					var l=this._flow[a].ctrl.offsetLeft+this._flow[a].ctrl.offsetWidth;
					this._flow[a].style.left=l+"px";
					this._flow[a].style.width=this.rowsAr[a].offsetWidth-l-4+"px"
				}
			}
			else{
				this._flow[a].ctrl=null;
				this.objBox.removeChild(this._flow[a]);
				delete this._flow[a];
			}

	this._in_correction=false;
}
dhtmlXGridObject.prototype._collapsMonolite=function(){
		for (var a in this._flow)
			if (this._flow[a] && this._flow[a].tagName=="DIV")
				if (this.rowsAr[a])
					this.cells4(this._flow[a].ctrl).close();
}
//(c)dhtmlx ltd. www.dhtmlx.com


/*
Product Name: dhtmlxSuite 
Version: 4.1.3 
Edition: Professional 
License: content of this file is covered by DHTMLX Commercial or Enterprise license. Usage without proper license is prohibited. To obtain it contact sales@dhtmlx.com
Copyright UAB Dinamenta http://www.dhtmlx.com
*/

/**
*   @desc: radio editor
*   @returns: dhtmlxGrid cell editor object
*   @type: public
*/
function eXcell_ra_str(cell){
   if (cell){
   this.base = eXcell_ra;
   this.base(cell)
   this.grid = cell.parentNode.grid;
	}
}
eXcell_ra_str.prototype = new eXcell_ch;
eXcell_ra_str.prototype.setValue = function(val){
                  this.cell.style.verticalAlign = "middle";//nb:to center checkbox in line
                  if (val){
                           val=val.toString()._dhx_trim();
                     if ((val=="false")||(val=="0")) val="";
                     }
                  if(val){
		    if (this.grid.rowsAr[this.cell.parentNode.idd])
                     for (var i=0;i<this.grid._cCount;i++) {
			if (i!==this.cell._cellIndex) {
                            var cell = this.grid.cells(this.cell.parentNode.idd,i);
                            if ((cell.cell._cellType||this.grid.cellType[cell.cell._cellIndex])!="ra_str") continue;
                            if (cell.getValue())
                               cell.setValue("0");
			}
                     }
                     val = "1";
                     this.cell.chstate = "1";
                  }else{
                     val = "0";
                     this.cell.chstate = "0"
                  }
                  this.setCValue("<img src='"+this.grid.imgURL+"radio_chk"+val+".gif' onclick='new eXcell_ra_str(this.parentNode).changeState()'>",this.cell.chstate);
               }
//(c)dhtmlx ltd. www.dhtmlx.com

/*
Product Name: dhtmlxSuite 
Version: 4.1.3 
Edition: Professional 
License: content of this file is covered by DHTMLX Commercial or Enterprise license. Usage without proper license is prohibited. To obtain it contact sales@dhtmlx.com
Copyright UAB Dinamenta http://www.dhtmlx.com
*/

dhx4.attachEvent("onGridCreated", function(grid){
	if (!window.dhx_globalImgPath) window.dhx_globalImgPath = grid.imgURL;
	
	grid._col_combos = [];
	for (var i=0; i<grid._cCount; i++) {
		if(grid.cellType[i].indexOf("combo") == 0) {
			grid._col_combos[i] = eXcell_combo.prototype.initCombo.call({grid:grid},i);
		}
	}
	
	if (!grid._loading_handler_set) {
		grid._loading_handler_set = grid.attachEvent("onXLE", function(a,b,c,xml){
				eXcell_combo.prototype.fillColumnCombos(this,xml);
				this.detachEvent(this._loading_handler_set);
				this._loading_handler_set = null;
		});
	}
});


function eXcell_combo(cell) {
	
	if (!cell) return;
	
	this.cell = cell;
	this.grid = cell.parentNode.grid;
	this._combo_pre = "";
	
	this.edit = function(){
		
		if (!window.dhx_globalImgPath) window.dhx_globalImgPath = this.grid.imgURL;
		
		this.val = this.getValue();
		var val = this.getText();
		if (this.cell._clearCell) val="";
		this.cell.innerHTML = "";
		
		if (!this.cell._brval) {
			this.combo = (this.grid._realfake?this.grid._fake:this.grid)._col_combos[this.cell._cellIndex];
		} else {
			this.combo = this.cell._brval;
		}
		this.cell.appendChild(this.combo.DOMParent);

		this.combo.DOMParent.style.margin = "0";
		
		this.combo.DOMelem_input.focus();
		this.combo.setSize(this.cell.offsetWidth-2);
		if (!this.combo._xml) {
			if (this.combo.getIndexByValue(this.cell.combo_value)!=-1) {
				this.combo.selectOption(this.combo.getIndexByValue(this.cell.combo_value));
			} else {
				if (this.combo.getOptionByLabel(val)) {
					this.combo.selectOption(this.combo.getIndexByValue(this.combo.getOptionByLabel(val).value));
				} else {
					this.combo.setComboText(val);
				}
			}
		} else {
			this.combo.setComboText(val);
		}
		this.combo.openSelect();
	}
	
	this.selectComboOption = function(val,obj){
		obj.selectOption(obj.getIndexByValue(obj.getOptionByLabel(val).value));
	}
	
	this.getValue = function(val){
		return this.cell.combo_value||"";
	}
	
	this.getText = function(val){
		var c = this.cell;
		if (this._combo_pre == "" && c.childNodes[1]) {
			c = c.childNodes[1];
		} else {
			c.childNodes[0].childNodes[1];
		}
		return (_isIE ? c.innerText : c.textContent);
	}
	
	this.setValue = function(val){
		
		if (typeof(val) == "object"){
			
			this.cell._brval = this.initCombo();
			var index = this.cell._cellIndex;
			var idd = this.cell.parentNode.idd;
			if (!val.firstChild) {
				this.cell.combo_value = "&nbsp;";
				this.cell._clearCell = true;
			} else {
				this.cell.combo_value = val.firstChild.data;
			}
			this.setComboOptions(this.cell._brval, val, this.grid, index, idd);
			
		} else {
			this.cell.combo_value = val;
			var cm = null;
			if ((cm = this.cell._brval) && (typeof(this.cell._brval) == "object")) {
				val = (cm.getOption(val)||{}).text||val;
			} else if (cm = this.grid._col_combos[this.cell._cellIndex]||((this.grid._fake) && (cm = this.grid._fake._col_combos[this.cell._cellIndex]))) {
				val = (cm.getOption(val)||{}).text||val;
			}
			
			if ((val||"").toString()._dhx_trim()=="") val = null;
			
			if (val !== null) {
				this.setComboCValue(val);
			} else {
				this.setComboCValue("&nbsp;", "");
				this.cell._clearCell = true;
			}
		}
	}
	
	this.detach = function(){
		var p = this.combo.getParent();
		if (p.parentNode == this.cell) {
			this.cell.removeChild(p);
		} else {
			return false;
		}
		var val = this.cell.combo_value;
		if (!this.combo.getComboText() || this.combo.getComboText().toString()._dhx_trim()=="") {
			this.setComboCValue("&nbsp;");
			this.cell._clearCell=true;
		} else {
			this.setComboCValue(this.combo.getComboText().replace(/\&/g,"&amp;").replace(/</g,"&lt;").replace(/>/g,"&gt;"),this.combo.getActualValue());
			this.cell._clearCell = false;
		}
		this.combo._confirmSelect();
		this.cell.combo_value = this.combo.getActualValue();
		this.combo.closeAll();
		this.grid._still_active=true;
		this.grid.setActive(1);
		return val!=this.cell.combo_value;
	}
}


eXcell_combo.prototype = new eXcell;
eXcell_combo_v = function(cell){
	var combo = new eXcell_combo(cell);
	combo._combo_pre = "<img src='"+(window.dhx_globalImgPath?window.dhx_globalImgPath:this.grid.imgURL)+"combo_select"+(dhtmlx.skin?"_"+dhtmlx.skin:"")+".gif' class='dhxgrid_combo_icon'/>";
	return combo;
};

eXcell_combo.prototype.initCombo = function(index){
	
	var container = document.createElement("DIV");
	container.className = "dhxcombo_in_grid_parent";
	var type = this.grid.defVal[arguments.length?index:this.cell._cellIndex];
	var combo = new dhtmlXCombo(container, "combo", 0, type);
	this.grid.defVal[arguments.length?index:this.cell._cellIndex] = "";
	
	var grid = this.grid;
	combo.DOMelem.onmousedown = combo.DOMelem.onclick = function(e){
		e = e||event;
		e.cancelBubble = true;
	};
	combo.DOMelem.onselectstart = function(e){
		e = e||event;
		e.cancelBubble = true;
		return true;
	};
	
	combo.attachEvent("onKeyPressed",function(ev){
		if (ev==13 || ev==27) {
			grid.editStop();
			if (grid._fake) grid._fake.editStop();
		}
	});
	
	return combo;
	
};

eXcell_combo.prototype.fillColumnCombos = function(grid,xml){
	if (!xml) return;
	var top  = dhx4.ajax.xmltop("rows", xml, -1);
	if (top && top.tagName !== "DIV"){
		grid.combo_columns = grid.combo_columns||[];
		columns = dhx4.ajax.xpath("//column", top);
		for (var i=0; i<columns.length; i++) {
			if ((columns[i].getAttribute("type")||"").indexOf("combo") == 0) {
				grid.combo_columns[grid.combo_columns.length] = i;
				this.setComboOptions(grid._col_combos[i], columns[i], grid, i);
			}
		}
	}
};

eXcell_combo.prototype.setComboCValue = function(value, value2) {
   	if (this._combo_pre != "") {
		var height = (this.cell.offsetHeight?this.cell.offsetHeight+"px":0);
   		value = "<div style='width:100%;position:relative;height:100%;overflow:hidden;'>"+this._combo_pre+"<span>"+value+"</span></div>";
   	}
   	if (arguments.length > 1) {
  		this.setCValue(value,value2);
	} else {
		this.setCValue(value);
	}
};

eXcell_combo.prototype.setComboOptions = function(combo, obj, grid, index, idd) {
	
	if (window.dhx4.s2b(obj.getAttribute("xmlcontent"))) {
		
		if (!obj.getAttribute("source")) {
			options = obj.childNodes;
			var _optArr = [];
			for (var i=0; i < options.length; i++){
				if(options[i].tagName =="option"){
					var text_opt = options[i].firstChild? options[i].firstChild.data:"";
					_optArr[_optArr.length]= [options[i].getAttribute("value"),text_opt];
				}
			}
			combo.addOption(_optArr)
			if(arguments.length == 4){
				grid.forEachRowA(function(id){
						var c = grid.cells(id,index);
						if(!c.cell._brval&&!c.cell._cellType&&(c.cell._cellIndex==index)){
							if(c.cell.combo_value=="") c.setComboCValue("&nbsp;","");
							else{
								if(!combo.getOption(c.cell.combo_value))
									c.setComboCValue(c.cell.combo_value);
								else c.setComboCValue(combo.getOption(c.cell.combo_value).text);
							}
						}
				});	
			}
			else {
				var c = (this.cell)?this:grid.cells(idd,index);
				if(obj.getAttribute("text")) {
					if(obj.getAttribute("text")._dhx_trim()=="") c.setComboCValue("&nbsp;",""); 
					else c.setComboCValue(obj.getAttribute("text")); 
				}
				else{
					if((!c.cell.combo_value)||(c.cell.combo_value._dhx_trim()=="")) c.setComboCValue("&nbsp;","");
					else{
						if(!combo.getOption(c.cell.combo_value))
							c.setComboCValue(c.cell.combo_value);
						else c.setComboCValue(combo.getOption(c.cell.combo_value).text);
					}
				}
			}
			
		}
	}
	
	if (obj.getAttribute("source")) {
		if (obj.getAttribute("auto") && window.dhx4.s2b(obj.getAttribute("auto"))) {
			
			if (obj.getAttribute("xmlcontent")) {
				var c = (this.cell)?this:grid.cells(idd,index);
				if (obj.getAttribute("text")) c.setComboCValue(obj.getAttribute("text"));
			} else {
				grid.forEachRowA(function(id){
					var c = grid.cells(id,index);
					if (!c.cell._brval && !c.cell._cellType) {
						var str = c.cell.combo_value.toString();
						if (str.indexOf("^") != -1) {
							var arr = str.split("^");
							c.cell.combo_value = arr[0];
							c.setComboCValue(arr[1]);
						}
					}
				});
			}
			combo.enableFilteringMode(true, obj.getAttribute("source"), window.dhx4.s2b(obj.getAttribute("cache")||true), window.dhx4.s2b(obj.getAttribute("sub")||false));
			
		} else {
			
			var that = this;
			var length = arguments.length; 
			combo.load(obj.getAttribute("source"), function(){
				if (length == 4) {
					grid.forEachRow(function(id){
						var c = grid.cells(id,index);
						if (!c.cell._brval && !c.cell._cellType) {
							if (combo.getOption(c.cell.combo_value)) {
								c.setComboCValue(combo.getOption(c.cell.combo_value).text);
							} else {
								if ((c.cell.combo_value||"").toString()._dhx_trim() == "") {
									c.setComboCValue("&nbsp;","");
									c.cell._clearCell=true;
								} else {
									c.setComboCValue(c.cell.combo_value);
								}
							}
						}
					});
				} else {
					//var c = (that.cell)? that : grid.cells(idd,index);
					var c = grid.cells(idd,index);
					//c.setCValue(obj.getAttribute("text"));
					if (combo.getOption(c.cell.combo_value)) {
						c.setComboCValue(combo.getOption(c.cell.combo_value).text);
					} else {
						c.setComboCValue(c.cell.combo_value);
					}
				}
			});
			
		}
	}
	if (!obj.getAttribute("auto") || !window.dhx4.s2b(obj.getAttribute("auto"))) {
		if (obj.getAttribute("editable") && !window.dhx4.s2b(obj.getAttribute("editable"))) combo.readonly(true);
		if (obj.getAttribute("filter") && window.dhx4.s2b(obj.getAttribute("filter"))) combo.enableFilteringMode(true);
	}
	
};

eXcell_combo.prototype.getCellCombo = function() {
	
	if (this.cell._brval) return this.cell._brval;
	
	this.cell._brval = this.initCombo();
	return this.cell._brval;
	
};

eXcell_combo.prototype.refreshCell = function() {
	this.setValue(this.getValue());
};

dhtmlXGridObject.prototype.getColumnCombo = function(index) {
	if (this._col_combos && this._col_combos[index]) return this._col_combos[index];
	
	if (!this._col_combos) this._col_combos = [];
	this._col_combos[index] = eXcell_combo.prototype.initCombo.call({grid:this},index);
	return this._col_combos[index];
	
};

dhtmlXGridObject.prototype.refreshComboColumn = function(index) {
	this.forEachRow(function(id){
		if (this.cells(id,index).refreshCell) this.cells(id,index).refreshCell();
	});
};


/*
Product Name: dhtmlxSuite 
Version: 4.1.3 
Edition: Professional 
License: content of this file is covered by DHTMLX Commercial or Enterprise license. Usage without proper license is prohibited. To obtain it contact sales@dhtmlx.com
Copyright UAB Dinamenta http://www.dhtmlx.com
*/

/**
*	@desc: multi select list editor
*	@returns: dhtmlxGrid cell editor object
*	@type: public
*/
function eXcell_clist(cell){
	try{
		this.cell = cell;
		this.grid = this.cell.parentNode.grid;
	}catch(er){}
	this.edit = function(){
					this.val = this.getValue();
                    var a=(this.cell._combo||this.grid.clists[this.cell._cellIndex]);
                    if (!a) return;
					this.obj = document.createElement("DIV");
                    var b=this.val.split(",");
                    var text="";

                    for (var i=0; i<a.length; i++){
                        var fl=false;
                        for (var j=0; j<b.length; j++)
                            if (a[i]==b[j]) fl=true;
                        if (fl)
                         text+="<div><input type='checkbox' id='dhx_clist_"+i+"' checked='true' /><label for='dhx_clist_"+i+"'>"+a[i]+"</label></div>";
                        else
                         text+="<div><input type='checkbox' id='dhx_clist_"+i+"'/><label for='dhx_clist_"+i+"'>"+a[i]+"</label></div>";
                    }
                    text+="<div><input type='button' value='"+(this.grid.applyButtonText||"Apply")+"' style='width:100px; font-size:8pt;' onclick='this.parentNode.parentNode.editor.grid.editStop();'/></div>"

                    this.obj.editor=this;
                    this.obj.innerHTML=text;
                    document.body.appendChild(this.obj);
                    this.obj.style.position="absolute";
					this.obj.className="dhx_clist";
					this.obj.onclick=function(e){  (e||event).cancelBubble=true; return true; };
					var arPos = this.grid.getPosition(this.cell);
                    this.obj.style.left=arPos[0]+"px";
                    this.obj.style.top=arPos[1]+this.cell.offsetHeight+"px";

                    this.obj.getValue=function(){
                        var text="";
                        for (var i=0; i<this.childNodes.length-1; i++)
                            if (this.childNodes[i].childNodes[0].checked){
                                if (text) text+=", ";
                                    text+=this.childNodes[i].childNodes[1].innerHTML;
                                }
                        return text.replace(/&amp;/g,"&");
                    }
				}
	this.getValue = function(){
		//this.grid.editStop();
		if (this.cell._clearCell) return "";
		return this.cell.innerHTML.toString()._dhx_trim().replace(/&amp;/g,"&").replace(/, /g, ",");
	}

	this.detach = function(val){
                    if (this.obj){
    					this.setValue(this.obj.getValue());
                        this.obj.editor=null;
                        this.obj.parentNode.removeChild(this.obj);
                        this.obj=null;
                        }
					return this.val!=this.getValue();
				}
}
eXcell_clist.prototype = new eXcell;

eXcell_clist.prototype.setValue = function(val){
						if (typeof(val)=="object"){
							var optCol=dhx4.ajax.xpath("./option",val);
                            if (optCol.length)
                            	this.cell._combo=[];
                                for (var j=0;j<optCol.length; j++)
									this.cell._combo.push(optCol[j].firstChild?optCol[j].firstChild.data:"");
							val=val.firstChild.data;
						}
						if (val==="" || val === this.undefined){
							this.setCTxtValue(" ",val);
							this.cell._clearCell=true;
						}
						else{
                            val = val.replace(/,[ ]*/g, ", ");
                        	this.setCTxtValue(val);
                        	this.cell._clearCell=false;
                        }
					}

/**
*	@desc: register list of values for CList cell
*	@param: col - index of CList collumn
*	@param: list - array of list data
*	@type:  public
*   @edition: Professional
*/
dhtmlXGridObject.prototype.registerCList=function(col,list){
    if (!this.clists) this.clists=new Array();
	if (typeof(list)!="object") list=list.split(",");
    this.clists[col]=list;
    }

//(c)dhtmlx ltd. www.dhtmlx.com

/*
 Product Name: dhtmlxSuite
 Version: 4.1.3
 Edition: Professional
 License: content of this file is covered by DHTMLX Commercial or Enterprise license. Usage without proper license is prohibited. To obtain it contact sales@dhtmlx.com
 Copyright UAB Dinamenta http://www.dhtmlx.com
 */

/**
 *	@desc: calculator editor
 *	@returns: dhtmlxGrid cell editor object
 *	@type: public
 */
function eXcell_calck(cell){
	try{
		this.cell = cell;
		this.grid = this.cell.parentNode.grid;
	}catch(er){}
	this.edit = function(){
		this.val = this.getValue();

		var arPos = this.grid.getPosition(this.cell);
		this.obj = new calcX(arPos[0], arPos[1]+this.cell.offsetHeight, this, this.val);
		this.obj.old_value = this.val;
	};
	this.getValue = function(){
		//this.grid.editStop();
		return this.grid._aplNFb ? this.grid._aplNFb(this.cell.innerHTML.toString()._dhx_trim(),this.cell._cellIndex) : this.cell.value;
	};
	this.detach = function(){
		if (this.obj) {
			this.setValue(this.obj.inputZone.value);
			this.obj.removeSelf();
		}
		this.obj=null;
		return this.val!=this.getValue();
	};

	function calcX(left, top, onReturnSub, val){
		this.top=(top||0)-22;
		this.left=left||0;
		this.onReturnSub=onReturnSub||null;

		this.operandA=0;
		this.operandB=0;
		this.operatorA="";
		this.state=0;
		this.dotState=0;

		var that = this;

		function out_click(e){
			if(e.target != that.onReturnSub.cell && e.path.indexOf(that.topNod) == -1){
				that.removeSelf();
				that.onReturnSub.grid.editStop(false);
			}
		}

		if(!onReturnSub.grid._aplNFb)
			document.addEventListener('click', out_click, false);


		this.calckGo=function(){
			return Math.round((eval((this.operandA || "0")+"*1"+this.operatorA+this.operandB+"*1"))*1000)/1000;
		};

		this.isNumeric=function(str){
			return ((str.search(/[^1234567890]/gi)==-1)?(true):(false));
		};
		this.isOperation=function(str){
			return ((str.search(/[^\+\*\-\/]/gi)==-1)?(true):(false));
		};
		this.onCalcKey=function(e)
		{
			var z=this.innerHTML,
				rZone=that.inputZone;

			if (((that.state==0)||(that.state==2))&&(that.isNumeric(z))){
				if(!((e||event) instanceof KeyboardEvent)){
					(e||event).preventDefault();
					if (rZone.value!="0"){
						if(rZone.selectionStart == rZone.selectionEnd)
							rZone.value+=z;
						else
							rZone.value= rZone.value.substr(0, rZone.selectionStart) + z + rZone.value.substr(rZone.selectionEnd);
					}

					else rZone.value=z;
				}
			}else
				(e||event).preventDefault();

			if ((((that.state==0)||(that.state==2))&&(z=='.'))&&(that.dotState==0)) {
				that.dotState=1;
				rZone.value+=z;
			}
			if ((z=="±"))  {
				rZone.value=rZone.value*(-1);
				//that.dotState=0;
				that.state=0;
			}
			if ((that.state==0)&&(that.isOperation(z)))  { that.operatorA=z;  that.operandA=rZone.value; that.state=1; }
			if ((that.state==2)&&(that.isOperation(z)))  { that.operandB=rZone.value; rZone.value=that.calckGo(); that.operatorA=z;  that.operandA=rZone.value; that.state=1; }
			if ((that.state==2)&&(z=="="))  { that.operandB=rZone.value; rZone.value=that.calckGo(); that.operatorA=z;  that.operandA=rZone.value; that.state=3; }
			if ((that.state==1)&&(that.isNumeric(z))) { rZone.value=z; that.state=2;  that.dotState=0 }
			if ((that.state==3)&&(that.isNumeric(z))) { rZone.value=z; that.state=0; }
			if ((that.state==3)&&(that.isOperation(z))) { that.operatorA=z;  that.operandA=rZone.value; that.state=1; }

			if (z=="e") { rZone.value=Math.E;  if (that.state==1) that.state=2; that.dotState=0   }
			if (z=="p") { rZone.value=Math.PI; if (that.state==1) that.state=2; that.dotState=0  }

			if (z=="Off"){
				rZone.value = that.old_value;
				that.removeSelf();
			}else
				rZone.focus();

			if (e||event)
				(e||event).cancelBubble=true;


		};
		this.sendResult=function(){
			if (that.state==2){
				var rZone=that.inputZone;
				that.operandB=rZone.value;
				rZone.value=that.calckGo();
				that.operatorA=z;
				that.operandA=rZone.value;
				that.state=3; }
			var z=that.inputZone.value;

			if(that.onReturnSub.cell && that.onReturnSub.cell.value != undefined)
				that.onReturnSub.cell.value = z;

			that.removeSelf();
			that.onReturnSub.grid.editStop(false);
		};

		this.removeSelf=function(){
			if (this.topNod.parentNode)
				this.topNod.parentNode.removeChild(this.topNod);

			document.removeEventListener('click', out_click);
		};

		this.keyDown=function(){
			this.className="calcPressed";
		};

		this.keyUp=function(){
			this.className="calcButton";
		};

		this.init_table=function(){

			var table=this.topNod.childNodes[0];

			if ((!table)||(table.tagName!="TABLE"))
				return;
			var root = table.childNodes[0].childNodes;

			for (var i=1; i<root.length; i++)
				for (var j=0; j<root[i].childNodes.length; j++){

					root[i].childNodes[j].onclick=this.onCalcKey;
					root[i].childNodes[j].onmousedown=this.keyDown;
					root[i].childNodes[j].onmouseout=this.keyUp;
					root[i].childNodes[j].onmouseup=this.keyUp;
				}
			this.inputZone=this.topNod.childNodes[0].childNodes[0].childNodes[0].childNodes[0].childNodes[0].childNodes[0].childNodes[0].childNodes[0].childNodes[0];
			if (this.onReturnSub)
			{
				this.topNod.childNodes[0].childNodes[0].childNodes[0].childNodes[0].childNodes[0].childNodes[0].childNodes[0].childNodes[1].onclick=this.sendResult;
				this.topNod.childNodes[0].childNodes[0].childNodes[0].childNodes[0].childNodes[0].childNodes[0].childNodes[0].childNodes[1].calk=this;
			}
			else this.topNod.childNodes[0].childNodes[0].childNodes[0].childNodes[0].childNodes[0].childNodes[0].childNodes[0].childNodes[1].innerHTML="";

			this.inputZone.onkeydown=function(evt){

				var keyCode = evt.keyCode;

				evt.cancelBubble=true;

				function return_prevent(btn){
					if(btn){
						that.keyDown.call(btn, evt);
						that.onCalcKey.call(btn, evt);
						setTimeout(function () {
							that.keyUp.call(btn, evt);
						}, 60);
					}else
						return btn;
				}

				if (keyCode == 13 || keyCode == 9) {
					that.sendResult.call({calk: that});
					return return_prevent(false);

				}else if(keyCode == 27){
					rZone.value = that.old_value;
					that.removeSelf();
					return return_prevent(false);

				}else if(keyCode == 188 || keyCode == 190 || keyCode == 191 || keyCode == 110){
					return return_prevent(root[5].childNodes[1]);	// точка

				}else if(keyCode == 109 || keyCode == 189){
					return return_prevent(root[4].childNodes[3]);	// минус

				}else if(keyCode == 111){
					return return_prevent(root[1].childNodes[3]);	// деление

				}else if(keyCode == 106){
					return return_prevent(root[2].childNodes[3]);	// умножение

				}else if(keyCode == 107 || keyCode == 187){
					return return_prevent(root[3].childNodes[3]);	// плюс

				}else if(keyCode == 96 || keyCode == 48){
					return return_prevent(root[5].childNodes[0]);	// 0

				}else if(keyCode == 97 || keyCode == 49){
					return return_prevent(root[4].childNodes[0]);	// 1

				}else if(keyCode == 98 || keyCode == 50){
					return return_prevent(root[4].childNodes[1]);	// 2

				}else if(keyCode == 99 || keyCode == 51){
					return return_prevent(root[4].childNodes[2]);	// 3

				}else if(keyCode == 100 || keyCode == 52){
					return return_prevent(root[3].childNodes[0]);	// 4

				}else if(keyCode == 101 || keyCode == 53){
					return return_prevent(root[3].childNodes[1]);	// 5

				}else if(keyCode == 102 || keyCode == 54){
					return return_prevent(root[3].childNodes[2]);	// 6

				}else if(keyCode == 103 || keyCode == 55){
					return return_prevent(root[2].childNodes[0]);	// 7

				}else if(keyCode == 104 || keyCode == 56){
					return return_prevent(root[2].childNodes[1]);	// 8

				}else if(keyCode == 105 || keyCode == 57){
					return return_prevent(root[2].childNodes[2]);	// 9

				}else if((keyCode == 8)	// забой
					|| (keyCode == 46) // del
					|| (keyCode >= 16 && keyCode <= 18) // shift-alt-control
					|| (keyCode >= 35 && keyCode <= 40)	// кнопки навигации
					|| (keyCode >= 96 && keyCode <= 105)
					|| (keyCode >= 112 && keyCode <= 123)	// F1-F12
				)
					return;

				else
					return return_prevent(false);

			};
			that.inputZone.focus();
		};

		this.drawSelf=function(){
			var div=document.createElement("div");
			div.className="calcTable";
			div.style.position="absolute";
			div.style.top=this.top+"px";
			div.style.left=this.left+"px";
			div.innerHTML="<table cellspacing='0' id='calc_01' class='calcTable'><tr><td colspan='4' style='padding: 0px;'><table cellpadding='1' cellspacing='0' width='100%'><tr><td width='100%' style='overflow:hidden; padding: 0px;'><input type='search' class='calcInput' value='0' align='right'></td><td class='calkSubmit'>Ok</td></tr></table></td></tr><tr><td class='calcButton' width='25%'>Off</td><td class='calcButton' width='25%'>p</td><td class='calcButton' width='25%'>e</td><td class='calcButton' width='25%'>/</td></tr><tr><td class='calcButton'>7</td><td class='calcButton'>8</td><td class='calcButton'>9</td><td class='calcButton'>*</td></tr><tr><td class='calcButton'>4</td><td class='calcButton'>5</td><td class='calcButton'>6</td><td class='calcButton'>+</td></tr><tr><td class='calcButton'>1</td><td class='calcButton'>2</td><td class='calcButton'>3</td><td class='calcButton'>-</td></tr><tr><td class='calcButton'>0</td><td class='calcButton'>.</td><td class='calcButton' style='font-family: Arial, Helvetica; font-size: 12pt;'>±</td><td class='calcButton'>=</td></tr></table>";
			div.onclick=function(e){ (e||event).cancelBubble=true; };
			document.body.appendChild(div);
			this.topNod=div;
		};

		this.drawSelf();
		this.init_table();

		if (val){
			var rZone=this.inputZone;
			rZone.value=val*1;
			this.operandA=val*1;
			rZone.select();
			this.state=0;
			this.dotState= this.operandA == Math.round(this.operandA) ? 0 : 1;
		}
		return this;
	};
}

if(!window.eXcell)
	window.eXcell = function eXcell() { };
eXcell_calck.prototype = new eXcell;
eXcell_calck.prototype.setValue = function(val){
	if(!val || val.toString()._dhx_trim()=="")
		val="0";
	else
		val=parseFloat(val);
	if(this.grid._aplNF)
		this.setCValue(this.grid._aplNF(val, this.cell._cellIndex), val);
};


//(c)dhtmlx ltd. www.dhtmlx.com
/*
Product Name: dhtmlxSuite 
Version: 4.1.3 
Edition: Professional 
License: content of this file is covered by DHTMLX Commercial or Enterprise license. Usage without proper license is prohibited. To obtain it contact sales@dhtmlx.com
Copyright UAB Dinamenta http://www.dhtmlx.com
*/

/**
*   @desc: switch current row state (collapse/expand) tree grid row
*   @param: obj - row object
*   @type: private
*/
dhtmlXGridObject.prototype._updateTGRState=function(z){ 
	if (!z.update || z.id==0) return;
	if (this.rowsAr[z.id].imgTag)
	this.rowsAr[z.id].imgTag.src=this.iconTree+z.state+".gif";
	z.update=false;
}


dhtmlXGridObject.prototype.doExpand=function(obj){  
	this.editStop();
    var row = obj.parentNode.parentNode.parentNode;
	var r=this._h2.get[row.idd];
	if (!this.callEvent("onOpen",[row.idd,(r.state=="plus"?-1:1)])) return;
    if(r.state=="plus")
      this.expandKids(row)
    else
   	  if((r.state=="minus")&&(!r._closeable))
          this.collapseKids(row)
}


function dhtmlxHierarchy(){
		
		var z={id:0, childs:[], level:-1, parent:null, index:0, state:dhtmlXGridObject._emptyLineImg};
		this.order=[z];
		this.get={"0":z};

		this.swap=function(a,b){
			var p=a.parent;
			var z=a.index;
			p.childs[z]=b;
			p.childs[b.index]=a;
			a.index=b.index; b.index=z;
		}
		this.forEachChildF=function(id,funct,that,funct2){
			var z=this.get[id];
			for (var i=0; i<z.childs.length; i++){
				if (!funct.apply((that||this),[z.childs[i]])) continue;
				if (z.childs[i].childs.length) this.forEachChildF(z.childs[i].id,funct,that,funct2);
				if (funct2) funct2.call((that||this),z.childs[i]);
			}
		}
		this.forEachChild=function(id,funct,that){
				var z=this.get[id];
				for (var i=0; i<z.childs.length; i++){
					funct.apply((that||this),[z.childs[i]]);
					if (z.childs[i].childs.length) this.forEachChild(z.childs[i].id,funct,that);
				}
		}
		this.change=function(id,name,val){
			var z=this.get[id];
			if (z[name]==val) return;
				z[name]=val;
				z.update=true;
		}
		this.add=function(id,parentId){ 
			return this.addAfter(id,parentId);
		}
		this.addAfter=function(id,parentId,afterId,fix){  
			var z=this.get[parentId||0];
			if (afterId)
				var ind=this.get[afterId].index+(fix?0:1);
			else var ind=z.childs.length;
			
			var x={id:id, childs:[], level:z.level+1, parent:z, index:ind, state:dhtmlXGridObject._emptyLineImg}
			if (z.state==dhtmlXGridObject._emptyLineImg)  this.change(parentId,"state",(parentId==0?"minus":"plus"));
			
			if (afterId){
				for (var i=ind; i<z.childs.length; i++) z.childs[i].index++;
				z.childs=z.childs.slice(0,ind).concat([x]).concat(z.childs.slice(ind,z.childs.length));
			}else
				z.childs.push(x);
			this.get[id]=x;
			return x;
		}
		this.addBefore=function(id,parentId,beforeId){
			return this.addAfter(id,parentId,beforeId,true)
		}		
		this.remove=function(id){  
			var z=this.get[id||0];
			for (var i=0; i<z.childs.length; i++)
				this.deleteAll(z.childs[i].id)
			z.childs=[];	
			z.parent.childs=z.parent.childs.slice(0,z.index).concat(z.parent.childs.slice(z.index+1));				
			for (var i=z.index; i<z.parent.childs.length; i++)
				z.parent.childs[i].index--;
			delete this.get[id];
		}
		this.deleteAll=function(id){
			var z=this.get[id||0];
			for (var i=0; i<z.childs.length; i++)
				this.deleteAll(z.childs[i].id)
				
			z.childs=[];				
			delete this.get[id];
		}		
		
		return this;
	}

dhtmlXGridObject.prototype._getOpenLenght=function(id,start){
	
	var z=this._h2.get[id].childs;
	start+=z.length;
	for (var i=0; i<z.length; i++)
		if (z[i].childs.length && z[i].state=='minus')
			start+=this._getOpenLenght(z[i].id,0);
	return start;
}
/**
*   @desc: close row of treegrid (removes kids from dom)
*   @param: curRow - row to process kids of
*   @type: private
*/
dhtmlXGridObject.prototype.collapseKids=function(curRow){ 
	var r=this._h2.get[curRow.idd];
    if (r.state!="minus") return;
    if (!this.callEvent("onOpenStart",[curRow.idd,1])) return;

    var start = curRow.rowIndex;
    //why Safari doesn't support standards?
    if (start<0) start=this.rowsCol._dhx_find(curRow)+1;

   	this._h2.change(r.id,"state","plus");
   	this._updateTGRState(r);

    if (this._srnd || this.pagingOn){
    	this._h2_to_buff();
    	this._renderSort();
    } else {
    var len=this._getOpenLenght(this.rowsCol[start-1].idd,0);
    for (var i=0; i<len; i++)
    	this.rowsCol[start+i].parentNode.removeChild(this.rowsCol[start+i]);
    this.rowsCol.splice(start,len);
	}

    //if (this._cssEven && !this._cssSP)
    this.callEvent("onGridReconstructed",[]);

    this.setSizes();
    this._h2_to_buff();
    this.callEvent("onOpenEnd",[curRow.idd,-1]);
}



dhtmlXGridObject.prototype._massInsert=function(r,start,ind,skip){  
	var anew=[];
	var par=(_isKHTML?this.obj:this.obj.rows[0].parentNode)
	this._h2_to_buff();
	if (this._srnd || this.pagingOn) return this._renderSort();
	var len=this._getOpenLenght(r.id,0);
	for(var i=0;i<len;i++){
		var ra=this.render_row(ind+i);
		if (start)
			start.parentNode.insertBefore(ra,start);
		else
			par.appendChild(ra);
		anew.push(ra)
		}
	this.rowsCol=dhtmlxArray(this.rowsCol.slice(0,ind).concat(anew).concat(this.rowsCol.slice(ind)));
	
	return r.childs.length+anew.length;
}
/**
*   @desc: change parent of row, correct kids collections
*   @param: curRow - row to process
*   @type: private
*/
dhtmlXGridObject.prototype.expandKids=function(curRow,sEv){

	var r=this._h2.get[curRow.idd];
	if ((!r.childs.length)&&(!r._xml_await)) return;
	if (r.state!="plus") return;
    
    
    if (!r._loading && !sEv)
    	if (!this.callEvent("onOpenStart",[r.id,-1])) return;
        


   var start = this.getRowIndex(r.id)+1;
   if(r.childs.length){
        r._loading=false;
        this._h2.change(r.id,"state","minus")
        this._updateTGRState(r);
		var len=this._massInsert(r,this.rowsCol[start],start);
		
		//if (this._cssEven && !this._cssSP)
		this.callEvent("onGridReconstructed",[]);
			

   }else{	
        if (r._xml_await){
			r._loading=true;
			if (this.callEvent("onDynXLS",[r.id]))
				this.load(this.kidsXmlFile+""+(this.kidsXmlFile.indexOf("?")!=-1?"&":"?")+"id="+encodeURIComponent(r.id), this._data_type);
        }
   }
    this.setSizes();
    if (!r._loading)
    this.callEvent("onOpenEnd",[r.id,1]);
    this._fixAlterCss();
}

dhtmlXGridObject.prototype.kidsXmlFile = "";



/**
*   @desc: sorts treegrid by specified column
*   @param: col - column index
*   @param:   type - str.int.date
*   @param: order - asc.desc
*   @type: public
*   @edition: Professional
*   @topic: 2,3,5,9
*/
dhtmlXGridObject.prototype.sortTreeRows = function(col,type,order){
				var amet="getValue";
				if (this.cells5({parentNode:{grid:this}},this.getColType(col)).getDate){ //FIXME! move inside cells5 in 2.2
					amet="getDate";
					type="str";
				}		
					

	            this.forEachRow(function(id){
                	var z=this._h2.get[id];
                	if (!z) return;
                	
                	var label=this._get_cell_value(z.buff,col,amet);
                	if(type=='int'){
						   z._sort=parseFloat(label);
						   z._sort=isNaN(z._sort)?-99999999999999:z._sort;
                     }else
                        z._sort=label;
                	});
                	
				var self=this;
				var pos=1; var neg=-1;
				if (order=="des") { pos=-1; neg=1; }
					
				var funct=null;
				if (typeof type == "function")
					funct = function(a,b){
						return type(a._sort, b._sort, order, a.id, b.id);
					}
				else {
	                if(type=='cus')
    	                 funct=function(a,b){
                            return self._customSorts[col](a._sort,b._sort,order,a.id,b.id);
                         };
     	
                   if(type=='str')
                     funct=function(a,b){return (a._sort<b._sort?neg:(a._sort==b._sort?0:pos))}

                  if(type=='int')
                     funct=function(a,b){return (a._sort<b._sort?neg:(a._sort==b._sort?0:pos))}

                  if(type=='date')
                     funct=function(a,b){return (Date.parse(new Date(a._sort||"01/01/1900"))-Date.parse(new Date(b._sort||"01/01/1900")))*pos}
                  }
                  this._sortTreeRows(funct,0);
                  this._renderSort(0,true);

            this.callEvent("onGridReconstructed",[]);
               
}

dhtmlXGridObject.prototype._sortTreeRows = function(funct,id){
				var ar=this._h2.get[id].childs;
				if (this.rowsCol.stablesort)
					this.rowsCol.stablesort.call(ar,funct);
				else
					ar.sort(funct);
					
				for (var i=0; i<ar.length; i++){
					if (ar[i].childs.length) 
						this._sortTreeRows(funct,ar[i].id);
					ar[i].index=i;
				}
};
dhtmlXGridObject.prototype._renderSort = function(id,mode){ 
	this._h2_to_buff();
	var top=this.objBox.scrollTop;
	this._reset_view();
	this.objBox.scrollTop=top;
};

dhtmlXGridObject.prototype._fixAlterCssTGR = function(){ 
if (!this._realfake)	
	this._h2.forEachChild(0,function(x){
		if (x.buff.tagName=="TR"){
			var cs=(this._cssSP?(x.level%2):(x.index%2))?this._cssUnEven:this._cssEven;
			this.rowsAr[x.id].className=(cs + (this._cssSU?(" "+cs+"_"+x.level):""))+" "+(this.rowsAr[x.id]._css||"")+((this.rowsAr[x.id].className.indexOf("rowselected") != -1)?" rowselected":"");
		}
	},this);
}
dhtmlXGridObject.prototype.moveRowUDTG = function(id,dir){ 
	var x=this._h2.get[id];
	var p=x.parent.childs[x.index+dir]
	if ((!p) || (p.parent!=x.parent)) return;
	var state=[x.state,p.state];
	this.collapseKids(this.rowsAr[x.id]);
	this.collapseKids(this.rowsAr[p.id]);	
	var ind = this.rowsCol._dhx_find(this.rowsAr[id]);
	var bInd = this.rowsBuffer._dhx_find(this.rowsAr[id]);
	
	var nod=this.obj.rows[0].parentNode.removeChild(this.rowsCol[ind]);	
	var tar=this.rowsCol[ind+((dir==1)?2:dir)];
	if (tar)
		tar.parentNode.insertBefore(nod,tar);
	else
		this.obj.rows[0].parentNode.appendChild(nod);
	this.rowsCol._dhx_swapItems(ind,ind+dir)
	this.rowsBuffer._dhx_swapItems(bInd,bInd+dir);
	this._h2.swap(p,x);
	
	
	if (state[0]=="minus") this.expandKids(this.rowsAr[x.id]);
	if (state[1]=="minus") this.expandKids(this.rowsAr[p.id]);	
	
	this._fixAlterCss(Math.min(ind,ind+dir));
}

/**
*   @desc: TreeGrid cell constructor (only for TreeGrid package)
*   @param: cell - cell object
*   @type: public
*/
function eXcell_tree(cell){
   if (cell){
      this.cell = cell;
      this.grid = this.cell.parentNode.grid;
   }
   this.isDisabled = function(){ return this.cell._disabled||this.grid._edtc; }
   this.edit = function(){
        if ((this.er)||(this.grid._edtc)) return;
        this.er=this.cell.parentNode.valTag;
        this.val=this.getLabel();
        this.cell.atag=((!this.grid.multiLine)&&(_isKHTML||_isMacOS||_isFF)) ? "INPUT" : "TEXTAREA";
        this.er.innerHTML="<"+this.cell.atag+" class='dhx_combo_edit' type='text' style='height:"+(this.cell.offsetHeight-4)+"px;line-height:"+(this.cell.offsetHeight-6)+"px; width:100%; border:0px; margin:0px; padding:0px; overflow:hidden;'></"+this.cell.atag+">";
        this.er.childNodes[0].onmousedown = function(e){(e||event).cancelBubble = true}
        this.er.childNodes[0].onselectstart=function(e){  if (!e) e=event; e.cancelBubble=true; return true;  };
        this.er.className+=" editable";
        this.er.firstChild.onclick = function(e){(e||event).cancelBubble = true};
        this.er.firstChild.value=this.val;
        this.obj=this.er.firstChild;
		this.er.firstChild.style.width=Math.max(0,this.cell.offsetWidth-this.er.offsetLeft-2)+"px";
        this.er.firstChild.focus();
        if (_isIE)
			this.er.firstChild.focus();
    }
   this.detach = function(){
        if (!this.er) return;
            this.setLabel(this.er.firstChild.value);
            this.er.className=this.er.className.replace("editable","");
            var z=(this.val!=this.er.innerHTML);

			this.obj=this.er=null;
        return (z);
    }
   this.getValue = function(){
   		return this.getLabel();
   }

    
    /**
    *   @desc: get image of treegrid item
    *   @param: content - new text of label
    *   @type: private
    */
   this.setImage = function(url){
        this.cell.parentNode.imgTag.nextSibling.src=this.grid.iconURL+url;
        this.grid._h2.get[this.cell.parentNode.idd].image=url;
   }
    /**
    *   @desc: set image of treegrid item
    *   @param: content - new text of label
    *   @type: private
    */
   this.getImage = function(){
   		return this.grid._h2.get[this.cell.parentNode.idd].image;
   }

   /**
   *   @desc: sets text representation of cell ( setLabel doesn't triger math calculations as setValue do)
   *   @param: val - new value
   *   @type: public
   */
   this.setLabel = function(val){
                  this.setValueA(val);
            }

   /**
   *   @desc: sets text representation of cell ( setLabel doesn't triger math calculations as setValue do)
   *   @param: val - new value
   *   @type: public
   */
   this.getLabel = function(val){
     return this.cell.parentNode.valTag.innerHTML;
    }
}
    /**
    *   @desc: set value of grid item
    *   @param: val  - new value (for treegrid this method only used while adding new rows)
    *   @type: private
    */
	
eXcell_tree.prototype = new eXcell;
    /**
    *   @desc: set label of treegrid item
    *   @param: content - new text of label
    *   @type: private
    */
   eXcell_tree.prototype.setValueA = function(content){
   		this.cell.parentNode.valTag.innerHTML=content;
		this.grid.callEvent("onCellChanged",[this.cell.parentNode.idd,this.cell._cellIndex,content])
    }
	eXcell_tree.prototype.setValue = function(valAr){
		if (this.cell.parentNode.imgTag)
			return this.setLabel(valAr);
			
			
		if ((this.grid._tgc.iconTree==null)||(this.grid._tgc.iconTree!=this.grid.iconTree)){
			var _tgc={};
			_tgc.spacer="<img src='"+this.grid.iconTree+"blank.gif'  align='top' class='space'>";
			_tgc.imst="<img style='margin-top:-2px;' src='"+this.grid.iconTree;
			_tgc.imsti="<img style='padding-top:2px;'  src='"+(this.grid.iconURL||this.grid.iconTree);
			_tgc.imact="' align='top' onclick='this."+(_isKHTML?"":"parentNode.")+"parentNode.parentNode.parentNode.parentNode.grid.doExpand(this);event.cancelBubble=true;'>"
			_tgc.plus=_tgc.imst+"plus.gif"+_tgc.imact;
			_tgc.minus=_tgc.imst+"minus.gif"+_tgc.imact;
			_tgc.blank=_tgc.imst+"blank.gif"+_tgc.imact;
			_tgc.start="<div class='treegrid_cell' style='overflow:hidden; white-space : nowrap; line-height:23px; height:"+(_isIE?21:23)+"px;'>";
			
			_tgc.itemim="' align='top' "+(this.grid._img_height?(" height=\""+this.grid._img_height+"\""):"")+(this.grid._img_width?(" width=\""+this.grid._img_width+"\""):"")+" ><span id='nodeval'>";
			_tgc.close="</span></div>";
			this.grid._tgc=_tgc;
		}
		var _h2=this.grid._h2;
		var _tgc=this.grid._tgc;
				
		var rid=this.cell.parentNode.idd;
		var row=this.grid._h2.get[rid];
		
		if (this.grid.kidsXmlFile || this.grid._slowParse) { 
			row.has_kids=(row.has_kids||(this.cell.parentNode._attrs["xmlkids"]&&(row.state!="minus")));
			row._xml_await=!!row.has_kids;
		}
		
		
		row.image=row.image||(this.cell._attrs["image"]||"leaf.gif");
		row.label=valAr;
               
        var html=[_tgc.start];
		
        for(var i=0;i<row.level;i++)
        	html.push(_tgc.spacer);
        
       //if has children
        if(row.has_kids){
        	html.push(_tgc.plus);
        	row.state="plus"
        	}
        else
        	html.push(_tgc.imst+row.state+".gif"+_tgc.imact);
                        
		html.push(_tgc.imsti);
		html.push(row.image);
		html.push(_tgc.itemim);
		html.push(row.label);
		html.push(_tgc.close);
		
                    

		this.cell.innerHTML=html.join("");
		this.cell._treeCell=true;
		this.cell.parentNode.imgTag=this.cell.childNodes[0].childNodes[row.level];
		this.cell.parentNode.valTag=this.cell.childNodes[0].childNodes[row.level+2];
		if (_isKHTML) this.cell.vAlign="top";
		if (row.parent.id!=0 && row.parent.state=="plus") {
				this.grid._updateTGRState(row.parent,false);
				this.cell.parentNode._skipInsert=true;		
			}

		this.grid.callEvent("onCellChanged",[rid,this.cell._cellIndex,valAr]);
	}
    
dhtmlXGridObject.prototype._process_tree_xml=function(top,pid){
	this._parsing=true;
	var main=false;
	if (!pid){
		this.render_row=this.render_row_tree;
		main=true;
		
		pid=top.getAttribute("parent")||0;
		if (pid=="0") pid=0;
		if (!this._h2)	 this._h2=new dhtmlxHierarchy();
		if (this._fake) this._fake._h2=this._h2;
	} 

	var rows=dhx4.ajax.xpath(this.xml.row, top);
	this._open=this._open||[];
	for (var i=0; i < rows.length; i++) {
		var id=rows[i].getAttribute("id");
		if (!id) {
			id=this.uid();
			rows[i].setAttribute("id",id);
		}
		var row=this._h2.add(id,pid);
		row.buff={ idd:id, data:rows[i], _parser: this._process_xml_row, _locator:this._get_xml_data };
		if (rows[i].getAttribute("open")){
			row.state="minus";
			this._open.push(id);
		}
		
		this.rowsAr[id]=row.buff;
		this._process_tree_xml(rows[i],id);
	}
	if (main){ 
		if (!rows.length) this._h2.change(pid,"state",dhtmlXGridObject._emptyLineImg);
		else if (pid!=0 && !this._srnd) {
			this._h2.change(pid,"state","minus");
		}
		for (var i=0; i < this._open.length; i++) {
			var r=this._h2.get[this._open[i]];
			if (!r.childs.length)
					r.state=dhtmlXGridObject._emptyLineImg;
		};
		
		this._updateTGRState(this._h2.get[pid]);
		this._h2_to_buff();
		if (pid!=0 && this._srnd) this.openItem(pid);
		else {
			if (this.pagingOn)
				this._renderSort();
			else
				this.render_dataset();
		}

		if (this.kidsXmlFile){
			for (var i=0; i < this._open.length; i++) {
				var r=this._h2.get[this._open[i]];
				if (r._xml_await) 
					this.expandKids({idd:r.id});
			}
		}
		this._open=[];

		if (this._slowParse===false){
			this.forEachRow(function(id){
				this.render_row_tree(0,id)
			})
		}
		this._parsing=false;
		if (pid!=0 && !this._srnd) {
		    this.callEvent("onOpenEnd",[pid,1]);
		}
	}
}	
dhtmlXGridObject.prototype._h2_to_buff=function(top){
	if (!top){
		top=this._h2.get[0];
		this.rowsBuffer = new dhtmlxArray();
		if (this._fake && !this._realfake) this._fake.rowsBuffer = this.rowsBuffer;
	}
	for (var i=0; i < top.childs.length; i++) {
		this.rowsBuffer.push(top.childs[i].buff);
		if (top.childs[i].state == "minus")
			this._h2_to_buff(top.childs[i]);
	}
};
dhtmlXGridObject.prototype.render_row_tree=function(ind,id){ 
	if (id){
		var r=this._h2.get[id];
		r=r?r.buff:r;
	} else
	var r=this.rowsBuffer[ind];
	if (!r) 
		return -1;
	
	if (r._parser){
		if (this.rowsAr[r.idd] && this.rowsAr[r.idd].tagName=="TR")
			return this._h2.get[r.idd].buff=this.rowsBuffer[ind]=this.rowsAr[r.idd];
		var row=this._prepareRow(r.idd);
		this.rowsAr[r.idd]=row;

		if (!id)
			this.rowsBuffer[ind]=row;
		this._h2.get[r.idd].buff=row;	//treegrid specific
		
		r._parser.call(this,row,r.data);
		this._postRowProcessing(row);		
		
		return row;
		}
	return r;
}
    
    /**
    *   @desc: remove row from treegrid
    *   @param: node  - row object
    *   @type: private
    */
dhtmlXGridObject.prototype._removeTrGrRow=function(node,x){ 
		 if(x){
		     this._h2.forEachChild(x.id,function(x){
		     	this._removeTrGrRow(null,x);
	    		delete this.rowsAr[x.id];
    		},this);
    		return;
		 }
		 
		 var ind=this.getRowIndex(node.idd);
		 var x=this._h2.get[node.idd];
		 
		 
		 if (ind!=-1 && ind!==this.undefined){// in case of dnd we can receive delete command for some child item, which was not rendered yet
		 	var len=1;
		 	if (x && x.state=="minus") len+=this._getOpenLenght(x.id,0)
		 	for (var i=0; i<len; i++)
		 		if (this.rowsCol[i+ind])
            		this.rowsCol[i+ind].parentNode.removeChild(this.rowsCol[i+ind]);
            if (this._fake){
            	for (var i=0; i<len; i++)
            		if (this._fake.rowsCol[i+ind])
            			this._fake.rowsCol[i+ind].parentNode.removeChild(this._fake.rowsCol[i+ind]);
            	if (len>1)
            		this._fake.rowsCol.splice(ind+1,len-1);
        	}
            	
	         this.rowsCol.splice(ind,len);
	         this.rowsBuffer.splice(ind,len);
	         
	    }
	    
	    if (!x) return;
	    this._removeTrGrRow(null,x);
    		
    	delete this.rowsAr[x.id];
	
    	if (x.parent.childs.length==1){
    		this._h2.change(x.parent.id,"state",dhtmlXGridObject._emptyLineImg);
    		this._updateTGRState(x.parent);
    	}
    	this._h2.remove(x.id);
      }




/**
*   @desc: expand row
*   @param: rowId - id of row
*   @type:  public
*   @edition: Professional
*   @topic: 7
*/
dhtmlXGridObject.prototype.openItem=function(rowId){
		var y=this._h2.get[rowId||0];
        var x=this.getRowById(rowId||0);
		if (!x) return;
        if (y.parent && y.parent.id!=0)
        	this.openItem(y.parent.id);
        this.expandKids(x);
}

dhtmlXGridObject.prototype._addRowClassic=dhtmlXGridObject.prototype.addRow;

    /**
    *   @desc: add new row to treeGrid
    *   @param: new_id  - new row id
    *   @param: text  - array of row label
    *   @param: ind  - position of row (set to null, for using parentId)
    *   @param: parent_id  - id of parent row
    *   @param: img  - img url for new row
    *   @param: child - child flag [optional]
    *   @type: public
    *   @edition: Professional
    */
dhtmlXGridObject.prototype.addRow=function(new_id,text,ind,parent_id,img,child){ 
	if (!this._h2) return this._addRowClassic(new_id,text,ind);
	parent_id=parent_id||0;
	var trcol=this.cellType._dhx_find("tree");
    if (typeof(text)=="string") text=text.split(this.delim);
    var row=this._h2.get[new_id];
    if (!row){
	    if (parent_id==0) ind=this.rowsBuffer.length;
	    else{
	    	ind=this.getRowIndex(parent_id)+1;
			if (this._h2.get[parent_id].state=="minus") 
				ind+=this._getOpenLenght(parent_id,0);
            else
				this._skipInsert=true;
            }
}
	row=row||this._h2.add(new_id,parent_id);
	row.image=img;
	row.has_kids=child;
    return row.buff=this._addRowClassic(new_id,text,ind);
}
    /**
    *   @desc: add new row to treeGrid, before some other row
    *   @param: new_id  - new row id
    *   @param: text  - array of row label
    *   @param: sibl_id  - id of row, related to which new one will be added
    *   @param: img  - img url for new row
    *   @param: child - child flag [optional]
    *   @type: public
    *   @edition: Professional
    */
dhtmlXGridObject.prototype.addRowBefore=function(new_id,text,sibl_id,img,child){
	var sb=this.rowsAr[sibl_id];
	if (!sb) return;
	if (!this._h2) return this.addRow(new_id,text,this.getRowIndex(sibl_id));
	var pid=this._h2.get[sibl_id].parent.id;

	var ind=this.getRowIndex(sibl_id);
	if (ind==-1) this._skipInsert=true;
	this._h2.addBefore(new_id,pid,sibl_id);
	return this.addRow(new_id,text,ind,this._h2.get[sibl_id].parent.id,img,child);
}
    /**
    *   @desc: add new row to treeGrid, after some other row
    *   @param: new_id  - new row id
    *   @param: text  - array of row label
    *   @param: sibl_id  - id of row, related to which new one will be added
    *   @param: img  - img url for new row
    *   @param: child - child flag [optional]
    *   @type: public
    *   @edition: Professional
    */
dhtmlXGridObject.prototype.addRowAfter=function(new_id,text,sibl_id,img,child){
	var sb=this.rowsAr[sibl_id];
	if (!sb) return;
	if (!this._h2) return this.addRow(new_id,text,this.getRowIndex(sibl_id)+1);
	var pid=this._h2.get[sibl_id].parent.id;

	var ind=this.getRowIndex(sibl_id);
	if (ind==-1) this._skipInsert=true;
	if (this._h2.get[sibl_id].state=="minus") ind+=this._getOpenLenght(sibl_id,0)+1;	
	else	ind++;
	
	this._h2.addAfter(new_id,pid,sibl_id);
	return this.addRow(new_id,text,ind,pid,img,child);
}





dhtmlXGridObject.prototype.enableSmartXMLParsing=function(mode) {
	this._slowParse=dhx4.s2b(mode);
};



    /**
    *   @desc: copy content between different rows
    *   @param: frRow  - source row object
    *   @param: from_row_id  - source row id
    *   @param: to_row_id  - target row id
    *   @type: private
    */
dhtmlXGridObject.prototype._copyTreeGridRowContent=function(frRow,from_row_id,to_row_id){
    var z=this.cellType._dhx_find("tree");
    for(i=0;i<frRow.cells.length;i++){
        if (i!=z)
           this.cells(to_row_id,i).setValue(this.cells(from_row_id,i).getValue())
        else
            this.cells(to_row_id,i).setValueA(this.cells(from_row_id,i).getValue())

    }
}

/**
*   @desc: collapse row
*   @param: rowId - id of row
*   @type:  public
*   @edition: Professional
*   @topic: 7
*/
dhtmlXGridObject.prototype.closeItem=function(rowId){
        var x=this.getRowById(rowId);
        if (!x) return;
        this.collapseKids(x);
}
/**
*   @desc: delete all childs of row in question
*   @param: rowId - id of row
*   @type:  public
*   @edition: Professional
*   @topic: 7
*/
dhtmlXGridObject.prototype.deleteChildItems=function(rowId){
        var z=this._h2.get[rowId];
        if (!z) return;
        while (z.childs.length)
            this.deleteRow(z.childs[0].id);
            
}
/**
*   @desc: get list of id of all nested rows
*   @param: rowId - id of row
*   @type:  public
*   @returns: list of id of all nested rows
*   @edition: Professional
*   @topic: 7
*/
dhtmlXGridObject.prototype.getAllSubItems=function(rowId){
        var str=[];
        var z=this._h2.get[rowId||0];
        if (z)
        for (var i=0; i<z.childs.length; i++){
            str.push(z.childs[i].id);
            if (z.childs[i].childs.length)
            str=str.concat(this.getAllSubItems(z.childs[i].id).split(this.delim));
            }

        return str.join(this.delim);
}

/**
*   @desc: get id of child item at specified position
*   @param: rowId - id of row
*   @param: ind - child node index
*   @type:  public
*   @returns: id of child item at specified position
*   @edition: Professional
*   @topic: 7
*/
dhtmlXGridObject.prototype.getChildItemIdByIndex=function(rowId,ind){
		var z=this._h2.get[rowId||0];
        if (!z) return null;
        return (z.childs[ind]?z.childs[ind].id:null);
}

/**
*   @desc: get real caption of tree col
*   @param: rowId - id of row
*   @type:  public
*   @edition: Professional
*   @returns: real caption of tree col
*   @topic: 7
*/
dhtmlXGridObject.prototype.getItemText=function(rowId){
        return this.cells(rowId,this.cellType._dhx_find("tree")).getLabel();
}

/**
*   @desc: return open/close state of row
*   @param: rowId - id of row
*   @type:  public
*   @returns: open/close state of row
*   @edition: Professional
*   @topic: 7
*/
dhtmlXGridObject.prototype.getOpenState=function(rowId){
        var z=this._h2.get[rowId||0];
        if (!z) return;
        if (z.state=="minus") return true;
        return false;
}
/**
*   @desc: return id of parent row
*   @param: rowId - id of row
*   @type:  public
*   @edition: Professional
*   @returns: id of parent row
*   @topic: 7
*/
dhtmlXGridObject.prototype.getParentId=function(rowId){
        var z=this._h2.get[rowId||0];
        if ((!z) || (!z.parent)) return null;
        return z.parent.id;
}
/**
*   @desc: return list of child row id, sparated by comma
*   @param: rowId - id of row
*   @type:  public
*   @edition: Professional
*   @returns: list of child rows
*   @topic: 7
*/
dhtmlXGridObject.prototype.getSubItems=function(rowId){
      var str=[];
      var z=this._h2.get[rowId||0];
      if (z)
      	for (var i=0; i<z.childs.length; i++)
      		str.push(z.childs[i].id);
      return str.join(this.delim);
}


/**
*   @desc: expand all tree structure
*   @type:  public
*   @edition: Professional
*   @topic: 7
*/
dhtmlXGridObject.prototype.expandAll=function(rowId){
	this._renderAllExpand(rowId||0);
	this._h2_to_buff();
	this._reset_view();
	this.setSizes();
	this.callEvent("onGridReconstructed",[]);
	if (this._redrawLines) this._redrawLines();
}
	
dhtmlXGridObject.prototype._renderAllExpand=function(z){
	var x=this._h2.get[z].childs;
	for (var i=0; i<x.length; i++){
		if (x[i].childs.length){
			this._h2.change(x[i].id,"state","minus")
			this._updateTGRState(x[i]);
			this._renderAllExpand(x[i].id)
		}
	}
}
/**
*   @desc: collapse all tree structure
*   @type:  public
*   @edition: Professional
*   @topic: 7
*/
dhtmlXGridObject.prototype.collapseAll=function(rowId){
	this._h2.forEachChild((rowId||0),function(z){
		if (z && z.state=="minus"){
			z.state="plus";
			z.update=true;
			this._updateTGRState(z);
		}
	},this);
	this._h2_to_buff();
	this._reset_view();
	this.setSizes();
	this.callEvent("onGridReconstructed",[]);
	if (this._redrawLines) this._redrawLines();
}

/**
*   @desc: return children count
*   @param: rowId - id of row
*   @type:  public
*   @edition: Professional
*   @returns: children count
*   @topic: 7
*/
dhtmlXGridObject.prototype.hasChildren=function(rowId){
        var x=this._h2.get[rowId];
        if (x && x.childs.length) return x.childs.length;
        if (x._xml_await) return -1;
        return 0;
}


/**
*   @desc: enable/disable closing of row
*   @param: rowId - id of row
*   @param: status - true/false
*   @type:  public
*   @edition: Professional
*   @topic: 7
*/

dhtmlXGridObject.prototype.setItemCloseable=function(rowId,status){
        var x=this._h2.get[rowId];
        if (!x) return;
        x._closeable=(!dhx4.s2b(status));
}
/**
*   @desc: set real caption of tree col
*   @param: rowId - id of row
*   @param: newtext - new text
*   @type:  public
*   @edition: Professional
*   @topic: 7
*/
dhtmlXGridObject.prototype.setItemText=function(rowId,newtext){
	return this.cells(rowId,this.cellType._dhx_find("tree")).setLabel(newtext);
}


/**
*   @desc: set image of tree col
*   @param: rowId - id of row
*   @param: url - image url
*   @type:  public
*   @edition: Professional
*   @topic: 7
*/
dhtmlXGridObject.prototype.setItemImage=function(rowId,url){
	this._h2.get[rowId].image=url; 
	this.rowsAr[rowId].imgTag.nextSibling.src=(this.iconURL||"")+url; 
}

/**
*   @desc: get image of tree col
*   @param: rowId - id of row
*   @type:  public
*   @edition: Professional
*   @topic: 7
*/
dhtmlXGridObject.prototype.getItemImage=function(rowId){
	this.getRowById(rowId);
	return this._h2.get[rowId].image;  
}


/**
*   @desc: set size of treegrid images
*   @param: width -  width of image
*   @param: height - height of image
*   @type:  public
*   @edition: Professional
*   @topic: 7
*/
dhtmlXGridObject.prototype.setImageSize=function(width,height){
        this._img_width=width;
        this._img_height=height;
}


dhtmlXGridObject.prototype._getRowImage=function(row){
	return this._h2.get[row.idd].image;    
        }


/**
*     @desc: set function called before tree node opened/closed
*     @param: func - event handling function
*     @type: public
*     @topic: 0,10
*     @event:  onOpenStart
*     @eventdesc: Event raised immideatly after item in tree got command to open/close , and before item was opened//closed. Event also raised for unclosable nodes and nodes without open/close functionality - in that case result of function will be ignored.
            Event not raised if node opened by dhtmlXtree API.
*     @eventparam: ID of node which will be opened/closed
*     @eventparam: Current open state of tree item. -1 - item closed, 1 - item opened.
*     @eventreturn: true - confirm opening/closing; false - deny opening/closing;
*/
   dhtmlXGridObject.prototype.setOnOpenStartHandler=function(func){  this.attachEvent("onOpenStart",func); };
   
/**
*     @desc: set function called after tree node opened/closed
*     @param: func - event handling function
*     @type: public
*     @topic: 0,10
*     @event:  onOpenEnd
*     @eventdesc: Event raised immideatly after item in tree got command to open/close , and before item was opened//closed. Event also raised for unclosable nodes and nodes without open/close functionality - in that case result of function will be ignored.
            Event not raised if node opened by dhtmlXtree API.
*     @eventparam: ID of node which will be opened/closed
*     @eventparam: Current open state of tree item. -1 - item closed, 1 - item opened.
*/
   dhtmlXGridObject.prototype.setOnOpenEndHandler=function(func){  this.attachEvent("onOpenEnd",func);   };


    /**
*     @desc: enable/disable editor of tree cell ; enabled by default
*     @param: mode -  (boolean) true/false
*     @type: public
*     @topic: 0
*/
   dhtmlXGridObject.prototype.enableTreeCellEdit=function(mode){
        this._edtc=!dhx4.s2b(mode);
    };



/**
*   @desc: return level of treeGrid row
*   @param: rowId - id of row
*   @type:  public
*   @returns: level of treeGrid row
*   @topic: 7
*/
dhtmlXGridObject.prototype.getLevel=function(rowId){      
        var z=this._h2.get[rowId||0];
        if (!z) return -1;
        return z.level;
}

dhtmlXGridObject.prototype._fixHiddenRowsAllTG=function(ind,state){
  for (i in this.rowsAr){
     if ((this.rowsAr[i])&&(this.rowsAr[i].childNodes))
        this.rowsAr[i].childNodes[ind].style.display=state;
  }
}

dhtmlXGridObject._emptyLineImg="blank";
//(c)dhtmlx ltd. www.dhtmlx.com


/*
Product Name: dhtmlxSuite 
Version: 4.1.3 
Edition: Professional 
License: content of this file is covered by DHTMLX Commercial or Enterprise license. Usage without proper license is prohibited. To obtain it contact sales@dhtmlx.com
Copyright UAB Dinamenta http://www.dhtmlx.com
*/

if (window.dhtmlxHierarchy){
	
	if (window.dhtmlXCellObject)
		dhtmlXCellObject.prototype.attachPropertyGrid = function() {
			var p = this.attachGrid();
			new dhtmlXPropertyGrid(p);
			return p;
		}
	
	function eXcell_tree_property(cell){
		if (cell){
		  this.cell = cell;
		  this.grid = this.cell.parentNode.grid;
		}
		this.isDisabled = function(){ return true; }
		this.getValue = function(){
	   		return this.cell.parentNode.valTag.innerHTML;
	   }
	}
	eXcell_tree_property.prototype = new eXcell_tree;
	eXcell_tree_property.prototype.setValue = function(valAr){
		if (this.cell.parentNode.imgTag)
			return this.setLabel(valAr);
			
			
		if ((this.grid._tgc.iconTree==null)||(this.grid._tgc.iconTree!=this.grid.iconTree)){
			var _tgc={};
			_tgc.imst="<img src='"+this.grid.iconTree;
			_tgc.imsti="<img src='"+(this.grid.iconURL||this.grid.iconTree);
			_tgc.imact="' align='absmiddle'  onclick='this."+(_isKHTML?"":"parentNode.")+"parentNode.parentNode.parentNode.parentNode.grid.doExpand(this);event.cancelBubble=true;' class='property_image'>"
			_tgc.plus=_tgc.imst+"plus.gif"+_tgc.imact;
			_tgc.minus=_tgc.imst+"minus.gif"+_tgc.imact;
			_tgc.blank=_tgc.imst+"blank.gif"+_tgc.imact;
			_tgc.start="<div style=' overflow:hidden; white-space : nowrap; height:"+(_isIE?20:21)+"px;'>";
			
			_tgc.itemim="<span "+(_isFF?"style='position:relative; top:2px;'":"")+"id='nodeval'>";
			_tgc.close="</span><div class='property_space'></div></div>";
			this.grid._tgc=_tgc;
		}
		var _h2=this.grid._h2;
		var _tgc=this.grid._tgc;
				
		var rid=this.cell.parentNode.idd;
		var row=this.grid._h2.get[rid];
		
		if (this.grid.kidsXmlFile || this.grid._slowParse) {
			row.has_kids=(row.has_kids||(this.cell.parentNode._attrs["xmlkids"]&&(row.state!="minus")));
			row._xml_await=!!row.has_kids;
		}
		
		
		row.image=row.image||(this.cell._attrs["image"]||"leaf.gif");
		row.label=valAr;
	           
	    var html=[_tgc.start];
		
	   //if has children
	    if(row.has_kids){
	    	html.push(_tgc.plus);
	    	row.state="plus"
	    	}
	    else
	    	html.push(_tgc.imst+row.state+".gif"+_tgc.imact+_tgc.itemim);
	                    
		html.push(row.label);
		html.push(_tgc.close);
		
	                
	
		this.cell.innerHTML=html.join("");
		this.cell.style.paddingLeft="0px";
		this.cell.parentNode.imgTag=this.cell.childNodes[0].childNodes[0];
		this.cell.parentNode.valTag=this.cell.childNodes[0].childNodes[1];
		if (row.childs.length) {
			this.grid.getRowById(this.cell.parentNode.idd)._attrs["class"] = " dhx_parent_row ";
			this.cell.nextSibling.style.borderLeft="1px solid #D4D0C8";
		}
		
		if (_isKHTML) this.cell.vAlign="top";
		if (row.parent.id!=0 && row.parent.state=="plus"){
			this.grid._updateTGRState(row.parent,false);
			this.cell.parentNode._skipInsert=true;		
		}
	
		this.grid.callEvent("onCellChanged",[rid,this.cell._cellIndex,valAr]);
	}
}

function eXcell_list(cell){
	if (cell){
		this.cell=cell;
		this.grid=this.cell.parentNode.grid;
	}
	this.edit=function(){
		this.cell.innerHTML="<select style='width:100%;' ></select>";
		this.obj=this.cell.firstChild;
		this.obj.onclick=function(e){
			(e||event).cancelBubble=true
		}
		this.obj.onmousedown=function(e){
			(e||event).cancelBubble=true
		}
		this.obj.onkeydown=function(e){
			var ev = (e||event);

			if (ev.keyCode == 9 || ev.keyCode == 13){
				globalActiveDHTMLGridObject.entBox.focus();
				globalActiveDHTMLGridObject.doKey({
					keyCode: ev.keyCode,
					shiftKey: ev.shiftKey,
					srcElement: "0"
					});

				return false;
			}
			ev.cancelBubble=true
		}
		
		var self=this;
		this.obj.onchange=function(){
			self.grid.editStop();
			self=null;
		}
		
		
		var opt=this.getAttribute("values").split(",");
		for (var i=0; i < opt.length; i++)
			this.obj.options[i]=new Option(opt[i],opt[i]);
		this.obj.value=this.cell._val
		this.obj.focus()
	}
	this.getValue=function(){
		return this.cell._val;
	}

	this.detach=function(){
		var val=this.obj.value;
		var sel=this.obj.selectedIndex;
		this.setValue(sel==-1?"":this.obj.options[sel].value);
		return val!= this.getValue();
	}
}
eXcell_list.prototype=new eXcell;

eXcell_list.prototype.setValue=function(val){ 
	this.cell._val=val;
	if (!val||val.toString()._dhx_trim() == ""){
		this.cell._clearCell=true;
		this.setCValue("&nbsp","");
	} else {
		this.cell._clearCell=false;
		this.setCValue(this.grid._aplNF(val, this.cell._cellIndex));
	}
}



	function dhtmlXPropertyGrid(cont){
		var t;
		if (cont.objBox)
			t = cont;
		else
			t = new dhtmlXGridObject(cont);
			
			t.setHeader("Name,Value");
			t.setColAlign("left,left");
			
			if (window.dhtmlxHierarchy){
				//treegrid available
				t.setColTypes("tree_property,ro");
				t.isTreeGrid=function(){return true;}
				t.enableSmartXMLParsing(false)
			} else
				t.setColTypes("ro,ro");
			t.setColSorting("na,na")	
			t.setInitWidths("*,*");
			t.setNoHeader(true);
			t.setSkin("dhx_skyblue");
			t.entBox.className += " gridbox_property";

			t.i18n.validation_error="Value is incorrect";
			t.attachEvent("onRowSelect",function(id,ind){
				if (!this.editor){
					this.selectCell(this.getRowIndex(id),1);
					this.editCell();
				}
			})
			t.attachEvent("onBeforeSelect",function(id){
				//if (this._h2 && this._h2.get[id].childs.length) return false;
				if (this._block_selection) return false;
				return true;
			})			
			t.attachEvent("onRowCreated",function(id,row){
				if (!this._h2 || !this._h2.get[id].childs.length){
					row.childNodes[1].style.backgroundColor="white";
				}
			})			
			t.attachEvent("onEditCell",function(stage,id,ind,nv,ov){
				if (stage==1 && this.editor && this.editor.obj && this.editor.obj.select)
					this.editor.obj.select();
				if (stage==2 && ov!=nv) {
					var val=this.cells(id,1).getAttribute("validate");
					var result=true;
					switch(val){
						case "int":
							result=(parseFloat(nv)==nv);
							break;
					}
					if (result){
						this._block_selection=false;
						this.callEvent("onPropertyChanged",[this.cells(id,0).getValue(),nv,ov]);
					} else {
						alert(this.i18n.validation_error);
						this._block_selection=true;
						var self=this;
						window.setTimeout(function(){
							self.selectCell(id,ind)
							self.editCell();
						},1)
					}
				}
				return true;
			})
			t._key_events.k13_0_0=t._key_events.k9_0_0=t._key_events.k40_0_0;
			t.getProperties=function(){
				this.editStop(true);
				var data={};
				this.forEachRow(function(id){
					data[this.cells(id,0).getValue()]=this.cells(id,1).getValue();
				});
				return data;
			}
			t.setProperties=function(data){
				this.editStop();
				this.forEachRow(function(id){
					var t=this.cells(id,0).getValue();
					if (typeof data[t] != "undefined")
						this.cells(id,1).setValue(data[t]);
				})
				this.callEvent("onPropertyChanged",[]);
			}
		return t;
	}

/*
Product Name: dhtmlxSuite 
Version: 4.1.3 
Edition: Professional 
License: content of this file is covered by DHTMLX Commercial or Enterprise license. Usage without proper license is prohibited. To obtain it contact sales@dhtmlx.com
Copyright UAB Dinamenta http://www.dhtmlx.com
*/

function dhtmlXForm(parentObj, data, skin) {
	
	this.idef = {
		position:	"label-left",
		labelWidth:	"auto",
		labelHeight:	"auto",
		inputWidth:	"auto",
		inputHeight:	"auto",
		labelAlign:	"left",
		noteWidth:	"auto",
		offsetTop:	0,
		offsetLeft:	0,
		blockOffset:	20 // block only
	};
	this.idef_const = {
		offsetNested:	20 // sub_level
	};
	this.apos_css = {
		"label-left":	"dhxform_item_label_left",
		"label-right":	"dhxform_item_label_right",
		"label-top":	"dhxform_item_label_top",
		"label-bottom":	"dhxform_item_label_bottom", // new
		"absolute":	"dhxform_item_absolute"
	};
	this.align_css = {
		left:		"dhxform_label_align_left",
		center:		"dhxform_label_align_center",
		right:		"dhxform_label_align_right"
	};
	
	var that = this;
	
	// define skin
	
	// 1) skin 3rd arg [new]
	// 2) dhtmlx.skin
	// 3) autodetect skin
	// 4) default skyblue
	
	this.setSkin = function(skin) {
		this.skin = skin;
		this.cont.className = "dhxform_obj_"+this.skin;
		this.cont.style.fontSize = (skin=="dhx_terrace"?"13px":"12px");
		this._updateBlocks();
		// update calendar skin
		this.forEachItem(function(id){
			var t = that.getItemType(id);
			if (typeof(that.items[t]) != "undefined" && typeof(that.items[t].setSkin) == "function") {
				that.doWithItem(id, "setSkin", skin);
			}
		});
	}
	
	this.skin = (skin||window.dhx4.skin||(typeof(dhtmlx)!="undefined"?dhtmlx.skin:null)||window.dhx4.skinDetect("dhx_form")||"dhx_skyblue");
	
	this.separator = ",";
	this.live_validate = false;
	
	this._type = "checkbox";
	this._rGroup = "default";
	
	this._idIndex = {};
	this._indexId = [];
	
	this.cont = (typeof(parentObj)=="object"?parentObj:document.getElementById(parentObj));
	
	if (!parentObj._isNestedForm) {
		
		this._parentForm = true;
		
		this.cont.style.fontSize = (this.skin=="dhx_terrace"?"13px":"12px");
		this.cont.className = "dhxform_obj_"+this.skin;
		
		this.setFontSize = function(fs) {
			this.cont.style.fontSize = fs;
			this._updateBlocks();
		}
		
		this.getForm = function() {
			return this;
		}
		
		this.cont.onkeypress = function(e) {
			e = (e||event);
			if (e.keyCode == 13) {
				var t = (e.target||e.srcElement);
				if (typeof(t.tagName) != "undefined" && String(t.tagName).toLowerCase() == "textarea" && !e.ctrlKey) return;
				that.callEvent("onEnter",[]);
			}
		}
		
	}
	
	this.b_index = null;
	this.base = [];
	this._prepare = function(ofsLeft, pos) {
		
		if (this.b_index == null) this.b_index = 0; else this.b_index++;
		
		// if pos specified, check all items inside all bases,
		var insBeforeBase = null; // base
		var insBeforeItem = null; // items from start to move next-items within single base
		
		if (pos != null) {
			if (pos < 0) pos = 0;
			var i = 0;
			for (var w=0; w<this.cont.childNodes.length; w++) { // bases sit here, 1 base = 1 newcolumn
				for (var q=0; q<this.cont.childNodes[w].childNodes.length; q++) { // items inside single base, i.e.between two nearest newcolumns/form_start/form_end
					if (insBeforeItem == null && this.cont.childNodes[w].childNodes[q]._isNestedForm != true) {
						if (i == pos) {
							insBeforeBase = this.cont.childNodes[w].nextSibling; // insert new column before this base
							insBeforeItem = this.cont.childNodes[w].childNodes[q]; // move all items within single base from this item to end of base to new column
						}
						i++;
					}
				}
			}
		}
		
		this.base[this.b_index] = document.createElement("DIV");
		this.base[this.b_index].className = "dhxform_base";
		
		if (typeof(ofsLeft) != "undefined") this.base[this.b_index].style.cssText += " margin-left:"+ofsLeft+"px!important;";
		
		// add block
		if (insBeforeBase != null) {
			this.cont.insertBefore(this.base[this.b_index], insBeforeBase);
			insBeforeBase = null;
		} else {
			this.cont.appendChild(this.base[this.b_index]);
		}
		
		// move items if any
		if (insBeforeItem != null) {
			while (insBeforeItem != null) {
				var t = insBeforeItem;
				insBeforeItem = insBeforeItem.nextSibling;
				this.base[this.b_index].appendChild(t);
				t = null;
			}
		}
	}
	
	
	this.setSizes = function() {
		/*
		for (var q=0; q<this.base.length; q++) {
			this.base.style.height = this.cont.offsetHeight+"px";
			this.base.style.overflow = "auto";
		}
		*/
	}
	
	this._mergeSettings = function(data) {
		
		var u = -1;
		var i = {type: "settings"};
		for (var a in this.idef) i[a] = this.idef[a];
		
		for (var q=0; q<data.length; q++) {
			if (typeof(data[q]) != "undefined" && data[q].type == "settings") {
				for (var a in data[q]) i[a] = data[q][a];
				u = q;
			}
		}
		data[u>=0?u:data.length] = i;
		return data;
	}
	
	this._genStr = function(w) {
		var s = ""; var z = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";
		for (var q=0; q<w; q++) s += z.charAt(Math.floor(Math.random() * z.length));
		return s;
	}
	
	this.idPrefix = "dhxForm_"+this._genStr(12)+"_";
	
	this._rId = (this._parentForm?this._genStr(12)+"_":parentObj._rId);
	
	this.objPull = {};
	this.itemPull = {};
	this._ic = 0;
	
	this._addItem = function(type, id, data, sId, lp, pos, insertAfter) {
		
		// id-index
		if (this.items[type]._index) {
			this.getForm()._indexId.push(id);
			this.getForm()._idIndex[id] = {ind: this.getForm()._indexId.length-1};
		}
		
		if (!type) type = this._type;
		
		if (type == "list" && lp != null && this.itemPull[this.idPrefix+lp] != null && typeof(this.itemPull[this.idPrefix+lp]._addSubListNode) == "function") {
			var tr = this.itemPull[this.idPrefix+lp]._addSubListNode();
		} else {
			if (type == "newcolumn") {
				var tr = {};
			} else {
				var insBeforeBase = this.base[this.b_index];
				var insBeforeItem = null;
				if (typeof(pos) != "undefined" && !isNaN(pos) && type != "list") {
					pos = Math.max(parseInt(pos), 0)+1;
					for (var w=0; w<this.cont.childNodes.length; w++) {
						for (var q=0; q<this.cont.childNodes[w].childNodes.length; q++) {
							if (insBeforeItem == null && this.cont.childNodes[w].childNodes[q]._isNestedForm != true) {
								pos--;
								if (pos == 0) {
									insBeforeItem = this.cont.childNodes[w].childNodes[q];
									insBeforeBase = this.cont.childNodes[w];
								}
							}
						}
					}
				} else if (type == "list") { //??
					for (var a in this.itemPull) {
						if (a == this.idPrefix+id) {
							insBeforeItem = this.itemPull[a].nextSibling;
							if (this.itemPull[a]._listBase != null && this.itemPull[a]._listBase.length > 0) {
								insBeforeItem = this.itemPull[a]._listBase[this.itemPull[a]._listBase.length-1];
							}
							
						}
					}
				}
				var tr = document.createElement("DIV");
				if (insertAfter == true && insBeforeItem != null) insBeforeItem = insBeforeItem.nextSibling;
				if (insBeforeItem != null) {
					insBeforeBase.insertBefore(tr, insBeforeItem);
				} else {
					insBeforeBase.appendChild(tr);
				}
			}
		}
		
		tr._idd = id;
		tr._rId = this._rId;
		
		if (typeof(tr.style) != "undefined") {
			// read from settings if not set
			if (typeof(data.offsetLeft) == "undefined" && this.idef.offsetLeft > 0) data.offsetLeft = this.idef.offsetLeft;
			if (typeof(data.offsetTop) == "undefined" && this.idef.offsetTop > 0) data.offsetTop = this.idef.offsetTop;
			//
			var k = "";
			if (typeof(data.offsetLeft) != "undefined") k += " padding-left:"+data.offsetLeft+"px!important;";
			if (typeof(data.offsetTop) != "undefined") k += " padding-top:"+data.offsetTop+"px!important;";
			tr.style.cssText += k;
		}
		
		if (type == "block") {
			if (isNaN(data.blockOffset)) data.blockOffset = this.idef.blockOffset;
		}
		
		if (type == "list") {
			
			if (typeof(tr._ofsNested) == "undefined") tr._ofsNested = this.idef_const.offsetNested;
			
			if (sId != null) tr._sId = sId;
			
			var listData = this.items[type].render(tr, this.skin);
			
			if (!this.itemPull[this.idPrefix+id]._listObj) this.itemPull[this.idPrefix+id]._listObj = [];
			if (!this.itemPull[this.idPrefix+id]._list) this.itemPull[this.idPrefix+id]._list = [];
			if (!this.itemPull[this.idPrefix+id]._listBase) this.itemPull[this.idPrefix+id]._listBase = [];
			
			(this.itemPull[this.idPrefix+id]._listObj).push(listData[0]);
			(this.itemPull[this.idPrefix+id]._list).push(listData[1]);
			(this.itemPull[this.idPrefix+id]._listBase).push(tr);
			
			listData[1].checkEvent = function(evName) {
				return that.checkEvent(evName);
			}
			listData[1].callEvent = function(evName, evData) {
				return that.callEvent(evName, evData);
			}
			listData[1].getForm = function() {
				return that.getForm();
			}
			listData[1]._initObj(this._mergeSettings(data));
			
			if (tr._inBlcok) tr.className += " in_block";
			
			return listData[1];
			
		}
		
		if (type == "newcolumn") {
			this._prepare(data.offset, pos);
			return;
		}
		
		if (type == "label" && this._ic++ == 0) data._isTopmost = true;
		
		data.position = this.apos_css[(!data.position||!this.apos_css[data.position]?this.idef.position:data.position)];
		tr.className = data.position+(typeof(data.className)=="string"?" "+data.className:"");
		
		if (!data.labelWidth) data.labelWidth = this.idef.labelWidth;
		if (!data.labelHeight) data.labelHeight = this.idef.labelHeight;
		
		if (typeof(data.wrap) != "undefined") data.wrap = window.dhx4.s2b(data.wrap);
			
		data.labelAlign = (this.align_css[data.labelAlign]?this.align_css[data.labelAlign]:this.align_css[this.idef.labelAlign]);
		
		data.inputWidth = (data.width?data.width:(data.inputWidth?data.inputWidth:this.idef.inputWidth));
		if (!data.inputHeight) data.inputHeight = this.idef.inputHeight;
		
		if (typeof(data.note) != "undefined") {
			if (data.note.length != null && data.note[0] != null) data.note = data.note[0]; // probably array from xml conversion
			if (typeof(data.note.width) == "undefined") data.note.width = this.idef.noteWidth;
			if (data.note.width == "auto") data.note.width = data.inputWidth;
		}
		
		tr.checkEvent = function(evName) {
			return that.checkEvent(evName);
		}
		tr.callEvent = function(evName, evData) {
			return that.callEvent(evName, evData);
		}
		tr.getForm = function() {
			return that.getForm();
		}
		tr._autoCheck = function(t) {
			that._autoCheck(t);
		}
		
		// convert r/o
		if (typeof(data.readonly) == "string") data.readonly = window.dhx4.s2b(data.readonly);
		if (typeof(data.autoStart) == "string") data.autoStart = window.dhx4.s2b(data.autoStart);
		if (typeof(data.autoRemove) == "string") data.autoRemove = window.dhx4.s2b(data.autoRemove);
		if (typeof(data.titleScreen) == "string") data.titleScreen = window.dhx4.s2b(data.titleScreen);
		if (typeof(data.info) == "string") data.info = window.dhx4.s2b(data.info);
		if (typeof(data.hidden) == "string") data.hidden = window.dhx4.s2b(data.hidden);
		if (typeof(data.checked) == "string") data.checked = window.dhx4.s2b(data.checked);
		
		// userdata
		if (typeof(data.userdata) != "undefined") {
			for (var a in data.userdata) this.getForm().setUserData(id,a,data.userdata[a]);
		}
		
		// validate
		if (data.validate) {
			if (typeof(data.validate != "undefined") && (typeof(data.validate) == "function" || typeof(window[data.validate]) == "function")) {
				tr._validate = [data.validate];
			} else {
				tr._validate = String(data.validate).split(this.separator);
			}
		}
		if (typeof(data.required) != "undefined") {
			if (typeof(data.required) == "string") data.required = window.dhx4.s2b(data.required);
			tr._required = (data.required==true);
		}
		if (tr._required) {
			if (!tr._validate) tr._validate = [];
			var p = false;
			for (q=0; q<tr._validate.length; q++) p = (p||(tr._validate[q]=="NotEmpty"));
			if (!p) tr._validate.push("NotEmpty");
		}
		
		tr._ll = (data.position == this.apos_css["label-left"] || data.position == this.apos_css["label-top"]);
		
		this.objPull[this.idPrefix+id] = this.items[type].render(tr, data);
		this.itemPull[this.idPrefix+id] = tr;
		
	}
	
	/*********************************************************************************************************************************************
		OBJECT INIT
	*********************************************************************************************************************************************/
	
	this._initObj = function(data, url) {
		
		if (typeof(data.data) != "undefined") {
			// data loading
			var id = null;
			if (typeof(url) != "undefined") {
				id = url.match(/(\?|\&)id\=([a-z0-9_\-]*)/i);
				if (id != null && id[0] != null) id = id[0].split("=")[1];
			}
			if (this.callEvent("onBeforeDataLoad", [id, window.dhx4._copyObj(data.data)]) === true) {
				this.formId = id;
				this._last_load_data = data;
				this.setFormData(data.data);
				this.resetDataProcessor("updated");
			}
			
			return;
		}
		
		// struct
		this._prepare();
		
		// search form settings
		for (var q=0; q<data.length; q++) {
			// add check for incorrect values:
			// position - allow only predefined, this.apos_css
			// labelAlign - allow only predefined, this.align_css
			// input/label top/left/width/height - numeric or auto
			if (typeof(data[q]) != "undefined" && data[q].type == "settings") for (var a in data[q]) this.idef[a] = data[q][a];
		}
		
		for (var q=0; q<data.length; q++) this._prepareItem(data[q]);
		
		this._autoCheck();
	}
	
	this._prepareItem = function(data, pos, insertAfter) {
		
		var type = (data!=null && data.type!=null ? data.type : "");
		
		if (this.items[type]) {
			
			if (!data.name) data.name = this._genStr(12);
			var id = data.name;
			if (this.objPull[this.idPrefix+id] != null || type=="radio") id = this._genStr(12);
			
			var obj = data;
			obj.label = obj.label||"";
			//obj.value = obj.value||"";
			obj.value = obj.value;
			obj.checked = window.dhx4.s2b(obj.checked);
			obj.disabled = window.dhx4.s2b(obj.disabled);
			obj.name = obj.name||this._genStr(12);
			obj.options = obj.options||[];
			obj.rows = obj.rows||"none";
			obj.uid = this._genStr(12);
			
			this._addItem(type, id, obj, null, null, pos, insertAfter);
			pos = null;
			
			if (this._parentEnabled === false) this._disableItem(id);
			
			for (var w=0; w<obj.options.length; w++) {
				if (obj.options[w].list != null) {
					if (!obj.options[w].value) obj.options[w].value = this._genStr();
					var subList = this._addItem("list", id, obj.options[w].list, obj.options[w].value, null);
					subList._subSelect = true;
					subList._subSelectId = obj.options[w].value;
				}
			}
			
			
			if (data.list != null) {
				if (!data.listParent) data.listParent = obj.name;//data[q].name;
				var subList = this._addItem("list", id, data.list, null, data.listParent);
			}
		}
	}
	
	/*********************************************************************************************************************************************
		XML
	*********************************************************************************************************************************************/
	
	this._xmlSubItems = {item: "list", option: "options", note: "note", userdata: "_userdata"};
	
	this._xmlToObject = function(xml, rootLevel) {
		
		if (typeof(rootLevel) == "undefined") rootLevel = true;
		
		if (rootLevel) {
			
			// try struct
			var xmlStruct = xml.getElementsByTagName("items");
			xmlStruct = (xmlStruct != null && xmlStruct[0] != null ? xmlStruct[0] : null);
			// try data
			var xmlData = xml.getElementsByTagName("data");
			xmlData = (xmlData != null && xmlData[0] != null ? xmlData[0] : null);
			
		} else {
			xmlStruct = xml;
		}
		
		var data = (rootLevel?[]:{});
		
		if (xmlStruct != null) {
			
			for (var q=0; q<xmlStruct.childNodes.length; q++) {
				
				if (typeof(xmlStruct.childNodes[q].tagName) != "undefined") {
					
					var tg = xmlStruct.childNodes[q].tagName;
					
					if (this._xmlSubItems[tg] != null) {
					
						var node = this._xmlSubItems[tg];
						if (typeof(data[node]) == "undefined") data[node] = [];
						
						// parse attributes
						var k = {};
						for (var w=0; w<xmlStruct.childNodes[q].attributes.length; w++) {
							var attrName = xmlStruct.childNodes[q].attributes[w].name;
							var attrValue = xmlStruct.childNodes[q].attributes[w].value;
							k[attrName] = attrValue;
						}
						
						// parse custom data
						if (node == "note") k.text = xmlStruct.childNodes[q].firstChild.nodeValue;
						
						// pasrse userdata value
						if (node == "_userdata") k.value = xmlStruct.childNodes[q].firstChild.nodeValue;
						
						// parse nested items, merge with current
						var data2 = this._xmlToObject(xmlStruct.childNodes[q], false);
						for (var a in data2) {
							if (a == "_userdata") {
								if (!k.userdata) k.userdata = {};
								for (var w=0; w<data2[a].length; w++) k.userdata[data2[a][w].name] = data2[a][w].value;
							} else {
								k[a] = data2[a];
							}
						}
						
						if (rootLevel) data.push(k); else data[node].push(k);
						
					}
				}
			}
		}
		
		if (xmlData != null) {
			data = {data:{}};
			for (var q=0; q<xmlData.childNodes.length; q++) {
				if (typeof(xmlData.childNodes[q].tagName) != "undefined") {
					var name = xmlData.childNodes[q].tagName;
					var value = (xmlData.childNodes[q].firstChild!=null?xmlData.childNodes[q].firstChild.nodeValue:"");
					data.data[name] = value;
				}
			}
		}
		
		return data;
		
	}
	
	/*********************************************************************************************************************************************
		AUTOCHECK (Global enable/disable functionality)
	*********************************************************************************************************************************************/
	
	this._autoCheck = function(enabled) {
		if (this._locked === true) {
			enabled = false;
		} else {
			if (typeof(enabled) == "undefined") enabled = true;
		}
		for (var a in this.itemPull) {
			var isEnabled = (enabled&&(this.itemPull[a]._udis!==true));
			this[isEnabled?"_enableItem":"_disableItem"](this.itemPull[a]._idd);
			
			// id-index state
			if (this.getForm()._idIndex[this.itemPull[a]._idd] != null) {
				this.getForm()._idIndex[this.itemPull[a]._idd].enabled = isEnabled;
			}
			
			// nested forms
			var pEnabled = (isEnabled&&(typeof(this.itemPull[a]._checked)=="boolean"?this.itemPull[a]._checked:true));
			if (this.itemPull[a]._list) {
				for (var q=0; q<this.itemPull[a]._list.length; q++) {
					var f = true;
					if (this.itemPull[a]._list[q]._subSelect == true) {
						f = false
						var v = this.getItemValue(this.itemPull[a]._idd);
						if (!(typeof(v) == "object" && typeof(v.length) == "number")) v = [v];
						for (var w=0; w<v.length; w++) f = (v[w]==this.itemPull[a]._list[q]._subSelectId)||f;
						this.itemPull[a]._listObj[q][f?"show":"hide"](this.itemPull[a]._listBase[q]);
					}
					this.itemPull[a]._list[q]._autoCheck(pEnabled&&f);
				}
			}
		}
	}
	
	/*********************************************************************************************************************************************
		PUBLIC API
	*********************************************************************************************************************************************/
	
	this.doWithItem = function(id, method, a, b, c, d) {
		// radio
		//console.log(method)
		
		if (typeof(id) == "object") {
			var group = id[0];
			var value = id[1];
			var item = null;
			var res = null;
			for (var k in this.itemPull) {
				if ((this.itemPull[k]._value == value || value === null) && this.itemPull[k]._group == group) return this.objPull[k][method](this.itemPull[k], a, b, c, d);
				if (this.itemPull[k]._list != null && !res) {
					for (var q=0; q<this.itemPull[k]._list.length; q++) {
						res = this.itemPull[k]._list[q].doWithItem(id, method, a, b, c);
					}
				}
			}
			if (res != null) {
				return res;
			} else {
				if (method == "getType") return this.doWithItem(id[0], "getType");
			}
		// checkbox, input, select, label
		} else {
			if (!this.itemPull[this.idPrefix+id]) {
				var res = null;
				for (var k in this.itemPull) {
					if (this.itemPull[k]._list && !res) {
						for (var q=0; q<this.itemPull[k]._list.length; q++) {
							if (res == null) res = this.itemPull[k]._list[q].doWithItem(id, method, a, b, c, d);
						}
					}
				}
				return res;
			} else {
				return this.objPull[this.idPrefix+id][method](this.itemPull[this.idPrefix+id], a, b, c, d);
			}
		}
	}
	
	this._removeItem = function(id, value) {
		if (value != null) id = this.doWithItem([id, value], "destruct"); else this.doWithItem(id, "destruct");
		this._clearItemData(id);
	}
	
	this._clearItemData = function(id) {
		if (this.itemPull[this.idPrefix+id]) {
			id = this.idPrefix+id;
			try {
				this.objPull[id] = null;
				this.itemPull[id] = null;
				delete this.objPull[id];
				delete this.itemPull[id];
			} catch(e) {}
		} else {
			for (var k in this.itemPull) {
				if (this.itemPull[k]._list) {
					for (var q=0; q<this.itemPull[k]._list.length; q++) this.itemPull[k]._list[q]._clearItemData(id);
				}
			}
		}
	}
	
	this.isItem = function(id, value) {
		if (value != null) id = [id, value];
		return this.doWithItem(id, "isExist");
	}
	
	this.getItemType = function(id, value) {
		id = [id, (value||null)];
		return this.doWithItem(id, "getType");
	}

	/* iterator */
	this.forEachItem = function(handler) {
		for (var a in this.objPull) {
			if (this.objPull[a].t == "radio") {
				handler(this.itemPull[a]._group, this.itemPull[a]._value);
			} else {
				handler(String(a).replace(this.idPrefix,""));
			}
			if (this.itemPull[a]._list) {
				for (var q=0; q<this.itemPull[a]._list.length; q++) this.itemPull[a]._list[q].forEachItem(handler);
			}
		}
	}
	
	/* text */
	this.setItemLabel = function(id, value, text) {
		if (text != null) id = [id, value]; else text = value;
		this.doWithItem(id, "setText", text);
	}
	
	this.getItemLabel = function(id, value) {
		if (value != null) id = [id, value];
		return this.doWithItem(id, "getText");
	}
	
	/* state */
	this._enableItem = function(id) {
		this.doWithItem(id, "enable");
	}
	
	this._disableItem = function(id) {
		this.doWithItem(id, "disable");
	}
	
	this._isItemEnabled = function(id) {
		return this.doWithItem(id, "isEnabled");
	}
	
	/* selection */
	this.checkItem = function(id, value) {
		if (value != null) id = [id, value];
		this.doWithItem(id, "check");
		this._autoCheck();
	}
	
	this.uncheckItem = function(id, value) {
		if (value != null) id = [id, value];
		this.doWithItem(id, "unCheck");
		this._autoCheck();
	}
	
	this.isItemChecked = function(id, value) {
		if (value != null) id = [id, value];
		return this.doWithItem(id, "isChecked");
	}
	
	this.getCheckedValue = function(id) {
		return this.doWithItem([id, null], "getChecked");
	}
	
	/* value */
	
	// get radio group by id
	this._getRGroup = function(id, val) {
		for (var a in this.itemPull) {
			if (this.itemPull[a]._group == id && (val == null || this.itemPull[a]._value == val)) return this.itemPull[a]._idd;
			if (this.itemPull[a]._list != null) {
				for (var q=0; q<this.itemPull[a]._list.length; q++) {
					var r = this.itemPull[a]._list[q]._getRGroup(id, val);
					if (r != null) return r;
				}
			}
		}
		return null;
	}
	
	this.setItemValue = function(id, value) {
		this.resetValidateCss(id, value);
		if (this.getItemType(id) == "radio") {
			if (this._getRGroup(id, value) != null) this.checkItem(id, value); else this.uncheckItem(id, this.getCheckedValue(id));
			return null;
		}
		return this.doWithItem(id, "setValue", value);
	}
	
	this.getItemValue = function(id, param) {
		if (this.getItemType(id) == "radio") return this.getCheckedValue(id);
		return this.doWithItem(id, "getValue", param);
	}
	
	this.updateValues = function() {
		this._updateValues();
	}
	
	/* visibility */
	this.showItem = function(id, value) {
		if (value != null) id = [id,value];
		this.doWithItem(id, "show");
	}
	
	this.hideItem = function(id, value) {
		if (value != null) id = [id,value];
		this.doWithItem(id, "hide");
	}
	
	this.isItemHidden = function(id, value) {
		if (value != null) id = [id,value];
		return this.doWithItem(id, "isHidden");
	}
	
	/* options (select only) */
	this.getOptions = function(id) {
		return this.doWithItem(id, "getOptions");
	}
	
	/* width/height */
	this.setItemWidth = function(id, width) {
		this.doWithItem(id, "setWidth", width);
	}
	
	this.getItemWidth = function(id) {
		return this.doWithItem(id, "getWidth");
	}
	
	this.setItemHeight = function(id, height) { // textarea
		this.doWithItem(id, "setHeight", height);
	}
	
	this.setItemFocus = function(id, value) {
		if (value != null) id = [id,value];
		this.doWithItem(id, "setFocus");
	}
	
	/* validation */
	
	// required before validate and data sending for updating values for input, password
	// datasending call validation inside
	this._updateValues = function() {
		for (var a in this.itemPull) {
			if (this.objPull[a] && typeof(this.objPull[a].updateValue) == "function") {
				this.objPull[a].updateValue(this.itemPull[a]);
			}
			if (this.itemPull[a]._list) {
				for (var q=0; q<this.itemPull[a]._list.length; q++) {
					this.itemPull[a]._list[q]._updateValues();
				}
			}
		}
	}
	
	// css
	this._getItemByName = function(id) {
		for (var a in this.itemPull) {
			if (this.itemPull[a]._idd == id) return this.itemPull[a];
			if (this.itemPull[a]._list != null) {
				for (var q=0; q<this.itemPull[a]._list.length; q++) {
					var r = this.itemPull[a]._list[q]._getItemByName(id);
					if (r != null) return r;
				}
			}
		}
		return null;
	}
	this._resetValidateCss = function(item) {
		item.className = (item.className).replace(item._vcss,"");
		item._vcss = null;
	}
	this.setValidateCss = function(name, state, custom) {
		var item = this[this.getItemType(name)=="radio"?"_getRGroup":"_getItemByName"](name);
		if (!item) return;
		if (item._vcss != null) this._resetValidateCss(item);
		item._vcss = (typeof(custom)=="string"?custom:"validate_"+(state===true?"ok":"error"));
		item.className += " "+item._vcss;
	}
	this.resetValidateCss = function(name) {
		for (var a in this.itemPull) {
			if (this.itemPull[a]._vcss != null) this._resetValidateCss(this.itemPull[a]);
			if (this.itemPull[a]._list != null) {
				for (var q=0; q<this.itemPull[a]._list.length; q++) this.itemPull[a]._list[q].resetValidateCss();
			}
		}
	}
	// action
	this.validate = function(type) {
		
		if (this.callEvent("onBeforeValidate",[]) == false) return;
		
		var completed = true;
		
		this.forEachItem(function(name, value){
			if (typeof(value) != "undefined") name = [name,value];
			var k = that.doWithItem(name,"_validate");
			if (typeof(k) != "boolean") k = true;
			completed = k && completed;
		});
		
		this.callEvent("onAfterValidate",[completed]);
		return completed;
		
	}
	
	this.validateItem = function(name, value) {
		if (typeof(value) != "undefined") name = [name,value];
		return this.doWithItem(name,"_validate");
	}
	
	this.enableLiveValidation = function(state) {
		this.live_validate = (state==true);
	}
	
	
	/* readonly */
	
	this.setReadonly = function(id, state) {
		this.doWithItem(id, "setReadonly", state);
	}
	
	this.isReadonly = function(id) {
		return this.doWithItem(id, "isReadonly");
	}
	
	/* index */
	
	this.getFirstActive = function(withFocus) {
		for (var q=0; q<this._indexId.length; q++) {
			var k = true;
			if (withFocus == true) {
				var t = this.getItemType(this._indexId[q]);
				if (!dhtmlXForm.prototype.items[t].setFocus) k = false;
			}
			if (k && this._idIndex[this._indexId[q]].enabled) return this._indexId[q];
		}
		return null;
	}
	
	this.setFocusOnFirstActive = function() {
		var k = this.getFirstActive(true);
		if (k != null) this.setItemFocus(k);
	}
	
	/* enable/disable */
	
	this.enableItem = function(id, value) {
		if (value != null) id = [id,value];
		this.doWithItem(id, "userEnable");
		this._autoCheck();
	}
	
	this.disableItem = function(id, value) {
		if (value != null) id = [id,value];
		this.doWithItem(id, "userDisable");
		this._autoCheck();
	}
	
	this.isItemEnabled = function(id, value) {
		if (value != null) id = [id,value];
		return this.doWithItem(id, "isUserEnabled");
	}
	
	this.clear = function() {
		var usedRAs = {};
		this.formId = (new Date()).valueOf();//remove form id, so next operation will be insert
		this.resetDataProcessor("inserted");
		
		for (var a in this.itemPull) {
			var t = this.itemPull[a]._idd;
			// checkbox
			if (this.itemPull[a]._type == "ch") this.uncheckItem(t);
			// input/textarea
			if (this.itemPull[a]._type in {"ta":1,"editor":1,"calendar":1,"pw":1,"hd":1})
				this.setItemValue(t, "");
			// dhxcombo
			if (this.itemPull[a]._type == "combo") {
				this.itemPull[a]._apiChange = true;
				var combo = this.getCombo(t);
				combo.selectOption(0);
				combo = null;
				this.itemPull[a]._apiChange = false;
			}
			// select
			if (this.itemPull[a]._type == "se") {
				var opts = this.getOptions(t);
				if (opts.length > 0) opts[0].selected = true;
			}
			// radiobutton
			if (this.itemPull[a]._type == "ra") {
				var g = this.itemPull[a]._group;
				if (!usedRAs[g]) { this.checkItem(g, this.doWithItem(t, "_getFirstValue")); usedRAs[g] = true; }
			}
			// nested lists
			if (this.itemPull[a]._list) for (var q=0; q<this.itemPull[a]._list.length; q++) this.itemPull[a]._list[q].clear();
			// check for custom cell
			if (this["setFormData_"+this.itemPull[a]._type]) {
				this["setFormData_"+this.itemPull[a]._type](t,"");
			}
		}
		usedRAs = null;
		if (this._parentForm) this._autoCheck();
		
		// validate
		this.resetValidateCss();
		
	}
	
	this.unload = function() {
		
		window.dhx4._enableDataLoading(this, null, null, null, "clear");
		window.dhx4._eventable(this, "clear");
		
		for (var a in this.objPull) this._removeItem(String(a).replace(this.idPrefix,""));
		
		if (this._ccTm) window.clearTimeout(this._ccTm);
		this._formLS = null;
		
		for (var q=0; q<this.base.length; q++) {
			while (this.base[q].childNodes.length > 0) this.base[q].removeChild(this.base[q].childNodes[0]);
			if (this.base[q].parentNode) this.base[q].parentNode.removeChild(this.base[q]);
			this.base[q] = null;
		}
		this.base = null;
		
		this.cont.onkeypress = null;
		this.cont.className = "";
		this.cont = null;
		
		for (var a in this) this[a] = null;
		
		that = null;
		
	}
	
	for (var a in this.items) {
		
		this.items[a].t = a;
		
		if (typeof(this.items[a]._index) == "undefined") {
			this.items[a]._index = true;
		}
		
		if (!this.items[a].show) {
			this.items[a].show = function(item) {
				item.style.display = "";
				if (item._listObj) for (var q=0; q<item._listObj.length; q++) item._listObj[q].show(item._listBase[q]);
			}
		}
		
		if (!this.items[a].hide) {
			this.items[a].hide = function(item) {
				item.style.display = "none";
				if (item._listObj) for (var q=0; q<item._listObj.length; q++) item._listObj[q].hide(item._listBase[q]);
			}
		}
		
		if (!this.items[a].isHidden) {
			this.items[a].isHidden = function(item) {
				return (item.style.display == "none");
			}
		}
		
		if (!this.items[a].userEnable) {
			this.items[a].userEnable = function(item) {
				item._udis = false;
			}
		}
			
		if (!this.items[a].userDisable) {
			this.items[a].userDisable = function(item) {
				item._udis = true;
			}
		}
		
		if (!this.items[a].isUserEnabled) {
			this.items[a].isUserEnabled = function(item) {
				return (item._udis!==true);
			}
		}
		
		if (!this.items[a].getType) {
			this.items[a].getType = function() {
				return this.t;
			}
		}
		
		if (!this.items[a].isExist) {
			this.items[a].isExist = function() {
				return true;
			}
		}
		
		if (!this.items[a]._validate) {
			this.items[a]._validate = function(item) {
				
				if (!item._validate || !item._enabled) return true;
				
				if (item._type == "ch") {
					var val = (this.isChecked(item)?this.getValue(item):0);
				} else {
					var val = this.getValue(item);
				}
				
				var r = true;
				
				for (var q=0; q<item._validate.length; q++) {
					
					var v = "is"+item._validate[q];
					
					if ((val == null || val.length == 0) && v != "isNotEmpty" && item._type != "container") {
						// field not required or empty (+ validate not set to NotEmpty)
					} else {
						var f = dhtmlxValidation[v];
						
						if (item._type == "container" && typeof(f) == "function") f = function(){return true;}
						
						if (typeof(f) != "function" && typeof(item._validate[q]) == "function") f = item._validate[q];
						if (typeof(f) != "function" && typeof(window[item._validate[q]]) == "function") f = window[item._validate[q]];
						r = ((typeof(f)=="function"?f(val,item._idd):new RegExp(item._validate[q]).test(val)) && r);
						f = null;
					}
				}
				
				if (!(item.callEvent("onValidate"+(r?"Success":"Error"),[item._idd,val,r])===false)) item.getForm().setValidateCss(item._idd, r);
				
				return r;
			}
		}
		
		
	}
	
	// lock/unlock form
	this._locked = false;
	this._doLock = function(state) {
		var t = (state===true?true:false);
		if (this._locked == t) return; else this._locked = t;
		this._autoCheck(!this._locked);
	}
	this.lock = function() {
		this._doLock(true);
	}
	this.unlock = function() {
		this._doLock(false);
	}
	this.isLocked = function() {
		return this._locked;
	}
	
	// date format for inputs
	this.setNumberFormat = function(id, format, g_sep, d_sep) {
		// return false if format incorrect and true if it successfuly applied
		return this.doWithItem(id, "setNumberFormat", format, g_sep, d_sep);
	}
	
	window.dhx4._enableDataLoading(this, "_initObj", "_xmlToObject", "items", {struct: true, data: true});
	window.dhx4._eventable(this);
	
	this.attachEvent("_onButtonClick", function(name, cmd){
		this.callEvent("onButtonClick", [name, cmd]);
	});
	
	this._updateBlocks = function() {
		this.forEachItem(function(id){
			if (that.getItemType(id) == "block" || that.getItemType(id) == "combo") {
				that.doWithItem(id,"_setCss",that.skin,that.cont.style.fontSize);
			}
		});
	}
	
	// copy init data to prevent init obj extension
	this._isObj = function(k) {
		return (k != null && typeof(k) == "object" && typeof(k.length) == "undefined");
	}
	this._copyObj = function(r) {
		if (this._isObj(r)) {
			var t = {};
			for (var a in r) {
				if (typeof(r[a]) == "object" && r[a] != null) t[a] = this._copyObj(r[a]); else t[a] = r[a];
			}
		} else {
			var t = [];
			for (var a=0; a<r.length; a++) {
				if (typeof(r[a]) == "object" && r[a] != null) t[a] = this._copyObj(r[a]); else t[a] = r[a];
			}
		}
		return t;
	}
	//
	
	if (data != null && typeof(data) == "object") {
		this._initObj(this._copyObj(data));
	};
	
	if (this._parentForm) {
		this._updateBlocks();
	}
	
	// ls for input change, affected: input, select, pwd, calendar, colorpicker
	this._ccActive = false;
	this._ccTm = null;
	
	return this;
	
};

dhtmlXForm.prototype.getInput = function(id) {
	return this.doWithItem(id, "getInput");
};

dhtmlXForm.prototype.getSelect = function(id) {
	return this.doWithItem(id, "getSelect");
};


dhtmlXForm.prototype.items = {};

/* checkbox */
dhtmlXForm.prototype.items.checkbox = {
	
	render: function(item, data) {
		
		item._type = "ch";
		item._enabled = true;
		item._checked = false;
		item._value = (typeof(data.value)=="undefined"?null:String(data.value));
		item._ro = (data.readonly==true);
		
		if (data._autoInputWidth !== false) data.inputWidth = 14;
		
		this.doAddLabel(item, data);
		this.doAddInput(item, data, "INPUT", "TEXT", true, true, "dhxform_textarea");
		
		item.childNodes[item._ll?1:0].className += " dhxform_img_node";
		
		var p = document.createElement("DIV");
		p.className = "dhxform_img chbx0";
		item.appendChild(p);
		
		if (!isNaN(data.inputLeft)) item.childNodes[item._ll?1:0].style.left = parseInt(data.inputLeft)+"px";
		if (!isNaN(data.inputTop)) item.childNodes[item._ll?1:0].style.top = parseInt(data.inputTop)+"px";
		
		item.childNodes[item._ll?1:0].appendChild(p);
		item.childNodes[item._ll?1:0].firstChild.value = String(data.value);
		
		item._updateImgNode = function(item, state) {
			var t = item.childNodes[item._ll?1:0].lastChild;
			t.className = (state?"dhxform_actv_c":"dhxform_img")+" "+(item._checked?"chbx1":"chbx0");
			item = t = null;
		}
		
		item._doOnFocus = function(item) {
			item.getForm().callEvent("onFocus",[item._idd]);
		}
		
		item._doOnBlur = function(item) {
			item.getForm().callEvent("onBlur",[item._idd]);
		}
		
		item._doOnKeyUpDown = function(evName, evObj) {
			this.callEvent(evName, [this.childNodes[this._ll?0:1].childNodes[0], evObj, this._idd]);
		}
		
		if (data.checked == true) this.check(item);
		if (data.hidden == true) this.hide(item);
		if (data.disabled == true) this.userDisable(item);
		
		this.doAttachEvents(item);
		
		return this;
	},
	
	destruct: function(item) {
		item._doOnFocus = item._doOnBlur = item._updateImgNode = null;
		this.doUnloadNestedLists(item);
		this.doDestruct(item);
	},
	
	doAddLabel: function(item, data) {
		
		var t = document.createElement("DIV");
		t.className = "dhxform_label "+data.labelAlign;
		
		if (data.wrap == true) t.style.whiteSpace = "normal";
		
		if (item._ll) {
			item.insertBefore(t,item.firstChild);
		} else {
			item.appendChild(t);
		}
		
		if (typeof(data.tooltip) != "undefined") t.title = data.tooltip;
		
		t.innerHTML = "<div class='dhxform_label_nav_link' "+
				"onfocus='if(this.parentNode.parentNode._updateImgNode)this.parentNode.parentNode._updateImgNode(this.parentNode.parentNode,true);this.parentNode.parentNode._doOnFocus(this.parentNode.parentNode);' "+
				"onblur='if(this.parentNode.parentNode._updateImgNode)this.parentNode.parentNode._updateImgNode(this.parentNode.parentNode,false);this.parentNode.parentNode._doOnBlur(this.parentNode.parentNode);' "+
				"onkeypress='var e=event||window.arguments[0];if(e.keyCode==32||e.charCode==32){e.cancelBubble=true;if(e.preventDefault)e.preventDefault();else e.returnValue=false;_dhxForm_doClick(this,\"mousedown\");return false;}' "+
				"onkeyup='var e=event||window.arguments[0];this.parentNode.parentNode._doOnKeyUpDown(\"onKeyUp\",e);' "+
				"onkeydown='var e=event||window.arguments[0];this.parentNode.parentNode._doOnKeyUpDown(\"onKeyDown\",e);' "+
				(window.dhx4.isIPad?"ontouchstart='var e=event;e.preventDefault();_dhxForm_doClick(this,\"mousedown\");' ":"")+
				"role='link' tabindex='0'>"+data.label+(data.info?"<span class='dhxform_info'>[?]</span>":"")+(item._required?"<span class='dhxform_item_required'>*</span>":"")+'</div>';
		
		if (!isNaN(data.labelWidth)) t.firstChild.style.width = parseInt(data.labelWidth)+"px";
		if (!isNaN(data.labelHeight)) t.firstChild.style.height = parseInt(data.labelHeight)+"px";
		
		if (!isNaN(data.labelLeft)) t.style.left = parseInt(data.labelLeft)+"px";
		if (!isNaN(data.labelTop)) t.style.top = parseInt(data.labelTop)+"px";
		
	},
	
	doAddInput: function(item, data, el, type, pos, dim, css) {
		
		var p = document.createElement("DIV");
		p.className = "dhxform_control";
		
		if (item._ll) {
			item.appendChild(p);
		} else {
			item.insertBefore(p,item.firstChild);
		}
		
		var t = document.createElement(el);
		t.className = css;
		t.name = item._idd;
		t._idd = item._idd;
		t.id = data.uid;
		
		if (typeof(type) == "string") t.type = type;
		
		if (el == "INPUT" || el == "TEXTAREA") {
			t.onkeyup = function(e) {
				e = e||event;
				item.callEvent("onKeyUp",[this,e,this._idd]);
			};
			t.onkeydown = function(e) {
				e = e||event;
				item.callEvent("onKeyDown",[this,e,this._idd]);
			};
		}
		
		p.appendChild(t);
		
		if (data.readonly) this.setReadonly(item, true);
		if (data.hidden == true) this.hide(item);
		if (data.disabled == true) this.userDisable(item);
		
		if (pos) {
			if (!isNaN(data.inputLeft)) p.style.left = parseInt(data.inputLeft)+"px";
			if (!isNaN(data.inputTop)) p.style.top = parseInt(data.inputTop)+"px";
		}
		
		var u = "";
		
		var dimFix = false;
		if (dim) {
			if (!isNaN(data.inputWidth)) { u += "width:"+parseInt(data.inputWidth)+"px;"; dimFix=true; }
			if (!isNaN(data.inputHeight)) u += "height:"+parseInt(data.inputHeight)+"px;";
		}
		if (typeof(data.style) == "string") u += data.style;
		t.style.cssText = u;
		
		if (data.maxLength) t.setAttribute("maxLength", data.maxLength);
		if (data.connector) t.setAttribute("connector",data.connector);
		
		var i = (dhtmlXForm.prototype.items[this.t] != null ? dhtmlXForm.prototype.items[this.t]._dimFix == true : false);
		if (dimFix && ({input: 1, password:1, select:1, multiselect:1, calendar:1, colorpicker:1}[this.t] == 1 || i)) {
			
			if (dhtmlXForm.prototype.items[this.t]._dim == null) {
				
				var testNode = document.createElement("DIV");
				testNode.className = "dhxform_dim_test_"+item.getForm().skin;
				document.body.appendChild(testNode);
				
				var pNode = p.parentNode;
				var sNode = p.nextSibling;
				testNode.appendChild(p);
				
				var w = parseInt(t.style.width);
				var w2 = (dhx4.isFF || dhx4.isIE || dhx4.isChrome || dhx4.isOpera ? t.offsetWidth : t.clientWidth);
				dhtmlXForm.prototype.items[this.t]._dim = w2-w;
				
				if (sNode != null) {
					pNode.insertBefore(p, sNode);
				} else {
					pNode.appendChild(p);
				}
				testNode.parentNode.removeChild(testNode);
				pNode = sNode = testNode = null;
			}
			
			t.style.width = parseInt(t.style.width)-dhtmlXForm.prototype.items[this.t]._dim+"px";
			
		}
		
		if (typeof(data.note) == "object") {
			var note = document.createElement("DIV");
			note.className = "dhxform_note";
			note.style.width = (isNaN(data.note.width)?t.offsetWidth:parseInt(data.note.width))+"px";
			note._w = data.note.width;
			note.innerHTML = data.note.text;
			p.appendChild(note);
			note = null;
		}
		
	},
	
	doUnloadNestedLists: function(item) {
		
		if (!item._list) return;
		for (var q=0; q<item._list.length; q++) {
			item._list[q].unload();
			item._list[q] = null;
			item._listObj[q] = null;
			item._listBase[q].parentNode.removeChild(item._listBase[q]);
			item._listBase[q] = null;
		}
		item._list = null;
		item._listObj = null;
		item._listBase = null;
	},
	
	doDestruct: function(item) {
		
		item.callEvent = null;
		item.checkEvent = null;
		item.getForm = null;
		
		item._autoCheck = null;
		item._checked = null;
		item._enabled = null;
		item._idd = null;
		item._type = null;
		item._value = null;
		item._group = null;
		
		item.onselectstart = null;
		
		item.childNodes[item._ll?1:0].onmousedown = null;
		item.childNodes[item._ll?1:0].ontouchstart = null;
		
		item.childNodes[item._ll?0:1].onmousedown = null;
		item.childNodes[item._ll?0:1].ontouchstart = null;
		
		item.childNodes[item._ll?0:1].childNodes[0].onfocus = null;
		item.childNodes[item._ll?0:1].childNodes[0].onblur = null;
		item.childNodes[item._ll?0:1].childNodes[0].onkeypress = null;
		item.childNodes[item._ll?0:1].childNodes[0].onkeyup = null;
		item.childNodes[item._ll?0:1].childNodes[0].onkeydown = null;
		item.childNodes[item._ll?0:1].childNodes[0].onmousedown = null;
		item.childNodes[item._ll?0:1].childNodes[0].ontouchstart = null;
		item.childNodes[item._ll?0:1].removeChild(item.childNodes[item._ll?0:1].childNodes[0]);
		
		while (item.childNodes.length > 0) item.removeChild(item.childNodes[0]);
		
		item.parentNode.removeChild(item);
		item = null;
		
	},
	
	doAttachEvents: function(item) {
		var that = this;
		// image click
		item.childNodes[item._ll?1:0][window.dhx4.isIPad?"ontouchstart":"onmousedown"] = function(e) {
			e = e||event;
			if (e.preventDefault) e.preventDefault();
			var t = (e.target||e.srcElement); // need to skip "note" if exists
			if (!this.parentNode._enabled || this.parentNode._ro || (typeof(t.className) != "undefined" && t.className == "dhxform_note")) {
				e.cancelBubble = true;
				if (e.preventDefault) e.preventDefault(); else e.returnValue = false;
				return false;
			}
			that.doClick(this.parentNode);
		}
		// label click
		item.childNodes[item._ll?0:1].childNodes[0][window.dhx4.isIPad?"ontouchstart":"onmousedown"] = function(e) {
			e = e||event;
			if (e.preventDefault) e.preventDefault();
			// do not check if r/o here, allow item's be highlighted, check for r/o added into doClick
			if (!this.parentNode.parentNode._enabled) {
				e.cancelBubble = true;
				if (e.preventDefault) e.preventDefault(); else e.returnValue = false;
				return false;
			}
			// check if "info" clicked (checkbox/radio only)
			var t = e.target||e.srcElement;
			if (typeof(t.className) != "undefined" && t.className == "dhxform_info") {
				this.parentNode.parentNode.callEvent("onInfo",[this.parentNode.parentNode._idd]);
				e.cancelBubble = true;
				if (e.preventDefault) e.preventDefault(); else e.returnValue = false;
				return false;
			}
			that.doClick(this.parentNode.parentNode);
		}
	},
	
	doClick: function(item) {
		
		item.childNodes[item._ll?0:1].childNodes[0].focus();
		
		if (!item._enabled || item._ro) return;
		
		if (item.checkEvent("onBeforeChange")) if (item.callEvent("onBeforeChange", [item._idd, item._value, item._checked]) !== true) return;
		
		this.setChecked(item, !item._checked);
		item._autoCheck();
		item.callEvent("onChange", [item._idd, item._value, item._checked]);
	},
	
	doCheckValue: function(item) {
		if (item._checked && item._enabled) {
			item.childNodes[item._ll?1:0].firstChild.name = String(item._idd);
			item.childNodes[item._ll?1:0].firstChild.value = this.getValue(item);
		} else {
			item.childNodes[item._ll?1:0].firstChild.name = "";
			item.childNodes[item._ll?1:0].firstChild.value = "";
		}
	},
	
	setChecked: function(item, state) {
		item._checked = (state===true?true:false);
		//item.childNodes[item._ll?1:0].lastChild.className = "dhxform_img "+(item._checked?"chbx1":"chbx0");
		item.childNodes[item._ll?1:0].lastChild.className = item.childNodes[item._ll?1:0].lastChild.className.replace(/chbx[0-1]{1}/gi,"")+(item._checked?" chbx1":" chbx0");
		this.doCheckValue(item);
	},
	
	check: function(item) {
		this.setChecked(item, true);
	},
	
	unCheck: function(item) {
		this.setChecked(item, false);
	},
	
	isChecked: function(item) {
		return item._checked;
	},
	
	enable: function(item) {
		if (String(item.className).search("disabled") >= 0) item.className = String(item.className).replace(/disabled/gi,"");
		item._enabled = true;
		item.childNodes[item._ll?0:1].childNodes[0].tabIndex = 0;
		item.childNodes[item._ll?0:1].childNodes[0].removeAttribute("disabled");
		this.doCheckValue(item);
	},
	
	disable: function(item) {
		if (String(item.className).search("disabled") < 0) item.className += " disabled";
		item._enabled = false;
		if (item._updateImgNode != null) item._updateImgNode(item, false); // clear focus on disable fix
		item.childNodes[item._ll?0:1].childNodes[0].tabIndex = -1;
		item.childNodes[item._ll?0:1].childNodes[0].setAttribute("disabled", "true");
		this.doCheckValue(item);
	},
	
	isEnabled: function(item) {
		return item._enabled;
	},
	
	setText: function(item, text) {
		item.childNodes[item._ll?0:1].childNodes[0].innerHTML = text+(item._required?"<span class='dhxform_item_required'>*</span>":"");
	},
	
	getText: function(item) {
		return item.childNodes[item._ll?0:1].childNodes[0].innerHTML.replace(/<span class=\"dhxform_item_required\">[^<]*<\/span>/g,"");
	},
	
	setValue: function(item, value) {
		this.setChecked(item,(value===true||parseInt(value)==1||value=="true"||item._value===value));
	},
	
	getValue: function(item, mode) {
		if (mode == "realvalue") return item._value;
		return ((typeof(item._value)=="undefined"||item._value==null)?(item._checked?1:0):item._value);
	},
	
	setReadonly: function(item, state) {
		item._ro = (state===true);
	},
	
	isReadonly: function(item) {
		return item._ro;
	},
	
	setFocus: function(item) {
		item.childNodes[item._ll?0:1].childNodes[0].focus();
	}
	
};

/* radio */
dhtmlXForm.prototype.items.radio = {
	
	input: {},
	
	r: {},
	
	firstValue: {},
	
	render: function(item, data, uid) {
		
		item._type = "ra";
		item._enabled = true;
		item._checked = false;
		item._group = data.name;
		item._value = data.value;
		item._uid = uid;
		item._ro = (data.readonly==true);
		item._rName = item._rId+item._group;
		
		this.r[item._idd] = item;
		
		data.inputWidth = 14;
		
		this.doAddLabel(item, data);
		this.doAddInput(item, data, "INPUT", "TEXT", true, true, "dhxform_textarea");
		
		item.childNodes[item._ll?1:0].className += " dhxform_img_node";
		
		// radio img
		var p = document.createElement("DIV");
		p.className = "dhxform_img rdbt0";
		item.appendChild(p);
		
		if (!isNaN(data.inputLeft)) item.childNodes[item._ll?1:0].style.left = parseInt(data.inputLeft)+"px";
		if (!isNaN(data.inputTop)) item.childNodes[item._ll?1:0].style.top = parseInt(data.inputTop)+"px";
		
		item.childNodes[item._ll?1:0].appendChild(p);
		
		// hidden input needed just to keep common logic, name-value should be empty to prevent sending to server from real form
		item.childNodes[item._ll?1:0].firstChild.name = "";
		item.childNodes[item._ll?1:0].firstChild.value = "";
		
		item._updateImgNode = function(item, state) {
			var t = item.childNodes[item._ll?1:0].lastChild;
			t.className = (state?"dhxform_actv_r":"dhxform_img")+" "+(item._checked?"rdbt1":"rdbt0");
			item = t = null;
		}
		
		item._doOnFocus = function(item) {
			item.getForm().callEvent("onFocus",[item._group, item._value]);
		}
		
		item._doOnBlur = function(item) {
			item.getForm().callEvent("onBlur",[item._group, item._value]);
		}
		
		item._doOnKeyUpDown = function(evName, evObj) {
			this.callEvent(evName, [this.childNodes[this._ll?0:1].childNodes[0], evObj, this._group, this._value]);
		}
		
		// input
		if (this.input[item._rName] == null) {
			var k = document.createElement("INPUT");
			k.type = "HIDDEN";
			k.name = data.name;
			k.firstValue = item._value;
			item.appendChild(k);
			this.input[item._rName] = k;
		}
		
		if (!this.firstValue[item._rName]) this.firstValue[item._rName] = data.value;
		
		if (data.checked == true) this.check(item);
		if (data.hidden == true) this.hide(item);
		if (data.disabled == true) this.userDisable(item);
		
		this.doAttachEvents(item);
		
		return this;
	},
	
	destruct: function(item, value) {
		
		// check if any items will left to keep hidden input on page
		
		if (item.lastChild == this.input[item._rName]) {
			var done = false;
			for (var a in this.r) {
				if (!done && this.r[a]._group == item._group && this.r[a]._idd != item._idd) {
					this.r[a].appendChild(this.input[item._rName]);
					done = true;
				}
			}
			if (!done) {
				// remove hidden input
				this.input[item._rName].parentNode.removeChild(this.input[item._rName]);
				this.input[item._rName] = null;
				this.firstValue[item._rName] = null;
			}
		}
		
		var id = item._idd;
		item._doOnFocus = item._doOnBlur = item._updateImgNode = null;
		this.doUnloadNestedLists(item);
		this.doDestruct(item);
		
		return id;
		
	},
	
	doClick: function(item) {
		
		item.childNodes[item._ll?0:1].childNodes[0].focus();
		
		if (!(item._enabled && !item._checked)) return;
		if (item._ro) return;
		
		var args = [item._group, item._value, true];
		if (item.checkEvent("onBeforeChange")) if (item.callEvent("onBeforeChange", args) !== true) return;
		this.setChecked(item, true);
		item.getForm()._autoCheck();
		item.callEvent("onChange", args);
		
	},
	
	doCheckValue: function(item) {
		var value = null;
		for (var a in this.r) {
			if (this.r[a]._checked && this.r[a]._group == item._group && this.r[a]._rId == item._rId) value = this.r[a]._value; // allow getChecked for disabled, v3.6.2
		}
		if (value != null && this.r[a]._enabled) {
			this.input[item._rName].name = String(item._group);
			this.input[item._rName].value = value;
		} else {
			this.input[item._rName].name = "";
			this.input[item._rName].value = "";
		}
		this.input[item._rName]._value = value;
	},
	
	setChecked: function(item, state) {
		state = (state===true);
		for (var a in this.r) {
			if (this.r[a]._group == item._group && this.r[a]._rId == item._rId) {
				var needCheck = false;
				if (this.r[a]._idd == item._idd) {
					if (this.r[a]._checked != state) { this.r[a]._checked = state; needCheck = true; }
				} else {
					if (this.r[a]._checked) { this.r[a]._checked = false; needCheck = true; }
				}
				if (needCheck) {
					var t = this.r[a].childNodes[this.r[a]._ll?1:0].childNodes[1];
					t.className = t.className.replace(/rdbt[0-1]{1}/gi,"")+(this.r[a]._checked?" rdbt1":" rdbt0");
					t = null;
				}
			}
		}
		this.doCheckValue(item);
	},
	
	getChecked: function(item) {
		return this.input[item._rName]._value;
	},
	
	_getFirstValue: function(item) {
		return this.firstValue[item._rName];
	},
	
	_getId: function(item) {
		return item._idd; // return inner id by name/value
	},
	
	setValue: function(item, value) {
		// this method will never called at all
	}
	
};

(function(){
	for (var a in {doAddLabel:1,doAddInput:1,doDestruct:1,doUnloadNestedLists:1,doAttachEvents:1,check:1,unCheck:1,isChecked:1,enable:1,disable:1,isEnabled:1,setText:1,getText:1,getValue:1,setReadonly:1,isReadonly:1,setFocus:1})
		dhtmlXForm.prototype.items.radio[a] = dhtmlXForm.prototype.items.checkbox[a];
})();


/* select */
dhtmlXForm.prototype.items.select = {
	
	render: function(item, data) {
		
		item._type = "se";
		item._enabled = true;
		item._value = null;
		item._newValue = null;
		
		this.doAddLabel(item, data);
		this.doAddInput(item, data, "SELECT", null, true, true, "dhxform_select");
		this.doAttachEvents(item);
		
		this.doLoadOpts(item, data);
		if (data.connector != null) this.doLoadOptsConnector(item, data.connector);
		
		if (typeof(data.value) != "undefined" && data.value != null) {
			this.setValue(item, data.value);
		}
		
		return this;
	},
	
	destruct: function(item) {
		
		this.doUnloadNestedLists(item);
		
		item.callEvent = null;
		item.checkEvent = null;
		item.getForm = null;
		
		item._autoCheck = null;
		item._enabled = null;
		item._idd = null;
		item._type = null;
		item._value = null;
		item._newValue = null;
		
		item.onselectstart = null;
		
		item.childNodes[item._ll?1:0].childNodes[0].onclick = null;
		item.childNodes[item._ll?1:0].childNodes[0].onkeydown = null;
		item.childNodes[item._ll?1:0].childNodes[0].onchange = null;
		item.childNodes[item._ll?1:0].childNodes[0].onfocus = null;
		item.childNodes[item._ll?1:0].childNodes[0].onblur = null;
		item.childNodes[item._ll?1:0].childNodes[0].onkeyup = null;
		item.childNodes[item._ll?1:0].removeChild(item.childNodes[item._ll?1:0].childNodes[0]);
		
		while (item.childNodes.length > 0) item.removeChild(item.childNodes[0]);
		
		item.parentNode.removeChild(item);
		item = null;
		
	},
	
	doAddLabel: function(item, data) {
		
		var j = document.createElement("DIV");
		j.className = "dhxform_label "+data.labelAlign;
		j.innerHTML = "<label for='"+data.uid+"'>"+
				data.label+
				(data.info?"<span class='dhxform_info'>[?]</span>":"")+
				(item._required?"<span class='dhxform_item_required'>*</span>":"")+
				"</label>";
		//
		if (data.wrap == true) j.style.whiteSpace = "normal";
		
		if (typeof(data.tooltip) != "undefined") j.title = data.tooltip;
		
		item.appendChild(j);
		
		if (typeof(data.label) == "undefined" || data.label == null || data.label.length == 0) j.style.display = "none";
		
		if (!isNaN(data.labelWidth)) j.style.width = parseInt(data.labelWidth)+"px";
		if (!isNaN(data.labelHeight)) j.style.height = parseInt(data.labelHeight)+"px";
		
		if (!isNaN(data.labelLeft)) j.style.left = parseInt(data.labelLeft)+"px";
		if (!isNaN(data.labelTop)) j.style.top = parseInt(data.labelTop)+"px";
		
		if (data.info) {
			j.onclick = function(e) {
				e = e||event;
				var t = e.target||e.srcElement;
				if (typeof(t.className) != "undefined" && t.className == "dhxform_info") {
					this.parentNode.callEvent("onInfo",[this.parentNode._idd]);
					e.cancelBubble = true;
					if (e.preventDefault) e.preventDefault(); else e.returnValue = false;
					return false;
				}
			}
		}
	},
	
	doAttachEvents: function(item) {
		
		var t = item.childNodes[item._ll?1:0].childNodes[0];
		var that = this;
		
		t.onclick = function() {
			that.doOnChange(this);
		}
		t.onkeydown = function(e) {
			e = e||event;
			that.doOnChange(this);
			this.parentNode.parentNode.callEvent("onKeyDown",[this,e,this.parentNode.parentNode._idd]);
		}
		t.onchange = function() {
			that.doOnChange(this);
		}
		t.onkeyup = function(e) {
			e = e||event;
			this.parentNode.parentNode.callEvent("onKeyUp",[this,e,this.parentNode.parentNode._idd]);
		}
		t = null;
		
		this.doAttachChangeLS(item);
	},
	
	doAttachChangeLS: function(item) {
		
		var t = item.childNodes[item._ll?1:0].childNodes[0];
		t.onfocus = function() {
			var i = this.parentNode.parentNode;
			i.getForm()._ccActivate(i._idd, this, i.getForm().getItemValue(i._idd,true));
			i.getForm().callEvent("onFocus",[i._idd]);
			i = null;
		}
		t.onblur = function() {
			var i = this.parentNode.parentNode;
			i.getForm()._ccDeactivate(i._idd);
			i.getForm().callEvent("onBlur",[i._idd]);
			i = null;
		}
		t = null;
	},
	
	doValidate: function(item) {
		if (item.getForm().live_validate) this._validate(item);
	},
	
	doLoadOpts: function(item, data, callEvent) {
		var t = item.childNodes[item._ll?1:0].childNodes[0];
		var opts = data.options;
		var k = false;
		for (var q=0; q<opts.length; q++) {
			var t0 = opts[q].text||opts[q].label;
			if (!t0 || typeof(t0) == "undefined") t0 = "";
			var opt = new Option(t0, opts[q].value);
			if (typeof(opts[q].img_src) == "string") opt.setAttribute("img_src", opts[q].img_src);
			t.options.add(opt);
			// selected
			if (typeof(opts[q].selected) != "undefined" && window.dhx4.s2b(opts[q].selected) == true) {
				opt.selected = true;
				item._value = opts[q].value;
				k = true;
			}
			// cehcked (combo only)
			if (typeof(opts[q].checked) != "undefined" && window.dhx4.s2b(opts[q].checked) == true) {
				opt.setAttribute("checked", "1");
			}
			// images (combo only)
			if (typeof(opts[q].img) != "undefined") opt.setAttribute("img", opts[q].img);
			if (typeof(opts[q].img_dis) != "undefined") opt.setAttribute("img_dis", opts[q].img_dis);
		}
		// if "selected" option was not specified, check selected in control
		if (!k && t.selectedIndex >= 0) item._value = t.options[t.selectedIndex].value;
		
		if (callEvent === true) item.callEvent("onOptionsLoaded", [item._idd]);
		// fix note if width set to auto
		this._checkNoteWidth(item);
	},
	
	doLoadOptsConnector: function(item, url) {
		
		var that = this;
		item._connector_working = true;
		
		window.dhx4.ajax.get(url, function(r) {
			
			r = r.xmlDoc.responseXML;
			if (r == null) return;
			
			var root = r.getElementsByTagName("data");
			if (root == null || root[0] == null) return;
			
			root = root[0];
			
			var opts = [];
			for (var q=0; q<root.childNodes.length; q++) {
				if (typeof(root.childNodes[q].tagName) != "undefined" && String(root.childNodes[q].tagName).toLowerCase() == "item") {
					var option = root.childNodes[q];
					opts.push({
						label: option.getAttribute("label"),
						value: option.getAttribute("value"),
						selected: (option.getAttribute("selected") != null)
					});
					option = null;
				}
			}
			
			that.doLoadOpts(item, {options:opts}, true);
			
			// try to set value if it was called while options loading was in progress
			
			item._connector_working = false;
			if (item._connector_value != null) {
				that.setValue(item, item._connector_value);
				item._connector_value = null;
			}
			
			that = item = null;
		});
	},
	
	doOnChange: function(sel) {
		var item = sel.parentNode.parentNode;
		item._newValue = (sel.selectedIndex>=0?sel.options[sel.selectedIndex].value:null);
		if (item._newValue != item._value) {
			if (item.checkEvent("onBeforeChange")) {
				if (item.callEvent("onBeforeChange", [item._idd, item._value, item._newValue]) !== true) {
					// restore last value
					for (var q=0; q<sel.options.length; q++) if (sel.options[q].value == item._value) sel.options[q].selected = true;
					return;
				}
			}
			item._value = item._newValue;
			item.callEvent("onChange", [item._idd, item._value]);
			if (item._type == "se" && item.getForm().live_validate) this._validate(item);
		}
		item._autoCheck();
	},
	
	setText: function(item, text) {
		if (!text) text = "";
		item.childNodes[item._ll?0:1].childNodes[0].innerHTML = text+(item._required?"<span class='dhxform_item_required'>*</span>":"");
		item.childNodes[item._ll?0:1].style.display = (text.length==0||text==null?"none":"");
	},
	
	getText: function(item) {
		return item.childNodes[item._ll?0:1].childNodes[0].innerHTML.replace(/<span class=\"dhxform_item_required\">[^<]*<\/span>/g,"");
	},
	
	enable: function(item) {
		if (String(item.className).search("disabled") >= 0) item.className = String(item.className).replace(/disabled/gi,"");
		item._enabled = true;
		item.childNodes[item._ll?1:0].childNodes[0].removeAttribute("disabled");
	},
	
	disable: function(item) {
		if (String(item.className).search("disabled") < 0) item.className += " disabled";
		item._enabled = false;
		item.childNodes[item._ll?1:0].childNodes[0].setAttribute("disabled", true);
	},
	
	getOptions: function(item) {
		return item.childNodes[item._ll?1:0].childNodes[0].options;
	},
	
	setValue: function(item, val) {
		if (item._connector_working) { // attemp to set value while optins not yet loaded (connector used)
			item._connector_value = val;
			return;
		}
		var opts = this.getOptions(item);
		for (var q=0; q<opts.length; q++) {
			if (opts[q].value == val) {
				opts[q].selected = true;
				item._value = opts[q].value;
			}
		}
		if (item._list != null && item._list.length > 0) {
			item.getForm()._autoCheck();
		}
		
		item.getForm()._ccReload(item._idd, item._value); // selected option id
		
	},
	
	getValue: function(item) {
		var k = -1;
		var opts = this.getOptions(item);
		for (var q=0; q<opts.length; q++) if (opts[q].selected) k = opts[q].value;
		return k;
	},
	
	setWidth: function(item, width) {
		item.childNodes[item._ll?1:0].childNodes[0].style.width = width+"px";
	},
	
	getSelect: function(item) {
		return item.childNodes[item._ll?1:0].childNodes[0];
	},
	
	setFocus: function(item) {
		item.childNodes[item._ll?1:0].childNodes[0].focus();
	},
	
	_checkNoteWidth: function(item) {
		var t;
		if (item.childNodes[item._ll?1:0].childNodes[1] != null) {
			t = item.childNodes[item._ll?1:0].childNodes[1];
			if (t.className != null && t.className.search(/dhxform_note/gi) >= 0 && t._w == "auto") t.style.width = item.childNodes[item._ll?1:0].childNodes[0].offsetWidth+"px";
		}
		t = null;
	}
	
};
(function(){
	for (var a in {doAddInput:1,doUnloadNestedLists:1,isEnabled:1})
		dhtmlXForm.prototype.items.select[a] = dhtmlXForm.prototype.items.checkbox[a];
})();

/* multiselect */
dhtmlXForm.prototype.items.multiselect = {
	
	doLoadOpts: function(item, data, callEvent) {
		var t = item.childNodes[item._ll?1:0].childNodes[0];
		t.multiple = true;
		if (!isNaN(data.size)) t.size = Number(data.size);
		item._value = [];
		item._newValue = [];
		var opts = data.options;
		for (var q=0; q<opts.length; q++) {
			var opt = new Option(opts[q].text||opts[q].label, opts[q].value);
			t.options.add(opt);
			if (opts[q].selected == true || opts[q].selected == "true") {
				opt.selected = true;
				item._value.push(opts[q].value);
			}
		}
		if (callEvent === true) item.callEvent("onOptionsLoaded", [item._idd]);
		//
		this._checkNoteWidth(item);
	},
	
	doAttachEvents: function(item) {
		
		var t = item.childNodes[item._ll?1:0].childNodes[0];
		var that = this;
		
		t.onfocus = function() {
			that.doOnChange(this);
			var i = this.parentNode.parentNode;
			i.getForm().callEvent("onFocus",[i._idd]);
			i = null;
		}
		
		t.onblur = function() {
			that.doOnChange(this);
			var i = this.parentNode.parentNode;
			i.getForm().callEvent("onBlur",[i._idd]);
			i = null;
		}
		
		t.onclick = function() {
			that.doOnChange(this);
			var i = this.parentNode.parentNode;
			i._autoCheck();
			i = null;
		}
		
	},
	
	doOnChange: function(sel) {
		
		var item = sel.parentNode.parentNode;
		
		item._newValue = [];
		for (var q=0; q<sel.options.length; q++) if (sel.options[q].selected) item._newValue.push(sel.options[q].value);
		
		if ((item._value).sort().toString() != (item._newValue).sort().toString()) {
			if (item.checkEvent("onBeforeChange")) {
				if (item.callEvent("onBeforeChange", [item._idd, item._value, item._newValue]) !== true) {
					// restore last value
					var k = {};
					for (var q=0; q<item._value.length; q++) k[item._value[q]] = true;
					for (var q=0; q<sel.options.length; q++) sel.options[q].selected = (k[sel.options[q].value] == true);
					k = null;
					return;
				}
			}
			item._value = [];
			for (var q=0; q<item._newValue.length; q++) item._value.push(item._newValue[q]);
			item.callEvent("onChange", [item._idd, item._value]);
		}
		
		// check autocheck for multiselect
		item._autoCheck();
		
	},
	
	setValue: function(item, val) {
		
		var k = {};
		if (typeof(val) == "string") val = val.split(",");
		if (typeof(val) != "object") val = [val];
		for (var q=0; q<val.length; q++) k[val[q]] = true;
		
		var opts = this.getOptions(item);
		for (var q=0; q<opts.length; q++) opts[q].selected = (k[opts[q].value] == true);
		
		item._autoCheck();
	},
	
	getValue: function(item) {
		
		var k = [];
		
		var opts = this.getOptions(item);
		for (var q=0; q<opts.length; q++) if (opts[q].selected) k.push(opts[q].value);
		return k;
	}
};

(function() {
	for (var a in dhtmlXForm.prototype.items.select) {
		if (!dhtmlXForm.prototype.items.multiselect[a]) dhtmlXForm.prototype.items.multiselect[a] = dhtmlXForm.prototype.items.select[a];
	}
})();

/* input */
dhtmlXForm.prototype.items.input = {
	
	render: function(item, data) {
		
		var ta = (!isNaN(data.rows));
		
		item._type = "ta";
		item._enabled = true;
		
		this.doAddLabel(item, data);
		this.doAddInput(item, data, (ta?"TEXTAREA":"INPUT"), (ta?null:"TEXT"), true, true, "dhxform_textarea");
		this.doAttachEvents(item);
		
		if (ta) item.childNodes[item._ll?1:0].childNodes[0].rows = Number(data.rows)+(window.dhx4.isIE6?1:0);
		
		if (typeof(data.numberFormat) != "undefined") {
			var a,b=null,c=null;
			if (typeof(data.numberFormat) != "string") {
				a = data.numberFormat[0];
				b = data.numberFormat[1]||null;
				c = data.numberFormat[2]||null;
			} else {
				a = data.numberFormat;
				if (typeof(data.groupSep) == "string") b = data.groupSep;
				if (typeof(data.decSep) == "string") c = data.decSep;
			}
			this.setNumberFormat(item, a, b, c, false);
		}
		
		this.setValue(item, data.value);
		
		return this;
		
	},
	
	doAttachEvents: function(item) {
		
		var that = this;
		
		if (item._type == "ta" || item._type == "se" || item._type == "pw") {
			item.childNodes[item._ll?1:0].childNodes[0].onfocus = function() {
				var i = this.parentNode.parentNode;
				if (i._df != null) this.value = i._value||"";
				i.getForm()._ccActivate(i._idd, this, this.value);
				i.getForm().callEvent("onFocus",[i._idd]);
				i = null;
			}
		}
		
		item.childNodes[item._ll?1:0].childNodes[0].onblur = function() {
			var i = this.parentNode.parentNode;
			i.getForm()._ccDeactivate(i._idd);
			that.updateValue(i, true);
			if (i.getForm().live_validate) that._validate(i);
			i.getForm().callEvent("onBlur",[i._idd]);
			i = null;
		}
	},
	
	updateValue: function(item, foc) {
		
		var value = item.childNodes[item._ll?1:0].childNodes[0].value;
		
		var form = item.getForm();
		var in_focus = (form._ccActive == true && form._formLS != null && form._formLS[item._idd] != null);
		form = null;
		
		if (!in_focus && item._df != null && value == window.dhx4.template._getFmtValue(item._value, item._df)) return; // if item not in focus
		
		if (!foc && item._df != null && item._value == value && value == window.dhx4.template._getFmtValue(value, item._df)) return;
		
		var t = this;
		if (item._value != value) {
			if (item.checkEvent("onBeforeChange")) if (item.callEvent("onBeforeChange",[item._idd, item._value, value]) !== true) {
				// restore
				if (item._df != null) t.setValue(item, item._value); else item.childNodes[item._ll?1:0].childNodes[0].value = item._value;
				return;
			}
			// accepted
			if (item._df != null && foc) t.setValue(item, value); else item._value = value;
			item.callEvent("onChange",[item._idd, value]);
			return;
		}
		if (item._df != null && foc) this.setValue(item, item._value);
	},
	
	setValue: function(item, value) {
		
		// str only
		item._value = (typeof(value) != "undefined" && value != null ? value : "");
		
		var v = (String(item._value)||"");
		var k = item.childNodes[item._ll?1:0].childNodes[0];
		
		// check if formatting available
		if (item._df != null) v = window.dhx4.template._getFmtValue(v, item._df);
		
		if (k.value != v) {
			k.value = v;
			item.getForm()._ccReload(item._idd, v);
		}
		
		k = null;
	},
	
	getValue: function(item) {
		// update value if item have focus
		var f = item.getForm();
		if (f._formLS && f._formLS[item._idd] != null) this.updateValue(item);
		f = null;
		// str only
		return (typeof(item._value) != "undefined" && item._value != null ? item._value : "");
	},
	
	setReadonly: function(item, state) {
		item._ro = (state===true);
		if (item._ro) {
			item.childNodes[item._ll?1:0].childNodes[0].setAttribute("readOnly", "true");
		} else {
			item.childNodes[item._ll?1:0].childNodes[0].removeAttribute("readOnly");
		}
	},
	
	isReadonly: function(item) {
		if (!item._ro) item._ro = false;
		return item._ro;
	},
	
	getInput: function(item) {
		return item.childNodes[item._ll?1:0].childNodes[0];
	},
	
	setNumberFormat: function(item, format, g_sep, d_sep, refresh) {
		
		if (typeof(refresh) != "boolean") refresh = true;
		
		if (format == "") {
			item._df = null;
			if (refresh) this.setValue(item, item._value);
			return true;
		}
		
		if (typeof(format) != "string") return;
		
		var fmt = window.dhx4.template._parseFmt(format, g_sep, d_sep);
		if (fmt == false) return false; else item._df = fmt;
		
		if (refresh) this.setValue(item, item._value);
		
		return true;
		
	}
	
};

(function(){
	for (var a in {doAddLabel:1,doAddInput:1,destruct:1,doUnloadNestedLists:1,setText:1,getText:1,enable:1,disable:1,isEnabled:1,setWidth:1,setFocus:1})
		dhtmlXForm.prototype.items.input[a] = dhtmlXForm.prototype.items.select[a];
})();


/* password */
dhtmlXForm.prototype.items.password = {
	
	render: function(item, data) {
		
		item._type = "pw";
		item._enabled = true;
		
		this.doAddLabel(item, data);
		this.doAddInput(item, data, "INPUT", "PASSWORD", true, true, "dhxform_textarea");
		this.doAttachEvents(item);
		
		this.setValue(item, data.value);
		
		return this;
		
	}
};

(function(){
	for (var a in {doAddLabel:1,doAddInput:1,doAttachEvents:1,destruct:1,doUnloadNestedLists:1,setText:1,getText:1,setValue:1,getValue:1,updateValue:1,enable:1,disable:1,isEnabled:1,setWidth:1,setReadonly:1,isReadonly:1,setFocus:1,getInput:1})
		dhtmlXForm.prototype.items.password[a] = dhtmlXForm.prototype.items.input[a];
})();

/* file */
dhtmlXForm.prototype.items.file = {
	
	render: function(item, data) {
		
		item._type = "fl";
		item._enabled = true;
		
		this.doAddLabel(item, data);
		this.doAddInput(item, data, "INPUT", "FILE", true, false, "dhxform_textarea");
		
		var t = item.childNodes[item._ll ? 1 : 0].childNodes[0];
		var that = this;
		t.onfocus = function() {
			var i = this.parentNode.parentNode;
			i.getForm().callEvent("onFocus",[i._idd]);
			i = null;
		};
		t.onblur = function () {
			var i = this.parentNode.parentNode;
			if (i.getForm().live_validate) that._validate(i);
			i.getForm().callEvent("onBlur", [i._idd]);
			i = null;
		};
		t = null;
		
		item.childNodes[item._ll?1:0].childNodes[0].onchange = function() {
			item.callEvent("onChange", [item._idd, this.value]);
		}
		
		return this;
		
	},
	
	setValue: function(){},
	
	getValue: function(item) {
		return item.childNodes[item._ll?1:0].childNodes[0].value;
	}
	
};

(function(){
	for (var a in {doAddLabel:1,doAddInput:1,destruct:1,doUnloadNestedLists:1,setText:1,getText:1,getInput:1,enable:1,disable:1,isEnabled:1,setWidth:1})
		dhtmlXForm.prototype.items.file[a] = dhtmlXForm.prototype.items.input[a];
})();

/* label */
dhtmlXForm.prototype.items.label = {
	
	_index: false,
	
	render: function(item, data) {
		
		item._type = "lb";
		item._enabled = true;
		item._checked = true;
		
		var t = document.createElement("DIV");
		t.className = "dhxform_txt_label2"+(data._isTopmost?" topmost":"");
		t.innerHTML = data.label;
		item.appendChild(t);
		
		if (data.hidden == true) this.hide(item);
		if (data.disabled == true) this.userDisable(item);
		
		if (!isNaN(data.labelWidth)) t.style.width = parseInt(data.labelWidth)+"px";
		if (!isNaN(data.labelHeight)) t.style.height = parseInt(data.labelHeight)+"px";
		
		if (!isNaN(data.labelLeft)) t.style.left = parseInt(data.labelLeft)+"px";
		if (!isNaN(data.labelTop)) t.style.top = parseInt(data.labelTop)+"px";
		
		return this;
	},
	
	destruct: function(item) {
		
		this.doUnloadNestedLists(item);
		
		item._autoCheck = null;
		item._enabled = null;
		item._type = null;
		
		item.callEvent = null;
		item.checkEvent = null;
		item.getForm = null;
		
		item.onselectstart = null;
		item.parentNode.removeChild(item);
		item = null;
		
	},
	
	enable: function(item) {
		if (String(item.className).search("disabled") >= 0) item.className = String(item.className).replace(/disabled/gi,"");
		item._enabled = true;
	},
	
	disable: function(item) {
		if (String(item.className).search("disabled") < 0) item.className += " disabled";
		item._enabled = false;
	},
	
	setText: function(item, text) {
		item.firstChild.innerHTML = text;
	},

	getText: function(item) {
		return item.firstChild.innerHTML;
	}
	
};

(function(){
	for (var a in {doUnloadNestedLists:1,isEnabled:1})
		dhtmlXForm.prototype.items.label[a] = dhtmlXForm.prototype.items.checkbox[a];
})();


/* button */
dhtmlXForm.prototype.items.button = {
	
	render: function(item, data) {
		
		item._type = "bt";
		item._enabled = true;
		item._name = data.name;
		
		item.className = String(item.className).replace("item_label_top","item_label_left").replace("item_label_right","item_label_left");
		
		if (!isNaN(data.width)) var w = Math.max(data.width,10);
		var k = (typeof(w) != "undefined");
		
		item._doOnKeyUpDown = function(evName, evObj) {
			this.callEvent(evName, [this.childNodes[0].childNodes[0], evObj, this._idd]);
		}
		
		item.innerHTML = '<div class="dhxform_btn" role="link" tabindex="0" dir="ltr">'+
					'<div class="dhxform_btn_txt" '+(k?' style="width:'+w+'px;"':'')+'>'+data.value+'</div>'+
					'<div class="dhxform_btn_filler" disabled="true"></div>'+ // IE click w/o focus loss
				'</div>';
		
		if (!isNaN(data.inputLeft)) item.childNodes[0].style.left = parseInt(data.inputLeft)+"px";
		if (!isNaN(data.inputTop)) item.childNodes[0].style.top = parseInt(data.inputTop)+"px";
		
		if (data.hidden == true) this.hide(item);
		if (data.disabled == true) this.userDisable(item);
		
		if (typeof(data.tooltip) != "undefined") item.firstChild.title = data.tooltip;
		
		// item onselectstart also needed once
		// will reconstructed!
		
		item.onselectstart = function(e){
			e = e||event;
			e.cancelBubble = true;
			if (e.preventDefault) e.preventDefault(); else e.returnValue = false;
			return false;
		}
		item.firstChild.onselectstart = function(e){
			e = e||event;
			e.cancelBubble = true;
			if (e.preventDefault) e.preventDefault(); else e.returnValue = false;
			return false;
		}
		
		item.firstChild.onkeypress = function(e) {
			e = e||event
			if ((e.keyCode == 32 || e.charCode == 32 || e.keyCode == 13 || e.charCode == 13) && !this.parentNode._busy) {
				this.parentNode._busy = true;
				e.cancelBubble = true;
				if (e.preventDefault) e.preventDefault(); else e.returnValue = false;
				_dhxForm_doClick(this.childNodes[0], ["mousedown", "mouseup"]);
				return false;
			}
		}
		
		item.firstChild.onfocus = function() {
			this.parentNode._doOnFocus(this.parentNode);
		}
		
		item.firstChild.onblur = function() {
			_dhxForm_doClick(this.childNodes[0], "mouseout");
			this.parentNode._doOnBlur(this.parentNode);
		}
		
		item.firstChild.onkeyup = function(e) {
			this.parentNode._doOnKeyUpDown("onKeyUp", e||event);
		}
		item.firstChild.onkeydown = function(e) {
			this.parentNode._doOnKeyUpDown("onKeyDown", e||event);
		}
		item.firstChild.onmouseover = function(){
			var t = this.parentNode;
			if (!t._enabled) return;
			this._isOver = true;
			this.className = "dhxform_btn dhxform_btn_over";
			t = null;
		}
		item.firstChild.onmouseout = function(){
			var t = this.parentNode;
			if (!t._enabled) return;
			this.className = "dhxform_btn";
			this._allowClick = false;
			this._pressed = false;
			this._isOver = false;
			t = null;
		}
		item.firstChild.ontouchstart = item.firstChild.onmousedown = function(e){
			e = e||event;
			if (e.type == "touchstart" && e.preventDefault) e.preventDefault();
			if (e.button >= 2) return; // ie=0/other=1
			if (this._pressed) return;
			var t = this.parentNode;
			if (!t._enabled) return;
			this.className = "dhxform_btn dhxform_btn_pressed";
			this._allowClick = true;
			this._pressed = true;
			t = null;
		}
		
		item.firstChild.ontouchend = item.firstChild.onmouseup = function(e){
			e = e||event;
			if (e.button >= 2) return;
			if (!this._pressed) return;
			var t = this.parentNode;
			if (!t._enabled) return;
			t._busy = false;
			this.className = "dhxform_btn"+(this._isOver?" dhxform_btn_over":"");
			if (this._pressed && this._allowClick) t.callEvent("_onButtonClick", [t._name, t._cmd]);
			this._allowClick = false;
			this._pressed = false;
			t = null;
		}
		
		item._doOnFocus = function(item) {
			item.getForm().callEvent("onFocus",[item._idd]);
		}
		
		item._doOnBlur = function(item) {
			item.getForm().callEvent("onBlur",[item._idd]);
		}
		
		return this;
	},
	
	destruct: function(item) {
		
		this.doUnloadNestedLists(item);
		
		item.callEvent = null;
		item.checkEvent = null;
		item.getForm = null;
		
		item._autoCheck = null;
		item._type = null;
		item._enabled = null;
		item._cmd = null;
		item._name = null;
		item._doOnFocus = null;
		item._doOnBlur = null;
		item._doOnKeyUpDown = null;
		
		item.onselectstart = null;
		
		item.firstChild.onselectstart = null;
		item.firstChild.onkeypress = null;
		item.firstChild.ontouchstart = null;
		item.firstChild.ontouchend = null;
		item.firstChild.onfocus = null;
		item.firstChild.onblur = null;
		item.firstChild.onkeyup = null;
		item.firstChild.onkeydown = null;
		item.firstChild.onmouseover = null;
		item.firstChild.onmouseout = null;
		item.firstChild.onmousedown = null;
		item.firstChild.onmouseup = null;
		
		while (item.childNodes.length > 0) item.removeChild(item.childNodes[0]);
		
		item.parentNode.removeChild(item);
		item = null;
		
	},
	
	enable: function(item) {
		if (String(item.className).search("disabled") >= 0) item.className = String(item.className).replace(/disabled/gi,"");
		item._enabled = true;
		item.childNodes[0].removeAttribute("disabled");
		item.childNodes[0].setAttribute("role", "link");
		item.childNodes[0].setAttribute("tabIndex", "0");
	},
	
	disable: function(item) {
		if (String(item.className).search("disabled") < 0) item.className += " disabled";
		item._enabled = false;
		item.childNodes[0].setAttribute("disabled", "true");
		item.childNodes[0].removeAttribute("role");
		item.childNodes[0].removeAttribute("tabIndex");
	},
	
	setText: function(item, text) {
		item.childNodes[0].childNodes[0].innerHTML = text;
	},

	getText: function(item) {
		return item.childNodes[0].childNodes[0].innerHTML;
	},
	
	setFocus: function(item) {
		item.childNodes[0].focus();
	}
	
};

(function(){
	for (var a in {doUnloadNestedLists:1,isEnabled:1})
		dhtmlXForm.prototype.items.button[a] = dhtmlXForm.prototype.items.checkbox[a];
})();

/* hidden item */
dhtmlXForm.prototype.items.hidden = {
	
	_index: false,
	
	render: function(item, data) {
		
		item.style.display = "none";
		
		item._name = data.name;
		item._type = "hd";
		item._enabled = true;
		
		var t = document.createElement("INPUT");
		t.type = "HIDDEN";
		t.name = data.name;
		t.value = (data.value||"")
		item.appendChild(t);
		
		return this;
	},
	
	destruct: function(item) {
		
		
		this.doUnloadNestedLists(item);
		
		while (item.childNodes.length > 0) item.removeChild(item.childNodes[0]);
		
		item._autoCheck = null;
		item._name = null;
		item._type = null;
		item._enabled = null;
		item.onselectstart = null;
		item.callEvent = null;
		item.checkEvent = null;
		item.getForm = null;
		item.parentNode.removeChild(item);
		item = null;
		
	},
	
	enable: function(item) {
		item._enabled = true;
		item.childNodes[0].setAttribute("name", item._name);
	},
	
	disable: function(item) {
		item._enabled = false;
		item.childNodes[0].removeAttribute("name");
	},
	
	show: function() {
		
	},
	
	hide: function() {
		
	},
	
	isHidden: function() {
		return true;
	},
	
	setValue: function(item, val) {
		item.childNodes[0].value = val;
	},
	
	getValue: function(item) {
		return item.childNodes[0].value;
	},
	
	getInput: function(item) {
		return item.childNodes[0];
	}
	
};

(function(){
	for (var a in {doUnloadNestedLists:1,isEnabled:1})
		dhtmlXForm.prototype.items.hidden[a] = dhtmlXForm.prototype.items.checkbox[a];
})();

/* sub list */
dhtmlXForm.prototype.items.list = {
	
	_index: false,
	
	render: function(item, skin) {
		
		item._type = "list";
		item._enabled = true;
		item._isNestedForm = true;
		item.style.paddingLeft = item._ofsNested+"px";
		
		item.className = "dhxform_base_nested"+(item._custom_css||"");
		
		return [this, new dhtmlXForm(item, null, skin)];
	},
	
	destruct: function(item) {
		
		// linked to _listBase
		// automaticaly cleared when parent item unloaded
		
	}
};

/* fieldset */
dhtmlXForm.prototype.items.fieldset = {
	
	_index: false,
	
	render: function(item, data) {
		
		item._type = "fs";
		
		if (typeof(parseInt(data.inputWidth)) == "number") {
			// if (window.dhx4.isFF||window.dhx4.isOpera) data.inputWidth -= 12;
			// chrome-11/ie9 - ok
		}
		
		item._width = data.width;
		
		item._enabled = true;
		item._checked = true; // required for authoCheck
		
		item.className = "fs_"+data.position+(typeof(data.className)=="string"?" "+data.className:"");
		
		var f = document.createElement("FIELDSET");
		f.className = "dhxform_fs";
		var align = String(data.labelAlign).replace("align_","");
		f.innerHTML = "<legend class='fs_legend' align='"+align+"' style='text-align:"+align+"'>"+data.label+"</legend>";
		item.appendChild(f);
		
		if (!isNaN(data.inputLeft)) f.style.left = parseInt(data.inputLeft)+"px";
		if (!isNaN(data.inputTop)) f.style.top = parseInt(data.inputTop)+"px";
		if (data.inputWidth != "auto") {
			if (!isNaN(data.inputWidth)) {
				f.style.width = parseInt(data.inputWidth)+"px";
				var w = parseInt(f.style.width);
				if (f.offsetWidth > w) f.style.width = w+(w-f.offsetWidth)+"px";
			}
		}
		
		item._addSubListNode = function() {
			var t = document.createElement("DIV");
			t._custom_css = " dhxform_fs_nested";
			this.childNodes[0].appendChild(t);
			return t;
		}
		
		if (data.hidden == true) this.hide(item);
		if (data.disabled == true) this.userDisable(item);
		
		return this;
	},
	
	destruct: function(item) {
		
		this.doUnloadNestedLists(item);
		
		item._checked = null;
		item._enabled = null;
		item._idd = null;
		item._type = null;
		item._width = null;
		
		item.onselectstart = null;
		
		item._addSubListNode = null;
		item._autoCheck = null;
		item.callEvent = null;
		item.checkEvent = null;
		item.getForm = null;
		
		while (item.childNodes.length > 0) item.removeChild(item.childNodes[0]);
		
		item.parentNode.removeChild(item);
		item = null;
	
	},
	
	setText: function(item, text) {
		item.childNodes[0].childNodes[0].innerHTML = text;
	},
	
	getText: function(item) {
		return item.childNodes[0].childNodes[0].innerHTML;
	},
	
	enable: function(item) {
		item._enabled = true;
		if (String(item.className).search("disabled") >= 0) item.className = String(item.className).replace(/disabled/gi,"");
	},
	
	disable: function(item) {
		item._enabled = false;
		if (String(item.className).search("disabled") < 0) item.className += " disabled";
	},
	
	setWidth: function(item, width) {
		item.childNodes[0].style.width = width+"px";
		item._width = width;
	},
	
	getWidth: function(item) {
		return item._width;
	}
	
};

(function(){
	for (var a in {doUnloadNestedLists:1,isEnabled:1})
		dhtmlXForm.prototype.items.fieldset[a] = dhtmlXForm.prototype.items.checkbox[a];
})();


/* block */
dhtmlXForm.prototype.items.block = {
	
	_index: false,
	
	render: function(item, data) {
		
		item._type = "bl";
		
		item._width = data.width;
		
		item._enabled = true;
		item._checked = true; // required for authoCheck
		
		item.className = "block_"+data.position+(typeof(data.className)=="string"?" "+data.className:"");
		
		var b = document.createElement("DIV");
		b.className = "dhxform_obj_"+item.getForm().skin+" dhxform_block";
		b.style.fontSize = item.getForm().cont.style.fontSize;
		if (data.style) b.style.cssText = data.style;
		
		if (typeof(data.id) != "undefined") b.id = data.id;
		
		item.appendChild(b);
		
		if (!isNaN(data.inputLeft)) b.style.left = parseInt(data.inputLeft)+"px";
		if (!isNaN(data.inputTop)) b.style.top = parseInt(data.inputTop)+"px";
		if (data.inputWidth != "auto") if (!isNaN(data.inputWidth)) b.style.width = parseInt(data.inputWidth)+"px";
		
		if (!isNaN(data.blockOffset)) {
			item._ofsNested = data.blockOffset;
		}
		
		item._addSubListNode = function() {
			var t = document.createElement("DIV");
			t._inBlcok = true;
			if (typeof(this._ofsNested) != "undefined") t._ofsNested = this._ofsNested;
			this.childNodes[0].appendChild(t);
			return t;
		}
		
		if (data.hidden == true) this.hide(item);
		if (data.disabled == true) this.userDisable(item);
		
		return this;
	},
	
	_setCss: function(item, skin, fontSize) {
		item.firstChild.className = "dhxform_obj_"+skin+" dhxform_block";
		item.firstChild.style.fontSize = fontSize;
	}
};

(function(){
	for (var a in {enable:1,disable:1,isEnabled:1,setWidth:1,getWidth:1,doUnloadNestedLists:1,destruct:1})
		dhtmlXForm.prototype.items.block[a] = dhtmlXForm.prototype.items.fieldset[a];
})();

/* new column */
dhtmlXForm.prototype.items.newcolumn = {
	_index: false
};

/* template */
dhtmlXForm.prototype.items.template = {
	
	render: function(item, data) {
		
		var ta = (!isNaN(data.rows));
		
		item._type = "tp";
		item._enabled = true;
		
		if (data.format != null) {
			if (typeof(data.format) == "function") {
				item.format = data.format;
			} else if (typeof(data.format) == "string" && typeof(window[data.format]) == "function") {
				item.format = window[data.format];
			}
		}
		if (item.format == null) {
			item.format = function(name, value) { return value; }
		}
		
		this.doAddLabel(item, data);
		this.doAddInput(item, data, "DIV", null, true, true, "dhxform_item_template");
		
		this.setValue(item, data.value||"");
		
		return this;
		
	},
	
	destruct: function(item) {
		item.format = null;
		this.d2(item);
		item = null;
	},
	
	setValue: function(item, value) {
		item._value = value;
		item.childNodes[item._ll?1:0].childNodes[0].innerHTML = item.format(item._idd, item._value);
	},
	
	getValue: function(item) {
		return item._value;
	},
	
	enable: function(item) {
		if (String(item.className).search("disabled") >= 0) item.className = String(item.className).replace(/disabled/gi,"");
		item._enabled = true;
	},
	
	disable: function(item) {
		if (String(item.className).search("disabled") < 0) item.className += " disabled";
		item._enabled = false;
	}
	
};

(function(){
	dhtmlXForm.prototype.items.template.d2 = dhtmlXForm.prototype.items.input.destruct;
	for (var a in {doAddLabel:1,doAddInput:1,doUnloadNestedLists:1,setText:1,getText:1,isEnabled:1,setWidth:1})
		dhtmlXForm.prototype.items.template[a] = dhtmlXForm.prototype.items.select[a];
})();

//loading from UL list

dhtmlXForm.prototype._ulToObject = function(ulData, a) {
	var obj = [];
	for (var q=0; q<ulData.childNodes.length; q++) {
		if (String(ulData.childNodes[q].tagName||"").toLowerCase() == "li") {
			var p = {};
			var t = ulData.childNodes[q];
			for (var w=0; w<a.length; w++) if (t.getAttribute(a[w]) != null) p[String(a[w]).replace("ftype","type")] = t.getAttribute(a[w]);
			if (!p.label) try { p.label = t.firstChild.nodeValue; } catch(e){}
			var n = t.getElementsByTagName("UL");
			if (n[0] != null) p[(p.type=="select"?"options":"list")] = dhtmlXForm.prototype._ulToObject(n[0], a);
			// userdata
			for (var w=0; w<t.childNodes.length; w++) {
				if (String(t.childNodes[w].tagName||"").toLowerCase() == "userdata") {
					if (!p.userdata) p.userdata = {};
					p.userdata[t.childNodes[w].getAttribute("name")] = t.childNodes[w].firstChild.nodeValue;
				}
			}
			obj[obj.length] = p;
		}
		if (String(ulData.childNodes[q].tagName||"").toLowerCase() == "div") {
			var p = {};
			p.type = "label";
			try { p.label = ulData.childNodes[q].firstChild.nodeValue; } catch(e){}
			obj[obj.length] = p;
		}
	}
	return obj;
};

dhtmlXForm.prototype.setUserData = function(id, name, value, rValue) {
	if (typeof(rValue) != "undefined") { // radiobutton: name,value,ud_name,ud_value
		var k = this.doWithItem([id,name], "_getId");
		if (k != null) { id = k; name = value; value = rValue; }
	}
	if (!this._userdata) this._userdata = {};
	this._userdata[id] = (this._userdata[id]||{});
	this._userdata[id][name] = value;
};

dhtmlXForm.prototype.getUserData = function(id, name, rValue) {
	if (typeof(rValue) != "undefined") { // radiobutton: name,value,ud_name
		var k = this.doWithItem([id,name], "_getId");
		if (k != null) { id = k; name = rValue; }
	}
	if (this._userdata != null && typeof(this._userdata[id]) != "undefined" && typeof(this._userdata[id][name]) != "undefined") return this._userdata[id][name];
	return "";
};

dhtmlXForm.prototype.setRTL = function(state) {
	this._rtl = (state===true?true:false);
	if (this._rtl) {
		if (String(this.cont).search(/dhxform_rtl/gi) < 0) this.cont.className += " dhxform_rtl";
	} else {
		if (String(this.cont).search(/dhxform_rtl/gi) >= 0) this.cont.className = String(this.cont.className).replace(/dhxform_rtl/gi,"");
	}
};

_dhxForm_doClick = function(obj, evType) {
	if (typeof(evType) == "object") {
		var t = evType[1];
		evType = evType[0];
	}
	if (document.createEvent) {
		var e = document.createEvent("MouseEvents");
		e.initEvent(evType, true, false);
		obj.dispatchEvent(e);
	} else if (document.createEventObject) {
		var e = document.createEventObject();
		e.button = 1;
		obj.fireEvent("on"+evType, e);
	}
	if (t) window.setTimeout(function(){_dhxForm_doClick(obj,t);},100);
}

dhtmlXForm.prototype.setFormData = function(t) {
	for (var a in t) {
		var r = this.getItemType(a);
		switch (r) {
			case "checkbox":
				this[t[a]==true||parseInt(t[a])==1||t[a]=="true"||t[a]==this.getItemValue(a, "realvalue")?"checkItem":"uncheckItem"](a);
				break;
			case "radio":
				this.checkItem(a,t[a]);
				break;
			case "input":
			case "textarea":
			case "password":
			case "select":
			case "multiselect":
			case "hidden":
			case "template":
			case "combo":
			case "calendar":
			case "colorpicker":
			case "editor":
				this.setItemValue(a,t[a]);
				break;
			default:
				if (this["setFormData_"+r]) {
					// check for custom cell
					this["setFormData_"+r](a,t[a]);
				} else {
					// if item with specified name not found, keep value in userdata
					if (!this.hId) this.hId = this._genStr(12);
					this.setUserData(this.hId, a, t[a]);
				}
				break;
		}
	}
};

dhtmlXForm.prototype.getFormData = function(p0, only_fields) {
	
	var r = {};
	var that = this;
	for (var a in this.itemPull) {
		var i = this.itemPull[a]._idd;
		var t = this.itemPull[a]._type;
		if (t == "ch") r[i] = (this.isItemChecked(i)?this.getItemValue(i):0);
		if (t == "ra" && !r[this.itemPull[a]._group]) r[this.itemPull[a]._group] = this.getCheckedValue(this.itemPull[a]._group);
		if (t in {se:1,ta:1,pw:1,hd:1,tp:1,fl:1,calendar:1,combo:1,editor:1,colorpicker:1}) r[i] = this.getItemValue(i,p0);
		// check for custom cell
		if (this["getFormData_"+t]) r[i] = this["getFormData_"+t](i);
		// merge with files/uploader
		if (t == "up") {
			var r0 = this.getItemValue(i);
			for (var a0 in r0) r[a0] = r0[a0];
		}
		//
		if (this.itemPull[a]._list) {
			for (var q=0; q<this.itemPull[a]._list.length; q++) {
				var k = this.itemPull[a]._list[q].getFormData(p0,only_fields);
				for (var b in k) r[b] = k[b];
			}
		}
	}
	// collecr hId userdata
	if (!only_fields && this.hId && this._userdata[this.hId]) {
		for (var a in this._userdata[this.hId]) {
			if (!r[a]) r[a] = this._userdata[this.hId][a];
		}
	}
	return r;
};

dhtmlXForm.prototype.adjustParentSize = function() {
	
	var kx = 0;
	var ky = -1;
	for (var q=0; q<this.base.length; q++) {
		kx += this.base[q].firstChild.offsetWidth;
		if (this.base[q].offsetHeight > ky) ky = this.base[q].offsetHeight;
	}
	
	// check if layout
	var isLayout = false;
	try {
		isLayout = (this.cont.parentNode.parentNode.parentNode.parentNode._isCell==true);
		if (isLayout) var layoutCell = this.cont.parentNode.parentNode.parentNode.parentNode;
	} catch(e){};
	
	if (isLayout && typeof(layoutCell) != "undefined") {
		
		if (kx > 0) layoutCell.setWidth(kx+10);
		if (ky > 0) layoutCell.setHeight(ky+layoutCell.firstChild.firstChild.offsetHeight+5);
		
		isLayout = layoutCell = null;
		return;
	}
	
	// check if window
	var isWindow = false;
	try {
		isWindow = (this.cont.parentNode.parentNode.parentNode._isWindow == true);
		if (isWindow) {
			var winCell = this.cont.parentNode.parentNode;
			if (typeof(winCell.callEvent) == "function") {
				this.cont.style.display = "none";
				winCell.callEvent("_setCellSize", [kx+15,ky+15]);
				this.cont.style.display = "";
			}
		}
	} catch(e){};
	
};

// dataproc
dhtmlXForm.prototype.reset = function() {
	if (this.callEvent("onBeforeReset", [this.formId, this.getFormData()])) {
		if (this._last_load_data) this.setFormData(this._last_load_data);
		this.callEvent("onAfterReset", [this.formId]);
	}
};

dhtmlXForm.prototype.send = function(url, mode, callback, skipValidation) {
	
	if (typeof mode == "function") {
		callback = mode;
		mode = "post";
	} else {
		mode = (mode=="get"?"get":"post");
	}
	
	if (skipValidation !== true && !this.validate()) return;
	var formData = this.getFormData(true);
	
	var data = [];
	for (var key in formData) data.push(key+"="+encodeURIComponent(formData[key]));
	
	var afterload = function(loader) {
		if (callback) callback.call(this, loader, loader.xmlDoc.responseText);
	};
	
	if (mode == "get") {
		window.dhx4.ajax.get(url+(url.indexOf("?")==-1?"?":"&")+data.join("&"), afterload);
	} else {
		window.dhx4.ajax.post(url, data.join("&"), afterload);
	}
	
};

dhtmlXForm.prototype.save = function(url, type){};

dhtmlXForm.prototype.dummy = function(){};

dhtmlXForm.prototype._changeFormId = function(oldid, newid) {
	this.formId = newid;
};

dhtmlXForm.prototype._dp_init = function(dp) {
	
	dp._methods = ["dummy", "dummy", "_changeFormId", "dummy"];
	
	dp._getRowData = function(id, pref) {
		var data = this.obj.getFormData(true);
		data[this.action_param] = this.obj.getUserData(id, this.action_param);
		return data;
	};
	dp._clearUpdateFlag = function(){};
	
	dp.attachEvent("onAfterUpdate", function(sid, action, tid, tag){
		if (action == "inserted" || action == "updated"){
			this.obj.resetDataProcessor("updated");
			this.obj._last_load_data = this.obj.getFormData(true);
		}
		this.obj.callEvent("onAfterSave",[this.obj.formId, tag]);
		return true;
	});
	
	dp.autoUpdate = false;
	dp.setTransactionMode("POST", true);
	
	this.dp = dp;
	
	this.formId = (new Date()).valueOf();
	this.resetDataProcessor("inserted");
	
	this.save = function(){
		if (!this.callEvent("onBeforeSave", [this.formId, this.getFormData()])) return;
		if (!this.validate()) return;
		dp.sendData();
	};
};


dhtmlXForm.prototype.resetDataProcessor = function(mode){
	if (!this.dp) return;
	this.dp.updatedRows = []; this.dp._in_progress = [];
	this.dp.setUpdated(this.formId, true, mode);
};

// cc listener
dhtmlXForm.prototype._ccActivate = function(id, inp, val) {
	
	if (!this._formLS) this._formLS = {};
	if (!this._formLS[id]) this._formLS[id] = {input: inp, value: val};
	if (!this._ccActive) {
		this._ccActive = true;
		this._ccDo();
	}
	inp = null;
};

dhtmlXForm.prototype._ccDeactivate = function(id) {
	
	if (this._ccTm) window.clearTimeout(this._ccTm);
	this._ccActive = false;
	if (this._formLS != null && this._formLS[id] != null) {
		this._formLS[id].input = null;
		this._formLS[id] = null;
		delete this._formLS[id];
	}
};

dhtmlXForm.prototype._ccDo = function() {
	
	if (this._ccTm) window.clearTimeout(this._ccTm);
	
	for (var a in this._formLS) {
		
		var inp = this._formLS[a].input;
		
		if (String(inp.tagName).toLowerCase() == "select") {
			var v = "";
			if (inp.selectedIndex >= 0 && inp.selectedIndex < inp.options.length) v = inp.options[inp.selectedIndex].value;
		} else {
			var v = inp.value;
		}
		if (v != this._formLS[a].value) {
			this._formLS[a].value = v;
			this.callEvent("onInputChange",[inp._idd,v,this]);
		}
		inp = null;
		
	}
	
	if (this._ccActive) {
		var t = this;
		this._ccTm = window.setTimeout(function(){t._ccDo();t=null;},100);
	}
	
};
	
dhtmlXForm.prototype._ccReload = function(id, value) { // update item's value while item have focus
	if (this._formLS && this._formLS[id]) {
		this._formLS[id].value = value;
	}
};



dhtmlXForm.prototype._autoload = function() {
	var a = [
		"ftype", "name", "value", "label", "check", "checked", "disabled", "text", "rows", "select", "selected", "width", "style", "className",
		"labelWidth", "labelHeight", "labelLeft", "labelTop", "inputWidth", "inputHeight", "inputLeft", "inputTop", "position", "size"
	];
	var k = document.getElementsByTagName("UL");
	var u = [];
	for (var q=0; q<k.length; q++) {
		if (k[q].className == "dhtmlxForm") {
			var formNode = document.createElement("DIV");
			u[u.length] = {nodeUL:k[q], nodeForm:formNode, data:dhtmlXForm.prototype._ulToObject(k[q], a), name:(k[q].getAttribute("name")||null)};
		}
	}
	for (var q=0; q<u.length; q++) {
		u[q].nodeUL.parentNode.insertBefore(u[q].nodeForm, u[q].nodeUL);
		var listObj = new dhtmlXForm(u[q].nodeForm, u[q].data);
		if (u[q].name !== null) window[u[q].name] = listObj;
		var t = (u[q].nodeUL.getAttribute("oninit")||null);
		u[q].nodeUL.parentNode.removeChild(u[q].nodeUL);
		u[q].nodeUL = null;
		u[q].nodeForm = null;
		u[q].data = null;
		u[q] = null;
		// oninit call
		if (t) { if (typeof(t) == "function") t(); else if (typeof(window[t]) == "function") window[t](); }
	}
	if (typeof(window.addEventListener) == "function") {
		window.removeEventListener("load", dhtmlXForm.prototype._autoload, false);
	} else {
		window.detachEvent("onload", dhtmlXForm.prototype._autoload);
	};
	
};

if (typeof(window.addEventListener) == "function") {
	window.addEventListener("load", dhtmlXForm.prototype._autoload, false);
} else {
	window.attachEvent("onload", dhtmlXForm.prototype._autoload);
};

/* validation */
//all purpose set of rules, based on http://code.google.com/p/validation-js
if (!window.dhtmlxValidation){
	dhtmlxValidation = function(){};
	dhtmlxValidation.prototype = {
		isEmpty: function(value) {
			return value == '';
		},
		isNotEmpty: function(value) {
			return (value instanceof Array?value.length>0:!value == ''); // array in case of multiselect
		},
		isValidBoolean: function(value) {
			return !!value.toString().match(/^(0|1|true|false)$/);
		},
		isValidEmail: function(value) {
			return !!value.toString().match(/(^[a-z0-9]([0-9a-z\-_\.]*)@([0-9a-z_\-\.]*)([.][a-z]{3})$)|(^[a-z]([0-9a-z_\.\-]*)@([0-9a-z_\-\.]*)(\.[a-z]{2,4})$)/i);
		},
		isValidInteger: function(value) {
			return !!value.toString().match(/(^-?\d+$)/);
		},
		isValidNumeric: function(value) {
			return !!value.toString().match(/(^-?\d\d*[\.|,]\d*$)|(^-?\d\d*$)|(^-?[\.|,]\d\d*$)/);
		},
		isValidAplhaNumeric: function(value) {
			return !!value.toString().match(/^[_\-a-z0-9]+$/gi);
		},
		// 0000-00-00 00:00:00 to 9999:12:31 59:59:59 (no it is not a "valid DATE" function)
		isValidDatetime: function(value) {
			var dt = value.toString().match(/^(\d{4})-(\d{2})-(\d{2})\s(\d{2}):(\d{2}):(\d{2})$/);
			return dt && !!(dt[1]<=9999 && dt[2]<=12 && dt[3]<=31 && dt[4]<=59 && dt[5]<=59 && dt[6]<=59) || false;
		},
		// 0000-00-00 to 9999-12-31
		isValidDate: function(value) {
			var d = value.toString().match(/^(\d{4})-(\d{2})-(\d{2})$/);
			return d && !!(d[1]<=9999 && d[2]<=12 && d[3]<=31) || false;
		},
		// 00:00:00 to 59:59:59
		isValidTime: function(value) {
			var t = value.toString().match(/^(\d{1,2}):(\d{1,2}):(\d{1,2})$/);
			return t && !!(t[1]<=24 && t[2]<=59 && t[3]<=59) || false;
		},
		// 0.0.0.0 to 255.255.255.255
		isValidIPv4: function(value) { 
			var ip = value.toString().match(/^(\d{1,3})\.(\d{1,3})\.(\d{1,3})\.(\d{1,3})$/);
			return ip && !!(ip[1]<=255 && ip[2]<=255 && ip[3]<=255 && ip[4]<=255) || false;
		},
		isValidCurrency: function(value) { // Q: Should I consider those signs valid too ? : ¢|€|₤|₦|¥
			return value.toString().match(/^\$?\s?\d+?([\.,\,]?\d+)?\s?\$?$/) && true || false;
		},
		// Social Security Number (999-99-9999 or 999999999)
		isValidSSN: function(value) {
			return value.toString().match(/^\d{3}\-?\d{2}\-?\d{4}$/) && true || false;
		},
		// Social Insurance Number (999999999)
		isValidSIN: function(value) {
			return value.toString().match(/^\d{9}$/) && true || false;
		}
	};
	dhtmlxValidation = new dhtmlxValidation();
};


if (typeof(window.dhtmlXCellObject) != "undefined") {
	
	dhtmlXCellObject.prototype.attachForm = function(data) {
		
		var obj = document.createElement("DIV");
		obj.style.width = "100%";
		obj.style.height = "100%";
		obj.style.position = "relative";
		
		if (window.dhtmlx && dhtmlx.$customScroll) dhtmlx.CustomScroll.enable(obj); else obj.style.overflow = "auto";
		
		this._attachObject(obj);
		
		this.dataType = "form";
		this.dataObj = new dhtmlXForm(obj, data);
		this.dataObj.setSkin(this.conf.skin);
		
		obj = null;
		
		this.callEvent("_onContentAttach",[]);
		
		return this.dataObj;
		
	};
	
}


/*
Product Name: dhtmlxSuite 
Version: 4.1.3 
Edition: Professional 
License: content of this file is covered by DHTMLX Commercial or Enterprise license. Usage without proper license is prohibited. To obtain it contact sales@dhtmlx.com
Copyright UAB Dinamenta http://www.dhtmlx.com
*/

dhtmlXForm.prototype.items.combo = {
	
	render: function(item, data) {
		
		item._type = "combo";
		item._enabled = true;
		item._value = null;
		item._newValue = null;
		
		this.doAddLabel(item, data);
		this.doAddInput(item, data, "SELECT", null, true, true, "dhxform_select");
		this.doAttachEvents(item);
		this.doLoadOpts(item, data);
		
		// allow selection to prevent broking combo logic
		item.onselectstart = function(e){return true;}
		
		// item.childNodes[1].childNodes[0].opt_type = data.comboType||"";
		item.childNodes[item._ll?1:0].childNodes[0].setAttribute("mode", data.comboType||"");
		if (data.comboImagePath) item.childNodes[item._ll?1:0].childNodes[0].setAttribute("imagePath", data.comboImagePath);
		if (data.comboDefaultImage) item.childNodes[item._ll?1:0].childNodes[0].setAttribute("defaultImage", data.comboDefaultImage);
		if (data.comboDefaultImageDis) item.childNodes[item._ll?1:0].childNodes[0].setAttribute("defaultImageDis", data.comboDefaultImageDis);
		
		item._combo = new dhtmlXComboFromSelect(item.childNodes[item._ll?1:0].childNodes[0]);
		item._combo.setSkin(item.getForm().skin);
		item._combo._currentComboValue = item._combo.getSelectedValue();
		item._combo.getInput().id = data.uid;
		
		var k = this;
		item._combo.attachEvent("onChange", function(){
			k.doOnChange(this);
		});
		
		if (data.connector) this.doLoadOptsConnector(item, data.connector);
		
		if (data.filtering) {
			item._combo.enableFilteringMode(true);
		} else if (data.serverFiltering) {
			item._combo.enableFilteringMode(true, data.serverFiltering, data.filterCache, data.filterSubLoad);
		}
		
		if (data.readonly == true) this.setReadonly(item, true);
		
		if (data.style) item._combo.DOMelem_input.style.cssText += data.style;
		
		item._combo.attachEvent("onFocus", function(){
			var item = this.cont.parentNode.parentNode;
			var f = item.getForm();
			if (f.skin == "dhx_terrace" && this.cont.className.search(/combo_in_focus/) < 0) this.cont.className += " combo_in_focus";
			f.callEvent("onFocus", [item._idd]);
			f = item = null;
		});
		
		item._combo.attachEvent("onBlur", function(){
			var item = this.cont.parentNode.parentNode;
			var f = item.getForm();
			if (f.skin == "dhx_terrace" && this.cont.className.search(/combo_in_focus/) >= 0) this.cont.className = this.cont.className.replace(/\s{0,}combo_in_focus/gi,"");
			f.callEvent("onBlur", [item._idd]);
			f = item = null;
		});
		
		return this;
	},
	
	destruct: function(item) {
		
		// unload combo
		item.childNodes[item._ll?1:0].childNodes[0].onchange = null;
		
		item._combo._currentComboValue = null;
		item._combo.unload();
		item._combo = null;
		
		// unload item
		item._apiChange = null;
		this.d2(item);
		item = null;
		
	},
	
	doAttachEvents: function(item) {
		
		var that = this;
		
		item.childNodes[item._ll?1:0].childNodes[0].onchange = function() {
			that.doOnChange(this);
			that.doValidate(this.DOMParent.parentNode.parentNode);
		}
	},
	
	doValidate: function(item) {
		if (item.getForm().hot_validate) this._validate(item);
	},
	
	doOnChange: function(combo) {
		var item = combo.base.parentNode.parentNode.parentNode;
		if (item._apiChange) return;
		combo._newComboValue = combo.getSelectedValue();
		if (combo._newComboValue != combo._currentComboValue) {
			if (item.checkEvent("onBeforeChange")) {
				if (item.callEvent("onBeforeChange", [item._idd, combo._currentComboValue, combo._newComboValue]) !== true) {
					// restore last value
					// not the best solution, should be improved
					window.setTimeout(function(){combo.setComboValue(combo._currentComboValue);},1);
					return false;
				}
			}
			combo._currentComboValue = combo._newComboValue;
			item.callEvent("onChange", [item._idd, combo._currentComboValue]);
		}
		item._autoCheck(item._enabled);
	},
	
	doLoadOptsConnector: function(item, url) {
		var that = this;
		var i = item;
		item._connector_working = true;
		item._apiChange = true;
		item._combo.load(url, function(){
			// try to set value if it was called while options loading was in progress
			i.callEvent("onOptionsLoaded", [i._idd]);
			i._connector_working = false;
			if (i._connector_value != null) {
				that.setValue(i, i._connector_value);
				i._connector_value = null;
			}
			i._apiChange = false;
			that = i = null;
		});
	},
	
	enable: function(item) {
		if (String(item.className).search("disabled") >= 0) item.className = String(item.className).replace(/disabled/gi,"");
		item._enabled = true;
		item._combo.enable();
	},
	
	disable: function(item) {
		if (String(item.className).search("disabled") < 0) item.className += " disabled";
		item._enabled = false;
		item._combo.disable();
	},
	
	getCombo: function(item) {
		return item._combo;
	},
	
	setValue: function(item, val) {
		if (item._connector_working) { // attemp to set value while optins not yet loaded (connector used)
			item._connector_value = val;
			return;
		}
		item._apiChange = true;
		item._combo.setComboValue(val);
		item._combo._currentComboValue = item._combo.getActualValue();
		item._apiChange = false;
	},
	
	getValue: function(item) {
		return item._combo.getActualValue();
	},
	
	setWidth: function(item, width) {
		item.childNodes[item._ll?1:0].childNodes[0].style.width = width+"px";
	},
	
	setReadonly: function(item, state) {
		if (!item._combo) return;
		item._combo_ro = state;
		item._combo.readonly(item._combo_ro);
	},

	isReadonly: function(item, state) {
		return item._combo_ro||false;
	},
	
	setFocus: function(item) {
		if (item._enabled) item._combo.setFocus();
	},
	
	_setCss: function(item, skin, fontSize) {
		// update font-size for input and list-options div
		item._combo.setFontSize(fontSize, fontSize);
	}
	
};

(function(){
	for (var a in {doAddLabel:1,doAddInput:1,doLoadOpts:1,doUnloadNestedLists:1,setText:1,getText:1,isEnabled:1,_checkNoteWidth:1})
		dhtmlXForm.prototype.items.combo[a] = dhtmlXForm.prototype.items.select[a];
})();

dhtmlXForm.prototype.items.combo.d2 = dhtmlXForm.prototype.items.select.destruct;

dhtmlXForm.prototype.getCombo = function(name) {
	return this.doWithItem(name, "getCombo");
};



/*
Product Name: dhtmlxSuite 
Version: 4.1.3 
Edition: Professional 
License: content of this file is covered by DHTMLX Commercial or Enterprise license. Usage without proper license is prohibited. To obtain it contact sales@dhtmlx.com
Copyright UAB Dinamenta http://www.dhtmlx.com
*/

dhtmlXForm.prototype.items.calendar = {
	
	render: function(item, data) {
		
		var t = this;
		
		item._type = "calendar";
		item._enabled = true;
		
		// dbl-click fix for IE6-8 (i.e. to select date user needs to click twice)
		var n = navigator.userAgent;
		var dblclickFix = (n.indexOf("MSIE 6.0") >= 0 || n.indexOf("MSIE 7.0") >= 0 || n.indexOf("MSIE 8.0") >= 0);
		
		this.doAddLabel(item, data);
		this.doAddInput(item, data, "INPUT", "TEXT", true, true, "dhxform_textarea calendar");
		this.doAttachChangeLS(item);
		
		if (dblclickFix) {
			item.childNodes[item._ll?1:0].childNodes[0].onfocus2 = item.childNodes[item._ll?1:0].childNodes[0].onfocus;
			item.childNodes[item._ll?1:0].childNodes[0].onfocus = function() {
				if (this._skipOnFocus == true) {
					this._skipOnFocus = false;
					return;
				}
				this.onfocus2.apply(this,arguments);
			}
		}
		
		item.childNodes[item._ll?1:0].childNodes[0]._idd = item._idd;
		item.childNodes[item._ll?1:0].childNodes[0].onblur = function() {
			var i = this.parentNode.parentNode;
			if (i._c.base._formMouseDown) { // dblclickFix
				i._c.base._formMouseDown = false;
				this._skipOnFocus = true;
				this.focus();
				this.value = this.value;
				i = null;
				return true;
			}
			var f = i.getForm();
			f._ccDeactivate(i._idd);
			t.checkEnteredValue(this.parentNode.parentNode);
			if (f.live_validate) t._validate(i);
			f.callEvent("onBlur",[i._idd]);
			f = i = null;
		}
		
		item._f = (data.dateFormat||null); // formats
		item._f0 = (data.serverDateFormat||item._f); // formats for save-load, if set - use them for saving and loading only
		
		var f = item.getForm();
		
		item._c = new dhtmlXCalendarObject(item.childNodes[item._ll?1:0].childNodes[0], data.skin||f.skin||"dhx_skyblue");
		item._c._nullInInput = true; // allow null value from input
		item._c.enableListener(item.childNodes[item._ll?1:0].childNodes[0]);
		if (item._f != null) item._c.setDateFormat(item._f);
		if (!window.dhx4.s2b(data.enableTime)) item._c.hideTime();
		if (window.dhx4.s2b(data.showWeekNumbers)) item._c.showWeekNumbers();
		if (!isNaN(data.weekStart)) item._c.setWeekStartDay(data.weekStart);
		if (typeof(data.calendarPosition) != "undefined") item._c.setPosition(data.calendarPosition);
		if (data.minutesInterval != null) item._c.setMinutesInterval(data.minutesInterval);
		
		item._c._itemIdd = item._idd;
		
		item._c.attachEvent("onBeforeChange", function(d) {
			if (item._value != d) {
				// call some events
				if (item.checkEvent("onBeforeChange")) {
					if (item.callEvent("onBeforeChange",[item._idd, item._value, d]) !== true) {
						return false;
					}
				}
				// accepted
				item._tempValue = item._value = d;
				t.setValue(item, d, false);
				item.callEvent("onChange", [this._itemIdd, item._value]);
			}
			return true;
			
		});
		
		item._c.attachEvent("onClick", function(){
			item._tempValue = null;
		});
		
		if (dblclickFix) {
			item._c.base.onmousedown = function() {
				this._formMouseDown = true;
				return false;
			}
		}
		
		this.setValue(item, data.value);
		
		f = null;
		
		return this;
		
	},
	
	getCalendar: function(item) {
		return item._c;
	},
	
	setSkin: function(item, skin) {
		item._c.setSkin(skin);
	},
	
	setValue: function(item, value, cUpd) {
		if (!value || value == null || typeof(value) == "undefined" || value == "") {
			item._value = null;
			item.childNodes[item._ll?1:0].childNodes[0].value = "";
		} else {
			item._value = (value instanceof Date ? value : item._c._strToDate(value, item._f0||item._c._dateFormat));
			item.childNodes[item._ll?1:0].childNodes[0].value = item._c._dateToStr(item._value, item._f||item._c._dateFormat);
		}
		if (cUpd !== false) item._c.setDate(item._value);
	},
	
	getValue: function(item, asString) {
		var d = item._tempValue||item._c.getDate();
		if (asString===true && d == null) return "";
		return (asString===true?item._c._dateToStr(d,item._f0||item._c._dateFormat):d);
	},
	
	setDateFormat: function(item, dateFormat, serverDateFormat) {
		item._f = dateFormat;
		item._f0 = (serverDateFormat||item._f);
		item._c.setDateFormat(item._f);
		this.setValue(item, this.getValue(item));
	},
	
	destruct: function(item) {
		
		// unload calendar instance
		item._c.disableListener(item.childNodes[item._ll?1:0].childNodes[0]);
		item._c.unload();
		item._c = null;
		try {delete item._c;} catch(e){}
		
		item._f = null;
		try {delete item._f;} catch(e){}
		
		item._f0 = null;
		try {delete item._f0;} catch(e){}
		
		// remove custom events/objects
		item.childNodes[item._ll?1:0].childNodes[0]._idd = null;
		item.childNodes[item._ll?1:0].childNodes[0].onblur = null;
		
		// unload item
		this.d2(item);
		item = null;
	},
	
	checkEnteredValue: function(item) {
		this.setValue(item, item._c.getDate());
	}
	
};

(function(){
	for (var a in {doAddLabel:1,doAddInput:1,doUnloadNestedLists:1,setText:1,getText:1,enable:1,disable:1,isEnabled:1,setWidth:1,setReadonly:1,isReadonly:1,setFocus:1,getInput:1})
		dhtmlXForm.prototype.items.calendar[a] = dhtmlXForm.prototype.items.input[a];
})();
dhtmlXForm.prototype.items.calendar.doAttachChangeLS = dhtmlXForm.prototype.items.select.doAttachChangeLS;
dhtmlXForm.prototype.items.calendar.d2 = dhtmlXForm.prototype.items.input.destruct;

dhtmlXForm.prototype.getCalendar = function(name) {
	return this.doWithItem(name, "getCalendar");
};

dhtmlXForm.prototype.setCalendarDateFormat = function(name, dateFormat, serverDateFormat) {
	this.doWithItem(name, "setDateFormat", dateFormat, serverDateFormat);
};


/*
Product Name: dhtmlxSuite 
Version: 4.1.3 
Edition: Professional 
License: content of this file is covered by DHTMLX Commercial or Enterprise license. Usage without proper license is prohibited. To obtain it contact sales@dhtmlx.com
Copyright UAB Dinamenta http://www.dhtmlx.com
*/

dhtmlXForm.prototype.items.container = {
	
	render: function(item, data) {
		
		item._type = "container";
		item._enabled = true;
		
		this.doAddLabel(item, data);
		this.doAddInput(item, data, "DIV", null, true, true, "dhxform_container");
		
		return this;
		
	},
	
	getContainer: function(item) {
		return item.childNodes[item._ll?1:0].childNodes[0];
	},
	
	enable: function(item) {
		item._enabled = true;
		if (String(item.className).search("disabled") >= 0) item.className = String(item.className).replace(/disabled/gi,"");
		//
		item.callEvent("onEnable",[item._idd]);
	},
	
	disable: function(item) {
		item._enabled = false;
		if (String(item.className).search("disabled") < 0) item.className += " disabled";
		//
		item.callEvent("onDisable",[item._idd]);
	},
	
	doAttachEvents: function(){
		
	},
	
	setValue: function(){
		
	},
	
	getValue: function(){
		return null;
	}
	
};

dhtmlXForm.prototype.getContainer = function(name) {
	return this.doWithItem(name, "getContainer");
};

(function(){
	for (var a in dhtmlXForm.prototype.items.input) {
		if (!dhtmlXForm.prototype.items.container[a]) dhtmlXForm.prototype.items.container[a] = dhtmlXForm.prototype.items.input[a];
	}
})();


/*
Product Name: dhtmlxSuite 
Version: 4.1.3 
Edition: Professional 
License: content of this file is covered by DHTMLX Commercial or Enterprise license. Usage without proper license is prohibited. To obtain it contact sales@dhtmlx.com
Copyright UAB Dinamenta http://www.dhtmlx.com
*/

dhtmlXForm.prototype.items.editor = {
	
	editor: {},
	
	render: function(item, data) {
		
		var ta = (!isNaN(data.rows));
		
		item._type = "editor";
		item._enabled = true;
		
		this.doAddLabel(item, data);
		this.doAddInput(item, data, "DIV", null, true, true, "dhxform_item_template");
		
		item._value = (data.value||"");
		
		var that = this;
		this.editor[item._idd] = new dhtmlXEditor({
			parent: item.childNodes[item._ll?1:0].childNodes[0],
			content: item._value,
			iconsPath: data.iconsPath, // path for toolbar icons
			toolbar: data.toolbar
		});
		
		this.editor[item._idd].attachEvent("onAccess",function(t, ev){
			// generate body click to hide menu/toolbar/calendar/combo/other stuff if any
			item.callEvent("_onBeforeEditorAccess", []); // if editor attached to form in popup - do some tricks
			_dhxForm_doClick(document.body, "click");
			// continue
			if (t == "blur") {
				that.doOnBlur(item, this);
				item.callEvent("onBlur", [item._idd]);
				if (item.getForm().skin == "dhx_terrace") {
					var css = item.childNodes[item._ll?1:0].className;
					if (css.indexOf("dhxeditor_focus") >= 0) item.childNodes[item._ll?1:0].className = (css).replace(/\s{0,}dhxeditor_focus/gi,"");
				}
			} else {
				item.callEvent("onEditorAccess", [item._idd, t, ev, this, item.getForm()]);
				item.callEvent("onFocus", [item._idd]);
				if (item.getForm().skin == "dhx_terrace") {
					var css = item.childNodes[item._ll?1:0].className;
					if (css.indexOf("dhxeditor_focus") == -1) item.childNodes[item._ll?1:0].className += " dhxeditor_focus";
				}
			}
		});
		
		this.editor[item._idd].attachEvent("onToolbarClick", function(a){
			item.callEvent("onEditorToolbarClick", [item._idd, a, this, item.getForm()]);
		});
		
		if (data.readonly) this.setReadonly(item, true);
		
		// emulate label-for
		item.childNodes[item._ll?0:1].childNodes[0].removeAttribute("for");
		item.childNodes[item._ll?0:1].childNodes[0].onclick = function() {
			that.editor[item._idd]._focus();
		}
		
		return this;
		
	},
	
	// destructor for editor needed
	doOnBlur: function(item, editor) {
		var t = editor.getContent();
		if (item._value != t) {
			if (item.checkEvent("onBeforeChange")) {
				if (item.callEvent("onBeforeChange",[item._idd, item._value, t]) !== true) {
					// restore
					editor.setContent(item._value);
					return;
				}
			}
			// accepted
			item._value = t;
			item.callEvent("onChange",[item._idd, t]);
		}
	},
	
	setValue: function(item, value) {
		if (item._value == value) return;
		item._value = value;
		this.editor[item._idd].setContent(item._value);
	},
	
	getValue: function(item) {
		item._value = this.editor[item._idd].getContent();
		return item._value;
	},
	
	enable: function(item) {
		this.editor[item._idd].setReadonly(false);
		this.doEn(item);
	},
	
	disable: function(item) {
		this.editor[item._idd].setReadonly(true);
		this.doDis(item);
	},
	
	setReadonly: function(item, mode) {
		this.editor[item._idd].setReadonly(mode);
	},
	
	getEditor: function(item) {
		return (this.editor[item._idd]||null);
	},
	
	destruct: function(item) {
		
		// custom editor functionality
		item.childNodes[item._ll?0:1].childNodes[0].onclick = null;
		
		// unload editor
		this.editor[item._idd].unload();
		this.editor[item._idd] = null;
		
		// unload item
		this.d2(item);
		item = null;
		
	},
	
	setFocus: function(item) {
		this.editor[item._idd]._focus();
	}
	
};

(function(){
	for (var a in {doAddLabel:1,doAddInput:1,doUnloadNestedLists:1,setText:1,getText:1,setWidth:1,isEnabled:1})
		dhtmlXForm.prototype.items.editor[a] = dhtmlXForm.prototype.items.template[a];
})();

dhtmlXForm.prototype.items.editor.d2 = dhtmlXForm.prototype.items.select.destruct;
dhtmlXForm.prototype.items.editor.doEn = dhtmlXForm.prototype.items.select.enable;
dhtmlXForm.prototype.items.editor.doDis = dhtmlXForm.prototype.items.select.disable;

dhtmlXForm.prototype.getEditor = function(name) {
	return this.doWithItem(name, "getEditor");
};



/*
Product Name: dhtmlxSuite 
Version: 4.1.3 
Edition: Professional 
License: content of this file is covered by DHTMLX Commercial or Enterprise license. Usage without proper license is prohibited. To obtain it contact sales@dhtmlx.com
Copyright UAB Dinamenta http://www.dhtmlx.com
*/

/* add item */
dhtmlXForm.prototype.addItem = function(pId, itemData, pos, insertAfter) {
	
	// insertAfter
	// if any columns used - item will inserted into colunm where item[pos] positioned, before it
	// insertAfter specifies that new item will inserted after item[pos], to add possibility to make new item last in column
	// this param ignored when inserting newcolumn
	
	// pId = [id,value] for radiobutton
	var pValue = null;
	if (pId instanceof Array) {pValue = pId[1];pId = pId[0];}
	
	var f = null;
	if (pId != null) {
		var f = this._getParentForm(pId, pValue);
		// check if item in "f" have nested form
		if (f != null) {
			if (f.item._list == null) {
				// create list
				if (!itemData.listParent) itemData.listParent = f.item._idd;
				f.form._addItem("list", f.item._idd, [itemData], null, f.item._idd, pos, insertAfter);
			} else {
				f.item._list[0].addItem(null, itemData, pos, insertAfter);
			}
			f.form = f.item = null;
			f = null;
			this._autoCheck();
			return;
		}
	}
	
	this._prepareItem(itemData, pos, insertAfter);
	this._autoCheck();
};

/* remove item */
dhtmlXForm.prototype.removeItem = function(id, value) {
	this._removeItem(id, value);
};

/* remove newcolumn */
dhtmlXForm.prototype.removeColumn = function(pId, index, removeItems, moveAfter) {
	
	// index of column
	// if single column - only items can be deleted if removeItems==true
	// if more than one column and removeItems==false, move items to leftmost column (if not exists - to right) and vise versa if moveAfter=true
	
	// pId = [id,value] for radiobutton
	var pValue = null;
	if (pId instanceof Array) {pValue = pId[1];pId = pId[0];}
	
	if (pId != null) {
		var f = this._getParentForm(pId, pValue);
		if (f != null) {
			if (f.item._list != null && f.item._list[0] != null) {
				f.item._list[0].removeColumn(null, index, removeItems, moveAfter);
			}
			f.form = f.item = null;
			f = null;
		}
		return;
	}
	
	// find base
	index = Math.min(Math.max(index,0), this.cont.childNodes.length-1); // index [0..length-1)
	if (this.cont.childNodes.length == 1) {
		// one column
		if (removeItems == true) {
			// remove items
			this._removeItemsInColumn(this.cont.childNodes[index]);
		}
	} else {
		// more than one
		if (removeItems == true) {
			// remove items
			this._removeItemsInColumn(this.cont.childNodes[index]);
		} else {
			// move items to next column
			if (!moveAfter) {
				var moveToBase = index-1;
				if (moveToBase < 0) moveToBase = index+1;
			} else {
				var moveToBase = index+1;
				if (moveToBase > this.cont.childNodes.length-1) moveToBase = index-1;
			}
			// console.log("index ",index,"moveToBase",moveToBase)
			while (this.cont.childNodes[index].childNodes.length > 0) {
				this.cont.childNodes[moveToBase].appendChild(this.cont.childNodes[index].childNodes[0]);
			}
			
		}
		var t = [];
		for (var q=0; q<this.base.length; q++) {
			if (this.cont.childNodes[index] != this.base[q]) t.push(this.base[q]);
		}
		this.base = t;
		this.cont.removeChild(this.cont.childNodes[index]);
		this.b_index--;
		t = null;
	}
};

dhtmlXForm.prototype.getColumnNode = function(pId, index) {
	
	var node = null;
	
	var pValue = null;
	if (pId instanceof Array) {pValue = pId[1];pId = pId[0];}
	
	if (pId != null) {
		var f = this._getParentForm(pId, pValue);
		if (f != null) {
			if (f.item._list != null && f.item._list[0] != null && node == null) {
				node = f.item._list[0].getColumnNode(null, index);
			}
			f.form = f.item = null;
			f = null;
		}
		return node;
	}
	
	if (index < 0 || index > this.cont.childNodes.length-1) return null;
	return this.cont.childNodes[index];
};

dhtmlXForm.prototype._removeItemsInColumn = function(base) {
	var items = [];
	for (var q=0; q<base.childNodes.length; q++) {
		var i = base.childNodes[q];
		if (i._idd != null && i._type != null) items.push([i._idd, (i._type=="ra"?i._value:null)]);
		i = null;
	}
	for (var q=0; q<items.length; q++) {
		this.removeItem(items[q][0],items[q][1]);
	}
};

dhtmlXForm.prototype._getParentForm = function(id, value) {
	// check if simple item
	if (this.itemPull[this.idPrefix+id] != null) {
		return {form: this, item: this.itemPull[this.idPrefix+id]};
	}
	// check if radio
	for (var a in this.itemPull) {
		if (this.itemPull[a]._type == "ra" && this.itemPull[a]._group == id && this.itemPull[a]._value == value) {
			return {form: this, item: this.itemPull[a]};
		}
	}
	var f = null;
	for (var a in this.itemPull) {
		if (!f && this.itemPull[a]._list != null) {
			for (var q=0; q<this.itemPull[a]._list.length; q++) {
				if (!f) f = this.itemPull[a]._list[q]._getParentForm(id, value);
			}
		}
	}
	
	return f;
};

(function(){
	for (var a in dhtmlXForm.prototype.items) {
		if (!dhtmlXForm.prototype.items[a]._getItemNode) dhtmlXForm.prototype.items[a]._getItemNode = function(item){return item;}
	}
})();

dhtmlXForm.prototype._getItemNode = function(id, value) {
	if (value != null) id = [id, value];
	return this.doWithItem(id, "_getItemNode");
};


/* set/clear required flag */
dhtmlXForm.prototype.setRequired = function(id, value, state) {
	
	if (typeof(state) == "undefined") state = value; else id = [id,value];
	var item = this._getItemNode(id);
	if (!item) return;
	
	state = window.dhx4.s2b(state);
	item._required = (state==true);
	
	// validation
	if (item._required) {
		if (!item._validate) item._validate = [];
		var t = false;
		for (var q=0; q<item._validate.length; q++) t = (item._validate[q]=="NotEmpty"||t);
		if (!t) item._validate.push("NotEmpty");
		var p = item.childNodes[item._ll?0:1].childNodes[0];
		if (!(p.lastChild && p.lastChild.className && p.lastChild.className.search(/required/) >= 0)) {
			var k = document.createElement("SPAN");
			k.className = "dhxform_item_required";
			k.innerHTML = "*";
			p.appendChild(k);
			k = p = null;
		}
	} else {
		if (item._validate != null) {
			var t = item._validate;
			item._validate = [];
			for (var q=0; q<t.length; q++) { if (t[q] != "NotEmpty") item._validate.push(t[q]); }
			if (item._validate.length == 0) item._validate = null;
		}
		var p = item.childNodes[item._ll?0:1].childNodes[0];
		if (p.lastChild && p.lastChild.className && p.lastChild.className.search(/required/) >= 0) {
			p.removeChild(p.lastChild);
			p = null;
		}
	}
	
	this._resetValidateCss(item);
	item = null;
	
};

/* set/clear note */
dhtmlXForm.prototype.setNote = function(id, value, note) {
	
	if (typeof(note) == "undefined") note = value; else id = [id,value];
	var item = this._getItemNode(id);
	if (!item) return;
	
	var p = this._getNoteNode(item);
	
	if (!p) {
		if (!note.width) note.width = item.childNodes[item._ll?1:0].childNodes[0].offsetWidth;
		p = document.createElement("DIV");
		p.className = "dhxform_note";
		if ({"ch":1,"ra":1}[item._type]) {
			item.childNodes[item._ll?1:0].insertBefore(p, item.childNodes[item._ll?1:0].lastChild);
		} else {
			item.childNodes[item._ll?1:0].appendChild(p);
		}
		
	}
	
	p.innerHTML = note.text;
	if (note.width != null) {
		p.style.width = note.width+"px";
		p._w = note.width;
	}
	
	p = null;
};

dhtmlXForm.prototype.clearNote = function(id, value) {
	
	if (typeof(value) != "undefined") id = [id,value];
	var item = this._getItemNode(id);
	if (!item) return;
	
	var p = this._getNoteNode(item);
	if (p != null) {
		p.parentNode.removeChild(p);
		p = null;
	}
	
};

dhtmlXForm.prototype._getNoteNode = function(item) {
	
	var p = null;
	for (var q=0; q<item.childNodes[item._ll?1:0].childNodes.length; q++) {
		if (String(item.childNodes[item._ll?1:0].childNodes[q].className).search(/dhxform_note/) >= 0) {
			p = item.childNodes[item._ll?1:0].childNodes[q];
		}
	}
	
	item = null;
	
	return p;
};

/* set/clear validation */

dhtmlXForm.prototype.setValidation = function(id, value, rule) {
	
	if (typeof(note) == "undefined") rule = value; else id = [id,value];
	var item = this._getItemNode(id);
	if (!item) return;
	
	// init state, clear prev
	if (item._validate != null) for (var q=0; q<item._validate.length; q++) item._validate[q] = null;
	item._validate = [];
	
	// apply new rules
	if (typeof(rule) == "function" || typeof(window[rule]) == "function") {
		item._validate = [rule];
	} else {
		item._validate = String(rule).split(this.separator);
	}
	
	// check required state
	if (item._required) {
		var r = false;
		for (var q=0; q<item._validate.length; q++) r = (item._validate[q]=="NotEmpty"||r);
		if (!r) item._validate.push("NotEmpty");
	}
	
	item = null;

};

dhtmlXForm.prototype.clearValidation = function(id, value) {
	
	if (typeof(value) != "undefined") id = [id,value];
	var item = this._getItemNode(id);
	if (!item) return;
	
	// clear
	if (item._validate != null) for (var q=0; q<item._validate.length; q++) item._validate[q] = null;
	
	// check required
	item._validate = item._required?["NotEmpty"]:null;
	
	item = null;
	
};

/* reload options */

dhtmlXForm.prototype.reloadOptions = function(name, data) {
	
	var t = this.getItemType(name);
	
	if (!{select:1,multiselect:1,combo:1}[t]) return;
	
	if (t == "select" || t == "multiselect") {
		var opts = this.getOptions(name);
		while (opts.length > 0) opts.remove(0);
		opts.length = 0;
		opts = null;
		if (typeof(data) == "string") {
			this.doWithItem(name, "doLoadOptsConnector", data);
		} else if (data instanceof Array) {
			this.doWithItem(name, "doLoadOpts", {options:data});
		}
	}
	
	if (t == "combo") {
		var combo = this.getCombo(name);
		combo.clearAll();
		combo.setComboValue("");
		if (typeof(data) == "string") {
			this.doWithItem(name, "doLoadOptsConnector", data);
		} else if (data instanceof Array) {
			var toSelect = null;
			for (var q=0; q<data.length; q++) if (window.dhx4.s2b(data[q].selected)) toSelect = data[q].value;
			combo.addOption(data);
			if (toSelect != null) this.setItemValue(name, toSelect);
			combo = null;
		}
	}
};

/* tooltips */

dhtmlXForm.prototype.setTooltip = function(id, value, tooltip) {
	
	if (typeof(tooltip) == "undefined") tooltip = value; else id = [id,value];
	var item = this._getItemNode(id);
	if (!item) return;
	
	var node = null;
	if (item.childNodes.length == 1) {
		node = item.childNodes[0];
	} else {
		for (var q=0; q<item.childNodes.length; q++) {
			if (item.childNodes[q].className != null && item.childNodes[q].className.search("dhxform_label") >= 0) {
				node = item.childNodes[q];
			}
		}
	}
	if (node != null) {
		if (tooltip == null || tooltip.length == 0) {
			node.removeAttribute("title");
		} else {
			node.title = tooltip;
		}
	}
	node = null;
};


/**
 *  @desc: новый метод формы - очистить всё
 */
dhtmlXForm.prototype.clearAll = function(){
	var names = [];
	this.forEachItem(function(name){
		names.push(name);
	});
	for(var i in names)
		this.removeItem(names[i]);
};
/*
Product Name: dhtmlxSuite 
Version: 4.1.3 
Edition: Professional 
License: content of this file is covered by DHTMLX Commercial or Enterprise license. Usage without proper license is prohibited. To obtain it contact sales@dhtmlx.com
Copyright UAB Dinamenta http://www.dhtmlx.com
*/

function dhtmlXLayoutObject(base, pattern, skin) {
	
	// console.log("resize over iframe");
	
	var autoload = null;
	if (base != null && typeof(base) == "object" && typeof(base.tagName) == "undefined" && base._isCell != true) {
		// api-init
		autoload = {};
		if (base.autosize != null) autoload.autosize = base.autosize;
		if (base.cells != null) autoload.cells = base.cells;
		if (base.pattern != null) pattern = base.pattern;
		if (base.skin != null) skin = base.skin;
		if (base.offsets != null) autoload.offsets = base.offsets;
		base = base.parent;
	}
	
	if (base == document.body) {
		// fullscreen
		this.base = base;
	} else if (typeof(base) == "string") {
		// id
		this.base = document.getElementById(base);
	} else {
		// attach
		if (base._isCell == true) {
			
			var conf = (typeof(autoload) != "undefined" && autoload != null ? autoload : {});
			if (conf.pattern == null && pattern != null) conf.pattern = pattern;
			if (conf.skin == null && skin != null) conf.skin = skin;
			
			var layout = base.attachLayout(conf);
			return layout;
			
		}
		
		this.base = base;
	}
	
	if (this.base != document.body) {
		while (this.base.childNodes.length > 0) this.base.removeChild(this.base.lastChild);
	}
	
	this.cdata = {};
	this.conf = {
		skin: (skin||window.dhx4.skin||(typeof(dhtmlx)!="undefined"?dhtmlx.skin:null)||window.dhx4.skinDetect("dhxlayout")||"dhx_skyblue"),
		hh: 20, // header height collapsed, add auto-detect?
		progress: false,
		autosize: "b", // cell which will sized when parent size changed
		nextCell: {a:"b",b:"a"},
		ofs: {t:0,b:0,l:0,r:0}, // base outer offset (fullscreen margins)
		ofs_nodes: {t:{},b:{}}, // attached menu/toolbar/sb/hdr/ftr
		inited: false,
		b_size: {w:-1,h:-1} // base size for onResize
	};
	
	// deparator width
	this.conf.sw = this._detectSW();
	
	// apply only to 1st parent
	if (true||this.base._isParentCell !== true) this.base.className += " dhxlayout_base_"+this.conf.skin;
	
	// custom offset for body
	if (this.base == document.body) {
		var ofsDef = {
			dhx_skyblue: {t: 2, b: 2, l: 2, r: 2},
			dhx_web:     {t: 8, b: 8, l: 8, r: 8},
			dhx_terrace: {t: 9, b: 9, l: 8, r: 8}
		};
		this.conf.ofs = (ofsDef[this.conf.skin] != null ? ofsDef[this.conf.skin] : ofsDef.dhx_skyblue);
	}
	
	// conf-offsets override (attachObject usualy)
	if (autoload != null && autoload.offsets != null) {
		this.setOffsets(autoload.offsets);
	} else if (this.base._ofs != null) {
		this.setOffsets(this.base._ofs);
		this.base._ofs = null;
		try {delete this.base._ofs;}catch(e){}; // IE6/IE7 fix
	}
	
	this.dataNodes = {}; // menu/toolbar/ribbon/sb/hdr/ftr
	
	var that = this;
	
	this._getLayout = function() {
		return this;
	}
	
	this.mainInst = (base._layoutMainInst != null ? base._layoutMainInst : null);
	
	this._getMainInst = function(){
		if (this.mainInst != null) return this.mainInst._getMainInst();
		return this;
	}
	
	this._init = function(pattern) {
		
		var t = (typeof(pattern) == "string" ? this.tplData[pattern] : pattern );
		
		this.conf.mode = t.mode;
		
		if (this.conf.mode == "c") {
			this.cdata.a = new dhtmlXLayoutCell("a", this);
		} else {
			this.cdata.a = new dhtmlXLayoutCell("a", this);
			this.cdata.b = new dhtmlXLayoutCell("b", this);
		}
		
		for (var a in this.cdata) {
			this.base.appendChild(this.cdata[a].cell);
			this.cdata[a].conf.init = { w: 0.5, h: 0.5 };
		}
		
		if (this.conf.mode != "c") {
			
			var mainInst = this._getMainInst();
			if (mainInst.conf.sep_idx == null) mainInst.conf.sep_idx = 1; else mainInst.conf.sep_idx++;
			
			this.sep = new dhtmlXLayoutSepObject(this.conf.mode, mainInst.conf.sep_idx);
			this.base.appendChild(this.sep.sep);
			
			this.sep._getLayout = function() {
				return that._getLayout();
			}
			
			mainInst = null;
		}
		
		if (t.cells != null) {
			for (var a in t.cells) {
				if (t.cells[a].width != null) this.cdata[a].conf.init.w = t.cells[a].width;
				if (t.cells[a].height != null) this.cdata[a].conf.init.h = t.cells[a].height;
				if (t.cells[a].name != null) {
					this.cdata[a].conf.name = t.cells[a].name;
					this.cdata[a].setText(t.cells[a].name);
				}
				// fixed size conf
				if (t.cells[a].fsize != null) this.cdata[a].conf.fsize = t.cells[a].fsize;
			}
		}
		
		this.setSizes();
		
		for (var a in this.cdata) this.cdata[a].conf.init = {};
			
		if (t.cells != null) {
			for (var a in t.cells) {
				if (t.cells[a].layout != null) {
					this.cdata[a].dataNested = true;
					this.cdata[a]._layoutMainInst = this;
					this.cdata[a].attachLayout({pattern:t.cells[a].layout});
					this.cdata[a]._layoutMainInst = null;
				}
			}
		}
		
	}
	
	this.setSizes = function(parentIdd, autosize, noCalcCont, actionType) {
		
		var rEv = (this.conf.inited==true && this._getMainInst()==this && this.checkEvent("onResizeFinish")==true ? {}:false); // resize event
		
		// noCalcCont - skip inner content adjusting, for autoexpand
		
		var ofsYT = this.conf.ofs.t;
		for (var a in this.conf.ofs_nodes.t) ofsYT += (this.conf.ofs_nodes.t[a]==true ? this.dataNodes[a].offsetHeight:0);
		
		var ofsYB = this.conf.ofs.b;
		for (var a in this.conf.ofs_nodes.b) ofsYB += (this.conf.ofs_nodes.b[a]==true ? this.dataNodes[a].offsetHeight:0);
		
		var ofsXL = this.conf.ofs.l;
		var ofsXR = this.conf.ofs.r;
		
		var baseW = this.base.offsetWidth;
		var baseH = this.base.offsetHeight;
		
		if (this.conf.mode == "c") {
			
			var ax = ofsXL;
			var ay = ofsYT;
			var aw = baseW-ofsXL-ofsXR;
			var ah = baseH-ofsYT-ofsYB;
			
			this.cdata.a._setSize(ax, ay, aw, ah, parentIdd, noCalcCont, actionType);
			
			this.callEvent("_onSetSizes", []);
			
			if (rEv && (!(this.conf.b_size.w == baseW && this.conf.b_size.h == baseH))) {
				this._callMainEvent("onResizeFinish", []);
			}
			
			this.conf.b_size = {w: baseW, h: baseH};
			
			return;
		}
		
		if (typeof(autosize) == "undefined") {
			
			var k = (this.conf.mode=="v"?"w":"h");
			
			autosize = this.conf.autosize;
			
			if (this.cdata.a.conf.collapsed) {
				autosize = "b";
			} else if (this.cdata.b.conf.collapsed) {
				autosize = "a";
			} else if (parentIdd == "a" || parentIdd == "b") {
				autosize = this.conf.nextCell[parentIdd];
			}
			
		} else {
			//debugger
		}
		
		
		if (this.conf.mode == "v") {
			
			if (autosize == "a") {
				
				// fix "b", fit "a"
				
				if (this.cdata.b.conf.init.w != null) {
					var bw = Math.round(baseW*this.cdata.b.conf.init.w-this.conf.sw/2)-ofsXR;
				} else {
					var bw = this.cdata.b.conf.size.w;
				}
				var bx = baseW-bw-ofsXR;
				var by = ofsYT;
				var bh = baseH-ofsYT-ofsYB;
				
				//
				
				var ax = ofsXL;
				var ay = by;
				var aw = bx-ax-this.conf.sw;
				var ah = bh;
				
				
			} else {
				
				// fix "a", fit "b"
				var ax = ofsXL;
				var ay = ofsYT;
				
				// check if init stage
				if (this.cdata.a.conf.init.w != null) {
					
					var aw = Math.round(baseW*this.cdata.a.conf.init.w-this.conf.sw/2)-ax;
				} else {
					var aw = this.cdata.a.conf.size.w;
				}
				
				var ah = baseH-ay-ofsYB;
				
				//
				var bx = ax+aw+this.conf.sw;
				var by = ay;
				var bw = baseW-bx-ofsXR;
				var bh = ah;
				
				
			}
			
			
			this.cdata.a._setSize(ax, ay, aw, ah, parentIdd, noCalcCont, actionType);
			this.cdata.b._setSize(bx, by, bw, bh, parentIdd, noCalcCont, actionType);
			
			this.sep._setSize(ax+aw, ay, this.conf.sw, ah);
			
			
		} else {
			
			if (autosize == "a") {
				
				// fix "b", fit "a"
				
				if (this.cdata.b.conf.init.h != null) {
					var bh = Math.round((baseH-ofsYT)*this.cdata.b.conf.init.h-this.conf.sw/2);
				} else {
					var bh = this.cdata.b.conf.size.h;
				}
				var bx = ofsXL;
				var by = baseH-ofsYB-bh;
				var bw = baseW-bx-ofsXR;
				
				//
				
				var ax = bx;
				var ay = ofsYT;
				var aw = bw;
				var ah = by-ay-this.conf.sw;
				
				
			} else {
				
				// if (this.cdata.b.conf.name == "e") debugger
				
				// fix "a", fit "b"
				
				var ax = ofsXL;
				var ay = ofsYT;
				var aw = baseW-ax-ofsXR;
				
				// check if init stage
				if (this.cdata.a.conf.init.h != null) {
					var ah = Math.round((baseH-ofsYT)*this.cdata.a.conf.init.h-this.conf.sw/2);
				} else {
					var ah = this.cdata.a.conf.size.h;
				}
				
				
				//
				var bx = ax;
				var by = ay+ah+this.conf.sw;
				var bw = aw;
				var bh = baseH-by-ofsYB;
				
			}
			
			this.cdata.a._setSize(ax, ay, aw, ah, parentIdd, noCalcCont, actionType);
			this.cdata.b._setSize(bx, by, bw, bh, parentIdd, noCalcCont, actionType);
			
			this.sep._setSize(ax, ay+ah, aw, this.conf.sw);
			
			
		}
		
		this.callEvent("_onSetSizes", []);
		
		// public event for main instance
		
		if (rEv && (!(this.conf.b_size.w == baseW && this.conf.b_size.h == baseH))) {
			this._callMainEvent("onResizeFinish", []);
		}
		
		this.conf.b_size = {w: baseW, h: baseH};
	}
	
	this._getAvailWidth = function() {
		
		// logic:
		// 1) take width of all not-collapsed cells marked as "autosize"
		// 2) if cell collapsed - try next cell
		// 3) get min alaiv width
		// 4) base.ofsW - minW -> allowed min
		
		var w = [];
		
		for (var q=0; q<this.conf.as_cells.h.length; q++) {
			var cell = this.cells(this.conf.as_cells.h[q]);
			var k = cell.layout;
			var a = k.conf.autosize;
			if (cell.conf.collapsed) {
				cell = k.cdata[k.conf.nextCell[cell._idd]];
				a = k.conf.nextCell[a];
			}
			w.push(Math.max(0, cell.getWidth()-cell._getMinWidth(a))); // current_width - min_width = size allowed for cell shrink
			k = cell = null;
		}
		var r = (w.length>0?Math.min.apply(window, w):0);
		return this.base.offsetWidth-r;
		
	}
	
	this._getAvailHeight = function() {
		
		var h = [];
		
		for (var q=0; q<this.conf.as_cells.v.length; q++) {
			var cell = this.cells(this.conf.as_cells.v[q]);
			var k = cell.layout;
			var a = k.conf.autosize;
			if (cell.conf.collapsed) {
				cell = k.cdata[k.conf.nextCell[cell._idd]];
				a = k.conf.nextCell[a];
			}
			h.push(Math.max(0, cell.getHeight()-cell._getHdrHeight()-cell._getMinHeight(a))); // current_height - hdr_height - min_height = size allowed for cell shrink
			k = cell = null;
		}
		var r = Math.min.apply(window, h);
		return this.base.offsetHeight-r;
		
	}
	
	this.setSkin = function(skin) {
		this.base.className = this.base.className.replace(new RegExp("dhxlayout_dhx_"+this.conf.skin,"gi"), "dhxlayout_dhx_"+skin);
		this.conf.skin = skin;
	}
	
	this.unload = function() {
		
		this.conf.unloading = true;
		
		this.mainInst = null;
		this.parentLayout = null;
		
		this._mtbUnload();
		this.detachHeader();
		this.detachFooter();
		
		window.dhx4._eventable(this, "clear");
		
		var r = new RegExp("\s{0,}dhxlayout_base_"+this.conf.skin,"gi");
		this.base.className = this.base.className.replace(r,"");
		
		// deprecated in 4.0
		if (this.items != null) {
			for (var q=0; q<this.items.length; q++) this.items[q] = null;
			this.items = null;
		}
		
		if (this.conf.fs_mode == true) {
			if (window.addEventListener) {
				window.removeEventListener("resize", this._doOnResizeStart, false);
			} else {
				window.detachEvent("onresize", this._doOnResizeStart);
			}
		}
		
		if (this.dhxWins != null) {
			this.dhxWins.unload();
			this.dhxWins = null;
		}
		
		if (this.sep != null) {
			this.sep._unload();
			this.sep = null;
		}
		
		for (var a in this.cdata) {
			this.cdata[a]._unload();
			//this.cdata[a] = null;
		}
		
		this.base = null;
		for (var a in this) this[a] = null;
		
		that = null;
	}
	
	// old container version compat
	this._getWindowMinDimension = function(win) {
		
		var w = that._getAvailWidth()+7+7; // + window left/right borders, move to conf?
		var h = that._getAvailHeight()+7+31; // + window hdr height + bottom border
		
		var t = {w: Math.max(w,200), h: Math.max(h, 140)}; // default window min width/height
		win = null;
		
		return t;
	}
	
	// resize events
	if (this.base == document.body) {
		
		this.conf.fs_mode = true;
		
		this._tmTime = null;
		this._doOnResizeStart = function() {
			window.clearTimeout(that._tmTime);
			that._tmTime = window.setTimeout(that._doOnResizeEnd, 200);
		}
		
		this._doOnResizeEnd = function() {
			that.setSizes();
		}
		
		if (window.addEventListener) {
			window.addEventListener("resize", this._doOnResizeStart, false);
		} else {
			window.attachEvent("onresize", this._doOnResizeStart);
		}
		
	}
	
	
	window.dhx4._eventable(this);
	this._callMainEvent = function(name, args) {
		return this.callEvent(name, args);
	}
	this._init(pattern||"3E");
	
	var a = this._availAutoSize[pattern];
	if (a != null) {
		this.conf.pattern = pattern;
		this.setAutoSize(a.h[a.h.length-1], a.v[a.v.length-1]);
	}
	
	if (typeof(window.dhtmlXWindows) == "function") {
		// console.log("init windows on demand and only for first instance");
		this.dhxWins = new dhtmlXWindows();
		this.dhxWins.setSkin(this.conf.skin);
	}
	
	this.conf.inited = true;
	
	// deprecated in 4.0
	if (this == this._getMainInst()) {
		var idx = 0;
		this.items = [];
		this.forEachItem(function(cell){
			that.items.push(cell);
			cell.conf.index = idx++;
		});
	}
	
	// autoload
	if (this == this._getMainInst() && autoload != null) {
		if (autoload.autosize != null) this.setAutoSize.apply(this, autoload.autosize);
		if (autoload.cells != null) {
			for (var q=0; q<autoload.cells.length; q++) {
				var data = autoload.cells[q];
				var cell = this.cells(data.id);
				if (data.width) cell.setWidth(data.width);
				if (data.height) cell.setHeight(data.height);
				if (data.text) cell.setText(data.text);
				if (data.collapsed_text) cell.setCollapsedText(data.collapsed_text);
				if (data.collapse) cell.collapse();
				if (data.fix_size) cell.fixSize(data.fix_size[0], data.fix_size[1]);
				if (typeof(data.header) != "undefined" && window.dhx4.s2b(data.header) == false) cell.hideHeader();
			}
		}
		
	}
	autoload = null;
	
	return this;
};

// cell access
dhtmlXLayoutObject.prototype.cells = function(name) {
	for (var a in this.cdata) {
		if (this.cdata[a].conf.name == name) return this.cdata[a];
		if (this.cdata[a].dataType == "layout" && this.cdata[a].dataNested == true && this.cdata[a].dataObj != null) {
			var k = this.cdata[a].dataObj.cells(name);
			if (k != null) return k;
		}
	}
	return null;
};

// iterator
dhtmlXLayoutObject.prototype.forEachItem = function(handler, env) {
	if (typeof(handler) != "function") return;
	if (typeof(env) == "undefined") env = this;
	for (var a in this.cdata) {
		if (typeof(this.cdata[a].conf.name) != "undefined") handler.apply(env, [this.cdata[a]]);
		if (this.cdata[a].dataType == "layout" && this.cdata[a].dataNested == true && this.cdata[a].dataObj != null) {
			this.cdata[a].dataObj.forEachItem(handler, env);
		}
	}
	env = null;
};

dhtmlXLayoutObject.prototype._forEachSep = function(handler, env) {
	if (typeof(handler) != "function") return;
	if (typeof(env) == "undefined") env = this;
	if (this.sep != null) handler.apply(env, [this.sep])
	for (var a in this.cdata) {
		if (this.cdata[a].dataType == "layout" && this.cdata[a].dataNested == true && this.cdata[a].dataObj != null) {
			this.cdata[a].dataObj._forEachSep(handler, env);
		}
	}
	env = null;
};

// outer offsets
dhtmlXLayoutObject.prototype.setOffsets = function(data) {
	var t = false;
	for (var a in data) {
		var k = a.charAt(0);
		if (typeof(this.conf.ofs[k]) != "undefined" && !isNaN(data[a])) {
			this.conf.ofs[k] = parseInt(data[a]);
			t = true;
		}
	}
	if (typeof(this.setSizes) == "function" && t == true) this.setSizes();
};

// separator width/height detect
dhtmlXLayoutObject.prototype._detectSW = function() {
	if (this._confGlob.sw == null) this._confGlob.sw = {};
	if (this._confGlob.sw[this.conf.skin] == null) {
		this._confGlob.sw[this.conf.skin] = window.dhx4.readFromCss("dhxlayout_sep_sw_"+this.conf.skin);
	}
	return this._confGlob.sw[this.conf.skin];
};


// conf
dhtmlXLayoutObject.prototype._confGlob = {};

// top margin (2px for skyblue) for fullscreen will always adjusted automatcaly
// bottom margin - can be generated by user-content, write in documentstion
// same for footer

dhtmlXLayoutObject.prototype.attachHeader = function(obj, height) {

	if (this.dataNodes.haObj != null) return; // already attached
	
	if (typeof(obj) != "object") obj = document.getElementById(obj);
	
	this.dataNodes.haObj = document.createElement("DIV");
	this.dataNodes.haObj.className = "dhxlayout_hdr_attached";
	this.dataNodes.haObj.style.height = (height||obj.offsetHeight)+"px";
	
	this.base.insertBefore(this.dataNodes.haObj, this.dataNodes.menuObj||this.dataNodes.toolbarObj||this.cdata.a.cell);
	
	this.dataNodes.haObj.appendChild(obj);
	obj.style.visibility = "visible";
	obj = null;
	
	this.dataNodes.haEv = this.attachEvent("_onSetSizes", function(){
		this.dataNodes.haObj.style.left = this.conf.ofs.l+"px";
		this.dataNodes.haObj.style.marginTop = this.conf.ofs.t+"px";
		this.dataNodes.haObj.style.width = this.base.offsetWidth-this.conf.ofs.l-this.conf.ofs.r+"px";
	});
	
	this.conf.ofs_nodes.t.haObj = true;
	
	this.setSizes();
	
};

dhtmlXLayoutObject.prototype.detachHeader = function() {
	
	if (!this.dataNodes.haObj) return;
	
	while (this.dataNodes.haObj.childNodes.length > 0) {
		this.dataNodes.haObj.lastChild.style.visibility = "hidden";
		document.body.appendChild(this.dataNodes.haObj.lastChild);
	}
	this.dataNodes.haObj.parentNode.removeChild(this.dataNodes.haObj);
	this.dataNodes.haObj = null;
	
	this.detachEvent(this.dataNodes.haEv);
	this.dataNodes.haEv = null;
	
	this.conf.ofs_nodes.t.haObj = false;
	
	delete this.dataNodes.haEv;
	delete this.dataNodes.haObj;
	
	if (!this.conf.unloading) this.setSizes();

};

dhtmlXLayoutObject.prototype.attachFooter = function(obj, height) {
	
	if (this.dataNodes.faObj != null) return;
	
	if (typeof(obj) != "object") obj = document.getElementById(obj);
	
	this.dataNodes.faObj = document.createElement("DIV");
	this.dataNodes.faObj.className = "dhxlayout_ftr_attached";
	this.dataNodes.faObj.style.height = (height||obj.offsetHeight)+"px";
	
	var p = (this.dataNodes.sbObj||(this.conf.pattern=="1C"?this.cdata.a.cell:this.sep.sep));
	if (this.base.lastChild == p) {
		this.base.appendChild(this.dataNodes.faObj);
	} else {
		this.base.insertBefore(this.dataNodes.faObj, p.nextSibling);
	}
	
	this.dataNodes.faEv = this.attachEvent("_onSetSizes", function(){
		this.dataNodes.faObj.style.left = this.conf.ofs.l+"px";
		this.dataNodes.faObj.style.bottom = this.conf.ofs.t+"px";
		this.dataNodes.faObj.style.width = this.base.offsetWidth-this.conf.ofs.l-this.conf.ofs.r+"px";
	});
	
	this.dataNodes.faObj.appendChild(obj);
	obj.style.visibility = "visible";
	p = obj = null;
	
	this.conf.ofs_nodes.b.faObj = true;
	
	this.setSizes();
	
};

dhtmlXLayoutObject.prototype.detachFooter = function() {
	
	if (!this.dataNodes.faObj) return;
	
	while (this.dataNodes.faObj.childNodes.length > 0) {
		this.dataNodes.faObj.lastChild.style.visibility = "hidden";
		document.body.appendChild(this.dataNodes.faObj.lastChild);
	}
	this.dataNodes.faObj.parentNode.removeChild(this.dataNodes.faObj);
	this.dataNodes.faObj = null;
	
	this.detachEvent(this.dataNodes.faEv);
	this.dataNodes.faEv = null;
	
	this.conf.ofs_nodes.b.faObj = false;
	
	delete this.dataNodes.faEv;
	delete this.dataNodes.faObj;
	
	if (!this.conf.unloading) this.setSizes();
	
};

// top-level menu/toolbar/status
dhtmlXLayoutObject.prototype.attachMenu = function(conf) {
	
	if (this.dataNodes.menu != null) return;
	
	this.dataNodes.menuObj = document.createElement("DIV");
	this.dataNodes.menuObj.className = "dhxlayout_menu";
	
	this.base.insertBefore(this.dataNodes.menuObj, this.dataNodes.toolbarObj||this.dataNodes.ribbonObj||this.cdata.a.cell);
	
	if (typeof(conf) != "object" || conf == null) conf = {};
	conf.skin = this.conf.skin;
	conf.parent = this.dataNodes.menuObj;
	
	this.dataNodes.menu = new dhtmlXMenuObject(conf);
	
	this.dataNodes.menuEv = this.attachEvent("_onSetSizes", function(){
		if (this.dataNodes.menuObj.style.display == "none") return;
		this.dataNodes.menuObj.style.left = this.conf.ofs.l+"px";
		this.dataNodes.menuObj.style.marginTop = (this.dataNodes.haObj!=null?0:this.conf.ofs.t)+"px";
		this.dataNodes.menuObj.style.width = this.base.offsetWidth-this.conf.ofs.l-this.conf.ofs.r+"px";
	});
	
	this.conf.ofs_nodes.t.menuObj = true;
	
	this.setSizes();
	
	conf.parnt = null;
	conf = null;
	
	return this.dataNodes.menu;
};

dhtmlXLayoutObject.prototype.detachMenu = function() {
	
	if (this.dataNodes.menu == null) return;
	
	this.dataNodes.menu.unload();
	this.dataNodes.menu = null;
	
	this.dataNodes.menuObj.parentNode.removeChild(this.dataNodes.menuObj);
	this.dataNodes.menuObj = null;
	
	this.detachEvent(this.dataNodes.menuEv);
	this.dataNodes.menuEv = null;
	
	delete this.dataNodes.menu;
	delete this.dataNodes.menuObj;
	delete this.dataNodes.menuEv;
	
	this.conf.ofs_nodes.t.menuObj = false;
	
	if (!this.conf.unloading) this.setSizes();
};

// toolbar

dhtmlXLayoutObject.prototype.attachToolbar = function(conf) {
	
	if (!(this.dataNodes.ribbon == null && this.dataNodes.toolbar == null)) return;
	
	this.dataNodes.toolbarObj = document.createElement("DIV");
	this.dataNodes.toolbarObj.className = "dhxlayout_toolbar";
	this.base.insertBefore(this.dataNodes.toolbarObj, this.cdata.a.cell);
	this.dataNodes.toolbarObj.appendChild(document.createElement("DIV"));
	
	if (typeof(conf) != "object" || conf == null) conf = {};
	conf.skin = this.conf.skin;
	conf.parent = this.dataNodes.toolbarObj.firstChild;
	
	this.dataNodes.toolbar = new dhtmlXToolbarObject(conf);
	
	this.dataNodes.toolbarEv = this.attachEvent("_onSetSizes", function() {
		if (this.dataNodes.toolbarObj.style.display == "none") return;
		this.dataNodes.toolbarObj.style.left = this.conf.ofs.l+"px";
		this.dataNodes.toolbarObj.style.marginTop = (this.dataNodes.haObj!=null||this.dataNodes.menuObj!=null?0:this.conf.ofs.t)+"px";
		this.dataNodes.toolbarObj.style.width = this.base.offsetWidth-this.conf.ofs.l-this.conf.ofs.r+"px";
	});
	
	this.dataNodes.toolbar._masterCell = this;
	this.dataNodes.toolbar.attachEvent("_onIconSizeChange", function(){
		this._masterCell.setSizes();
	});
	
	this.conf.ofs_nodes.t.toolbarObj = true;
	
	this.setSizes();
	
	conf.parnt = null;
	conf = null;
	
	return this.dataNodes.toolbar;
};

dhtmlXLayoutObject.prototype.detachToolbar = function() {
	
	if (this.dataNodes.toolbar == null) return;
	
	this.dataNodes.toolbar._masterCell = null; // link to this
	this.dataNodes.toolbar.unload();
	this.dataNodes.toolbar = null;
	
	this.dataNodes.toolbarObj.parentNode.removeChild(this.dataNodes.toolbarObj);
	this.dataNodes.toolbarObj = null;
	
	this.detachEvent(this.dataNodes.toolbarEv);
	this.dataNodes.toolbarEv = null;
	
	this.conf.ofs_nodes.t.toolbarObj = false;
	
	delete this.dataNodes.toolbar;
	delete this.dataNodes.toolbarObj;
	delete this.dataNodes.toolbarEv;
	
	if (!this.conf.unloading) this.setSizes();
};

// toolbar

dhtmlXLayoutObject.prototype.attachRibbon = function(conf) {
	
	if (!(this.dataNodes.ribbon == null && this.dataNodes.toolbar == null)) return;
	
	this.dataNodes.ribbonObj = document.createElement("DIV");
	this.dataNodes.ribbonObj.className = "dhxlayout_ribbon";
	this.base.insertBefore(this.dataNodes.ribbonObj, this.cdata.a.cell);
	this.dataNodes.ribbonObj.appendChild(document.createElement("DIV"));
	
	if (typeof(conf) != "object" || conf == null) conf = {};
	conf.skin = this.conf.skin;
	conf.parent = this.dataNodes.ribbonObj.firstChild;
	
	this.dataNodes.ribbon = new dhtmlXRibbon(conf);
	
	this.dataNodes.ribbonEv = this.attachEvent("_onSetSizes", function() {
		if (this.dataNodes.ribbonObj.style.display == "none") return;
		this.dataNodes.ribbonObj.style.left = this.conf.ofs.l+"px";
		this.dataNodes.ribbonObj.style.marginTop = (this.dataNodes.haObj!=null||this.dataNodes.menuObj!=null?0:this.conf.ofs.t)+"px";
		this.dataNodes.ribbonObj.style.width = this.base.offsetWidth-this.conf.ofs.l-this.conf.ofs.r+"px";
		this.dataNodes.ribbon.setSizes();
	});
	
	this.conf.ofs_nodes.t.ribbonObj = true;
	
	var t = this;
	this.dataNodes.ribbon.attachEvent("_onHeightChanged", function(){
		t.setSizes();
	});
	
	this.setSizes();
	
	conf.parnt = null;
	conf = null;
	
	return this.dataNodes.ribbon;
};

dhtmlXLayoutObject.prototype.detachRibbon = function() {
	
	if (this.dataNodes.ribbon == null) return;
	
	this.dataNodes.ribbon.unload();
	this.dataNodes.ribbon = null;
	
	this.dataNodes.ribbonObj.parentNode.removeChild(this.dataNodes.ribbonObj);
	this.dataNodes.ribbonObj = null;
	
	this.detachEvent(this.dataNodes.ribbonEv);
	this.dataNodes.ribbonEv = null;
	
	this.conf.ofs_nodes.t.ribbonObj = false;
	
	delete this.dataNodes.ribbon;
	delete this.dataNodes.ribbonObj;
	delete this.dataNodes.ribbonEv;
	
	if (!this.conf.unloading) this.setSizes();
};


// status
dhtmlXLayoutObject.prototype.attachStatusBar = function(conf) { // arg-optional, new in version
	
	if (this.dataNodes.sbObj) return;
	
	if (typeof(conf) == "undefined") conf = {};
	
	this.dataNodes.sbObj = document.createElement("DIV");
	this.dataNodes.sbObj.className = "dhxlayout_statusbar";
	
	if (this.dataNodes.faObj != null) {
		this.base.insertBefore(this.dataNodes.sbObj, this.dataNodes.faObj);
	} else {
		if (this.sep == null || this.base.lastChild == this.sep.sep) {
			this.base.appendChild(this.dataNodes.sbObj);
		} else {
			this.base.insertBefore(this.dataNodes.sbObj, this.sep.sep.nextSibling);
		}
	}
	
	this.dataNodes.sbObj.innerHTML = "<div class='dhxcont_statusbar'>"+(typeof(conf.text)=="string" && conf.text.length > 0 ? conf.text:"&nbsp;")+"</div>";
	if (typeof(conf.height) == "number") this.dataNodes.sbObj.firstChild.style.height = this.dataNodes.sbObj.firstChild.style.lineHeight = conf.height+"px";
	
	this.dataNodes.sbObj.setText = function(text) { this.childNodes[0].innerHTML = text; }
	this.dataNodes.sbObj.getText = function() { return this.childNodes[0].innerHTML; }
	this.dataNodes.sbObj.onselectstart = function(e) { return false; }
	
	
	this.dataNodes.sbEv = this.attachEvent("_onSetSizes", function(){
		if (this.dataNodes.sbObj.style.display == "none") return;
		this.dataNodes.sbObj.style.left = this.conf.ofs.l+"px";
		this.dataNodes.sbObj.style.bottom = (this.dataNodes.faObj != null?this.dataNodes.faObj.offsetHeight:0)+this.conf.ofs.t+"px";
		this.dataNodes.sbObj.style.width = this.base.offsetWidth-this.conf.ofs.l-this.conf.ofs.r+"px";
	});
	
	this.conf.ofs_nodes.b.sbObj = true;
	
	this.setSizes();
	
	return this.dataNodes.sbObj;
	
};

dhtmlXLayoutObject.prototype.detachStatusBar = function() {
	
	if (!this.dataNodes.sbObj) return;
	
	this.dataNodes.sbObj.setText = this.dataNodes.sbObj.getText = this.dataNodes.sbObj.onselectstart = null;
	this.dataNodes.sbObj.parentNode.removeChild(this.dataNodes.sbObj);
	this.dataNodes.sbObj = null;
	
	this.detachEvent(this.dataNodes.sbEv);
	this.dataNodes.sbEv = null;
	
	this.conf.ofs_nodes.b.sbObj = false;
	
	delete this.dataNodes.sb;
	delete this.dataNodes.sbObj;
	delete this.dataNodes.sbEv;
	
	if (!this.conf.unloading) this.setSizes();
	
};

// show/hide

dhtmlXLayoutObject.prototype.showMenu = function() {
	this._mtbShowHide("menuObj", "");
};

dhtmlXLayoutObject.prototype.hideMenu = function() {
	this._mtbShowHide("menuObj", "none");
};

dhtmlXLayoutObject.prototype.showToolbar = function(){
	this._mtbShowHide("toolbarObj", "");
};

dhtmlXLayoutObject.prototype.hideToolbar = function(){
	this._mtbShowHide("toolbarObj", "none");
};

dhtmlXLayoutObject.prototype.showRibbon = function(){
	this._mtbShowHide("ribbonObj", "");
};

dhtmlXLayoutObject.prototype.hideRibbon = function(){
	this._mtbShowHide("ribbonObj", "none");
};

dhtmlXLayoutObject.prototype.showStatusBar = function() {
	this._mtbShowHide("sbObj", "");
};

dhtmlXLayoutObject.prototype.hideStatusBar = function(){
	this._mtbShowHide("sbObj", "none");
};

dhtmlXLayoutObject.prototype._mtbShowHide = function(name, disp) {
	if (this.dataNodes[name] == null) return;
	this.dataNodes[name].style.display = disp;
	this.setSizes();
};

dhtmlXLayoutObject.prototype._mtbUnload = function(name, disp) {
	this.detachMenu();
	this.detachToolbar();
	this.detachStatusBar();
	this.detachRibbon();
};

// getters
dhtmlXLayoutObject.prototype.getAttachedMenu = function() {
	return this.dataNodes.menu;
};
dhtmlXLayoutObject.prototype.getAttachedToolbar = function() {
	return this.dataNodes.toolbar;
};
dhtmlXLayoutObject.prototype.getAttachedRibbon = function() {
	return this.dataNodes.ribbon;
};
dhtmlXLayoutObject.prototype.getAttachedStatusBar = function() {
	return this.dataNodes.sbObj;
};


// top-level progress
dhtmlXLayoutObject.prototype.progressOn = function() {
	
	if (this.conf.progress) return;
	
	this.conf.progress = true;
	
	var t1 = document.createElement("DIV");
	t1.className = "dhxlayout_progress";
	this.base.appendChild(t1);
	
	var t2 = document.createElement("DIV");
	t2.className = "dhxlayout_progress_img";
	this.base.appendChild(t2);
	
	t1 = t2 = null;
	
};

dhtmlXLayoutObject.prototype.progressOff = function() {
	
	if (!this.conf.progress) return;
	
	var p = {dhxlayout_progress: true, dhxlayout_progress_img: true};
	for (var q=0; q<this.base.childNodes.length; q++) {
		if (typeof(this.base.childNodes[q].className) != "undefined" && p[this.base.childNodes[q].className] == true) {
			p[this.base.childNodes[q].className] = this.base.childNodes[q];
		}
	}
	
	for (var a in p) {
		if (p[a] != true) this.base.removeChild(p[a]);
		p[a] = null;
	}
	
	this.conf.progress = false;
	p = null;
	
};

dhtmlXLayoutObject.prototype.listPatterns = function() {
	var t = [];
	for (var a in this.tplData) t.push(a);
	return t;
};

dhtmlXLayoutObject.prototype.listAutoSizes = function() {
	
	var curH = (this.conf.as_cells != null ? (this.conf.as_cells.h).join(";") : "");
	var curV = (this.conf.as_cells != null ? (this.conf.as_cells.v).join(";") : "");
	
	var allH = this._availAutoSize[this.conf.pattern].h;
	var allV = this._availAutoSize[this.conf.pattern].v;
	
	return [curH, curV, allH, allV];
	
};


dhtmlXLayoutObject.prototype._getCellsNames = function(cId) {
	var names = {};
	if (this.cdata[cId].conf.name != null) names[this.cdata[cId].conf.name] = true;
	if (this.cdata[cId].dataType == "layout" && this.cdata[cId].dataObj != null && this.cdata[cId].dataObj.mainInst == this) {
		var k0 = this.cdata[cId].dataObj._getCellsNames("a");
		var k1 = this.cdata[cId].dataObj._getCellsNames("b");
		for (var a in k0) names[a] = k0[a];
		for (var a in k1) names[a] = k1[a];
	}
	return names;
};

dhtmlXLayoutObject.prototype.setAutoSize = function(hor, ver, innerCall) {
	
	if (innerCall !== true) {
	
		var t = this.listAutoSizes();
		if (t[0] == hor && t[1] == ver) return;
		
		var t0 = false;
		var t1 = false;
		for (var q=0; q<t[2].length; q++) t0 = t0||t[2][q]==hor;
		for (var q=0; q<t[3].length; q++) t1 = t1||t[3][q]==ver;
		
		if (!t0 || !t1) {
			// console.log("set autosize, incorect values, aborted", hor, ver, t[2], t[3])
			return;
		}
		
	}
	
	this.conf.as_cells = { h: hor.split(";"), v: ver.split(";") };
	var m = (this.conf.mode=="v"?"h":"v");
	
	for (var a in this.cdata) {
		var k = this._getCellsNames(a);
		var s = false;
		for (var q=0; q<this.conf.as_cells[m].length; q++) s = s||k[this.conf.as_cells[m][q]];
		if (s) this.conf.autosize = a;
		if (this.cdata[a].dataType == "layout" && this.cdata[a].dataObj != null) this.cdata[a].dataObj.setAutoSize(hor, ver, true);
	}
	
};

dhtmlXLayoutObject.prototype.tplData = {
	
	// fsize - separators near specified cell for fix_size
	
	"1C": { mode: "c", cells: { a: { name: "a" } } },
	
	"2E": { mode: "h", cells: { a: { name: "a", fsize: {v:1} }, b: { name: "b", fsize: {v:1} } } },
	"2U": { mode: "v", cells: { a: { name: "a", fsize: {h:1} }, b: { name: "b", fsize: {h:1} } } },
	
	"3E": { mode: "h", cells: { a: { name: "a", height: 1/3, fsize: {v:1} }, b: { layout: { mode: "h", cells: { a: { name: "b", fsize: {v:[1,2]} }, b: { name: "c", fsize: {v:2} } } } } } },
	"3W": { mode: "v", cells: { a: { name: "a",  width: 1/3, fsize: {h:1} }, b: { layout: { mode: "v", cells: { a: { name: "b", fsize: {h:[1,2]} }, b: { name: "c", fsize: {h:2} } } } } } },
	"3J": { mode: "v", cells: { a: { layout: { mode: "h", cells: { a: { name: "a", fsize: {h:1, v:2} }, b: { name: "c", fsize: {h:1, v:2} } } } }, b: { name: "b", fsize: {h:1} } } },
	"3L": { mode: "v", cells: { a: { name: "a", fsize: {h:1} }, b: { layout: { mode: "h", cells: { a: { name: "b", fsize: {h:1, v:2} }, b: { name: "c", fsize: {h:1, v:2} } } } } } },
	"3T": { mode: "h", cells: { a: { name: "a", fsize: {v:1} }, b: { layout: { mode: "v", cells: { a: { name: "b", fsize: {h:2, v:1} }, b: { name: "c", fsize: {h:2, v:1} } } } } } },
	"3U": { mode: "h", cells: { a: { layout: { mode: "v", cells: { a: { name: "a", fsize: {h:2, v:1} }, b: { name: "b", fsize: {h:2, v:1} } } } }, b: { name: "c", fsize: {v:1} } } },
	
	"4H": { mode: "v", cells: { a: { name: "a",  width: 1/3, fsize: {h:1} }, b: { layout: { mode: "v", cells: { a: { layout: { mode: "h", cells: { a: { name: "b", fsize: {h:[1,2], v:3} }, b: { name: "c", fsize: {h:[1,2], v:3} } } } }, b: { name: "d", fsize: {h:2} } } } } } },
	"4I": { mode: "h", cells: { a: { name: "a", height: 1/3, fsize: {v:1} }, b: { layout: { mode: "h", cells: { a: { layout: { mode: "v", cells: { a: { name: "b", fsize: {h:3, v:[1,2]} }, b: { name: "c", fsize: {h:3, v:[1,2]} } } } }, b: { name: "d", fsize: {v:2} } } } } } },
	"4T": { mode: "h", cells: { a: { name: "a", fsize: {v:1} }, b: { layout: { mode: "v", cells: { a: { name: "b", width: 1/3, fsize: {h:2, v:1} }, b: { layout: { mode: "v", cells: { a: { name: "c", fsize: {h:[2,3], v:1} }, b: { name: "d", fsize: {h:3, v:1} } } } } } } } } },
	"4U": { mode: "h", cells: { a: { layout: { mode: "v", cells: { a: { name: "a", width: 1/3, fsize: {h:2, v:1} }, b: { layout: { mode: "v", cells: { a: { name: "b", fsize: {h:[2,3], v:1} }, b: { name: "c", fsize: {h:3, v:1} } } } } } } }, b: { name: "d", fsize: {v:1} } } },
	"4E": { mode: "h", cells: { a: { name: "a", height: 1/4, fsize: {v:1} }, b: { layout: { mode: "h", cells: { a: { name: "b", height: 1/3, fsize: {v:[1,2]} }, b: { layout: { mode: "h", cells: { a: { name: "c", fsize: {v:[2,3]} }, b: { name: "d", fsize: {v:3} } } } } } } } } },
	"4W": { mode: "v", cells: { a: { name: "a",  width: 1/4, fsize: {h:1} }, b: { layout: { mode: "v", cells: { a: { name: "b",  width: 1/3, fsize: {h:[1,2]} }, b: { layout: { mode: "v", cells: { a: { name: "c", fsize: {h:[2,3]} }, b: { name: "d", fsize: {h:3} } } } } } } } } },
	"4A": { mode: "v", cells: { a: {  width: 1/3, layout: { mode: "h", cells: { a: { name: "a", fsize: {h:1, v:2} }, b: { name: "b", fsize: {h:1, v:2} } } } }, b: { layout: { mode: "v", cells: { a: { name: "c", fsize: {h:[1,3]} }, b: { name: "d", fsize: {h:3} } } } } } },
	"4L": { mode: "v", cells: { a: { name: "a",  width: 1/3, fsize: {h:1} }, b: { layout: { mode: "v", cells: { a: { name: "b", fsize: {h:[1,2]} }, b: { layout: { mode: "h", cells: { a: { name: "c", fsize: {h:2, v:3} }, b: { name: "d", fsize: {h:2, v:3} } } } } } } } } },
	"4J": { mode: "h", cells: { a: { name: "a", height: 1/3, fsize: {v:1} }, b: { layout: { mode: "h", cells: { a: { name: "b", fsize: {v:[1,2]} }, b: { layout: { mode: "v", cells: { a: { name: "c", fsize: {h:3, v:2} }, b: { name: "d", fsize: {h:3, v:2} } } } } } } } } },
	"4F": { mode: "h", cells: { a: { height: 1/3, layout: { mode: "v", cells: { a: { name: "a", fsize: {h:2, v:1} }, b: { name: "b", fsize: {h:2, v:1} } } } }, b: { layout: { mode: "h", cells: { a: { name: "c", fsize: {v:[1,3]} }, b: { name: "d", fsize: {v:3} } } } } } },
	"4G": { mode: "v", cells: { a: { layout: { mode: "h", cells: { a: { name: "a", height: 1/3, fsize: {h:1, v:2} }, b: { layout: { mode: "h", cells: { a: { name: "b", fsize: {h:1, v:[2,3]} }, b: { name: "c", fsize: {h:1, v:3} } } } } } } }, b: { name: "d", fsize: {h:1} } } },
	"4C": { mode: "v", cells: { a: { name: "a", fsize: {h:1} }, b: { layout: { mode: "h", cells: { a: { name: "b", height: 1/3, fsize: {h:1, v:2} }, b: { layout: { mode: "h", cells: { a: { name: "c", fsize: {h:1, v:[2,3]} }, b: { name: "d", fsize: {h:1, v:3} } } } } } } } } },
	
	"5H": { mode: "v", cells: { a: {  width: 1/3, name: "a", fsize: {h:1}}, b: { layout: { mode: "v", cells: { a: { layout: { mode: "h", cells: { a: { name: "b", height: 1/3, fsize: {h:[1,2], v:3} }, b: { layout: { mode: "h", cells: { a: { name: "c", fsize: {h:[1,2], v:[3,4]} }, b: { name: "d", fsize: {h:[1,2], v:4} } } } } } } }, b: { name: "e", fsize: {h:2} } } } } } },
	"5I": { mode: "h", cells: { a: { height: 1/3, name: "a", fsize: {v:1} }, b: { layout: { mode: "h", cells: { a: { layout: { mode: "v", cells: { a: { name: "b", width: 1/3, fsize: {h:3, v:[1,2]} }, b: { layout: { mode: "v", cells: { a: { name: "c", fsize: {h:[3,4], v:[1,2]} }, b: { name: "d", fsize: {h:4, v:[1,2]} } } } } } } }, b: { name: "e", fsize: {v:2} } } } } } },
	"5U": { mode: "h", cells: { a: { layout: { mode: "v", cells: { a: { name: "a",  width: 1/4, fsize: {h:2, v:1} }, b: { layout: { mode: "v", cells: { a: { name: "b",  width: 1/3, fsize: {h:[2,3], v:1} }, b: { layout: { mode: "v", cells: { a: { name: "c", fsize: {h:[3,4], v:1} }, b: { name: "d", fsize: {h:4, v:1} } } } } } } } } } }, b: { name: "e", fsize: {v:1} } } },
	"5E": { mode: "h", cells: { a: { name: "a", height: 1/5, fsize: {v:1} }, b: { layout: { mode: "h", cells: { a: { name: "b", height: 1/4, fsize: {v:[1,2]} }, b: { layout: { mode: "h", cells: { a: { name: "c", height: 1/3, fsize: {v:[2,3]} }, b: { layout: { mode: "h", cells: { a: { name: "d", fsize: {v:[3,4]} }, b: { name: "e", fsize: {v:4} } } } } } } } } } } } },
	"5W": { mode: "v", cells: { a: { name: "a",  width: 1/5, fsize: {h:1} }, b: { layout: { mode: "v", cells: { a: { name: "b",  width: 1/4, fsize: {h:[1,2]} }, b: { layout: { mode: "v", cells: { a: { name: "c",  width: 1/3, fsize: {h:[2,3]} }, b: { layout: { mode: "v", cells: { a: { name: "d", fsize: {h:[3,4]} }, b: { name: "e", fsize: {h:4} } } } } } } } } } } } },
	"5K": { mode: "v", cells: { a: { layout: { mode: "h", cells: { a: { name: "a", height: 1/3, fsize: {h:1, v:2} }, b: { layout: { mode: "h", cells: { a: { name: "b", fsize: {h:1, v:[2,3]} }, b: { name: "c", fsize: {h:1, v:3} } } } } } } }, b: { layout: { mode: "h", cells: { a: { name: "d", fsize: {h:1, v:4} }, b: { name: "e", fsize: {h:1, v:4} } } } } } },
	"5S": { mode: "v", cells: { a: { layout: { mode: "h", cells: { a: { name: "a", fsize: {h:1, v:2} }, b: { name: "b", fsize: {h:1, v:2} } } } }, b: { layout: { mode: "h", cells: { a: { name: "c", height: 1/3, fsize: {h:1, v:3} }, b: { layout: { mode: "h", cells: { a: { name: "d", fsize: {h:1, v:[3,2]} }, b: { name: "e", fsize: {h:1, v:4} } } } } } } } } },
	"5G": { mode: "v", cells: { a: {  width: 1/3, layout: { mode: "h", cells: { a: { name: "a", height: 1/3, fsize: {h:1, v:2} }, b: { layout: { mode: "h", cells: { a: { name: "b", fsize: {h:1, v:[2,3]} }, b: { name: "c", fsize: {h:1, v:3} } } } } } } }, b: { layout: { mode: "v", cells: { a: { name: "d", fsize: {h:[1,4]} }, b: { name: "e", fsize: {h:4} } } } } } },
	"5C": { mode: "v", cells: { a: {  width: 2/3, layout: { mode: "v", cells: { a: { name: "a", fsize: {h:2} }, b: { name: "b", fsize: {h:[2,1]} } } } }, b: { layout: { mode: "h", cells: { a: { name: "c", height: 1/3, fsize: {h:1, v:3} }, b: { layout: { mode: "h", cells: { a: { name: "d", fsize: {h:1, v:[3,4]} }, b: { name: "e", fsize: {h:1, v:4} } } } } } } } } },
	
	"6H": { mode: "v", cells: { a: {  width: 1/3, name: "a", fsize: {h:1} }, b: { layout: { mode: "v", cells: { a: { layout: { mode: "h", cells: { a: { name: "b", height: 1/4, fsize: {h:[1,2], v:3} }, b: { layout: { mode: "h", cells: { a: { name: "c", height: 1/3, fsize: {h:[1,2], v:[3,4]} }, b: { layout: { mode: "h", cells: { a: { name: "d", fsize: {h:[1,2], v:[4,5]} }, b: { name: "e", fsize: {h:[1,2], v:5} } } } } } } } } } }, b: { name: "f", fsize: {h:2} } } } } } },
	"6I": { mode: "h", cells: { a: { height: 1/3, name: "a", fsize: {v:1} }, b: { layout: { mode: "h", cells: { a: { layout: { mode: "v", cells: { a: { name: "b",  width: 1/4, fsize: {h:3, v:[1,2]} }, b: { layout: { mode: "v", cells: { a: { name: "c",  width: 1/3, fsize: {h:[3,4], v:[1,2]} }, b: { layout: { mode: "v", cells: { a: { name: "d", fsize: {h:[4,5], v:[1,2]} }, b: { name: "e", fsize: {h:5, v:[1,2]} } } } } } } } } } }, b: { name: "f", fsize: {v:2} } } } } } },
	"6A": { mode: "v", cells: { a: { layout: { mode: "h", cells: { a: { name: "a", height: 1/5, fsize: {h:1, v:2} }, b: { layout: { mode: "h", cells: { a: { name: "b", height: 1/4, fsize: {h:1, v:[2,3]} }, b: { layout: { mode: "h", cells: { a: { name: "c", height: 1/3, fsize: {h:1, v:[3,4]} }, b: { layout: { mode: "h", cells: { a: { name: "d", fsize: {h:1, v:[4,5]} }, b: { name: "e", fsize: {h:1, v:5} } } } } } } } } } } } } }, b: { name: "f", fsize: {h:1} } } },
	"6C": { mode: "v", cells: { a: { name: "a", fsize: {h:1} }, b: { layout: { mode: "h", cells: { a: { name: "b", height: 1/5, fsize: {h:1, v:2} }, b: { layout: { mode: "h", cells: { a: { name: "c", height: 1/4, fsize: {h:1, v:[2,3]} }, b: { layout: { mode: "h", cells: { a: { name: "d", height: 1/3, fsize: {h:1, v:[3,4]} }, b: { layout: { mode: "h", cells: { a: { name: "e", fsize: {h:1, v:[4,5]} }, b: { name: "f", fsize: {h:1, v:5} } } } } } } } } } } } } } } },
	"6J": { mode: "v", cells: { a: {  width: 1/3, layout: { mode: "h", cells: { a: { name: "a", height: 1/4, fsize: {h:1, v:2} }, b: { layout: { mode: "h", cells: { a: { name: "b", height: 1/3, fsize: {h:1, v:[2,3]} }, b: { layout: { mode: "h", cells: { a: { name: "c", fsize: {h:1, v:[3,4]} }, b: { name: "d", fsize: {h:1, v:4} } } } } } } } } } }, b: { layout: { mode: "v", cells: { a: { name: "e", fsize: {h:[1,5]} }, b: { name: "f", fsize: {h:5} } } } } } },
	"6E": { mode: "v", cells: { a: { name: "a",  width: 1/3, fsize: {h:1} }, b: { layout: { mode: "v", cells: { a: { name: "b", fsize: {h:[1,2]} }, b: { layout: { mode: "h", cells: { a: { name: "c", height: 1/4, fsize: {h:2, v:3} }, b: { layout: { mode: "h", cells: { a: { name: "d", height: 1/3, fsize: {h:2, v:[3,4]} }, b: { layout: { mode: "h", cells: { a: { name: "e", fsize: {h:2, v:[4,5]} }, b: { name: "f", fsize: {h:2, v:5} } } } } } } } } } } } } } } },
	"6W": { mode: "v", cells: { a: { name: "a",  width: 1/6, fsize: {h:1} }, b: { layout: { mode: "v", cells: { a: { name: "b", width: 1/5, fsize: {h:[1,2]} }, b: { layout: { mode: "v", cells: { a: { name: "c", width: 1/4, fsize: {h:[2,3]} }, b: { layout: { mode: "v", cells: { a: { name: "d", width: 1/3, fsize: {h:[3,4]} }, b: { layout: { mode: "v", cells: { a: { name: "e", fsize: {h:[4,5]} }, b: { name: "f", fsize: {h:5} } } } } } } } } } } } } } } },
	
	"7H": { mode: "v", cells: { a: { name: "a",  width: 1/3, fsize: {h:1} }, b: { layout: { mode: "v", cells: { a: { layout: { mode: "h", cells: { a: { name: "b", height: 1/5, fsize: {h:[1,2], v:3} }, b: { layout: { mode: "h", cells: { a: { name: "c", height: 1/4, fsize: {h:[1,2], v:[3,4]} }, b: { layout: { mode: "h", cells: { a: { name: "d", height: 1/3, fsize: {h:[1,2], v:[4,5]} }, b: { layout: { mode: "h", cells: { a: { name: "e", fsize: {h:[1,2], v:[5,6]} }, b: { name: "f", fsize: {h:[1,2], v:6} } } } } } } } } } } } } }, b: { name: "g", fsize: {h:2} } } } } } },
	"7I": { mode: "h", cells: { a: { name: "a", height: 1/3, fsize: {v:1} }, b: { layout: { mode: "h", cells: { a: { layout: { mode: "v", cells: { a: { name: "b",  width: 1/5, fsize: {h:3, v:[1,2]} }, b: { layout: { mode: "v", cells: { a: { name: "c",  width: 1/4, fsize: {h:[3,4], v:[1,2]} }, b: { layout: { mode: "v", cells: { a: { name: "d",  width: 1/3, fsize: {h:[4,5], v:[1,2]} }, b: { layout: { mode: "v", cells: { a: { name: "e", fsize: {h:[5,6], v:[1,2]} }, b: { name: "f", fsize: {h:6, v:[1,2]} } } } } } } } } } } } } }, b: { name: "g", fsize: {v:2} } } } } } }
	
};

dhtmlXLayoutObject.prototype._availAutoSize = {
	
	"1C": { h: ["a"], v: ["a"] },
	
	"2E": { h: ["a;b"], v: ["a", "b"] },
	"2U": { h: ["a", "b"], v: ["a;b"] },
	
	"3E": { h: ["a;b;c"], v: ["a", "b", "c"] },
	"3W": { h: ["a", "b", "c"], v: ["a;b;c"] },
	"3J": { h: ["a;c", "b"], v: ["a;b", "b;c"] },
	"3L": { h: ["a", "b;c"], v: ["a;b", "a;c"] },
	"3T": { h: ["a;b", "a;c"], v: ["a", "b;c"] },
	"3U": { h: ["a;c", "b;c"], v: ["a;b", "c"] },
	
	"4H": { h: ["a", "b;c", "d"], v: ["a;b;d", "a;c;d"] },
	"4I": { h: ["a;b;d", "a;c;d"], v: ["a", "b;c", "d"] },
	"4T": { h: ["a;b", "a;c", "a;d"], v: ["a", "b;c;d"] },
	"4U": { h: ["a;d", "b;d", "c;d"], v: ["a;b;c", "d"] },
	"4E": { h: ["a;b;c;d"], v: ["a", "b", "c", "d"] },
	"4W": { h: ["a", "b", "c", "d"], v: ["a;b;c;d"] },
	"4A": { h: ["a;b", "c", "d"], v: ["a;c;d", "b;c;d"] },
	"4L": { h: ["a", "b", "c;d"], v: ["a;b;c", "a;b;d"] },
	"4J": { h: ["a;b;c", "a;b;d"], v: ["a", "b", "c;d"] },
	"4F": { h: ["a;c;d", "b;c;d"], v: ["a;b", "c", "d"] },
	"4G": { h: ["a;b;c", "d"], v: ["a;d", "b;d", "c;d"] },
	"4C": { h: ["a", "b;c;d"], v: ["a;b", "a;c", "a;d"] },
	
	"5H": { h: ["a", "b;c;d", "e"], v: ["a;b;e", "a;c;e", "a;d;e"] },
	"5I": { h: ["a;b;e", "a;c;e", "a;d;e"], v: ["a", "b;c;d", "e"] },
	"5U": { h: ["a;e", "b;e", "c;e", "d;e"], v: ["a;b;c;d", "e"] },
	"5E": { h: ["a;b;c;d;e"], v: ["a", "b", "c", "d", "e"] },
	"5W": { h: ["a", "b", "c", "d", "e"], v: ["a;b;c;d;e"] },
	"5K": { h: ["a;b;c", "d;e"], v: ["a;d", "b;d", "c;d", "a;e", "b;e", "c;e"] },
	"5S": { h: ["a;b", "c;d;e"], v: ["a;c", "a;d", "a;e", "b;c", "b;d", "b;e"] },
	"5G": { h: ["a;b;c", "d", "e"], v: ["a;d;e", "b;d;e", "c;d;e"] },
	"5C": { h: ["a", "b", "c;d;e"], v: ["a;b;c", "a;b;d", "a;b;e"] },
	
	"6H": { h: ["a", "b;c;d;e", "f"], v: ["a;b;f", "a;c;f", "a;d;f", "a;e;f"] },
	"6I": { h: ["a;b;f", "a;c;f", "a;d;f", "a;e;f"], v: ["a", "b;c;d;e", "f"] },
	"6A": { h: ["a;b;c;d;e", "f"], v: ["a;f", "b;f", "c;f", "d;f", "e;f"] },
	"6C": { h: ["a", "b;c;d;e;f"], v: ["a;b", "a;c", "a;d", "a;e", "a;f"] },
	"6J": { h: ["a;b;c;d", "e", "f"], v: ["a;e;f", "b;e;f", "c;e;f", "d;e;f"] },
	"6E": { h: ["a", "b", "c;d;e;f"], v: ["a;b;c", "a;b;d", "a;b;e", "a;b;f"] },
	"6W": { h: ["a", "b", "c", "d", "e", "f"], v: ["a;b;c;d;e;f"] },
	
	"7H": { h: ["a", "b;c;d;e;f", "g"], v: ["a;b;g", "a;c;g", "a;d;g", "a;e;g", "a;f;g"] },
	"7I": { h: ["a;b;g", "a;c;g", "a;d;g", "a;e;g", "a;f;g"], v: ["a", "b;c;d;e;f", "g"] }
	
};

function dhtmlXLayoutSepObject(mode, idx) {
	
	var that = this;
	
	this.conf = {
		mode: mode,
		idx: idx,
		blocked: false, // by expand/collapse
		locked: false, // by fix cell size
		btn_left: ((window.dhx4.isIE6||window.dhx4.isIE7||window.dhx4.isIE8) && typeof(window.addEventListener) == "undefined" ? 1:0) // 1 for IE8-
	};
	
	// ie-11 in ie-7 mode
	if (window.dhx4.isIE && navigator.userAgent.indexOf("MSIE 7.0") >= 0 && navigator.userAgent.indexOf("Trident") >= 0) {
		this.conf.btn_left = 1;
	}
	
	this.sep = document.createElement("DIV");
	this.sep.className = "dhxlayout_sep";
	
	/*
	// dev, show sep index
	this.sep.innerHTML = "<span style='font-size: 11px; color: red; line-height: 9px;'>"+idx+"</span>";
	this.sep.style.overflow = "visible";
	*/
	
	if (window.dhx4.isIE == true) {
		this.sep.onselectstart = function(){return false;};
	}
	
	this.sep.className = "dhxlayout_sep dhxlayout_sep_resize_"+this.conf.mode;
	
	this._setSize = function(x, y, w, h) {
		this.sep.style.left = x+"px";
		this.sep.style.top = y+"px";
		this.sep.style.width = w+"px";
		this.sep.style.height = h+"px";
	}
	
	this._lockSep = function(mode) { // by fix cell size
		this.conf.locked = (mode==true);
		this._blockSep();
	}
	
	this._blockSep = function() { // by expand/collapse
		var k = this._getLayout();
		var state = k.cdata.a.conf.collapsed||k.cdata.b.conf.collapsed||this.conf.locked;
		k = null;
		if (this.conf.blocked == state) return;
		this.sep.className = "dhxlayout_sep"+(state?"":" dhxlayout_sep_resize_"+this.conf.mode);
		this.conf.blocked = state;
	}
	
	this._beforeResize = function(e) {
		
		if (this.conf.blocked) return;
		
		if (this.conf.resize != null && this.conf.resize.active == true) return;
		
		if (e.type == "touchstart") {
			this.sep.className += " dhxlayout_sep_resize_actv";
			var sx = (e.pageX||e.touches[0].pageX);
			var sy = (e.pageY||e.touches[0].pageY);
		} else {
			if (e.button !== this.conf.btn_left) return;
			var sx = e.clientX;
			var sy = e.clientY;
		}
		
		var k = this._getLayout();
		
		// resize init point
		
		this.conf.resize = {
			sx: sx,
			sy: sy,
			tx: e.layerX,
			ty: e.layerY,
			sep_x: parseInt(this.sep.style.left),
			sep_y: parseInt(this.sep.style.top),
			min_wa: k.cdata.a._getAvailWidth("a"),
			min_wb: k.cdata.b._getAvailWidth("b"),
			min_ha: k.cdata.a._getAvailHeight("a"),
			min_hb: k.cdata.b._getAvailHeight("b")
		}
		
		this.conf.resize.nx = this.conf.resize.sep_x;
		this.conf.resize.ny = this.conf.resize.sep_y;
		
		if (typeof(window.addEventListener) == "function") {
			window.addEventListener("mousemove", this._doOnMouseMove, false);
			window.addEventListener("mouseup", this._doOnMouseUp, false);
			window.addEventListener("touchmove", this._doOnMouseMove, false);
			window.addEventListener("touchend", this._doOnMouseUp, false);
		} else {
			document.body.attachEvent("onmousemove", this._doOnMouseMove);
			document.body.attachEvent("onmouseup", this._doOnMouseUp);
		}
		
		k = null;
		
	}
	
	this._onResize = function(e) {
		
		if (!this.conf.resize.active) {
			this._initResizeArea();
			this.conf.resize.active = true;
		}
		
		if (this.conf.mode == "v") {
			
			var x = (e.type == "mousemove" ? e.clientX : (e.pageX||e.touches[0].pageX));
			var ofs = this.conf.resize.sx-x;
			this.conf.resize.nx = this.conf.resize.sep_x-ofs;
			
			if (this.conf.resize.nx > this.conf.resize.sep_x+this.conf.resize.min_wb) {
				this.conf.resize.nx = this.conf.resize.sep_x+this.conf.resize.min_wb;
			} else if (this.conf.resize.nx < this.conf.resize.sep_x-this.conf.resize.min_wa) {
				this.conf.resize.nx = this.conf.resize.sep_x-this.conf.resize.min_wa;
			}
			
			this.r_sep.style.left = this.conf.resize.nx+"px";
			
		} else {
			
			var y = (e.type == "mousemove" ? e.clientY : (e.pageY||e.touches[0].pageY));
			var ofs = this.conf.resize.sy-y;
			this.conf.resize.ny = this.conf.resize.sep_y-ofs;
			
			if (this.conf.resize.ny > this.conf.resize.sep_y+this.conf.resize.min_hb) {
				this.conf.resize.ny = this.conf.resize.sep_y+this.conf.resize.min_hb;
			} else if (this.conf.resize.ny < this.conf.resize.sep_y-this.conf.resize.min_ha) {
				this.conf.resize.ny = this.conf.resize.sep_y-this.conf.resize.min_ha;
			}
			
			this.r_sep.style.top = this.conf.resize.ny+"px";
		}
		
	}
	
	this._afterResize = function(e) {
		
		if (typeof(window.addEventListener) == "function") {
			window.removeEventListener("mousemove", this._doOnMouseMove, false);
			window.removeEventListener("mouseup", this._doOnMouseUp, false);
			window.removeEventListener("touchmove", this._doOnMouseMove, false);
			window.removeEventListener("touchend", this._doOnMouseUp, false);
		} else {
			document.body.detachEvent("onmousemove", this._doOnMouseMove);
			document.body.detachEvent("onmouseup", this._doOnMouseUp);
		}
		
		if (!this.conf.resize.active) {
			this.conf.resize = null;
			return;
		}
		
		if (e.type == "touchend") {
			this.sep.className = this.sep.className.replace(/\s{0,}dhxlayout_sep_resize_actv/gi,"");
		} else {
			if (e.button !== this.conf.btn_left) return;
		}
		
		var k = this._getLayout();
		
		var mainInst = k._getMainInst();
		var rCells = (mainInst.checkEvent("onPanelResizeFinish")==true?{}:false);
		
		if (rCells !== false) {
			mainInst.forEachItem(function(cell){
				rCells[cell.conf.name] = {w: cell.conf.size.w, h: cell.conf.size.h};
				cell = null;
			});
		}
		
		var ofs_x = this.conf.resize.nx-this.conf.resize.sep_x;
		var ofs_y = this.conf.resize.ny-this.conf.resize.sep_y;
		
		k.cdata.a._setSize(k.cdata.a.conf.size.x, k.cdata.a.conf.size.y, k.cdata.a.conf.size.w+ofs_x, k.cdata.a.conf.size.h+ofs_y, "a");
		k.cdata.b._setSize(k.cdata.b.conf.size.x+ofs_x, k.cdata.b.conf.size.y+ofs_y, k.cdata.b.conf.size.w-ofs_x, k.cdata.b.conf.size.h-ofs_y, "b");
		
		this._setSize(parseInt(this.r_sep.style.left), parseInt(this.r_sep.style.top), parseInt(this.r_sep.style.width), parseInt(this.r_sep.style.height));
		
		if (window.dhx4.isIE) {
			// w/o timeout cursor not changed to normal state in IE
			var p0 = this;
			window.setTimeout(function(){p0._removeResizeArea();p0=null;},1);
		} else {
			this._removeResizeArea();
		}
		
		
		if (rCells !== false) {
			var p = [];
			mainInst.forEachItem(function(cell){
				var t = rCells[cell.conf.name];
				if (!(t.w == cell.conf.size.w && t.h == cell.conf.size.h)) p.push(cell.conf.name);
				cell = null;
			});
			mainInst._callMainEvent("onPanelResizeFinish", [p]);
		}
		
		mainInst = k = null;
		
		this.conf.resize.active = false;
		this.conf.resize = null;
		
	}
	
	this._initResizeArea = function() {
		
		if (this.r_sep == null) {
			
			this.r_sep = document.createElement("DIV");
			this.r_sep.className = "dhxlayout_resize_sep";
			this.r_sep.style.left = this.sep.style.left;
			this.r_sep.style.top = this.sep.style.top;
			this.r_sep.style.width = this.sep.style.width;
			this.r_sep.style.height = this.sep.style.height;
			this.sep.parentNode.appendChild(this.r_sep);
			
			if (window.dhx4.isIE) this.r_sep.onselectstart = function(){return false;};
			
		}
		
		if (this.r_area == null) {
			
			this.r_area = document.createElement("DIV");
			this.r_area.className = "dhxlayout_resize_area";
			this.sep.parentNode.appendChild(this.r_area);
			
			if (window.dhx4.isIE) this.r_area.onselectstart = function(){return false;};
			
			if (this.conf.mode == "v") {
				var x = parseInt(this.r_sep.style.left)-this.conf.resize.min_wa;
				var y = parseInt(this.r_sep.style.top);
				var w = this.conf.resize.min_wa+this.conf.resize.min_wb+parseInt(this.r_sep.style.width);
				var h = parseInt(this.r_sep.style.height);
			} else {
				var x = parseInt(this.r_sep.style.left);
				var y = parseInt(this.r_sep.style.top)-this.conf.resize.min_ha;
				var w = parseInt(this.r_sep.style.width);
				var h = this.conf.resize.min_ha+this.conf.resize.min_hb+parseInt(this.r_sep.style.height);
			}
			
			this.r_area.style.left = x+"px";
			this.r_area.style.top = y+"px";
			
			if (!dhtmlXLayoutObject.prototype._confGlob.reszieCover) {
				dhtmlXLayoutObject.prototype._confGlob.reszieCover = {};
				this.r_area.style.width = w+"px";
				this.r_area.style.height = h+"px";
				dhtmlXLayoutObject.prototype._confGlob.reszieCover.w = parseInt(this.r_area.style.width)-this.r_area.offsetWidth;
				dhtmlXLayoutObject.prototype._confGlob.reszieCover.h = parseInt(this.r_area.style.height)-this.r_area.offsetHeight;
			}
			
			this.r_area.style.width = w+dhtmlXLayoutObject.prototype._confGlob.reszieCover.w+"px";
			this.r_area.style.height = h+dhtmlXLayoutObject.prototype._confGlob.reszieCover.h+"px";
		}
		
		document.body.className += " dhxlayout_resize_"+this.conf.mode;
	}
	
	this._removeResizeArea = function() {
		
		this.r_sep.onselectstart = null;
		this.r_sep.parentNode.removeChild(this.r_sep);
		this.r_sep = null;
		
		this.r_area.onselectstart = null;
		this.r_area.parentNode.removeChild(this.r_area);
		this.r_area = null;
		
		document.body.className = String(document.body.className).replace(/\s{0,}dhxlayout_resize_[vh]/gi,"");
		
	}
	
	this._doOnMouseDown = function(e) {
		e = e||event;
		if (e.preventDefault) e.preventDefault(); else e.cancelBubble = true;
		that._beforeResize(e);
	}
	
	this._doOnMouseMove = function(e) {
		e = e||event;
		if (e.preventDefault) e.preventDefault(); else e.cancelBubble = true;
		that._onResize(e);
	}
	
	this._doOnMouseUp = function(e) {
		e = e||event;
		that._afterResize(e);
	}
	
	if (typeof(window.addEventListener) == "function") {
		this.sep.addEventListener("mousedown", this._doOnMouseDown, false);
		this.sep.addEventListener("touchstart", this._doOnMouseDown, false);
	} else {
		this.sep.attachEvent("onmousedown", this._doOnMouseDown);
	}
	
	this._unload = function() {
		
		if (typeof(window.addEventListener) == "function") {
			this.sep.removeEventListener("mousedown", this._doOnMouseDown, false);
			this.sep.removeEventListener("touchstart", this._doOnMouseDown, false);
		} else {
			this.sep.detachEvent("onmousedown", this._doOnMouseDown);
		}
		
		if (window.dhx4.isIE == true) {
			this.sep.onselectstart = null;
		}
		
		this.sep.parentNode.removeChild(this.sep);
		this.sep = null;
		
		for (var a in this) this[a] = null;
		
		that = null;
	}
	
	return this;
	
};


window.dhtmlXLayoutCell = function(id, layout) {
	
	dhtmlXCellObject.apply(this, [id, "_layout"]);
	
	var that = this;
	this.layout = layout;
	
	this.conf.skin = this.layout.conf.skin;
	this.conf.mode = this.layout.conf.mode;
	this.conf.collapsed = false;
	this.conf.fixed = {w: false, h: false}; // fix size
	this.conf.docked = true;
	
	this.attachEvent("_onCellUnload", function(){
		// dblclick header
		this.cell.childNodes[this.conf.idx.hdr].ondblclick = null;
		this._unloadDocking();
		this.layout = null;
		that = null;
	});
	
	// init header
	this._hdrInit();
	this.cell.childNodes[this.conf.idx.hdr].ondblclick = function(){
		var mainInst = that.layout._getMainInst();
		mainInst._callMainEvent("onDblClick", [that.conf.name]);
		mainInst = null;
	};
	
	// onContentLoaded
	this.attachEvent("_onContentLoaded", function() {
		var mainInst = this.layout._getMainInst();
		mainInst._callMainEvent("onContentLoaded", [this.conf.name]);
		mainInst = null;
	});
	
	// init expand/collapse
	if (this.conf.mode != "c") {
		
		var t = document.createElement("DIV");
		t.className = "dhxlayout_arrow dhxlayout_arrow_"+this.conf.mode+this._idd;
		this.cell.childNodes[this.conf.idx.hdr].appendChild(t);
		t.onclick = function(e) {
			if (that.conf.collapsed) that.expand(); else that.collapse();
		}
		t = null;
	}
	
	this._initDocking();
	
	return this;
	
};

dhtmlXLayoutCell.prototype = new dhtmlXCellObject();

dhtmlXLayoutCell.prototype.getId = function() {
	return this.conf.name;
};

dhtmlXLayoutCell.prototype._initDocking = function() {
	
	var that = this;
	
	this.dock = function() {
		
		var mainInst = this.layout._getMainInst();
		
		if (mainInst.dhxWins == null || this.conf.docked) {
			mainInst = null;
			return;
		}
		
		var w1 = mainInst.dhxWins.window(this.conf.name);
		w1.close();
		
		// move content
		this._attachFromCell(w1);
		
		this.conf.docked = true;
		if (!this.conf.dock_collapsed) this.expand();
		
		mainInst._callMainEvent("onDock",[this.conf.name]);
		
		mainInst = w1 = null;
		
	};
	
	this.undock = function(x, y, w, h) {
		
		var mainInst = this.layout._getMainInst();
		
		if (mainInst.dhxWins == null || this.conf.docked == false) {
			mainInst = null;
			return;
		}
		
		this.conf.dock_collapsed = this.conf.collapsed;
		if (!this.conf.collapsed) this.collapse();
		
		if (mainInst.dhxWins.window(this.conf.name) != null) {
			var w1 = mainInst.dhxWins.window(this.conf.name);
			w1.show();
		} else {
			if (x == null) x = 20;
			if (y == null) y = 20;
			if (w == null) w = 320;
			if (h == null) h = 200;
			
			var w1 = mainInst.dhxWins.createWindow(this.conf.name, x, y, w, h);
			w1.button("close").hide();
			
			// dock button
			w1.addUserButton("dock", 99, "Dock");
			w1.button("dock").show();
			w1.button("dock").attachEvent("onClick", this._doOnDockClick);
			
			// text update only first time
			w1.setText(this.getText());
			
			// closeing
			w1.attachEvent("onClose", this._doOnDockWinClose);
		}
		this.conf.docked = false;
		
		// move content
		w1._attachFromCell(this);
		
		mainInst._callMainEvent("onUnDock",[this.conf.name]);
		
		mainInst = w1 = null;
		
	}
	
	this._doOnDockClick = function() {
		that.dock();
	}
	this._doOnDockWinClose = function(win) {
		win.hide();
		return false;
	}
	
	this._unloadDocking = function() {
		that = null;
	}
};

dhtmlXLayoutCell.prototype._hdrInit = function() {
	
	var cssExt = "";
	if (window.dhx4.isIE) {
		if (navigator.userAgent.indexOf("MSIE 8.0") != -1) {
			cssExt = " dhx_cell_hdr_text_ie8";
		} else if (navigator.userAgent.indexOf("MSIE 7.0") != -1) {
			cssExt = " dhx_cell_hdr_text_ie7";
		} else if (navigator.userAgent.indexOf("MSIE 6.0") != -1) {
			cssExt = " dhx_cell_hdr_text_ie6";
		}
	} else if (window.dhx4.isChrome || window.dhx4.isKHTML) {
		cssExt = " dhx_cell_hdr_text_chrome";
	}
	
	var t = document.createElement("DIV");
	t.className = "dhx_cell_hdr";
	t.innerHTML = "<div class='dhx_cell_hdr_text"+cssExt+"'></div>";
	this.cell.insertBefore(t, this.cell.childNodes[this.conf.idx.cont]);
	t = null;
	
	// include into content top offset calculation
	this.conf.ofs_nodes.t._getHdrHeight = "func";
	
	// show/hide
	this.conf.hdr = {visible: true};
	
	// include into index
	this.conf.idx_data.hdr = "dhx_cell_hdr";
	this._updateIdx();
	
	// fit header when cell changed
	this.attachEvent("_onSetSize", this._hdrOnSetSize);
	this.attachEvent("_onBorderChange", this._hdrOnBorderChange);
	
	// keep visibility state of header if view changed
	this.attachEvent("_onViewSave", this._hdrOnViewSave);
	this.attachEvent("_onViewRestore", this._hdrOnViewRestore);
	
};

dhtmlXLayoutCell.prototype.showHeader = function(noCalcCont) {
	
	if (this.conf.hdr.visible || this.conf.collapsed) return;
	
	if (this.conf.hdr.w_saved > this._getAvailWidth() || this.conf.hdr.h_saved > this._getAvailHeight()) {
		// console.log("no space to show header");
		return;
	}
	
	this.conf.hdr.w_saved = this.conf.hdr.h_saved = null;
	
	this.conf.hdr.visible = true;
	this.cell.childNodes[this.conf.idx.hdr].className = "dhx_cell_hdr";
	
	if (noCalcCont !== true) this._adjustCont(this._idd);
};

dhtmlXLayoutCell.prototype.hideHeader = function(noCalcCont) {
	
	if (!this.conf.hdr.visible || this.conf.collapsed) return;
	
	this.conf.hdr.w_saved = this._getMinWidth();
	this.conf.hdr.h_saved = this._getMinHeight();
	
	this.conf.hdr.visible = false;
	this.cell.childNodes[this.conf.idx.hdr].className = "dhx_cell_hdr dhx_cell_hdr_hidden";
	this._hdrUpdBorder();
	this._mtbUpdBorder();
	
	if (noCalcCont !== true) this._adjustCont(this._idd);
};

dhtmlXLayoutCell.prototype.isHeaderVisible = function() {
	return (this.conf.hdr.visible==true);
};

// arrow
dhtmlXLayoutCell.prototype.showArrow = function() {
	this.cell.childNodes[this.conf.idx.hdr].childNodes[1].style.display = "";
};

dhtmlXLayoutCell.prototype.hideArrow = function() {
	this.cell.childNodes[this.conf.idx.hdr].childNodes[1].style.display = "none";
};

dhtmlXLayoutCell.prototype.isArrowVisible = function() {
	return (this.cell.childNodes[this.conf.idx.hdr].childNodes[1].style.display == "");
};

// text
dhtmlXLayoutCell.prototype.setText = function(text) {
	this.conf.hdr.text = text;
	this._hdrUpdText();
};

dhtmlXLayoutCell.prototype.getText = function() {
	return this.conf.hdr.text;
};

dhtmlXLayoutCell.prototype.setCollapsedText = function(text) {
	this.conf.hdr.text_collapsed = text;
	this._hdrUpdText();
};

dhtmlXLayoutCell.prototype.getCollapsedText = function() {
	return (this.conf.hdr.text_collapsed != null ? this.conf.hdr.text_collapsed : this.conf.hdr.text );
};

dhtmlXLayoutCell.prototype._hdrUpdText = function() {
	var text = (this.conf.collapsed == true && this.conf.hdr.text_collapsed != null ? this.conf.hdr.text_collapsed : this.conf.hdr.text);
	this.cell.childNodes[this.conf.idx.hdr].firstChild.innerHTML = "<span>"+text+"</span>";
};

dhtmlXLayoutCell.prototype._hdrUpdBorder = function() {
	if (this.conf.borders == true) {
		this.cell.childNodes[this.conf.idx.hdr].className = "dhx_cell_hdr"+(this.conf.hdr.visible?"":" dhx_cell_hdr_hidden");
	} else {
		if (!this.conf.hdr.visible) {
			this.cell.childNodes[this.conf.idx.hdr].className = "dhx_cell_hdr dhx_cell_hdr_hidden_no_borders";
		}
	}
};

dhtmlXLayoutCell.prototype._hdrOnSetSize = function() {
	if (this.conf.collapsed && this.conf.mode == "v") this._fitHdr();
};
dhtmlXLayoutCell.prototype._hdrOnBorderChange = function() {
	this.hideHeader(true);
	this._hdrUpdBorder();
};
dhtmlXLayoutCell.prototype._hdrOnViewSave = function(name) {
	this.views[name].hdr_vis = this.conf.hdr.visible;
};
dhtmlXLayoutCell.prototype._hdrOnViewRestore = function(name){
	if (this.conf.hdr.visible != this.views[name].hdr_vis) {
		this[this.views[name].hdr_vis?"showHeader":"hideHeader"](true);
	}
	this.views[name].hdr_vis = null;
	delete this.views[name].hdr_vis;
};
dhtmlXLayoutCell.prototype._getHdrHeight = function(incColl) {
	
	if (this.conf.collapsed && this.conf.mode == "v" && incColl !== true) {
		// collapsed vertical cell, move to conf?
		// offsetHeight returns full cell height, needed only for adjusting bottom border
		return 27;
	}
	return this.cell.childNodes[this.conf.idx.hdr].offsetHeight;
};

dhtmlXLayoutCell.prototype._fitHdr = function() {
	if (this.conf.collapsed) {
		if (typeof(dhtmlXLayoutObject.prototype._confGlob.hdrColH) == "undefined") {
			this.cell.childNodes[this.conf.idx.hdr].style.height = this.cell.offsetHeight+"px";
			dhtmlXLayoutObject.prototype._confGlob.hdrColH = parseInt(this.cell.childNodes[this.conf.idx.hdr].style.height)-this._getHdrHeight(true);
		}
		this.cell.childNodes[this.conf.idx.hdr].style.height = this.cell.offsetHeight+dhtmlXLayoutObject.prototype._confGlob.hdrColH+"px";
	} else {
		this.cell.childNodes[this.conf.idx.hdr].style.height = null;
		
	}
};


/* expand */
dhtmlXLayoutCell.prototype.expand = function(autoExpand) {
	
	if (!this.conf.collapsed) return true;
	
	var k = this.layout;
	
	if (this.conf.mode == "v") {
		
		var w_nextCell = (autoExpand ? k.conf.hh : k.cdata[k.conf.nextCell[this._idd]]._getMinWidth(this._idd));
		var w_avl = k.base.offsetWidth-k.conf.sw;
		
		if (w_nextCell + this.conf.size.w_avl > w_avl) {
			k = null;
			return false;
		}
		
	} else {
		
		// if autoExpand - next cell coing to be collapsed, move value to conf?
		// min heigth of next cell = min_height+hdr_height
		
		var h_nextCell = (autoExpand ? k.conf.hh : k.cdata[k.conf.nextCell[this._idd]]._getMinHeight(this._idd)+k.cdata[k.conf.nextCell[this._idd]]._getHdrHeight());
		var h_avl = k.base.offsetHeight-k.conf.sw; // avail height for both cells = base_h-sep_h
		
		if (h_nextCell + this.conf.size.h_avl > h_avl) {
			// new logic, menu/tb attached
			k = null;
			return false;
		}
		
	}
	
	if (this.conf.docked == false) {
		this.dock();
		return;
	}
	
	this.cell.className = String(this.cell.className).replace(/\s{0,}dhxlayout_collapsed_[hv]/gi, "");
	this.conf.collapsed = false;
	
	if (this.conf.mode == "v") {
		this.conf.size.w = Math.min(w_avl-w_nextCell, this.conf.size.w_saved);
		this.conf.size.w_saved = this.conf.size.w_avl = null;
	} else {
		this.conf.size.h = Math.min(h_avl-h_nextCell, this.conf.size.h_saved);
		this.conf.size.h_saved = this.conf.size.h_avl = null;
	}
	
	if (this.conf.mode == "v") this._fitHdr();
	
	k.setSizes(k.conf.nextCell[this._idd], k.conf.nextCell[this._idd], autoExpand==true, "expand");
	k.sep._blockSep();
	
	k = null;
	
	this._hdrUpdText();
	
	var mainInst = this.layout._getMainInst();
	mainInst._callMainEvent("onExpand", [this.conf.name]);
	mainInst = null;
	
	return true;
};

/* collapse */
dhtmlXLayoutCell.prototype.collapse = function() {
	
	if (this.conf.collapsed) return false;
	
	var k = this.layout;
	
	if (k.cdata[k.conf.nextCell[this._idd]].expand(true) == false) return false; // no space to expand next cell if it collapsed
	
	if (this.conf.mode == "v") {
		this.conf.size.w_saved = this.conf.size.w;
		this.conf.size.w_avl = this._getMinWidth(this._idd); // save min width
	} else {
		this.conf.size.h_saved = this.conf.size.h;
		this.conf.size.h_avl = this._getMinHeight(this._idd)+this._getHdrHeight(); // save min height
	}
	
	this.cell.className += " dhxlayout_collapsed_"+this.conf.mode;
	this.conf.collapsed = true;
	
	if (this.conf.mode == "v") {
		this.conf.size.w = k.conf.hh; // move to conf?
	} else {
		this.conf.size.h = this._getHdrHeight();
	}
	
	k.setSizes(k.conf.nextCell[this._idd], k.conf.nextCell[this._idd], false, "collapse");
	k.sep._blockSep();
	
	k = null;
	
	this._hdrUpdText();
	
	var mainInst = this.layout._getMainInst();
	mainInst._callMainEvent("onCollapse", [this.conf.name]);
	mainInst = null;
	
	return true;
	
};

dhtmlXLayoutCell.prototype.isCollapsed = function() {
	return (this.conf.collapsed==true);
};

// cell sizing
dhtmlXLayoutCell.prototype._getMinWidth = function(parentIdd) {
	// min space should allow to collapse ?
	if (this.dataType == "layout" && this.dataObj != null) {
		
		if (this.dataObj.conf.pattern == "1C") {
			return this.dataObj.cdata.a._getMinWidth(parentIdd);
		} else if (this.dataObj.conf.mode == "v") {
			
			var c1 = parentIdd;
			if (this.dataObj.cdata[c1].conf.collapsed) c1 = this.dataObj.conf.nextCell[c1];
			
			return this.dataObj.cdata[c1]._getMinWidth(parentIdd)+this.dataObj.cdata[this.dataObj.conf.nextCell[c1]]._getWidth()+this.dataObj.conf.sw; // c1 min width + c2 full width + sw
			
		} else {
			return Math.max(this.dataObj.cdata.a._getMinWidth(parentIdd), this.dataObj.cdata.b._getMinWidth(parentIdd));
		}
		
	}
	return 26;
};

dhtmlXLayoutCell.prototype._getMinHeight = function(parentIdd) {
	
	var h = 26;
	if (this.conf.idx.menu != null) h += this.cell.childNodes[this.conf.idx.menu].offsetHeight;
	
	if (this.dataType == "layout" && this.dataObj != null) {
		
		if (this.dataObj.conf.pattern == "1C") {
			return this.dataObj.cdata.a._getMinHeight(parentIdd);
		} else if (this.dataObj.conf.mode == "h") {
			
			var c1 = parentIdd;
			if (this.dataObj.cdata[c1].conf.collapsed) c1 = this.dataObj.conf.nextCell[c1];
			
			return this.dataObj.cdata[c1]._getMinHeight(parentIdd)+this.dataObj.cdata[c1]._getHdrHeight()+this.dataObj.cdata[this.dataObj.conf.nextCell[c1]]._getHeight()+this.dataObj.conf.sw; // c1 min height + c1 hdr height + c2 full height + sw
			
		} else {
			return Math.max(this.dataObj.cdata.a._getMinHeight(parentIdd)+this.dataObj.cdata.a._getHdrHeight(), this.dataObj.cdata.b._getMinHeight(parentIdd)+this.dataObj.cdata.b._getHdrHeight());
		}

	}
	
	return h;
};

dhtmlXLayoutCell.prototype._getAvailWidth = function(parentIdd) {
	
	if (this.dataType == "layout" && this.dataObj != null) {
		if (this.dataObj.conf.pattern == "1C") {
			return this.dataObj.cdata.a._getAvailWidth(parentIdd);
		} else if (this.dataObj.conf.mode == "v") {
			var ac = (this.dataObj.cdata.a.conf.collapsed == true);
			var bc = (this.dataObj.cdata.b.conf.collapsed == true);
			
			if (parentIdd == "a") {
				return this.dataObj.cdata[bc?"a":"b"]._getAvailWidth(parentIdd);
			} else {
				return this.dataObj.cdata[ac?"b":"a"]._getAvailWidth(parentIdd);
			}
		} else {
			return Math.min(this.dataObj.cdata.a._getAvailWidth(parentIdd), this.dataObj.cdata.b._getAvailWidth(parentIdd));
		}
		
	}
	return this.cell.offsetWidth-this._getMinWidth();
};

dhtmlXLayoutCell.prototype._getAvailHeight = function(parentIdd) {
	
	if (this.dataType == "layout" && this.dataObj != null) {
		if (this.dataObj.conf.pattern == "1C") {
			return this.dataObj.cdata.a._getAvailHeight(parentIdd);
		} else if (this.dataObj.conf.mode == "h") {
			
			var ac = (this.dataObj.cdata.a.conf.collapsed == true);
			var bc = (this.dataObj.cdata.b.conf.collapsed == true);
			
			if (parentIdd == "a") {
				return this.dataObj.cdata[bc?"a":"b"]._getAvailHeight(parentIdd);
			} else {
				return this.dataObj.cdata[ac?"b":"a"]._getAvailHeight(parentIdd);
			}
		} else {
			return Math.min(this.dataObj.cdata.a._getAvailHeight(parentIdd), this.dataObj.cdata.b._getAvailHeight(parentIdd));
		}
		
	}
	
	var hh = this._getHdrHeight();
	if (this.conf.mode == "v" && this.conf.collapsed) hh = this.conf.hh; // not include header if v-cell is collapsed
	
	return this.cell.offsetHeight-hh-this._getMinHeight();
};

dhtmlXLayoutCell.prototype.setWidth = function(w) {
	
	if (this.conf.mode == "v") {
		
		if (this.conf.collapsed) return;
		
		var k = this.layout;
		var nextCell = k.cdata[k.conf.nextCell[this._idd]];
		
		if (nextCell.conf.collapsed) {
			
			// try to change parent cell
			
			w = w + k.conf.sw + nextCell._getWidth(); // increase width including nextCell and sw
			
			/*
			var p = this.layout._getMainInst();
			if (p != this.layout) {
				for (var a in p.cdata) if (p.cdata[a].dataObj == k) p.cdata[a].setWidth(w);
			}
			*/
			
			p = k = nextCell = null;
			
			return;
			
		}
		
		var minW = this._getMinWidth(this._idd);
		var maxW = k.base.offsetWidth-nextCell._getMinWidth(this._idd)-k.conf.sw;
		w = Math.max(minW, Math.min(w, maxW));
		
		this.conf.size.w = w;
		
		k.setSizes(nextCell._idd, nextCell._idd);
		k = nextCell = null;
		
	} else {
		// check parent's width
		if (this.layout == null || this.layout.parentLayout == null) return;
		
		var p = this.layout.parentLayout;
		
		var k = this.layout;
		var nextCell = k.cdata[k.conf.nextCell[this._idd]];
		
		for (var a in p.cdata) if (p.cdata[a].dataObj == k) p.cdata[a].setWidth(w);
		
		p = k = null;
	}
	
};

dhtmlXLayoutCell.prototype.setHeight = function(h) {
	
	if (this.conf.mode == "h") {
		
		if (this.conf.collapsed) return;
		
		var k = this.layout;
		var nextCell = k.cdata[k.conf.nextCell[this._idd]];
		
		if (nextCell.conf.collapsed) {
			
			// try to change parent cell
			
			h = h + k.conf.sw + nextCell._getHeight(); // increase with including nextCell and sw, header=cell_height due it collapsed
			
			var p = (this.layout != null && this.layout.parentLayout != null ? this.layout.parentLayout : null);
			if (p != null) {
				for (var a in p.cdata) if (p.cdata[a].dataObj == k) p.cdata[a].setHeight(h);
			}
			
			p = k = nextCell = null;
			
			return;
			
		}
		
		var minH = this._getMinHeight(this._idd)+this._getHdrHeight();
		var maxH = k.base.offsetHeight-nextCell._getMinHeight(this._idd)-nextCell._getHdrHeight()-k.conf.sw;
		h = Math.max(minH, Math.min(h, maxH));
		
		this.conf.size.h = h;
		
		k.setSizes(nextCell._idd, nextCell._idd);
		k = nextCell = null;
		
	} else {
		// check parent's height
		if (this.layout == null || this.layout.parentLayout == null) return;
		
		var p = this.layout.parentLayout;
		
		var k = this.layout;
		var nextCell = k.cdata[k.conf.nextCell[this._idd]];
		
		for (var a in p.cdata) if (p.cdata[a].dataObj == k) p.cdata[a].setHeight(h);
		
		p = k = null;
	}
	
};

dhtmlXLayoutCell.prototype.getWidth = function() {
	return this.conf.size.w;
};

dhtmlXLayoutCell.prototype.getHeight = function() {
	return this.conf.size.h;
};

dhtmlXLayoutCell.prototype.fixSize = function(w, h) {
	
	this.conf.fixed.w = window.dhx4.s2b(w);
	this.conf.fixed.h = window.dhx4.s2b(h);
	
	var mainInst = this.layout._getMainInst();
	var s = {};
	
	mainInst.forEachItem(function(cell){
		if (cell.conf.fsize != null) {
			var id = cell.getId();
			var p = {
				h: (cell.conf.fixed.w==true),
				v: (cell.conf.fixed.h==true)
			};
			for (var a in p) {
				if (p[a] == true && cell.conf.fsize[a] != null) {
					if (!(cell.conf.fsize[a] instanceof Array)) cell.conf.fsize[a] = [cell.conf.fsize[a]];
					for (var q=0; q<cell.conf.fsize[a].length; q++) s[cell.conf.fsize[a][q]] = true;
				}
			}
		}
		cell = null;
	});
	
	mainInst._forEachSep(function(sep){
		sep._lockSep(s[sep.conf.idx]==true);
		sep = null;
	});
	
	mainInst = null;
	
};


dhtmlXCellObject.prototype.attachLayout = function(conf) {
	
	if (this.conf.skin == "dhx_skyblue"  && typeof(window.dhtmlXWindowsCell) != "undefined" && (this instanceof dhtmlXWindowsCell)) {
		// don't hide layout's borders in window
	}
	
	if (this instanceof dhtmlXLayoutCell) {
		this._hideBorders();
	}
	
	// attach to portal
	if (typeof(window.dhtmlXPortalCell) != "undefined" && this instanceof window.dhtmlXPortalCell) {
		this.hideHeader(true);
		this._hideBorders();
	}
	
	var obj = document.createElement("DIV");
	obj.style.width = "100%";
	obj.style.height = "100%";
	obj.style.position = "relative";
	obj.style.overflow = "hidden";
	this._attachObject(obj);
	
	if (typeof(this._layoutMainInst) != "undefined") {
		obj._layoutMainInst = this._layoutMainInst;
	}
	
	if (this instanceof window.dhtmlXLayoutCell) {
		//this.hideHeader();
		// this.cell.childNodes[this.conf.idx.cont].style.backgroundColor = "#f1f1f1";
		// obj._ofs = {t:5,b:5,l:5,r:5};
	}
	
	
	if (typeof(window.dhtmlXLayoutCell) != "undefined" && this instanceof dhtmlXLayoutCell) {
		obj._isParentCell = true;
	}
	
	// acc, move layout 1px-up to hide top borders
	if (typeof(window.dhtmlXAccordionCell) != "undefined" && (this instanceof window.dhtmlXAccordionCell)) {
		obj._ofs = {t:-1};
	}
	
	if (typeof(conf) == "string") conf = {pattern: conf};
	if (typeof(conf.skin) == "undefined") conf.skin = this.conf.skin;
	conf.parent = obj;
	
	this.dataType = "layout";
	this.dataObj = new dhtmlXLayoutObject(conf);
	
	if (this instanceof dhtmlXLayoutCell) {
		this.dataObj.parentLayout = this.layout;
	}
	
	obj._layoutMainInst = null;
	conf.parent = null;
	obj = conf = null;
	
	this.callEvent("_onContentAttach",[]);
	
	return this.dataObj;
	
};


/*
Product Name: dhtmlxSuite 
Version: 4.1.3 
Edition: Professional 
License: content of this file is covered by DHTMLX Commercial or Enterprise license. Usage without proper license is prohibited. To obtain it contact sales@dhtmlx.com
Copyright UAB Dinamenta http://www.dhtmlx.com
*/

function dhtmlXTabBar(conf, mode) { // skin? data?
	
	// console.log("context menu for tabs?");
	// console.log("first tab open event?");
	
	var that = this;
	
	this.conf = {
		skin: (window.dhx4.skin||(typeof(dhtmlx)!="undefined"?dhtmlx.skin:null)||window.dhx4.skinDetect("dhxtabbar")||"dhx_skyblue"),
		fullScreen: false,
		fullScreenResize: false, // autoresize not inited
		lastActive: null,
		closeButton: false,
		align: "left", // tabs aligned to right side, inversed, default "right" align
		tabsMode: (mode=="bottom"?"bottom":"top"), // top/bottom
		contZone: true,
		transSpeed: "0.15s",
		arwMode: "always", // always (def), auto
		baseOfs: {w:2,h:2}, // offset for base in fullscreen mode
		tabsOfs: 1, // dhx_skyblue and dhx_terrace have margin-left:-1px for tabs, should be included
		tabsTop: 0, // tabs top position, used in attachObject to hide border
		autoload: {}
	};
	
	var base;
	
	// check if api init
	if (conf != null && typeof(conf) == "object" && typeof(conf.tagName) == "undefined") {
		base = conf.parent;
		if (typeof(conf.skin) != "undefined") this.conf.skin = conf.skin;
		if (typeof(conf.mode) != "undefined") this.conf.tabsMode = (conf.mode=="bottom"?"bottom":"top");
		if (typeof(conf.align) != "undefined") this.conf.align = (conf.align=="right"?"right":"left");
		if (typeof(conf.close_button) != "undefined") this.conf.closeButton = window.dhx4.s2b(conf.close_button);
		if (typeof(conf.content_zone) != "undefined") this.conf.contZone = window.dhx4.s2b(conf.content_zone);
		if (typeof(conf.xml) != "undefined") this.conf.autoload.xml = conf.xml;
		if (typeof(conf.json) != "undefined") this.conf.autoload.xml = conf.json; // new in 4.0
		if (typeof(conf.tabs) != "undefined") this.conf.autoload.tabs = conf.tabs;
		if (typeof(conf.onload) != "undefined") this.conf.autoload.tabs = conf.tabs; // new in 4.0
		if (typeof(conf.arrows_mode) != "undefined") this.conf.autoload.arrows_mode = conf.arrows_mode; // new in 4.1.2
		// deprecated from 4.0
		// conf { height, offset, margin, image_path, href_mode, scroll, forced, size_by_content, auto_size }
	} else {
		base = conf;
	}
	
	if (base == document.body) {
		
		document.documentElement.className += " dhxtabbar_fullscreen";
		document.body.className += " dhxtabbar_fullscreen";
		this.conf.fullScreen = true;
		
		this.base = document.createElement("DIV");
		this.base.className = "dhxtabbar_base_"+this.conf.skin;
		this.base.style.position = "absolute";
		this.base.style.left = this.conf.baseOfs.w+"px";
		this.base.style.top = this.conf.baseOfs.h+"px";
		document.body.appendChild(this.base);
		
	} else {
		
		this.base = (typeof(base) == "string" ? document.getElementById(base) : base);
		base = null;
		
		this.base.className += " dhxtabbar_base_"+this.conf.skin;
		
	}
	
	// tabsTop override
	if (this.base._ofs != null && this.base._ofs.t != null) this.conf.tabsTop = this.base._ofs.t;
	
	this.tabsMode = document.createElement("DIV");
	this.tabsMode.className = "dhxtabbar_tabs_"+this.conf.tabsMode;
	this.base.appendChild(this.tabsMode);
	
	this.tabsArea = document.createElement("DIV");
	this.tabsArea.className = "dhxtabbar_tabs dhxtabbar_tabs_"+this.conf.tabsMode;
	this.tabsArea.innerHTML = "<div class='dhxtabbar_tabs_ar_left'><div class='dhxtabbar_arrow_img'></div></div>"+
					"<div class='dhxtabbar_tabs_base'>"+
						"<div class='dhxtabbar_tabs_cont_"+this.conf.align+"'>"+
							"<div class='dhxtabbar_tabs_line'></div>"+
						"</div>"+
					"</div>"+
					"<div class='dhxtabbar_tabs_ar_right'><div class='dhxtabbar_arrow_img'></div></div>";
	
	this.tabsArea.style.top = (this.conf.tabsMode=="top"?this.conf.tabsTop+"px":"auto");
	this.tabsMode.appendChild(this.tabsArea);
	
	// area to move tabs
	this.tabsArea.childNodes[1].childNodes[0].style[this.conf.align] = "0px";
	
	this.tabsArea.childNodes[0].onclick = function() {
		if (that.conf.align == "left") {
			that._moveTabs(1);
		} else {
			that._moveTabs(-1);
		}
	}
	this.tabsArea.childNodes[2].onclick = function() {
		if (that.conf.align == "left") {
			that._moveTabs(-1);
		} else {
			that._moveTabs(1);
		}
	}
	
	this._onTabsAreaClick = function(id) {
		return this._callMainEvent("onTabClose",[id]);
	}
	
	this.tabsArea.onclick = function(e) {
		e = e||event;
		var t = (e.target||e.srcElement);
		while (t != null) {
			if (typeof(t._tabCloseId) != "undefined") {
				if (that._onTabsAreaClick(t._tabCloseId) !== true) return;
				that.t[t._tabCloseId].conf.remove = true;
				that._hideTab(t._tabCloseId);
				t = null;
			} else if (typeof(t._tabId) != "undefined") {
				that._doOnClick(t._tabId);
				t = null;
			}
			if (t != null) {
				t = t.parentNode;
				if (t == this) t = null;
			}
		}
	}
	
	this.tabsArea.onselectstart = function(e) {
		e = e||event;
		if (e.preventDefault) e.preventDefault(); else e.returnValue = false;
	}
	
	this._doOnClick = function(id) {
		// onBeforeEvent here
		this.callEvent("onTabClick", [id, this.conf.lastActive]);
		if (this.t[id].conf.enabled) this._setTabActive(id);
	}
	
	this.t = {};
	
	this.addTab = function(id, text, width, position, active, close) {
		
		// close = show close button, false by default
		// true - show_closeButton
		// false - do not show (ignoring enableTabCloseButton)
		// not set - depending on enableTabCloseButton
		if (typeof(close) != "boolean") close = (this.conf.closeButton==true);
		active = window.dhx4.s2b(active);
		
		var tab = document.createElement("DIV");
		tab.className = "dhxtabbar_tab";
		tab.innerHTML = "<div class='dhxtabbar_tab_text"+(close?" dhxtabbar_tab_text_close":"")+"'>"+text+"</div>"+
				(close?"<div class='dhxtabbar_tab_close'></div>":"");
		
		tab._tabId = id;
		if (close) tab.childNodes[1]._tabCloseId = id; // close button
		
		var p = this.tabsArea.childNodes[1].firstChild;
		
		if (position != null && position+1 > 0 && position+1 < p.childNodes.length) { // 1st item - line
			p.insertBefore(tab, p.childNodes[position+1]);
		} else {
			p.appendChild(tab);
		}
		
		
		// width
		var autowidth = false;
		if (typeof(width) == "undefined" || width == null || width == "*") {
			width = this._getLabelWidth(text, close);
			autowidth = true;
		} else {
			width = parseInt(width);
		}
		
		tab.style.width = width+"px";
		
		var cell = new dhtmlXTabBarCell(id, this);
		this.tabsMode.appendChild(cell.cell);
		
		this.t[id] = {
			tab: tab,
			cell: cell,
			conf: {
				text: text,
				visible: true,
				active: false,
				enabled: true,
				close: close,
				width: width,
				autowidth: autowidth
			}
		};
		
		p = cell = null;
		
		if (active) {
			this._setTabActive(id);
		} else {
			this._adjustCell(id);
		}
		
		if (this.conf.initSeq != true && this.conf.arwMode == "auto") this.setSizes();
	}
	
	this.setSizes = function() {
		
		if (this.conf.fullScreen) {
			this.base.style.left = this.conf.baseOfs.w+"px";
			this.base.style.top = this.conf.baseOfs.h+"px";
			this.base.style.width = document.body.offsetWidth-this.conf.baseOfs.w*2+"px";
			this.base.style.height = document.body.offsetHeight-this.conf.baseOfs.h*2+"px";
		}
		
		if (this.conf.tabsAreaOfs == null) {
			this.tabsArea.style.width = this.base.offsetWidth+"px";
			this.conf.tabsAreaOfs = parseInt(this.tabsArea.style.width)-this.tabsArea.offsetWidth;
		}
		this.tabsArea.style.width = this.base.offsetWidth+this.conf.tabsAreaOfs+"px";
		
		this._adjustCell(this.conf.lastActive);
		this._adjustTabs(true);
		
	}
	
	this._adjustCell = function(id) {
		
		// adjust specified cell or active
		
		if (!this.conf.contZone || id == null) return;
		
		var y = (this.conf.tabsMode=="top"?this.tabsArea.offsetHeight:0)+this.conf.tabsTop;
		var h = this.base.offsetHeight-this.tabsArea.offsetHeight-this.conf.tabsTop;
		
		// if layout attached - move a bit
		var t = this.t[id].cell.dataType;
		if (this.conf.skin == "dhx_skyblue" && (t == "layout" || t == "tabbar" || t == "acc")) {
			if (this.conf.tabsMode == "top") y = y - 1; // only for top
			h = h + 1; // always
		}
		
		if (id != this.conf.lastActive) {
			y = -5000;
			this.t[id].cell.cell.style.visibility = "hidden";
			this.t[id].cell.cell.style.zIndex = 0;
		}
		this.t[id].cell._setSize(0, y, this.base.offsetWidth, h);

	}
	
	this.setTabsMode = function(mode) {
		// new
		this.conf.tabsMode = (mode=="bottom"?"bottom":"top");
		this.tabsMode.className = "dhxtabbar_tabs_"+this.conf.tabsMode;
		this.tabsArea.className = "dhxtabbar_tabs dhxtabbar_tabs_"+this.conf.tabsMode;
		this.tabsArea.style.top = (this.conf.tabsMode=="top"?this.conf.tabsTop+"px":"auto");
		this.setSizes();
	}
	
	// generate tab css depending on actv/en state
	this._tabCss = function(id, hidden) {
		var a = this.t[id].conf.active;
		var d = !this.t[id].conf.enabled;
		var h = !this.t[id].conf.visible;
		return "dhxtabbar_tab"+(h?" dhxtabbar_tab_hidden":(a||d?" dhxtabbar_tab"+(a?"_actv":"")+(d?"_dis":""):""));
	}
	
	// calculate tab width depending on text and close button
	this._getLabelWidth = function(text, close) {
		
		if (this.tabsTextTest == null) {
			this.tabsTextTest = document.createElement("SPAN");
			this.tabsTextTest.className = "dhxtabbar_tabs_text_test_"+this.conf.skin;
		}
		
		document.body.appendChild(this.tabsTextTest);
		this.tabsTextTest.innerHTML = text;
		var w = this.tabsTextTest.offsetWidth;
		if (window.dhx4.isIE && w == 0) w = this.tabsTextTest.offsetWidth; // strange IE bug
		
		// move to conf?
		w += (this.conf.skin == "dhx_terrace" ? 44:35);
		w += (close ? (this.conf.skin == "dhx_terrace" ? 14:9) : 0);
		//
		document.body.removeChild(this.tabsTextTest);
		return w;
	}
	
	// if tabs overflow left/right side, adjust active tab position
	this._adjustTabs = function(fixTabsArea) {
		
		if (this._checkArrows() == true || fixTabsArea == true) {
			this.tabsArea.childNodes[1].style.left = this.tabsArea.childNodes[0].offsetWidth-1+"px";
			this.tabsArea.childNodes[1].style.width = Math.max(0, this.tabsArea.offsetWidth-this.tabsArea.childNodes[0].offsetWidth-this.tabsArea.childNodes[2].offsetWidth)+1+"px"; // minus 2 arrows
		}
		
		var p = this.tabsArea.childNodes[1];
		if (p.offsetWidth < 5) {
			p = null;
			return;
		}
		
		var x = parseInt(p.childNodes[0].style[this.conf.align]);
		
		var k = null;
		for (var q=0; q<p.childNodes[0].childNodes.length; q++) {
			var id = p.childNodes[0].childNodes[q]._tabId;
			if (id != null && this.t[id].conf.visible) {
				var w = this.t[id].tab.offsetWidth-this.conf.tabsOfs;
				if (this.t[id].conf.active) {
					if (x < 0 || p.offsetWidth<w) {
						k = {d: 1, id: id}; // tab hidden on left side, move to right OR tab width less than space available
					} else if (x+w > p.offsetWidth) {
						k = {d:-1, id: id}; // overflow on right
					}
				}
				x += w;
			}
		}
		
		if (k != null) {
			// move selected tab to visible space
			this._moveTabs(k.d, k.id);
		} else if (p.offsetWidth > x+1) {
			// check space on right side
			p.childNodes[0].style[this.conf.align] = Math.min(0, parseInt(p.childNodes[0].style[this.conf.align])+(p.offsetWidth-x))+"px";
		}
		
		p = k = null;
		
	}
	
	// tabs scrolling
	this._moveTabs = function(d, tabId) {
		
		// get all visible tabs
		var p = this.tabsArea.childNodes[1].childNodes[0];
		var i = 0;
		var tabs = [];
		var tabInd = null; // index of tabId
		for (var q=0; q<p.childNodes.length; q++) {
			var id = p.childNodes[q]._tabId;
			if (id != null && this.t[id].conf.visible) {
				tabs.push({id: id, w: this.t[id].tab.offsetWidth-this.conf.tabsOfs, ind: i});
				if (id == tabId) tabInd = i;
				i++;
			}
		}
		
		// find 1st/last full visible tabs or null
		var x = parseInt(this.tabsArea.childNodes[1].childNodes[0].style[this.conf.align]);
		var totalSpace = this.tabsArea.offsetWidth-this.tabsArea.childNodes[0].offsetWidth-this.tabsArea.childNodes[2].offsetWidth;
		
		var f = null;
		var l = null;
		
		for (var q=0; q<tabs.length; q++) {
			tabs[q].x = x;
			if (f == null && x >= 0 && x+tabs[q].w > 0) f = tabs[q];
			if (x < totalSpace && x+tabs[q].w <= totalSpace) l = tabs[q];
			x += tabs[q].w;
		}
		
		if (tabInd != null) {
			
			var t = tabs[tabInd];
			
		} else {
			
			var t = null;
			if (d > 0) {
				// left arrow clicked
				// find prev tab (for 1st visible) or last (if 1st is null)
				if (f == null) {
					if (tabs.length > 0) t = tabs[tabs.length-1];
				} else {
					if (f.ind > 0 && tabs.length >= f.ind) t = tabs[f.ind-1];
				}
				
			} else {
				// right arrow clicked
				// find next tab (for last visible) or first (if last-visible is null)
				if (l == null) {
					if (tabs.length > 0) t = tabs[0];
				} else {
					if (tabs.length > l.ind) t = tabs[l.ind+1];
				}
				
			}
		}
		
		// move prev/last tab to 1st position
		if (t != null) {
			if (d > 0) {
				if (x < totalSpace) {
					// some tabs are on left and some space left on right
					p.style[this.conf.align] = Math.min(0, parseInt(p.style[this.conf.align])+(totalSpace-x))+"px";
				} else {
					// show tab on left
					p.style[this.conf.align] = parseInt(p.style[this.conf.align])-t.x+"px";
				}
			} else {
				p.style[this.conf.align] = parseInt(p.style[this.conf.align])-t.x+totalSpace-t.w+"px";
			}
		}
		
		p = t = tabs = null;
		
	}
	
	// return next visible related to tab-id
	this._getNextVisible = function(id, getFirst) {
		return this._getNearVisible(id, getFirst, "next");
	}
	
	// return prev visible related to tab-id
	this._getPrevVisible = function(id, getFirst) {
		return this._getNearVisible(id, getFirst, "previous");
	}
	
	// get first visible
	this._getFirstVisible = function() {
		return this._getNearVisible(null, false, "first");
	}
	
	this._getNearVisible = function(id, getFirst, mode) {
		
		if (mode == "first") {
			var node = this.tabsArea.childNodes[1].childNodes[0].childNodes[1]; // firstChild is line
			mode = "next";
		} else {
			if (id == null || this.t[id] == null) return (getFirst?this._getFirstVisible():null);
			var node = this.t[id].tab[mode+"Sibling"];
		}
		
		var tabId = null;
		
		while (node != null && tabId == null) {
			var k = node._tabId;
			if (k != null && tabId == null && this.t[k].conf.visible) {
				tabId = k;
			} else {
				node = node[mode+"Sibling"];
			}
		}
		
		node = null;
		
		return tabId;
	}
	
	
	
	this._showTab = function(id, activate) { // activate true/false
		
		if (!this.t[id] || this.t[id].conf.visible || this.t[id].conf.transActv) return;
		
		// get next tab
		// move
		// show prev+set marg to -1
		// get next/prev tabs
		
		if (this.conf.transProp !== false) {
			
			// slide effect
			this.t[id].conf.transActv = true;
			this.t[id].conf.transMode = "show";
			this.t[id].conf.transProp = this.conf.transProp;
			this.t[id].conf.transActvId = (activate?id:null);
			
			if (!this.t[id].conf.transEv) {
				this.t[id].tab.addEventListener(this.conf.transEv, this._doOnTrEnd);
				this.t[id].conf.transEv = true;
			}
			
			this.t[id].conf.visible = true;
			this.t[id].tab.className = this._tabCss(id);
			
			this.t[id].tab.style[this.conf.transProp] = this.conf.transValueWidth;
			this.t[id].tab.style.width = this.t[id].conf.width+"px";
			
			
		} else {
			this.t[id].conf.visible = true;
			this.t[id].tab.style.display = "";
			
			if (activate) {
				this._setTabActive(id);
			} else {
				this._adjustTabs();
			}
		}
	}
	
	this._hideTab = function(id, activateId) { // activateId - tab to activate
		
		// activateId
		// if set to true, selection jump from current tab to nearest one (old logic)
		// activateId can also be id of any other tab (new logic)
		
		if (!this.t[id] || !this.t[id].conf.visible || this.t[id].conf.transActv) return;
		
		// if tab was active clear flags/css
		var lastActive = false;
		if (this.conf.lastActive == id) {
			this.conf.lastActive = null;
			this.t[id].conf.active = false;
			this.t[id].tab.className = this._tabCss(id);
			lastActive = true;
		}
		
		// get next/prev tabs
		var prev = this._getPrevVisible(id);
		var next = this._getNextVisible(id);
		
		var actvId = (lastActive && activateId !== false ? (activateId==true?null:activateId)||next||prev : null);
		
		// hide and move next tab to left if any
		if (this.conf.transProp !== false) {
			
			this.t[id].conf.transActv = true;
			this.t[id].conf.transMode = "hide";
			this.t[id].conf.transProp = this.conf.transProp;
			this.t[id].conf.transActvId = actvId;
			this.t[id].conf.visible = false;
			
			if (!this.t[id].conf.transEv) {
				this.t[id].tab.addEventListener(this.conf.transEv, this._doOnTrEnd);
				this.t[id].conf.transEv = true;
			}
			
			this.t[id].tab.style.visibility = "hidden";
			this.t[id].tab.className = that._tabCss(id);
			this.t[id].tab.style[this.conf.transProp] = this.conf.transValueWidth;
			this.t[id].tab.style.width = "0px";
			
		} else {
			
			this.t[id].tab.style.display = "none";
			this.t[id].conf.visible = false;
			if (this.conf.contZone) {
				this.t[id].cell.cell.style.visibility = "hidden";
				this.t[id].cell.cell.style.top = "-5000px"; // "vis:hid" > "vis:vis" http://www.w3.org/TR/CSS2/visufx.html#visibility
			}
			
			if (actvId != null) this._setTabActive(actvId);
			this._adjustTabs();
			
			if (this.t[id].conf.remove) this._removeTab(id);
		}
		
	}
	
	this._isTabVisible = function(id) {
		return (this.t[id].conf.visible==true);
	}
	
	this._doOnTrEnd = function() {
		
		var id = this._tabId; // this points to tab
		
		if (that.t[id] == null) return;
		
		var t = that.t[id];
		var actvId = t.conf.transActvId;
		
		if (t.conf.transMode == "hide") {
			
			// remove if any
			if (t.conf.remove) {
				that._removeTab(id);
			} else {
				
				t.tab.style[t.conf.transProp] = "";
				
				if (that.conf.contZone) {
					t.cell.cell.style.visibility = "hidden";
					t.cell.cell.style.top = "-5000px";
				}
				
				t.conf.transActv = false;
				
			}
			
		} else if (t.conf.transMode == "show") {
			
			t.tab.style[t.conf.transProp] = "";
			t.tab.style.visibility = "visible";
			
			t.conf.transMode = null;
			t.conf.transActv = false;
			
		}
		
		if (actvId != null) {
			that._setTabActive(actvId);
		} else {
			that._adjustTabs();
		}
		
		t = null;
		
	}
	
	
	this.enableTabCloseButton = function(mode) {
		this.conf.closeButton = window.dhx4.s2b(mode);
	}
	
	this.unload = function() {
		
		this.clearAll(); // remove all tabs
		this.t = null;
		
		// fullscreen resize events
		if (this.conf.fullScreen) {
			if (window.addEventListener) {
				window.removeEventListener("resize", this._doOnResizeStart, false);
			} else {
				window.detachEvent("onresize", this._doOnResizeStart);
			}
			this._doOnResizeStart = null;
			this._doOnResizeEnd = null;
		}
		
		if (this.tabsTextTest != null) {
			if (this.tabsTextTest.parentNode) this.tabsTextTest.parentNode.removeChild(this.tabsTextTest);
			this.tabsTextTest = null;
		}
		
		// clear evernt
		window.dhx4._eventable(this, "clear");
		window.dhx4._enableDataLoading(this, null, null, null, "clear");
		
		this.tabsArea.childNodes[0].onclick = null;
		this.tabsArea.childNodes[2].onclick = null;
		this.tabsArea.onclick = null;
		this.tabsArea.onselectstart = null;
		this.tabsArea.parentNode.removeChild(this.tabsArea);
		this.tabsArea = null;
		
		this.tabsMode.parentNode.removeChild(this.tabsMode);
		this.tabsMode = null;
		
		if (this.conf.fullScreen) {
			this.base.parentNode.removeChild(this.base);
			document.documentElement.className = document.documentElement.className.replace("dhxtabbar_fullscreen","");
			document.body.className = document.body.className.replace("dhxtabbar_fullscreen","");
		} else {
			this.base.className = this.base.className.replace("dhxtabbar_base_"+this.conf.skin,"");
		}
		this.base = null;
		for (var a in this) this[a] = null;
		that = null;
	}
	
	this.enableContentZone = function(mode) {
		// enables/disables the content zone (enabled by default)
		// call before tabs adding
		this.conf.contZone = (mode==true);
	}
	
	this.setSkin = function(skin) {
		
		// sets style used for tabbar
		
		this.base.className = this.base.className.replace(new RegExp("dhxtabbar_base_"+this.conf.skin),"dhxtabbar_base_"+skin);
		this.conf.skin = skin;
		
		if (this.tabsTextTest != null) this.tabsTextTest.className = "dhxtabbar_tabs_text_test_"+this.conf.skin;
		
		for (var a in this.t) {
			
			// reset autosaved data for padding/border
			this.t[a].cell._resetSizeState();
			
			// tab width
			if (this.t[a].conf.autowidth == true) {
				this.t[a].conf.width = this._getLabelWidth(this.t[a].conf.text, this.t[a].conf.close);
				if (this.t[a].conf.visible) this.t[a].tab.style.width = this.t[a].conf.width+"px";
			}
			
		}
		
		this.conf.tabsAreaOfs = null;
		this._fixTabsOfs();
		
		this.setSizes();
	}
	
	this.setAlign = function(align) {
		
		align = (align=="left"?"left":"right");
		if (align == this.conf.align) {
			this.tabsArea.childNodes[1].childNodes[0].style[this.conf.align] = "0px";
			return;
		}
			
		if (this.conf.transProp !== false) {
			this.tabsArea.childNodes[1].childNodes[0].style[this.conf.transProp] = "";
		}
		this.tabsArea.childNodes[1].childNodes[0].style[this.conf.align] = "";
		
		this.conf.align = align;
		this.tabsArea.childNodes[1].childNodes[0].className = "dhxtabbar_tabs_cont_"+this.conf.align;
		this.tabsArea.childNodes[1].childNodes[0].style[this.conf.align] = "0px";
		
		if (this.conf.transProp !== false) {
			this.conf.transValuePos = this.conf.align+" "+this.conf.transSpeed;
			this.tabsArea.childNodes[1].childNodes[0].style[this.conf.transProp] = this.conf.transValuePos;
		}
	}
	
	this._initObj = function(data) {
		
		this.conf.initSeq = true;
		
		this.clearAll();
		
		var viaAjax = false;
		
		// settings
		if (data.settings != null) {
			if (data.settings.skin != null) this.setSkin(data.settings.skin);
			if (data.settings.closeButton != null) this.enableTabCloseButton(window.dhx4.s2b(data.settings.closeButton));
			if (data.settings.align != null) this.setAlign(data.settings.align);
			if (data.settings.hrefmode == "ajax" || data.settings.hrefmode == "ajax-html") viaAjax = true; // ajax-html is deprecated
		}

		// tabs
		if (data.tabs != null) {
			for (var q=0; q<data.tabs.length; q++) {
				var t = data.tabs[q];
				if (typeof(t.id) == "undefined") t.id = window.dhx4.newId();
				if (!isNaN(parseInt(t.width))) { t.width = parseInt(t.width); } else { t.width = null; }
				this.addTab(t.id, t.text||t.label||"", t.width, t.index, window.dhx4.s2b(t.selected)||window.dhx4.s2b(t.active), t.close);
				if (t.content != null) this.cells(t.id).attachHTMLString(t.content);
				if (t.href != null) this.cells(t.id).attachURL(t.href, viaAjax);
				if (typeof(t.enabled) != "undefined" && window.dhx4.s2b(t.enabled) == false) {
					this.tabs(t.id).disable();
				} else if (typeof(t.disabled) != "undefined" && window.dhx4.s2b(t.disabled) == true) {
					this.tabs(t.id).disable();
				}
			}
		}
		
		this.conf.initSeq = false;
		if (this.conf.arwMode == "auto") this.setSizes();
		
	}
	
	this._xmlToObj = function(data) {
		
		var obj = { settings: {}, tabs: [] };
		var r = data.getElementsByTagName("tabbar")[0];
		
		if (r != null) {
			
			// settings
			for (var a in {skin:1, align:1, closeButton:1, hrefmode:1}) {
				if (r.getAttribute(a) != null) obj.settings[a] = r.getAttribute(a);
			}
			
			// tabs
			var t = r.getElementsByTagName("tab");
			for (var q=0; q<t.length; q++) {
				
				var tab = { text: (t[q].firstChild.nodeValue||"") };
				
				// attrs
				for (var a in {id:1, width:1, close:1, selected:1, active:1, enabled:1, disabled:1, href:1}) {
					if (t[q].getAttribute(a) != null) tab[a] = t[q].getAttribute(a);
				}
				
				// content
				var cont = t[q].getElementsByTagName("content")[0];
				if (cont != null) {
					tab.content = "";
					for (var w=0; w<cont.childNodes.length; w++) tab.content += (cont.childNodes[w].nodeValue||"");
				}
				
				obj.tabs.push(tab);
			}
		}
		
		return obj;
	}
	
	dhx4._enableDataLoading(this, "_initObj", "_xmlToObj", "tabbar", {struct:true});
	
	// check for transition support
	var k = window.dhx4.transDetect();
	
	this.conf.transProp = k.transProp;
	this.conf.transEv = k.transEv;
	this.conf.transValueWidth = "width "+this.conf.transSpeed;
	
	k = null;
	
	if (this.conf.transProp !== false) {
		this.conf.transValuePos = this.conf.align+" "+this.conf.transSpeed;
		this.tabsArea.childNodes[1].childNodes[0].style[this.conf.transProp] = this.conf.transValuePos;
	}
	
	// fullscreen resize events
	this._initFullScreenResize = function() {
		
		if (this.conf.fullScreenResize) return;
		
		this.conf.tmResize = null;
		this._doOnResizeStart = function() {
			window.clearTimeout(that.conf.tmResize);
			that.conf.tmResize = window.setTimeout(that._doOnResizeEnd, 200);
		}
		
		this._doOnResizeEnd = function() {
			that.setSizes();
		}
		
		if (window.addEventListener) {
			window.addEventListener("resize", this._doOnResizeStart, false);
		} else {
			window.attachEvent("onresize", this._doOnResizeStart);
		}
		
		this.conf.fullScreenResize = true;
		
	}
	
	if (this.conf.fullScreen) this._initFullScreenResize();
	
	this._callMainEvent = function(name, args) {
		return this.callEvent(name, args);
	}
	
	window.dhx4._eventable(this);
	
	if (this.conf.autoload.json != null) {
		this.loadStruct(this.conf.autoload.json, this.conf.autoload.onload);
	} else if (this.conf.autoload.xml != null) {
		this.loadStruct(this.conf.autoload.xml, this.conf.autoload.onload);
	} else if (this.conf.autoload.tabs != null) {
		this.loadStruct({tabs:this.conf.autoload.tabs});
	}
	if (this.conf.autoload.arrows_mode != null) {
		this.setArrowsMode(this.conf.autoload.arrows_mode);
	}
	
	
	this._fixTabsOfs();
	this.setSizes();
	
	return this;
	
};

dhtmlXTabBar.prototype._fixTabsOfs = function() {
	this.conf.tabsOfs = (this.conf.skin == "dhx_web"?0:1);
};

/* cell access */
dhtmlXTabBar.prototype.cells = dhtmlXTabBar.prototype.tabs = function(id) {
	if (this.t[id]) return this.t[id].cell;
	return null;
};

dhtmlXTabBar.prototype.getAllTabs = function() {
	var t = [];
	for (var a in this.t) t.push(a);
	return t;
};

/* set/get active, tab switch */
dhtmlXTabBar.prototype._setTabActive = function(id, mode) {
	
	// mode - if set to true - call onSelect event handler (true by default)
	
	if (!this.t[id] || !this.t[id].conf.visible || this.t[id].conf.active) return;
	
	if (typeof(mode) == "undefined") mode = true;
	if (mode == true && this.callEvent("onSelect", [id, this.conf.lastActive]) !== true) return;
	
	this.setTabInActive();
	
	this.t[id].conf.active = true;
	if (this.conf.contZone) {
		this.t[id].cell.cell.style.visibility = "visible";
		this.t[id].cell.cell.style.top = "0px";
		this.t[id].cell.cell.style.zIndex = 1;
	}
	this.t[id].tab.className = this._tabCss(id);
	this.conf.lastActive = id;
	this.setSizes();
	
};

dhtmlXTabBar.prototype.setTabInActive = function() {
	
	if (this.conf.lastActive && this.t[this.conf.lastActive]) {
		this.t[this.conf.lastActive].conf.active = false;
		if (this.conf.contZone) {
			this.t[this.conf.lastActive].cell.cell.style.visibility = "hidden";
			this.t[this.conf.lastActive].cell.cell.style.top = "-5000px";
			this.t[this.conf.lastActive].cell.cell.style.zIndex = 0;
		}
		this.t[this.conf.lastActive].tab.className = this._tabCss(this.conf.lastActive);
		this.conf.lastActive = null;
	}
	
};

dhtmlXTabBar.prototype._isTabActive = function(id) {
	return (id == this.conf.lastActive && this.conf.lastActive != null);
};

dhtmlXTabBar.prototype.getActiveTab = function() {
	return this.conf.lastActive;
};

dhtmlXTabBar.prototype.goToNextTab = function() {
	var id = this._getNextVisible(this.conf.lastActive, true);
	if (id != null) this._setTabActive(id);
};

dhtmlXTabBar.prototype.goToPrevTab = function() {
	var id = this._getPrevVisible(this.conf.lastActive, true);
	if (id != null) this._setTabActive(id);
};



/* enable/disable */
dhtmlXTabBar.prototype._enableTab = function(id, mode) {
	
	// mode - set to true to select tab
	
	if (!this.t[id] || this.t[id].conf.enabled) return;
	this.t[id].conf.enabled = true;
	this.t[id].tab.className = this._tabCss(id);
	
	if (mode == true) this._setTabActive(id);
	
};

dhtmlXTabBar.prototype._disableTab = function(id, activateId) {
	
	// old code have 2nd param in descr but not in script, will added (logic the same as for hideTab)
	// activateId - if set to true, selection jump from current tab to nearest one, or you can specify tab id
	
	if (!this.t[id] || !this.t[id].conf.enabled) return;
	this.t[id].conf.enabled = false;
	this.t[id].tab.className = this._tabCss(id);
	
	if (activateId !== false && this.conf.lastActive == id) {
		if (activateId == true) activateId = this._getNextVisible(id)||this._getPrevVisible(id);
		this._setTabActive(activateId);
	}
	
};

dhtmlXTabBar.prototype._isTabEnabled = function(id) {
	return (this.t[id] != null && this.t[id].conf.enabled==true);
};

/* set/get label */
dhtmlXTabBar.prototype._setTabText = function(id, text, width) {
	
	if (!this.t[id]) return;
	
	var autowidth = false;
	if (typeof(width) == "undefined" || width == null) {
		width = this._getLabelWidth(text, this.t[id].conf.close);
		autowidth = true;
	}
	
	this.t[id].tab.style.width = width+"px";
	this.t[id].tab.childNodes[0].innerHTML = text;
	
	this.t[id].conf.text = text;
	this.t[id].conf.width = width;
	this.t[id].conf.autowidth = autowidth;
	
};

dhtmlXTabBar.prototype._getTabText = function(id) {
	if (!this.t[id]) return null;
	return this.t[id].conf.text;
};

/* remove tab/all tabs */
dhtmlXTabBar.prototype._removeTab = function(id, activateId, force) { // force = w/o effect, private?
	
	if (!this.t[id]) return;
	
	if (force != true && this.t[id].conf.remove != true) {
		this.t[id].conf.remove = true;
		this._hideTab(id, activateId);
		return;
	}
	
	if (typeof(activateId) == "undefined") activateId = true;
	
	var next = this._getNextVisible(id);
	var prev = this._getPrevVisible(id);
	
	if (this.t[id].conf.transEv == true) {
		this.t[id].tab.removeEventListener(this.conf.transEv, this._doOnTrEnd);
		this.t[id].conf.transEv = false;
	}
	
	for (var a in this.t[id].conf) this.t[id].conf[a] = null;
	this.t[id].conf = null;
	delete this.t[id].conf;
	
	this.t[id].cell._unload();
	this.t[id].cell = null;
	
	this.t[id].tab.parentNode.removeChild(this.t[id].tab);
	this.t[id].tab = null;
	
	this.t[id] = null;
	delete this.t[id];
	
	if (this.conf.lastActive == id && activateId != false) {
		this.conf.lastActive = null;
		var actvId = (activateId == true ? (next||prev||this._getFirstVisible()) : activateId);
		if (actvId != null) this._setTabActive(actvId);
	} else if (force != true) {
		this._adjustTabs();
	}
};

dhtmlXTabBar.prototype.clearAll = function() {
	// remove all tabs
	for (var a in this.t) this._removeTab(a, false, true);
	this.tabsArea.childNodes[1].childNodes[0].style[this.conf.align] = "0px";
};


/* positionig */
dhtmlXTabBar.prototype.moveTab = function(id, index) {
	
	if (!this.t[id] || index < 0) return;
	index += 1; // firstChild is line
	
	var p = this.tabsArea.childNodes[1].firstChild;
	
	if (p.childNodes[index] != this.t[id].tab) {
		p.removeChild(this.t[id].tab);
		if (index >= p.childNodes.length) {
			p.appendChild(this.t[id].tab);
		} else {
			p.insertBefore(this.t[id].tab, p.childNodes[index]);
		}
	}
	p = null;
};

dhtmlXTabBar.prototype._getIndex = function(id) {
	var i = -1;
	var p = this.tabsArea.childNodes[1].firstChild;
	for (var q=1; q<p.childNodes.length; q++) {
		if (p.childNodes[q]._tabId == id) i = q-1; // firstChild is line
	}
	p = null;
	return i;
};

dhtmlXTabBar.prototype.getNumberOfTabs = function(mode) {
	// mode - set to true for visible only (new)
	var p = 0;
	for (var a in this.t) {
		p += (mode!=true?1:(this.t[a].conf.visible==true?1:0));
	}
	return p;
};

dhtmlXTabBar.prototype.forEachCell = dhtmlXTabBar.prototype.forEachTab = function(func) {
	for (var a in this.t) func.apply(window, [this.t[a].cell]);
};

dhtmlXTabBar.prototype.enableAutoReSize = function() {
	this._initFullScreenResize();
};

// added in 4.1
dhtmlXTabBar.prototype.setArrowsMode = function(mode) {
	mode = {auto: "auto", always: "always"}[String(mode)];
	if (mode == null || mode == this.conf.mode) return;
	this.conf.arwMode = mode;
	
	if (mode == "always") {
		this.tabsArea.childNodes[0].className = "dhxtabbar_tabs_ar_left";
		this.tabsArea.childNodes[2].className = "dhxtabbar_tabs_ar_right";
	}
	
	this.setSizes();
};

dhtmlXTabBar.prototype._checkArrows = function() {
	
	var adj = false;
	
	if (this.conf.arwMode == "auto") {
		
		var w = 0;
		for (var a in this.t) w+= this.t[a].tab.offsetWidth;
		
		var arLeft = this.tabsArea.childNodes[0];
		var arRight = this.tabsArea.childNodes[2];
		
		if (w > this.base.offsetWidth) {
			// show arows
			if (arLeft.className.search(/dhxtabbar_tabs_ar_hidden/) >= 0) {
				arLeft.className = arLeft.className.replace(/\s{0,}dhxtabbar_tabs_ar_hidden/, "");
				arRight.className = arRight.className.replace(/\s{0,}dhxtabbar_tabs_ar_hidden/, "");
				adj = true;
			}
		} else {
			// hide arrows
			if (arLeft.className.search(/dhxtabbar_tabs_ar_hidden/) < 1) {
				arLeft.className += " dhxtabbar_tabs_ar_hidden";
				arRight.className += " dhxtabbar_tabs_ar_hidden";
				adj = true;
			}
		}
		arLeft = arRight = null;
		
	}
	
	return adj;
	
};


window.dhtmlXTabBarCell = function(id, tabbar) {
	
	dhtmlXCellObject.apply(this, [id, "_tabbar"]);
	
	this.tabbar = tabbar;
	
	this.conf.skin = this.tabbar.conf.skin;
	
	this.conf.tabbar_funcs = {
		show: "_showTab",
		hide: "_hideTab",
		isVisible: "_isTabVisible",
		enable: "_enableTab",
		disable: "_disableTab",
		isEnabled: "_isTabEnabled",
		getIndex: "_getIndex",
		getText: "_getTabText",
		setText: "_setTabText",
		setActive: "_setTabActive",
		isActive: "_isTabActive",
		close: "_removeTab"
	};
	
	this._tabbarCall = function(name) {
		return function(){
			var t = [this._idd];
			for (var q=0; q<arguments.length; q++) t.push(arguments[q]);
			return this.tabbar[name].apply(this.tabbar, t);
		};
	};
	
	for (var a in this.conf.tabbar_funcs) {
		this[a] = this._tabbarCall(this.conf.tabbar_funcs[a]);
	};
	
	
	this.attachEvent("_onCellUnload", function(){
		this.tabbar = null;
		for (var a in this.conf.tabbar_funcs) {
			this[a] = null;
			this.conf.tabbar_funcs[a] = null;
		}
		this.conf.tabbar_funcs = null;
	});
	
	// "onTabContentLoaded" DEPRECATED
	this.attachEvent("_onContentLoaded", function() {
		this.tabbar._callMainEvent("onContentLoaded", arguments);
		this.tabbar._callMainEvent("onTabContentLoaded", arguments);
	});
	
	this.attachEvent("_onContentAttach", function(){
		this.tabbar._adjustCell(this.tabbar.conf.lastActive);
	});
	
	
};

window.dhtmlXTabBarCell.prototype = new dhtmlXCellObject();

dhtmlXCellObject.prototype.attachTabbar = function(conf) {
	
	// attach to layout
	if (typeof(window.dhtmlXLayoutCell) != "undefined" && this instanceof dhtmlXLayoutCell) {
		this._hideBorders()
	}
	
	// attach to portal
	if (typeof(window.dhtmlXPortalCell) != "undefined" && this instanceof window.dhtmlXPortalCell) {
		this.hideHeader(true);
		this._hideBorders();
	}
	
	// 3.6 init - attachTabbar(mode)
	if (typeof(conf) == "string") {
		conf = {mode:conf};
	} else if (typeof(conf) != "object" || conf == null) {
		conf = {};
	}
	
	var obj = document.createElement("DIV");
	obj.style.width = "100%";
	obj.style.height = "100%";
	obj.style.position = "relative";
	obj.style.overflow = "hidden";
	
	// acc, move tabbar 1px-up to hide top borders
	if (typeof(window.dhtmlXAccordionCell) != "undefined" && (this instanceof window.dhtmlXAccordionCell)) {
		obj._ofs = {t:-1};
	}
	
	this._attachObject(obj);
	
	conf.skin = this.conf.skin;
	conf.parent = obj;
	
	this.dataType = "tabbar";
	this.dataObj = new dhtmlXTabBar(conf);
	
	conf.parent = obj = null;
	conf = null;
	
	this.callEvent("_onContentAttach",[]);
	
	return this.dataObj;
};


/*
Product Name: dhtmlxSuite 
Version: 4.1.3 
Edition: Professional 
License: content of this file is covered by DHTMLX Commercial or Enterprise license. Usage without proper license is prohibited. To obtain it contact sales@dhtmlx.com
Copyright UAB Dinamenta http://www.dhtmlx.com
*/

function dhtmlXTabBarInitFromHTML() {
	
	var z = document.getElementsByTagName("div");
	
	for (var i=0; i<z.length; i++) {
		
		if (z[i].className.indexOf("dhtmlxTabBar") != -1) {
			
			var conf = { settings: {}, tabs: [] };
			
			var n = z[i];
			var id = n.id;
			n.className = "";
			
			var k = new Array();
			for (var j=0; j<n.childNodes.length; j++) {
				if (n.childNodes[j].tagName && n.childNodes[j].tagName != "!") k[k.length] = n.childNodes[j];
			}
			
			var skin = n.getAttribute("skin");
			if (skin != null) conf.settings.skin = skin;
			
			var w = new dhtmlXTabBar({parent: id, mode: n.getAttribute("mode")});
			
			window[id] = w;
			acs = n.getAttribute("onbeforeinit");
			if (acs) eval(acs);
			
			align = n.getAttribute("align");
			if (align) conf.settings.align = align;
			
			var cont = {};
			
			for (var j=0; j<k.length; j++) {
				
				var m = k[j];
				
				var tab = {
					id: m.id,
					text: m.getAttribute("name"),
					width: m.getAttribute("width"),
					selected: m.getAttribute("selected"),
					active: m.getAttribute("active"),
					close: m.getAttribute("close")
				};
				
				var href = m.getAttribute("href");
				if (href) cont[m.id] = {href: href}; else cont[m.id] = {cont: m};
				
				conf.tabs.push(tab);
				
			}
			
			w.loadStruct(conf);
			for (var a in cont) {
				if (cont[a].href) {
					w.cells(a).attachURL(cont[a].href);
					cont[a].href = null;
				} else {
					w.cells(a).attachObject(cont[a].cont);
					if (cont[a].cont.style.display == "none") cont[a].cont.style.display = "";
					cont[a].cont = null;
				}
				cont[a] = null;
			}
			
			var selId = n.getAttribute("select");
			if (selId != null) {
				w.tabs(selId).setActive();
			} else if (w.getActiveTab() == null) {
				var v = w._getFirstVisible();
				if (v != null) w.cells(v).setActive();
			}
			
			acs = n.getAttribute("oninit");
			if (acs) eval(acs);
		}
	}
	
	if (typeof(window.addEventListener) == "function") {
		window.removeEventListener("load", dhtmlXTabBarInitFromHTML, false);
	} else {
		window.detachEvent("onload", dhtmlXTabBarInitFromHTML);
	};
};

if (typeof(window.addEventListener) == "function") {
	window.addEventListener("load", dhtmlXTabBarInitFromHTML, false);
} else {
	window.attachEvent("onload", dhtmlXTabBarInitFromHTML);
};



/*
Product Name: dhtmlxSuite 
Version: 4.1.3 
Edition: Professional 
License: content of this file is covered by DHTMLX Commercial or Enterprise license. Usage without proper license is prohibited. To obtain it contact sales@dhtmlx.com
Copyright UAB Dinamenta http://www.dhtmlx.com
*/

function dhtmlXWindows(params) {
	
	// console.log("context menu for top icon?");
	// console.log("resize with attached iframe - cover or cross events?");
	// console.log("resize allow while progress is on?");
	// console.log("deny resize for maxed window, but allow for partially maxed");
	// console.log("add cancelBubble for mousedown/click for modal cover?");
	
	var that = this;
	
	var conf = {};
	if (typeof(params) != "undefined") {
		for (var a in params) conf[a] = params[a];
	}
	params = null;
	
	
	this.conf = {
		skin: window.dhx4.skin||(typeof(dhtmlx)!="undefined"?dhtmlx.skin:null)||window.dhx4.skinDetect("dhxwins")||"dhx_skyblue",
		// viewport conf
		vp_pos_ofs: 20, // windows-veieport overlay (left, right, bottom) and 0 for top
		vp_custom: false,
		// window dinmension offset
		ofs_w: null,
		ofs_h: null,
		// button down/up state
		button_last: null,
		// hdr dblclick
		dblclick_tm: 300,
		dblclick_last: null,
		dblclick_id: null,
		dblclick_mode: "minmax", // "park", function(){}, "function_name"
		dblclick_active: false,
		dblclick_ev: (navigator.userAgent.indexOf("MSIE 6.0")>=0||navigator.userAgent.indexOf("MSIE 7.0")>=0||navigator.userAgent.indexOf("MSIE 8.0")>=0),
		// fr cover render
		fr_cover: (navigator.userAgent.indexOf("MSIE 6.0")>=0) // iframe+select issue, ie6 only
	};
	
	var transData = window.dhx4.transDetect();
	this.conf.tr = {
		prop: transData.transProp, // false if not available
		ev: transData.transEv,
		height_open: "height 0.2s cubic-bezier(0.25,0.1,0.25,1)", // cell open/close by click
		height_close: "height 0.18s cubic-bezier(0.25,0.1,0.25,1)", // cell open/close by click
		op_open: "opacity 0.16s ease-in", // cell_cont on open
		op_close: "opacity 0.2s ease-out", // cell_cont on close
		op_v_open: "1", // opacity for opened cell
		op_v_close: "0.4" // opacity for closed cell
	};
	
	if (!conf.viewport) {
		this.attachViewportTo(document.body);
	} else {
		if (conf.viewport.object != null) {
			this.attachViewportTo(conf.viewport.object);
		} else if (conf.viewport.left != null && conf.viewport.top != null && conf.viewport.width != null && conf.viewport.height != null) {
			this.setViewport(conf.viewport.left, conf.viewport.top, conf.viewport.width, conf.viewport.height, conf.viewport.parent);
		} else {
			this.attachViewportTo(document.body);
		}
	}
	
	this.w = {};
	
	this.createWindow = function(id, x, y, width, height) {
		
		var r = {};
		if (arguments.length == 1 && typeof(id) == "object") {
			r = id;
		} else {
			r.id = id;
			r.left = x;
			r.top = y;
			r.width = width;
			r.height = height;
			if (typeof(r.id) == "undefined" || r.id == null) r.id = window.dhx4.newId();
			while (this.w[r.id] != null) r.id = window.dhx4.newId();
		}
		
		if (r.left == null) r.left = 0;
		if (r.top == null) r.top = 0;
		
		r.move = (r.move != null && window.dhx4.s2b(r.move) == false ? false : (r.deny_move != null && window.dhx4.s2b(r.deny_move) == true ? false : true));
		r.park = (r.park != null && window.dhx4.s2b(r.park) == false ? false : (r.deny_park != null && window.dhx4.s2b(r.deny_park) == true ? false : true));
		r.resize = (r.resize != null && window.dhx4.s2b(r.resize) == false ? false : (r.deny_resize != null && window.dhx4.s2b(r.deny_resize) == true ? false : true));
		r.keep_in_viewport = (r.keep_in_viewport != null && window.dhx4.s2b(r.keep_in_viewport));
		r.modal = (r.modal != null && window.dhx4.s2b(r.modal));
		r.center = (r.center != null && window.dhx4.s2b(r.center));
		r.text = (r.text != null ? r.text:(r.caption!=null?r.caption:"dhtmlxWindow"));
		r.header = (!(r.header != null && window.dhx4.s2b(r.header) == false));
		
		var t = document.createElement("DIV");
		t.className = "dhxwin_active";
		this.vp.appendChild(t);
		
		t._isWindow = true;
		t._idd = r.id;
		
		var h = document.createElement("DIV");
		h.className = "dhxwin_hdr";
		h.style.zIndex = 0;
		h.innerHTML = "<div class='dhxwin_icon'></div>"+
				"<div class='dhxwin_text'><div class='dhxwin_text_inside'>"+r.text+"</div></div>"+
				"<div class='dhxwin_btns'></div>";
		t.appendChild(h);
		
		h.onselectstart = function(e) {
			e = e||event;
			if (e.preventDefault) e.preventDefault(); else e.returnValue = false;
			return false;
		}
		
		h.oncontextmenu = function(e) {
			e = e||event;
			e.cancelBubble = true;
			return false;
		}
		
		h._isWinHdr = true;
		h.firstChild._isWinIcon = true;
		
		var k = document.createElement("DIV");
		k.className = "dhxwin_brd";
		t.appendChild(k);
		
		var fr_cover = document.createElement("DIV");
		fr_cover.className = "dhxwin_fr_cover";
		fr_cover.innerHTML = "<iframe class='dhxwin_fr_cover_inner' frameborder='0' border='0'></iframe><div class='dhxwin_fr_cover_inner'></div>";
		t.appendChild(fr_cover);
		
		this.w[r.id] = {
			win: t,
			hdr: h,
			brd: k,
			fr_cover: fr_cover,
			b: {},
			conf: {
				z_id: window.dhx4.newId(),
				actv: false,
				modal: false,
				maxed: false,
				parked: false,
				sticked: false,
				visible: true,
				header: true,
				text: r.text,
				keep_in_vp: r.keep_in_viewport,
				allow_move: r.move,
				allow_park: r.park,
				allow_resize: r.resize,
				max_w: null,
				max_h: null,
				min_w: 80,
				min_h: 80
			}
		};
		
		// buttons, id=>visible
		var btns = {
			help: {title: "Help", visible: false},
			stick: {title: "Stick", visible: false},
			park: {title: "Park", visible: true},
			minmax: {title: "Min/Max", visible: true},
			close: {title: "Close", visible: true}
		};
		for (var a in btns) {
			var b = new dhtmlXWindowsButton(this, r.id, a, btns[a].title, false);
			if (btns[a].visible == false) b.hide();
			h.lastChild.appendChild(b.button);
			this.w[r.id].b[a] = b;
			b = null;
		}
		this._winAdjustTitle(r.id);
		
		this.w[r.id].win.style.zIndex = window.dhx4.zim.reserve(this.w[r.id].conf.z_id);
		
		var cell = new dhtmlXWindowsCell(r.id, this);
		this.w[r.id].win.insertBefore(cell.cell, fr_cover);
		this.w[r.id].cell = cell;
		
		if (typeof(window.addEventListener) == "function") {
			this.w[r.id].win.addEventListener("mousedown", this._winOnMouseDown, false);
			this.w[r.id].win.addEventListener("mouseup", this._winOnMouseDown, false);
			if (this.conf.dblclick_ev) this.w[r.id].win.addEventListener("dblclick", this._winOnMouseDown, false);
			// touch
			if (this.conf.dnd_evs != null) {
				this.w[r.id].win.addEventListener(this.conf.dnd_evs.start, this._winOnMouseDown, false);
				if (window.navigator.msPointerEnabled != true) {
					this.w[r.id].win.addEventListener(this.conf.dnd_evs.start, this._winOnMouseDown, false);
					this.w[r.id].win.addEventListener(this.conf.dnd_evs.end, this._winOnMouseDown, false);
				}
			}
		} else {
			this.w[r.id].win.attachEvent("onmousedown", this._winOnMouseDown);
			this.w[r.id].win.attachEvent("onmouseup", this._winOnMouseDown);
			if (this.conf.dblclick_ev) this.w[r.id].win.attachEvent("ondblclick", this._winOnMouseDown);
		}
		
		// fr for IE6
		this._winInitFRM(r.id);
		
		this._winSetPosition(r.id, r.left, r.top);
		this._winSetSize(r.id, r.width, r.height);
		this._winMakeActive(r.id);
		
		if (r.center == true) this.w[r.id].cell.center();
		if (r.modal == true) this.w[r.id].cell.setModal(true);
		if (r.header == false) this.w[r.id].cell.hideHeader();
		
		f = t = h = k = fr_cover = cell = null;
		
		return this.w[r.id].cell;
	}
	
	this._winOnMouseDown = function(e) {
		
		e = e||event;
		
		var t = e.target||e.srcElement;
		var data = {press_type: e.type};
		
		if (e.type == "MSPointerDown") {
			that.conf.ev_skip = true;
		} else if (that.conf.ev_skip == true) {
			that.conf.ev_skip = false;
			t = null;
			return;
		}
		
		
		while (t != null && t._isWindow != true) {
			if (typeof(t.className) != "undefined" && data.mode == null) {
				if (typeof(t._buttonName) != "undefined") {
					data.mode = "button";
					data.button_name = t._buttonName;
				} else if (t._isWinHdr == true) {
					data.mode = "hdr";
				} else if (t._isWinIcon == true) {
					data.mode = "icon";
				}
			}
			t = t.parentNode;
		}
		if (data.mode == null) data.mode = "win";
		
		data.id = (t != null && t._isWindow == true ? t._idd:null);
		
		t = null;
		
		if (data.id != null) that.callEvent("_winMouseDown",[e,data]);
	}
	
	this._winOnParkTrans = function(e) {
		if (e.stopPropagation) e.stopPropagation();
		var w = that.w[this._idd];
		if (e.propertyName == "opacity") {
			that._winCellClearOpacity(this._idd);
		}
		if (e.propertyName == "height" && w.conf.tr_mode == "park") {
			if (w.conf.tr_mode == "park") {
				w.win.style[that.conf.tr.prop] = "";
				if (!w.conf.parked) {
					that._winAdjustCell(this._idd);
					that._callMainEvent("onParkDown", this._idd);
					if (w.conf.keep_in_vp) that._winAdjustPosition(this._idd, w.conf.x, w.conf.y);
				} else {
					w.hdr.style.zIndex = 3;
					that._callMainEvent("onParkUp", this._idd);
				}
			}
			
		}
		w = null;
	}
	
	this.unload = function() {
		
		this.conf.unloading = true;
		
		// dnd
		if (this._dndInitModule) this._dndUnloadModule();
		
		// windows
		for (var a in this.w) this._winClose(a);
		this.w = null;
		
		// context menu
		if (this.cm != null && typeof(this._unloadContextMenu) == "function") this._unloadContextMenu();
		
		// events
		window.dhx4._eventable(this, "clear");
		
		// viewport
		this.attachViewportTo(null);
		
		// conf
		for (var a in this.conf) {
			this.conf[a] = null;
			delete this.conf[a];
		}
		
		for (var a in this) this[a] = null;
		
		that = a = null;
		
	}
	
	window.dhx4._eventable(this);
	
	this.attachEvent("_winMouseDown", this._winMouseDownHandler);
	
	if (this._dndInitModule) this._dndInitModule();
	
	if (conf.wins != null) {
		for (var q=0; q<conf.wins.length; q++) {
			var r = conf.wins[q];
			this.createWindow(r);
		}
	}
	conf = null;
	
	
	return this;
};

// common
dhtmlXWindows.prototype.forEachWindow = function(func) {
	for (var a in this.w) {
		func.apply(window, [this.w[a].cell]);
	}
};
dhtmlXWindows.prototype.window = function(id) {
	if (this.w[id] != null) return this.w[id].cell;
	return null;
};
dhtmlXWindows.prototype.isWindow = function(id) {
	return (this.w[id] != null);
};
dhtmlXWindows.prototype.findByText = function(text) {
	var p = [];
	for (var a in this.w) {
		if ((this.w[a].cell.getText()).indexOf(String(text)) >= 0) p.push(this.w[a]);
	}
	return p;
};
dhtmlXWindows.prototype.setSkin = function(skin) {
	if (skin == this.conf.skin) return;
	if (this.vp != null) {
		this.vp.className = String(this.vp.className).replace("dhxwins_vp_"+this.conf.skin," dhxwins_vp_"+skin);
	}
	for (var a in this.w) {
		this.w[a].cell._resetSizeState();
		this._winAdjustCell(a);
		this._winAdjustTitle(a);
	}
	this.conf.skin = skin;
};


// z-index
dhtmlXWindows.prototype.getBottommostWindow = function() {
	return this._getTopBottomWin(false);
};
dhtmlXWindows.prototype.getTopmostWindow = function() {
	return this._getTopBottomWin(true);
};
dhtmlXWindows.prototype._getTopBottomWin = function(mode) {
	var data = null;
	for (var a in this.w) {
		if (this.w[a].conf.visible) {
			var k = false;
			if (data != null) {
				k = data.z > this.w[a].win.style.zIndex;
				if (mode) k = !k;
			}
			if (data == null || k) data = {win: this.w[a].cell, z: this.w[a].win.style.zIndex};
		}
	}
	return (data?data.win:null);
};
dhtmlXWindows.prototype._winMakeActive = function(id, force) {
	
	// if id is null activate last z-index window
	
	if (id != null && force !== true && this.w[id].conf.actv == true) return;
	
	var all = [];
	
	// z-index order, from top to bottom,
	// first modal, then sticked if any, then regular
	var props = [
		{name: "modal",   value: true},
		{name: "sticked", value: true},
		{name: "sticked", value: false}
	];
	var inList = {};
	
	for (var q=0; q<props.length; q++) {
		
		var propName = props[q].name;
		var propValue = props[q].value;
		
		var st = [];
		
		// windows matched to prop but not with specified id
		for (var a in this.w) {
			var w = this.w[a];
			if (inList[a] == null && w.conf[propName] === propValue && w.conf.visible == true) {
				if (id != a) {
					window.dhx4.zim.clear(w.conf.z_id);
					st.push([a, Number(w.win.style.zIndex)]);
					inList[a] = true;
				}
			}
			w = null;
		}
		st.sort(function(a,b){
			return (a[1]<b[1]?1:-1);
		});
		
		// check windows which is specified to be active
		if (id != null && this.w[id].conf[propName] === propValue && inList[id] == null) {
			// clear zim
			window.dhx4.zim.clear(this.w[id].conf.z_id);
			var k = [[id, Number(this.w[id].win.style.zIndex)]];
			st = k.concat(st);
			inList[id] = true;
		}
		
		all = all.concat(st);
	}
	
	// change windows' z-index
	for (var q=all.length-1; q>=0; q--) {
		
		var a = all[q][0];
		var w = this.w[a];
		
		w.win.style.zIndex = window.dhx4.zim.reserve(w.conf.z_id);
		
		// adjust modal cover z-index
		if (w.conf.modal && this.mcover != null) {
			for (var b in this.mcover) this.mcover[b].style.zIndex = w.win.style.zIndex;
		}
		
		// ajust fr_cover if any
		this._winAdjustFRMZIndex(a);
		
		// if id not specified, make last z-index active, can be triggered from _winHide
		if (id == null && q == 0) id = a;
		
		w.conf.actv = (id==a);
		w.win.className = (w.conf.actv?"dhxwin_active":"dhxwin_inactive");
		
		w = null;
	}
	
	if (id != null && this.conf.last_active != id) this._callMainEvent("onFocus", id);
	
	this.conf.last_active = id;
	
};

// viewports
dhtmlXWindows.prototype._vpPull = {};

dhtmlXWindows.prototype._vpPullAdd = function() {
	if (this.vp == null) return;
	var id = null;
	for (var a in this._vpPull) {
		if (this._vpPull[a].vp == this.vp) {
			this._vpPull[a].count++;
			id = a;
		}
	}
	if (id == null) {
		this._vpPull[window.dhx4.newId()] = {vp: this.vp, count: 1};
	}
};

dhtmlXWindows.prototype._vpPullRemove = function() {
	if (this.vp == null) return 0;
	var count = 0;
	for (var a in this._vpPull) {
		if (this._vpPull[a].vp == this.vp) {
			count = --this._vpPull[a].count;
			if (count == 0) {
				this._vpPull[a].vp = null;
				this._vpPull[a].count = null;
				delete this._vpPull[a];
			}
		}
	}
	return count;
};

dhtmlXWindows.prototype.attachViewportTo = function(id) {
	
	// old one
	var vpCount = this._vpPullRemove();
	
	if (this.conf.vp_custom) {
		while (this.vp.childNodes.length > 0) this.vp.removeChild(this.vp.lastChild);
		this.vp.parentNode.removeChild(this.vp);
		this.vp = null;
	} else if (this.vp != null && vpCount == 0) {
		this.vp.className = String(this.vp.className).replace(new RegExp("\\s{1,}dhxwins_vp_"+this.conf.skin),""); // no more window instances attached to same object, clear css
	}
	
	// new if set
	if (id == null) {
		
		this.vp = null; // clear link
		
	} else {
		
		this.vp = (typeof(id)=="string"?document.getElementById(id):id);
		var skin = "dhxwins_vp_"+this.conf.skin;
		if (this.vp.className.indexOf(skin) < 0) this.vp.className += " "+skin;
		id = null;
		
		// windows
		for (var a in this.w) this.vp.appendChild(this.w[a].win);
		
		this.conf.vp_custom = false;
		
	}
	
	if (this.vp == document.body) {
		document.body.style.position = "static"; // abs-left/top broken for relative/absolute
	}
	
	this._vpPullAdd();
	
};

dhtmlXWindows.prototype.setViewport = function(x, y, width, height, parentObj) {
	
	var t = document.createElement("DIV");
	
	t.style.position = "absolute";
	t.style.left = x+"px";
	t.style.top = y+"px";
	t.style.width = width+"px";
	t.style.height = height+"px";
	
	if (typeof(parentObj) == "undefined" || parentObj == null) {
		parentObj = document.body;
	} else if (typeof(parentObj) == "string") {
		parentObj = document.getElementById(parentObj);
	}
	parentObj.appendChild(t);
	
	this.attachViewportTo(t);
	this.conf.vp_custom = true;
	
	parentObj = t = null;
	
};

// position
dhtmlXWindows.prototype._winSetPosition = function(id, x, y) {
	
	var w = this.w[id];
	
	if (w.conf.maxed) {
		// probably window have max_w/max_h set and dragable
		// adjust saved w/h
		w.conf.lastMX += (x-w.conf.x);
		w.conf.lastMY += (y-w.conf.y);
	}
	
	w.conf.x = x;
	w.conf.y = y;
	
	w.win.style.left = w.conf.x+"px";
	w.win.style.top = w.conf.y+"px";
	
	this._winAdjustFRMPosition(id);
	
	w = null;
};
dhtmlXWindows.prototype._winAdjustPosition = function(id, x, y) { // check if window out of viewport
	
	var w = this.w[id];
	
	// if called from cell's adjustPosition, just make sure window position is okey
	if (typeof(x) == "undefined") x = w.conf.x;
	if (typeof(y) == "undefined") y = w.conf.y;
	
	var minX = (w.conf.keep_in_vp?0:-w.conf.w+this.conf.vp_pos_ofs);
	var maxX = (w.conf.keep_in_vp?this.vp.clientWidth-w.conf.w:this.vp.clientWidth-this.conf.vp_pos_ofs);
	
	if (x < minX) {
		x = minX;
	} else if (x > maxX) {
		x = maxX;
	}
	
	var maxY = (w.conf.keep_in_vp?this.vp.clientHeight-w.conf.h:this.vp.clientHeight-this.conf.vp_pos_ofs);
	
	if (y < 0) {
		y = 0;
	} else if (y > maxY) {
		y = maxY;
	}
	
	if (x != w.conf.x || y != w.conf.y) {
		this._winSetPosition(id, x, y);
	}
	
	w = null;
};

// dimension
dhtmlXWindows.prototype._winSetSize = function(id, width, height, skipAdjust, fixPos) {
	
	var w = this.w[id];
	
	var w2 = (width != null ? width : w.conf.w);
	var h2 = (height != null ? height : w.conf.h);
	
	if (this.conf.ofs_w == null) {
		w.win.style.width = w2+"px";
		w.win.style.height = h2+"px";
		this.conf.ofs_w = w.win.offsetWidth-w2;
		this.conf.ofs_h = w.win.offsetHeight-h2;
	}
	
	if (w.conf.min_w != null && w2 < w.conf.min_w) w2 = w.conf.min_w;
	if (w.conf.max_w != null && w2 > w.conf.max_w) w2 = w.conf.max_w;
	
	if (!w.conf.parked && w.conf.min_h != null && h2 < w.conf.min_h) h2 = w.conf.min_h;
	if (w.conf.max_h != null && h2 > w.conf.max_h) h2 = w.conf.max_h;
	
	if (w.conf.keep_in_vp) {
		if (w2 > this.vp.clientWidth) w2 = this.vp.clientWidth;
		if (h2 > this.vp.clientHeight) h2 = this.vp.clientHeight;
	}
	
	w.win.style.width = w2-this.conf.ofs_w+"px";
	w.win.style.height = h2-this.conf.ofs_h+"px";
	
	w.conf.w = w2;
	w.conf.h = h2;
	
	this._winAdjustFRMSize(id);
	
	if (fixPos) this._winAdjustPosition(id, w.conf.x, w.conf.y);
	
	// adjust content
	if (!w.conf.parked && skipAdjust != true) this._winAdjustCell(id);
	
	w = null;
};

// minmax
dhtmlXWindows.prototype._winMinmax = function(id, mode) {
		
	if (typeof(mode) != "undefined" && this.w[id].conf.maxed == mode) return; // already requested state
	if (this.w[id].conf.allow_resize == false) return;
	
	var w = this.w[id];
	
	if (w.conf.parked) this._winPark(id, false);
	
	if (w.conf.maxed) {
		
		this._winSetSize(id, w.conf.lastMW, w.conf.lastMH);
		this._winAdjustPosition(id, w.conf.lastMX, w.conf.lastMY);
		w.conf.maxed = false;
		
	} else {
		
		var x = 0;
		var y = 0;
		
		// adjust position, if any max w/h values - do not allow win to be moved outside vp
		if (w.conf.max_w != null) x = w.conf.x + Math.round(w.conf.w-w.conf.max_w)/2;
		if (w.conf.max_h != null) y = Math.max(w.conf.y + Math.round(w.conf.h-w.conf.max_h)/2, 0);
		
		// save old coords and dim
		w.conf.lastMX = w.conf.x;
		w.conf.lastMY = w.conf.y;
		w.conf.lastMW = w.conf.w;
		w.conf.lastMH = w.conf.h;
		
		this._winSetSize(id, this.vp.clientWidth, this.vp.clientHeight);
		this._winAdjustPosition(id, x, y);
		
		
		w.conf.maxed = true;
		
	}
	
	w.b.minmax.setCss(w.conf.maxed?"minmaxed":"minmax");
	
	if (w.conf.maxed) {
		this._callMainEvent("onMaximize", id);
	} else {
		this._callMainEvent("onMinimize", id);
	}
	
	
	w = null;
};

// show/hide
dhtmlXWindows.prototype._winShow = function(id, makeActive) {
	
	if (this.w[id].conf.visible == true) return;
	
	this.w[id].win.style.display = "";
	this.w[id].conf.visible = true;
	
	// makeActive set to true or only this window is visible
	if (makeActive == true || this.conf.last_active == null) this._winMakeActive(id, true);
	
	this._callMainEvent("onShow", id);
};
dhtmlXWindows.prototype._winHide = function(id, actvId) {
	
	if (this.w[id].conf.visible == false) return;
	
	this.w[id].win.style.display = "none";
	this.w[id].conf.visible = false;
	
	if (this.w[id].conf.actv) {
		this.w[id].conf.actv = false;
		this.w[id].win.className = "dhxwin_inactive";
		this._winMakeActive(null, true);
	}
	
	this._callMainEvent("onHide", id);
};

// park
dhtmlXWindows.prototype._winPark = function(id, ef) {
		
	if (this.w[id].conf.allow_park == false) return;
	if (this.w[id].conf.header == false) return;
	
	var w = this.w[id];
	
	if (ef == true && this.conf.tr.prop !== false) {
		w.win.style[this.conf.tr.prop] = this.conf.tr[w.conf.parked?"height_open":"height_close"];
		if (!w.conf.tr_ev) {
			w.win.addEventListener(this.conf.tr.ev, this._winOnParkTrans, false);
			w.conf.tr_ev = true;
		}
	}
	
	if (w.conf.parked) {
		// restore
		w.hdr.className = String(w.hdr.className).replace(/\s{1,}dhxwin_hdr_parked/gi,"");
		w.hdr.style.zIndex = 0;
		w.conf.parked = false;
		w.conf.tr_mode = "park";
		this._winCellSetOpacity(id, "open", ef);
		this._winSetSize(id, w.conf.w, w.conf.lastPH, (ef==true && this.conf.tr.prop!==false)); // adjust cont if trans not available
		if (!(ef == true && this.conf.tr.prop !== false)) {
			this._callMainEvent("onParkDown", id);
			if (w.conf.keep_in_vp) this._winAdjustPosition(id, w.conf.x, w.conf.y);
		}
		// IE8 bottom-border fix
		if (window.dhx4.isIE8 == true && this.conf.tr.prop == false && w.cell.cell.className.match(/dhxwin_parked/) != null) {
			w.cell.cell.className = w.cell.cell.className.replace(/\s{0,}dhxwin_parked/gi,"");
		}
	} else {
		// park
		w.conf.lastPH = w.conf.h;
		w.hdr.className += " dhxwin_hdr_parked";
		if (ef == false || this.conf.tr.prop == false) w.hdr.style.zIndex = 3; // no-trans
		w.conf.parked = true;
		w.conf.tr_mode = "park";
		this._winCellSetOpacity(id, "close", ef);
		this._winSetSize(id, w.conf.w, w.hdr.offsetHeight+this.conf.ofs_h, (ef==true && this.conf.tr.prop!==false)); // adjust cont if trans not available
		if (!(ef == true && this.conf.tr.prop !== false)) this._callMainEvent("onParkUp", id);
		// IE8 bottom-border fix
		if (window.dhx4.isIE8 == true && this.conf.tr.prop == false && w.cell.cell.className.match(/dhxwin_parked/) == null) {
			w.cell.cell.className += " dhxwin_parked";
		}
	}
	
	w = null;
	
};
dhtmlXWindows.prototype._winCellSetOpacity = function(id, op, ef, mode) {
	var cell = this.w[id].cell;
	for (var a in cell.conf.idx) {
		if ({pr1:true,pr2:true}[a] != true) { // skip progress
			if (ef == true && this.conf.tr.prop != false) cell.cell.childNodes[cell.conf.idx[a]].style[this.conf.tr.prop] = this.conf.tr["op_"+op];
			cell.cell.childNodes[cell.conf.idx[a]].style.opacity = this.conf.tr["op_v_"+op];
		}
	}
	cell = null;
};
dhtmlXWindows.prototype._winCellClearOpacity = function(id) {
	var cell = this.w[id].cell;
	for (var a in cell.conf.idx) {
		if ({pr1:true,pr2:true}[a] != true) { // skip progress
			if (this.conf.tr.prop != false) cell.cell.childNodes[cell.conf.idx[a]].style[this.conf.tr.prop] = "";
		}
	}
	cell = null;
};

// stick
dhtmlXWindows.prototype._winStick = function(id, mode) {
	
	if (typeof(mode) != "undefined" && this.w[id].conf.sticked == mode) return; // already requested state
	
	this.w[id].conf.sticked = !this.w[id].conf.sticked;
	this.w[id].b.stick.setCss(this.w[id].conf.sticked?"sticked":"stick");
	
	this._winMakeActive(this.conf.last_active, true);
	if (this.w[id].conf.sticked) {
		this._callMainEvent("onStick", id);
	} else {
		this._callMainEvent("onUnStick", id);
	}
};

// close
dhtmlXWindows.prototype._winClose = function(id) {
	
	if (this._callMainEvent("onClose", id) !== true && this.conf.unloading != true) return;
	var w = this.w[id];
	
	if (w.conf.fs_mode) w.cell.setToFullScreen(false);
	if (w.conf.modal) this._winSetModal(id, false);
	
	// z-index clear
	window.dhx4.zim.clear(w.conf.z_id);
	
	// context menu
	if (this.cm != null && this.cm.icon[id] != null) {
		this._detachContextMenu("icon", id, null);
	}
	
	// header click/dblclick events
	if (typeof(window.addEventListener) == "function") {
		w.win.removeEventListener("mousedown", this._winOnMouseDown, false);
		w.win.removeEventListener("mouseup", this._winOnMouseDown, false);
		if (this.conf.dblclick_ev) w.win.removeEventListener("dblclick", this._winOnMouseDown, false);
		// touch
		if (this.conf.dnd_evs != null) {
			w.win.removeEventListener(this.conf.dnd_evs.start, this._winOnMouseDown, false)
			if (window.navigator.msPointerEnabled != true) {
				w.win.removeEventListener(this.conf.dnd_evs.start, this._winOnMouseDown, false);
				w.win.removeEventListener(this.conf.dnd_evs.end, this._winOnMouseDown, false);
			}
		}
	} else {
		w.win.detachEvent("onmousedown", this._winOnMouseDown);
		w.win.detachEvent("onmouseup", this._winOnMouseDown);
		if (this.conf.dblclick_ev) w.win.attachEvent("ondblclick", this._winOnMouseDown);
	}
	
	// buttons
	for (var a in w.b) this._winRemoveButton(id, a, true);
	w.b = null;
	
	// cell
	w.cell._unload();
	w.cell = null;
	
	// border
	w.brd.parentNode.removeChild(w.brd);
	w.brd = null;
	
	// covers
	if (w.fr_cover != null) {
		w.fr_cover.parentNode.removeChild(w.fr_cover);
		w.fr_cover = null;
	}
	if (w.fr_m_cover != null) {
		w.fr_m_cover.parentNode.removeChild(w.fr_m_cover);
		w.fr_m_cover = null;
	}
	
	// hdr
	w.hdr._isWinHdr = true;
	w.hdr.firstChild._isWinIcon = true;
	w.hdr.onselectstart = null;
	w.hdr.parentNode.removeChild(w.hdr);
	w.hdr = null;
	
	// conf
	for (var a in w.conf) {
		w.conf[a] = null;
		delete w.conf[a];
	}
	w.conf = null;
	
	// win
	w.win._idd = null;
	w.win._isWindow = null;
	w.win.parentNode.removeChild(w.win);
	w.win = null;
	
	w = null;
	this.w[id] = null;
	delete this.w[id];
	
	// activate topmost window
	if (!this.conf.unloading) this._winMakeActive(null, true);
	
};

// modal
dhtmlXWindows.prototype._winSetModal = function(id, modal, removeCover) {
	
	if (this.w[id].conf.modal == modal) return; // already have specified modal state
	
	if (typeof(removeCover) == "undefined") removeCover = true;
	
	var w = this.w[id];
	
	if (modal == true && w.conf.modal == false) {
		
		// remove modality from prev window
		if (this.conf.last_modal != null) {
			this._winSetModal(this.conf.last_modal, false, false);
		}
		
		if (this.mcover == null) {
			
			// create a new one
			var d = document.createElement("DIV");
			d.className = "dhxwins_mcover";
			this.vp.insertBefore(d, w.fr_m_cover||w.win);
			this.mcover = {d:d};
			
			if (this.conf.fr_cover) {
				this.mcover.f = document.createElement("IFRAME");
				this.mcover.f.className = "dhxwins_mcover";
				this.mcover.f.border = 0;
				this.mcover.f.frameBorder = 0;
				this.vp.insertBefore(this.mcover.f,d);
			}
			
			d = null;
			
		} else if (this.mcover.d.nextSibling != (w.fr_m_cover||w.win)) {
			// move cover to place it before modal window
			this.vp.insertBefore(this.mcover.d, w.fr_m_cover||w.win);
			if (this.mcover.f != null) this.vp.insertBefore(this.mcover.f, this.mcover.d);
		}
		
		w.conf.modal = true;
		this.conf.last_modal = id;
		
		this._winMakeActive(id, true);
		
	} else if (modal == false && w.conf.modal == true) {
		
		// remove modality, clear cover
		
		w.conf.modal = false;
		this.conf.last_modal = null;
		
		if (removeCover && this.mcover != null) {
			for (var a in this.mcover) {
				
				this.vp.removeChild(this.mcover[a]);
				this.mcover[a] = null;
			}
			this.mcover = null;
		}
		
	}
	
	w = null;
};

// misc
dhtmlXWindows.prototype._winMouseDownHandler = function(e, data) {
	
	var t = e.target||e.srcElement;
	
	if (e.button >= 2) return;
	
	if (data.mode == "button") {
		if (data.press_type == "mousedown") {
			this.conf.button_last = data.button_name;
		} else if ((data.press_type == "mouseup" && data.button_name == this.conf.button_last) || data.press_type == "MSPointerDown") {
			this.conf.button_last = null;
			if (this._winButtonClick(data.id, data.button_name, e) !== true) return;
		}
	}
	
	if ((data.press_type == "mousedown" || data.press_type == "dblclick") && data.mode == "hdr") {
		
		// dblclick
		this.conf.dblclick_active = false;
		if (this.conf.dblclick_ev == true) {
			// IE6, IE7, IE8 native dblclick event
			if (data.press_type == "dblclick") this.conf.dblclick_active = true;
		} else {
			
			if (this.conf.dblclick_last == null) {
				this.conf.dblclick_last = new Date().getTime();
				this.dblclick_id = data.id;
			} else {
				var t = new Date().getTime();
				if (this.conf.dblclick_last + this.conf.dblclick_tm > t && this.dblclick_id == data.id) {
					this.conf.dblclick_active = true;
					this.conf.dblclick_last = null;
					this.dblclick_id = null;
				} else {
					this.conf.dblclick_last = t;
					this.dblclick_id = data.id;
				}
			}
		}
		if (this.conf.dblclick_active) {
			this._winDoHeaderDblClick(data.id);
			return;
		}
	}
	
	// for all modes
	if (data.press_type == "mousedown" || (this.conf.dnd_evs != null && data.press_type == this.conf.dnd_evs.start)) {
		this._winMakeActive(data.id);
	}
	if (data.press_type == "touchend") {
		// if (e.preventDefault) e.preventDefault();
	}
	
};

dhtmlXWindows.prototype._winDoHeaderDblClick = function(id) {
	if (this.conf.dblclick_mode == "minmax") {
		this._winMinmax(id);
		return;
	}
	if (this.conf.dblclick_mode == "park") {
		this._winPark(id, true);
		return;
	}
	// use action if any
	if (typeof(this.conf.dblclick_mode) == "function") {
		this.conf.dblclick_mode.apply(window, [id]);
		return;
	}
	if (typeof(window[this.conf.dblclick_mode]) == "function") {
		window[this.conf.dblclick_mode].apply(window, [id]);
		return;
	}
};
dhtmlXWindows.prototype._winAdjustCell = function(id) {
	
	var w = this.w[id];
	
	var x = 1;
	var y = (w.conf.header?w.hdr.offsetHeight:1);
	var width = w.win.clientWidth-2;
	var height = w.win.clientHeight-y-1;
	
	w.brd.style.left = x+"px";
	w.brd.style.top = y+"px";
	if (w.conf.brd == null) {
		w.brd.style.width = width+"px";
		w.brd.style.height = height+"px";
		w.conf.brd = {
			w: width-w.brd.offsetWidth,
			h: height-w.brd.offsetHeight
		};
	}
	w.brd.style.width = width+w.conf.brd.w+"px";
	w.brd.style.height = height+w.conf.brd.h+"px";
	
	var p = 5;
	
	var x2 = 1+p;
	var y2 = (w.conf.header?y:y+p);
	var w2 = w.brd.clientWidth;
	var h2 = w.brd.clientHeight;
	
	w.cell._setSize(x2, y2, w2, h2);
	
	w.fr_cover.style.left = x2+"px";
	w.fr_cover.style.top = y2+"px";
	w.fr_cover.style.width = w2+"px";
	w.fr_cover.style.height = h2+"px";
	
	w = null;
};
dhtmlXWindows.prototype._winAdjustTitle = function(id) {
	var icon = this.w[id].hdr.childNodes[0];
	var text = this.w[id].hdr.childNodes[1];
	var btns = this.w[id].hdr.childNodes[2];
	text.style.paddingLeft = icon.offsetWidth+12+"px";
	text.style.paddingRight = btns.offsetWidth+10+"px";
	text = btns = icon = null;
};
dhtmlXWindows.prototype._callMainEvent = function(name, id) {
	var w = this.w[id];
	if (w.cell.checkEvent(name)) {
		var r = w.cell._callMainEvent(name, [w.cell]);
	} else {
		var r = this.callEvent(name, [w.cell]);
	}
	w = null;
	return r;
};

// fr_m_cover
dhtmlXWindows.prototype._winInitFRM = function(id) {
	if (this.conf.fr_cover != true) return;
	var w = this.w[id];
	var f = document.createElement("IFRAME");
	f.className = "dhxwin_main_fr_cover";
	f.border = 0;
	f.frameBorder = 0;
	f.style.zIndex = w.win.style.zIndex;
	w.win.parentNode.insertBefore(f, w.win);
	w.fr_m_cover = f;
	f = null;
};
dhtmlXWindows.prototype._winAdjustFRMSize = function(id) {
	var w = this.w[id];
	if (w.fr_m_cover != null) {
		w.fr_m_cover.style.width = w.conf.w+"px";
		w.fr_m_cover.style.height = w.conf.h+"px";
	}
	w = null;
};
dhtmlXWindows.prototype._winAdjustFRMPosition = function(id) {
	var w = this.w[id];
	if (w.fr_m_cover != null) {
		w.fr_m_cover.style.left = w.win.style.left;
		w.fr_m_cover.style.top = w.win.style.top;
	}
	w = null;
};
dhtmlXWindows.prototype._winAdjustFRMZIndex = function(id) {
	var w = this.w[id];
	if (w.fr_m_cover != null) {
		w.fr_m_cover.style.zIndex = w.win.style.zIndex;
	}
	w = null;
};


function dhtmlXWindowsCell(id, wins) {
	
	dhtmlXCellObject.apply(this, [id, "_wins"]);
	
	this.wins = wins;
	
	this.cell._winId = id;
	this.conf.skin = this.wins.conf.skin;
	
	this.attachEvent("_onCellUnload", function(){
		
		if (this._unloadResize) {
			this._unloadResize();
		}
		
		window.dhx4._eventable(this.cell, "clear");
		
		this.cell._winId = null;
		this.wins = null;
		
		this.setText = null;
		this.getText = null;
		this.allowMove = null;
		this.denyMove = null;
		this.isMovable = null;
		this.allowResize = null;
		this.denyResize = null;
		this.isResizable = null;
		this.maximize = null;
		this.minimize = null;
		this.isMaximized = null;
		this.setPosition = null;
		this.getPosition = null;
		this.adjustPosition = null;
		this.park = null;
		this.isParked = null;
		this.allowPark = null;
		this.denyPark = null;
		this.isParkable = null;
		this.show = null;
		this.hide = null;
		this.isHidden = null;
		this.stick = null;
		this.unstick = null;
		this.isSticked = null;
		this.setDimension = null;
		this.getDimension = null;
		this.setMinDimension = null;
		this.getMinDimension = null;
		this.setMaxDimension = null;
		this.getMaxDimension = null;
		this.keepInViewport = null;
		this.center = null;
		this.centerOnScreen = null;
		this.bringToTop = null;
		this.bringToBottom = null;
		this.isOnTop = null;
		this.isOnBottom = null;
		this.showHeader = null;
		this.hideHeader = null;
		this.setModal = null;
		this.isModal = null;
		this.close = null;
		
		this._adjustByCont = null;
		
		this.button = null;
		this.addUserButton = null;
		this.removeUserButton = null;
		
		that = null;
	});
	
	this.attachEvent("_onContentLoaded", function() {
		this.wins._callMainEvent("onContentLoaded", this._idd);
	});
	this.attachEvent("_onContentMouseDown", function(id,e) {
		this.wins.callEvent("_winMouseDown",[e,{id:id,mode:"win"}]);
	});
	
	this._callMainEvent = function(name, args) {
		return this.callEvent(name, args);
	}
	
	// open/close, check trans-effects
	
	this.conf.tr = {};
	for (var a in this.wins.conf.tr) this.conf.tr[a] = this.wins.conf.tr[a];
	
	if (this.conf.tr.prop != false) {
		/* 
		this.attachEvent("_onIdxUpdated", function(){
			// if cell hidden - update opacity for menu/toolbar/status which attached to parked window
			if (this.wins.w[this._idd].conf.parked) {
				for (var a in this.conf.idx) {
					if ({hdr:true,pr1:true,pr2:true}[a] != true) { // skip hdr and progress
						this.wins._winCellSetOpacity(this._idd, "close", false);
					}
				}
			}
		});
		*/
	}
	
	
	if (this._initResize) this._initResize();
	
	// personal window events,
	// dhxWins.window(id).attachEvent()
	window.dhx4._eventable(this.cell);
	
	// adjustParentSize (for form)
	var that = this;
	this.cell.attachEvent("_setCellSize", function(w, h){
		var w0 = that.wins.w[this._winId].conf.w-that.conf.size.w;
		var h0 = that.wins.w[this._winId].conf.h-that.conf.size.h;
		that.setDimension(w+w0, h+h0);
	});
	
	return this;
	
};

dhtmlXWindowsCell.prototype = new dhtmlXCellObject();

// text
dhtmlXWindowsCell.prototype.setText = function(text) {
	this.wins.w[this._idd].conf.text = text;
	this.wins.w[this._idd].hdr.childNodes[1].firstChild.innerHTML = text;
};
dhtmlXWindowsCell.prototype.getText = function() {
	return this.wins.w[this._idd].conf.text;
};

// move/dnd
dhtmlXWindowsCell.prototype.allowMove = function() {
	this.wins.w[this._idd].conf.allow_move = true;
};
dhtmlXWindowsCell.prototype.denyMove = function() {
	this.wins.w[this._idd].conf.allow_move = false;
};
dhtmlXWindowsCell.prototype.isMovable = function() {
	return (this.wins.w[this._idd].conf.allow_move == true);
};

// resize
dhtmlXWindowsCell.prototype.allowResize = function() {
	this.wins.w[this._idd].conf.allow_resize = true;
	this.wins.w[this._idd].b.minmax.enable();
};
dhtmlXWindowsCell.prototype.denyResize = function() {
	this.wins.w[this._idd].conf.allow_resize = false;
	this.wins.w[this._idd].b.minmax.disable();
};
dhtmlXWindowsCell.prototype.isResizable = function() {
	return (this.wins.w[this._idd].conf.allow_resize == true);
};

// min/max
dhtmlXWindowsCell.prototype.maximize = function() {
	this.wins._winMinmax(this._idd, true);
};
dhtmlXWindowsCell.prototype.minimize = function() {
	this.wins._winMinmax(this._idd, false);
};
dhtmlXWindowsCell.prototype.isMaximized = function() {
	return (this.wins.w[this._idd].conf.maxed == true);
};

// position
dhtmlXWindowsCell.prototype.setPosition = function(x, y) {
	this.wins._winSetPosition(this._idd, x, y);
};
dhtmlXWindowsCell.prototype.getPosition = function() {
	var w = this.wins.w[this._idd];
	var p = [w.conf.x,w.conf.y];
	w = null;
	return p;
};
dhtmlXWindowsCell.prototype.adjustPosition = function() {
	this.wins._winAdjustPosition(this._idd);
};

// parking
dhtmlXWindowsCell.prototype.park = function() {
	this.wins._winPark(this._idd, true); // with effect
};
dhtmlXWindowsCell.prototype.isParked = function() {
	return (this.wins.w[this._idd].conf.parked == true);
};
dhtmlXWindowsCell.prototype.allowPark = function() {
	this.wins.w[this._idd].conf.allow_park = true;
	this.wins.w[this._idd].b.park.enable();
};
dhtmlXWindowsCell.prototype.denyPark = function() {
	this.wins.w[this._idd].conf.allow_park = false;
	this.wins.w[this._idd].b.park.disable();
};
dhtmlXWindowsCell.prototype.isParkable = function() {
	return (this.wins.w[this._idd].conf.allow_park == true);
};

// show/hide
dhtmlXWindowsCell.prototype.show = function(makeActive) {
	this.wins._winShow(this._idd, window.dhx4.s2b(makeActive));
};
dhtmlXWindowsCell.prototype.hide = function() {
	this.wins._winHide(this._idd);
};
dhtmlXWindowsCell.prototype.isHidden = function() {
	return (this.wins.w[this._idd].conf.visible != true);
};

// sticking
dhtmlXWindowsCell.prototype.stick = function() {
	this.wins._winStick(this._idd, true);
};
dhtmlXWindowsCell.prototype.unstick = function() {
	this.wins._winStick(this._idd, false);
};
dhtmlXWindowsCell.prototype.isSticked = function() {
	return (this.wins.w[this._idd].conf.sticked == true);
};

// dimension
dhtmlXWindowsCell.prototype.setDimension = function(width, height) {
	var w = this.wins.w[this._idd];
	if (w.conf.parked) this.wins._winPark(this._idd, false);
	if (w.conf.maxed) {
		if (width != null) w.conf.lastMW = width;
		if (height != null) w.conf.lastMH = height;
		this.wins._winMinmax(this._idd);
	} else {
		this.wins._winSetSize(this._idd, width, height, false, true);
	}
	w = null;
};
dhtmlXWindowsCell.prototype.getDimension = function() {
	var w = this.wins.w[this._idd];
	var d = [w.conf.w, w.conf.h];
	w = null;
	return d;
};
dhtmlXWindowsCell.prototype.setMinDimension = function(width, height) {
	var w = this.wins.w[this._idd];
	w.conf.min_w = width;
	w.conf.min_h = height;
	// parked and maxed will ajusted in _winSetSize
	this.wins._winSetSize(this._idd, w.conf.w, w.conf.h);
	w = null;
};
dhtmlXWindowsCell.prototype.getMinDimension = function() {
	var w = this.wins.w[this._idd];
	var d = [w.conf.min_w, w.conf.min_h];
	w = null;
	return d;
};
dhtmlXWindowsCell.prototype.setMaxDimension = function(width, height) {
	var w = this.wins.w[this._idd];
	w.conf.max_w = width;
	w.conf.max_h = height;
	// parked and maxed will ajusted in _winSetSize
	this.wins._winSetSize(this._idd, w.conf.w, w.conf.h);
	w = null;
};
dhtmlXWindowsCell.prototype.getMaxDimension = function() {
	var w = this.wins.w[this._idd];
	var d = [w.conf.max_w, w.conf.max_h];
	w = null;
	return d;
};

// viewport
dhtmlXWindowsCell.prototype.keepInViewport = function(mode) {
	this.wins.w[this._idd].conf.keep_in_vp = window.dhx4.s2b(mode);
};
dhtmlXWindowsCell.prototype.center = function() {
	
	var vp = this.wins.vp;
	var w = this.wins.w[this._idd];
	
	var x = Math.round((vp.clientWidth-w.conf.w)/2);
	var y = Math.round((vp.clientHeight-w.conf.h)/2);
	
	this.wins._winSetPosition(this._idd, x, y);
	vp = w = null;
};
dhtmlXWindowsCell.prototype.centerOnScreen = function() {
	
	var w = this.wins.w[this._idd];
	var dim = window.dhx4.screenDim();
	
	// viewport correction
	var vx = window.dhx4.absLeft(this.wins.vp);
	var vy = window.dhx4.absTop(this.wins.vp);
	var k = this.wins.vp.parentNode;
	while (k != null) {
		if (k.scrollLeft) vx = vx-k.scrollLeft;
		if (k.scrollTop) vy = vy-k.scrollTop;
		k = k.parentNode;
	}
	
	var x = Math.round((dim.right-dim.left-w.conf.w)/2);
	var y = Math.round((dim.bottom-dim.top-w.conf.h)/2);
	
	this.wins._winAdjustPosition(this._idd, x-vx, y-vy);
	d = w = null;
	
};

// z-index
dhtmlXWindowsCell.prototype.bringToTop = function() {
	this.wins._winMakeActive(this._idd, true);
};
dhtmlXWindowsCell.prototype.bringToBottom = function() {
	var actv = (this.wins.w[this._idd].conf.actv?null:this.wins.conf.last_active);
	window.dhx4.zim.clear(this.wins.w[this._idd].conf.z_id);
	this.wins.w[this._idd].win.style.zIndex = 0;
	this.wins._winMakeActive(actv, true);
};
dhtmlXWindowsCell.prototype.isOnTop = function() {
	return (this.wins.w[this._idd].conf.actv == true);
};
dhtmlXWindowsCell.prototype.isOnBottom = function() {
	var data = {id: null, z:+Infinity};
	for (var a in this.wins.w) {
		if (this.wins.w[a].conf.visible && this.wins.w[a].win.style.zIndex < data.z) {
			data.id = a;
			data.z = this.wins.w[a].win.style.zIndex;
		}
	}
	return (data.id==this._idd);
};

// header
dhtmlXWindowsCell.prototype.showHeader = function() {
	var w = this.wins.w[this._idd];
	if (w.conf.header == false) {
		w.hdr.className = String(w.hdr.className).replace(/\s{0,}dhxwin_hdr_hidden/gi,"");
		w.brd.className = String(w.brd.className).replace(/\s{0,}dhxwin_hdr_hidden/gi,"");
		this.conf.cells_cont = null; // reset saved borders
		w.conf.brd = null; // reset brd
		w.conf.header = true;
		this.wins._winAdjustCell(this._idd);
	}
	w = null;
};
dhtmlXWindowsCell.prototype.hideHeader = function() {
	var w = this.wins.w[this._idd];
	if (w.conf.header == true) {
		if (w.conf.parked) this.wins._winPark(this._idd, false);
		w.hdr.className += " dhxwin_hdr_hidden";
		w.brd.className += " dhxwin_hdr_hidden";
		this.conf.cells_cont = null; // reset saved borders
		w.conf.brd = null; // reset brd
		w.conf.header = false;
		this.wins._winAdjustCell(this._idd);
	}
	w = null;
};

// modality
dhtmlXWindowsCell.prototype.setModal = function(modal) {
	this.wins._winSetModal(this._idd, window.dhx4.s2b(modal));
};
dhtmlXWindowsCell.prototype.isModal = function() {
	return (this.wins.w[this._idd].conf.modal==true);
};

// adjust cell to content
dhtmlXWindowsCell.prototype._adjustByCont = function(w, h) {
	w += this.wins.w[this._idd].conf.w-this.conf.size.w;
	h += this.wins.w[this._idd].conf.h-this.conf.size.h;
	this.wins._winSetSize(this._idd, w, h);
};

// closing
dhtmlXWindowsCell.prototype.close = function() {
	this.wins._winClose(this._idd);
};

// icon
dhtmlXWindowsCell.prototype.setIconCss = function(css) {
	this.wins.w[this._idd].hdr.firstChild.className = "dhxwin_icon "+css;
	this.wins._winAdjustTitle(this._idd);
};

// fullscreen mode
dhtmlXWindowsCell.prototype.setToFullScreen = function(mode) {
	
	mode = window.dhx4.s2b(mode);
	
	var w = this.wins.w[this._idd];
	
	if (w.conf.fs_mode == mode) {
		w = null;
		return;
	}
	
	if (this.wins.fsn == null) {
		this.wins.fsn = document.createElement("DIV");
		this.wins.fsn.className = this.wins.vp.className+" dhxwins_vp_fs";
		document.body.appendChild(this.wins.fsn);
	}
	
	if (mode) {
		this.wins.fsn.appendChild(w.win);
		this.maximize();
		this.hideHeader();
	} else {
		this.wins.vp.appendChild(w.win);
		this.minimize();
		this.showHeader();
		
		if (this.wins.fsn.childNodes.length == 0) {
			this.wins.fsn.parentNode.removeChild(this.wins.fsn);
			this.wins.fsn = null;
		}
	}
	
	w.conf.fs_mode = mode;
	w = null;
	
};

// buttons

dhtmlXWindowsCell.prototype.button = function(id) {
	if (id == "minmax1" || id == "minmax2") { // deprecated
		// console.warn("windows: minmax1/minmax2 buttons are deprecated, from 4.0 there is single button minmax");
		id = "minmax";
	}
	return this.wins.w[this._idd].b[id];
};

dhtmlXWindowsCell.prototype.addUserButton = function(id, pos, title) {
	var b = new dhtmlXWindowsButton(this.wins, this._idd, id, title, true);
	var n = null;
	var h = this.wins.w[this._idd].hdr.lastChild;
	if (isNaN(pos)) pos = 0; else if (pos < 0) pos = 0;
	if (h.childNodes[pos] != null) n = h.childNodes[pos];
	if (n != null) h.insertBefore(b.button, n); else h.appendChild(b.button);
	this.wins.w[this._idd].b[id] = b;
	b = n = h = null;
	this.wins._winAdjustTitle(this._idd);
};

dhtmlXWindowsCell.prototype.removeUserButton = function(id) {
	if (this.wins.w[this._idd].b[id] == null || this.wins.w[this._idd].b[id].conf.custom != true) return;
	this.wins._winRemoveButton(this._idd, id);
};


window.dhtmlXWindowsButton = function(wins, winId, name, title, custom) {
	
	this.conf = {
		wins: wins,
		winId: winId,
		name: name,
		enabled: true,
		visible: true,
		custom:  true
	};
	
	this.button = document.createElement("DIV");
	this.button._buttonName = name;
	this.button.title = title;
	
	this.enable = function() {
		this.conf.enabled = true;
		this.setCss(this.conf.css);
	}
	this.disable = function() {
		this.conf.enabled = false;
		this.setCss(this.conf.css);
	}
	this.isEnabled = function() {
		return (this.conf.enabled==true);
	}
	//
	this.show = function() {
		this.button.style.display = "";
		this.conf.visible = true;
		this.conf.wins._winAdjustTitle(this.conf.winId);
	}
	this.hide = function() {
		this.button.style.display = "none";
		this.conf.visible = false;
		this.conf.wins._winAdjustTitle(this.conf.winId);
	}
	this.isHidden = function() {
		return (this.conf.visible==false);
	}
	//
	this.setCss = function(css) {
		this.conf.css = css;
		var dis = (this.conf.enabled?"":"_dis");
		this.button.className = "dhxwin_button"+dis+" dhxwin_button_"+this.conf.css+dis;
	}
	
	this._doOnClick = function(ev) {
		return this.callEvent("onClick", [this.conf.wins.w[this.conf.winId].cell, this]);
	}
	
	this.unload = function(winClosing) {
		//
		dhx4._eventable(this, "clear");
		this.button._buttonName = null;
		this.button.parentNode.removeChild(this.button);
		
		// context context menu if any
		if (this.conf.wins.cm != null && this.conf.wins.cm.button[this.conf.winId] != null && this.conf.wins.cm.button[this.conf.winId][this.conf.name] != null) {
			this.conf.wins._detachContextMenu("button", this.conf.winId, this.conf.name);
		}
		
		this.button = null;
		this.enable = null;
		this.disable = null;
		this.isEnabled = null;
		this.show = null;
		this.hide = null;
		this.isHidden = null;
		this.setCss = null;
		this.unload = null;
		//
		if (winClosing != true) this.conf.wins._winAdjustTitle(this.conf.winId);
		//
		this.conf.wins = null;
		this.conf.winId = null;
		this.conf = null;
		
	}
	
	this.setCss(name);
	dhx4._eventable(this);
	
	return this;
};

dhtmlXWindows.prototype._winButtonClick = function(id, button, ev) {
	
	if (!this.w[id].b[button].isEnabled()) return true;
	
	if (this.w[id].b[button]._doOnClick() !== true) return;
	
	if (button == "help") {
		this._callMainEvent("onHelp", id);
	}
	
	if (button == "park") {
		this._winPark(id, true);
	}
	
	if (button == "minmax") {
		this._winMinmax(id);
	}
	
	if (button == "stick") {
		this._winStick(id);
		return false;
	}

	if (button == "close") {
		this._winClose(id);
		return false;
	}
	return true; // allow default action
};

dhtmlXWindows.prototype._winRemoveButton = function(wId, bId, winClosing) {
	this.w[wId].b[bId].unload(winClosing);
	this.w[wId].b[bId] = null;
	delete this.w[wId].b[bId];
};



/*
Product Name: dhtmlxSuite 
Version: 4.1.3 
Edition: Professional 
License: content of this file is covered by DHTMLX Commercial or Enterprise license. Usage without proper license is prohibited. To obtain it contact sales@dhtmlx.com
Copyright UAB Dinamenta http://www.dhtmlx.com
*/

dhtmlXWindows.prototype._dndInitModule = function() {
	
	var that = this;
	
	this.conf.dnd_tm = null;
	this.conf.dnd_time = 0; // 400 or 0
	
	if (window.navigator.msPointerEnabled == true) {
		this.conf.dnd_evs = {
			start: "MSPointerDown",
			move: "MSPointerMove",
			end: "MSPointerUp"
		};
	} else {
		this.conf.dnd_evs = {
			start: "touchstart",
			move: "touchmove",
			end: "touchend"
		};
	}
	
	
	this._dndOnMouseDown = function(e, id) {
		
		if (that.conf.dblclick_active) return;
		
		if (e.preventDefault) e.preventDefault(); else e.returnValue = false;
		
		
		that.conf.dnd = {
			id: id,
			x: e[that.conf.dnd_ev_prefix+"X"]||e.touches[0][that.conf.dnd_ev_prefix+"X"],
			y: e[that.conf.dnd_ev_prefix+"Y"]||e.touches[0][that.conf.dnd_ev_prefix+"Y"],
			ready: true,
			css: false,
			css_touch: false,
			css_vp: false,
			tr: null,
			mode: "def", //"def" - move win, "tr" - for translate, "rect" - move rectange
			moved: false,
			prevent: false
		};
		
		if (that.w[id].conf.keep_in_vp) {
			that.conf.dnd.minX = 0;
			that.conf.dnd.maxX = that.vp.clientWidth-that.w[id].conf.w;
			that.conf.dnd.minY = 0;
			that.conf.dnd.maxY = that.vp.clientHeight-that.w[id].conf.h;
		} else {
			that.conf.dnd.minX = -that.w[id].conf.w+that.conf.vp_pos_ofs;
			that.conf.dnd.maxX = that.vp.clientWidth-that.conf.vp_pos_ofs;
			that.conf.dnd.minY = 0;
			that.conf.dnd.maxY = that.vp.clientHeight-that.conf.vp_pos_ofs;
		}
		
		var k = [
			"MozTransform",
			"WebkitTransform",
			"OTransform",
			"msTransform",
			"transform"
		];
		
		for (var q=0; q<k.length; q++) {
			if (document.documentElement.style[k[q]] != null && that.conf.dnd.tr == null) {
				that.conf.dnd.tr = k[q];
				that.conf.dnd.mode = "tr";
			}
		}
		
		// that.conf.dnd.mode = "def";
		// console.log("dnd ready, mode: "+that.conf.dnd.mode);
		
		if (that.conf.dnd.mode == "tr") that.w[id].win.style[that.conf.dnd.tr] = "translate(0px,0px)";
		
		// touch indicator
		if (e.type == that.conf.dnd_evs.start) {
			if (that.conf.dnd.css_touch == false) {
				that.w[id].win.className += " dhxwin_dnd_touch";
				that.conf.dnd.css_touch = true;
			}
			if (that.conf.dnd.css_vp == false) {
				that.vp.className += " dhxwins_vp_dnd";
				that.conf.dnd.css_vp = true;
			}
		} else {
			// init events
			that._dndInitEvents();
		}
	}
	
	this._dndOnMouseMove = function(e) {
		
		// dhtmlx.message({text: "a", expire: 100});
		e = e||event;
		
		var dnd = that.conf.dnd;
		
		var x = (e[that.conf.dnd_ev_prefix+"X"]||e.touches[0][that.conf.dnd_ev_prefix+"X"])-dnd.x;
		var y = (e[that.conf.dnd_ev_prefix+"Y"]||e.touches[0][that.conf.dnd_ev_prefix+"Y"])-dnd.y;
		
		// check if user will move body while timer is active, allow 10px interval from touch point
		if (e.type == that.conf.dnd_evs.move) {
			
			if (dnd.moved != true && (Math.abs(x) > 20 || Math.abs(y) > 20)) {
				
				if (that.conf.dnd_tm != null) {
					window.clearTimeout(that.conf.dnd_tm);
					that.conf.dnd_tm = null;
				}
				window.removeEventListener(that.conf.dnd_evs.start, that._dndOnMouseMove, false);
				//if (window.dhx4.isIE) document.body.style.msTouchAction = "";
				
				return;
			}
		}
		
		
		if (dnd.ready != true) return;
		
		var w = that.w[dnd.id];
		
		// dhtmlx.message({text:x+","+y,expire:100});
		
		if (e.preventDefault) e.preventDefault(); else e.returnValue = false;
		
		
		if (dnd.css != true) {
			if (dnd.css_touch == false) w.win.className += " dhxwin_dnd";
			w.fr_cover.className += " dhxwin_fr_cover_dnd";
			dnd.css = true;
		}
		if (dnd.css_vp != true) {
			that.vp.className += " dhxwins_vp_dnd";
			dnd.css_vp = true;
		}
		
		dnd.newX = w.conf.x+x;
		dnd.newY = w.conf.y+y;
		
		if (dnd.mode == "tr") {
			
			dnd.newX = Math.min(Math.max(dnd.newX, dnd.minX), dnd.maxX);
			x = dnd.newX-w.conf.x;
			
			dnd.newY = Math.min(Math.max(dnd.newY, dnd.minY), dnd.maxY);
			y = dnd.newY-w.conf.y;
			
			w.win.style[dnd.tr] = "translate("+x+"px,"+y+"px)";
			
		} else {
			
			if (dnd.newX < dnd.minX || dnd.newX > dnd.maxX) {
				dnd.newX = Math.min(Math.max(dnd.newX, dnd.minX), dnd.maxX);
			} else {
				dnd.x = e[that.conf.dnd_ev_prefix+"X"]||e.touches[0][that.conf.dnd_ev_prefix+"X"];
			}
			
			if (dnd.newY < dnd.minY || dnd.newY > dnd.maxY) {
				dnd.newY = Math.min(Math.max(dnd.newY, dnd.minY), dnd.maxY);
			} else {
				dnd.y = e[that.conf.dnd_ev_prefix+"Y"]||e.touches[0][that.conf.dnd_ev_prefix+"Y"];
			}
			
			that._winSetPosition(dnd.id, dnd.newX, dnd.newY);
			
		}
		
		dnd.moved = true;
		
		w = dnd = null;
	}
	
	this._dndOnMouseUp = function(e) {
		
		e = e||event;
		
		if (that.conf.dnd != null) {
			
			var dnd = that.conf.dnd;
			var w = that.w[dnd.id];
			
			if (dnd.newX != null) {
				if (dnd.mode == "tr") {
					that._winSetPosition(dnd.id, dnd.newX, dnd.newY);
					w.win.style[dnd.tr] = "translate(0px,0px)";
				}
			}
			if (dnd.css == true) {
				if (dnd.css_touch == false) w.win.className = String(w.win.className).replace(/\s{0,}dhxwin_dnd/gi,"");
				w.fr_cover.className = String(w.fr_cover.className).replace(/\s{0,}dhxwin_fr_cover_dnd/gi,"");
			}
			if (dnd.css_touch == true) {
				w.win.className = String(w.win.className).replace(/\s{0,}dhxwin_dnd_touch/gi,"");
			}
			if (dnd.css_vp == true) {
				that.vp.className = String(that.vp.className).replace(/\s{0,}dhxwins_vp_dnd/gi,"");
			}
			
			that._dndUnloadEvents();
			
			if (dnd.moved) that._callMainEvent("onMoveFinish", dnd.id);
			
			w = dnd = that.conf.dnd = null;
			
		}
		
		if (window.dhx4.isIE == true && e.type == that.conf.dnd_evs.end && window.navigator.msPointerEnabled == true) {
			document.body.style.msTouchAction = "";
			window.removeEventListener(that.conf.dnd_evs.end, that._dndOnMouseUp, false);
			window.removeEventListener(that.conf.dnd_evs.move, that._dndOnMouseMove, false);
			if (that.conf.dnd_tm != null) window.clearTimeout(that.conf.dnd_tm);
			that.conf.dnd_tm = null;
		}
	}
	
	this._dndOnSelectStart = function(e) {
		e = e||event;
		if (e.preventDefault) e.preventDefault(); else e.returnValue = false;
		return false;
	}
	
	this._dndInitEvents = function() {
		if (typeof(window.addEventListener) == "function") {
			window.addEventListener("mousemove", this._dndOnMouseMove, false);
			window.addEventListener("mouseup", this._dndOnMouseUp, false);
			window.addEventListener("selectstart", this._dndOnSelectStart, false);
		} else {
			document.body.attachEvent("onmousemove", this._dndOnMouseMove);
			document.body.attachEvent("onmouseup", this._dndOnMouseUp);
			document.body.attachEvent("onselectstart", this._dndOnSelectStart);
		}
	}
	
	this._dndUnloadEvents = function() {
		if (typeof(window.addEventListener) == "function") {
			window.removeEventListener("mousemove", this._dndOnMouseMove, false);
			window.removeEventListener("mouseup", this._dndOnMouseUp, false);
			window.removeEventListener("selectstart", this._dndOnSelectStart, false);
		} else {
			document.body.detachEvent("onmousemove", this._dndOnMouseMove);
			document.body.detachEvent("onmouseup", this._dndOnMouseUp);
			document.body.detachEvent("onselectstart", this._dndOnSelectStart);
		}
	}
	
	this._dndUnloadModule = function() {
		
		this.detachEvent(this.conf.dnd_evid);
		this.conf.dnd_evid = null;
		
		this._dndOnMouseDown = null;
		this._dndOnMouseMove = null;
		this._dndOnMouseUp = null;
		this._dndOnSelectStart = null;
		this._dndInitEvents = null;
		this._dndUnloadEvents = null;
		this._dndInitModule = null;
		this._dndUnloadModule = null;
		
		that = null;
	}
	
	this.conf.dnd_evid = this.attachEvent("_winMouseDown", function(e, data){
		
		if (e.type == this.conf.dnd_evs.start) {
			
			if (data.mode == "hdr") {
				
				if (this.w[data.id].conf.maxed && this.w[data.id].conf.max_w == null && this.w[data.id].conf.max_h == null) return;
				
				this.conf.dnd_ev_prefix = "page";
				this.conf.dnd = {
					x: e[this.conf.dnd_ev_prefix+"X"]||e.touches[0][this.conf.dnd_ev_prefix+"X"],
					y: e[this.conf.dnd_ev_prefix+"Y"]||e.touches[0][this.conf.dnd_ev_prefix+"Y"]
				};
				if (this.conf.dnd_time < 1) {
					this._dndOnMouseDown(e, data.id);
				} else {
					if (this.conf.dnd_tm != null) window.clearTimeout(this.conf.dnd_tm);
					this.conf.dnd_tm = window.setTimeout(function(){that._dndOnMouseDown(e,data.id);}, this.conf.dnd_time);
				}
				
				if (window.dhx4.isIE == true && window.navigator.msPointerEnabled == true) {
					document.body.style.msTouchAction = "none";
					window.addEventListener(this.conf.dnd_evs.end, this._dndOnMouseUp, false);
				}
				
				window.addEventListener(this.conf.dnd_evs.move, this._dndOnMouseMove, false);
				
			}
			
			return false;
		}
		
		if (e.type == this.conf.dnd_evs.end) {
			
			if (this.conf.dnd_tm != null) {
				window.clearTimeout(this.conf.dnd_tm);
				this.conf.dnd_tm = null;
			}
			
			this._dndOnMouseUp();
			window.removeEventListener(this.conf.dnd_evs.move, this._dndOnMouseMove, false);
			
			return false;
		}
		
		if (e.button >= 2) return;
		
		this.conf.dnd_ev_prefix = "client";
		if (!(data.mode == "hdr" && e.type == "mousedown" && this.w[data.id].conf.allow_move == true)) return;
		if (this.w[data.id].conf.maxed && this.w[data.id].conf.max_w == null && this.w[data.id].conf.max_h == null) return;
		
		if (e.preventDefault) e.preventDefault(); else e.returnValue = false;
		this._dndOnMouseDown(e, data.id);
		return false;
		
	});
	
};


/*
Product Name: dhtmlxSuite 
Version: 4.1.3 
Edition: Professional 
License: content of this file is covered by DHTMLX Commercial or Enterprise license. Usage without proper license is prohibited. To obtain it contact sales@dhtmlx.com
Copyright UAB Dinamenta http://www.dhtmlx.com
*/

dhtmlXWindowsCell.prototype._initResize = function() {
	
	var that = this;
	var n = navigator.userAgent;
	
	this.conf.resize = {
		b_width: 6,
		c_type: (n.indexOf("MSIE 10.0")>0||n.indexOf("MSIE 9.0")>0||n.indexOf("MSIE 8.0")>0||n.indexOf("MSIE 7.0")>0||n.indexOf("MSIE 6.0")>0)
	};
	
	this._rOnCellMouseMove = function(e) {
		
		if (that.wins.conf.resize_actv == true || that.wins.w[that._idd].conf.allow_resize == false || that.conf.progress == true || that.wins.w[that._idd].conf.maxed == true || that.wins.w[that._idd].conf.fs_mode == true) {
			var k = that.wins.w[that._idd].brd;
			if (k.style.cursor != "default") k.style.cursor = "default";
			k = null;
			return;
		}
		
		
		e = e||event;
		
		var cont = that.wins.w[that._idd].brd;
		var r = that.conf.resize;
		
		var no_header = (that.wins.w[that._idd].conf.header==false);
		
		var x = e.clientX;
		var y = e.clientY;
		
		var x0 = window.dhx4.absLeft(cont);
		var y0 = window.dhx4.absTop(cont);
		
		var mode = "";
		if (x <= x0+r.b_width) { // left
			mode = "w";
		} else if (x >= x0+cont.offsetWidth-r.b_width) { // right
			mode = "e";
		}
		if (y >= y0+cont.offsetHeight-r.b_width) { // bottom
			mode = "s"+mode;
		} else if (no_header && y <= y0+r.b_width) { // top (only for no_header mode)
			mode = "n"+mode;
		}
		
		if (mode == "") mode = false;
		if (r.mode != mode) {
			r.mode = mode;
			if (mode == false) {
				cont.style.cursor = "default";
			} else {
				cont.style.cursor = mode+"-resize";
			}
		}
		
		cont = r = null;
	};
	
	this._rOnCellMouseDown = function(e) {
		
		if (that.conf.resize.mode == false) return;
		if (that.conf.progress == true) return; // if progress is on - deny
		if (that.wins.w[that._idd].conf.allow_resize == false) return;
		if (that.wins.w[that._idd].conf.fs_mode == true) return; // fullscreened window
		
		if (e.preventDefault) e.preventDefault(); else e.returnValue = false;
		
		var w = that.wins.w[that._idd];
		var r = that.conf.resize;
		
		that.wins.conf.resize_actv = true;
		
		r.min_w = w.conf.min_w;
		r.min_h = w.conf.min_h;
		r.max_w = w.conf.max_w||+Infinity;
		r.max_h = w.conf.max_h||+Infinity;
		
		// if layout attached - check custom min w/h
		if (w.cell.dataType == "layout" && w.cell.dataObj != null && typeof(w.cell.dataObj._getWindowMinDimension) == "function") {
			var t = w.cell.dataObj._getWindowMinDimension(w.cell);
			r.min_w = Math.max(t.w, r.min_w);
			r.min_h = Math.max(t.h, r.min_h);
		}
		
		r.vp_l = that.wins.conf.vp_pos_ofs;
		r.vp_r = that.wins.vp.clientWidth-that.wins.conf.vp_pos_ofs;
		r.vp_b = that.wins.vp.clientHeight-that.wins.conf.vp_pos_ofs;
		
		r.x = e.clientX;
		r.y = e.clientY;
		
		// start resize
		if (typeof(window.addEventListener) == "function") {
			window.addEventListener("mousemove", that._rOnWinMouseMove, false);
			window.addEventListener("mouseup", that._rOnWinMouseUp, false);
			window.addEventListener("selectstart", that._rOnSelectStart, false);
		} else {
			document.body.attachEvent("onmousemove", that._rOnWinMouseMove);
			document.body.attachEvent("onmouseup", that._rOnWinMouseUp);
			document.body.attachEvent("onselectstart", that._rOnSelectStart);
		}
		
		r.resized = false;
		
		r.vp_cursor = that.wins.vp.style.cursor;
		that.wins.vp.style.cursor = r.mode+"-resize";
		
		w = r = null;
	};
	
	this._rOnWinMouseMove = function(e) {
		
		// resize in progress
		e = e||event;
		
		var w = that.wins.w[that._idd];
		var r = that.conf.resize;
		
		if (!r.resized) {
			w.fr_cover.className += " dhxwin_fr_cover_resize";
			r.resized = true;
		}
		
		var x = e.clientX-r.x;
		var y = e.clientY-r.y;
		
		if (r.mode.indexOf("e") >= 0) { // right win side dragged
			
			r.rw = Math.min(Math.max(w.conf.w+x, r.min_w), r.max_w);
			r.rx = null;
			
			if (w.conf.x+r.rw < r.vp_l) { // check overflow to left
				r.rw = r.vp_l-w.conf.x;
			} else if (w.conf.x+r.rw > that.wins.vp.clientWidth) { // and right
				r.rw = that.wins.vp.clientWidth-w.conf.x;
			}
			
		} else if (r.mode.indexOf("w") >= 0) { // left win side dragged
			
			r.rw = Math.min(Math.max(w.conf.w-x,r.min_w),r.max_w);
			r.rx = w.conf.x+w.conf.w-r.rw;
			
			if (r.rx < 0) { // check overflow to left
				r.rw = r.rw+r.rx;
				r.rx = 0;
			} else if (r.rx > r.vp_r) { // and right
				r.rw = r.rw-r.vp_r;
				r.rx = r.vp_r;
			}
			
		}
		
		if (r.mode.indexOf("s") >= 0) { // bottom win side (can be together with left or right)
			
			r.rh = Math.min(Math.max(w.conf.h+y, r.min_h),r.max_h);
			r.ry = null;
			
			if (w.conf.y+r.rh > that.wins.vp.clientHeight) { // bottom overflow
				r.rh = that.wins.vp.clientHeight-w.conf.y;
			}
			
		} else if (r.mode.indexOf("n") >= 0) { // top win side (can be together with left or right) (only for no_header mode)
			
			r.rh = Math.min(Math.max(w.conf.h-y, r.min_h),r.max_h);
			r.ry = w.conf.y+w.conf.h-r.rh;
			
			if (r.ry < 0) { // top overflow
				r.rh = r.rh+r.ry;
				r.ry = 0;
			} else if (r.ry > r.vp_b) { // and bottom
				r.rh = r.rh-r.vp_b;
				r.ry = r.vp_b;
			}
		}
		
		that._rAdjustSizer();
		
		w = r = null;
	}
	this._rOnWinMouseUp = function() {
		
		// stop resize
		
		var r = that.conf.resize;
		var w = that.wins.w[that._idd];
		
		that.wins.conf.resize_actv = false;
		that.wins.vp.style.cursor = r.vp_cursor;
		
		w.fr_cover.className = String(w.fr_cover.className).replace(/\s{0,}dhxwin_fr_cover_resize/gi,"");
		
		if (r.resized) {
			that.wins._winSetSize(that._idd, r.rw, r.rh);
			if (r.rx == null) r.rx = w.conf.x;
			if (r.ry == null) r.ry = w.conf.y;
			if (r.rx != w.conf.x || r.ry != w.conf.y) that.wins._winSetPosition(that._idd, r.rx, r.ry);
		}
		
		if (r.obj != null) {
			r.obj.parentNode.removeChild(r.obj);
			r.obj = null;
		}
		if (r.objFR != null) {
			r.objFR.parentNode.removeChild(r.objFR);
			r.objFR = null;
		}
		
		if (typeof(window.addEventListener) == "function") {
			window.removeEventListener("mousemove", that._rOnWinMouseMove, false);
			window.removeEventListener("mouseup", that._rOnWinMouseUp, false);
			window.removeEventListener("selectstart", that._rOnSelectStart, false);
		} else {
			document.body.detachEvent("onmousemove", that._rOnWinMouseMove);
			document.body.detachEvent("onmouseup", that._rOnWinMouseUp);
			document.body.detachEvent("onselectstart", that._rOnSelectStart);
		}
		
		if (r.resized) {
			if (that.dataType == "layout" && that.dataObj != null) that.dataObj.callEvent("onResize",[]); // deprecated, 3.6 compat
			that.wins._callMainEvent("onResizeFinish", that._idd);
		}
		
		r.mode = "";
		
		w = r = null;
	}
	
	this._rOnSelectStart = function(e) {
		e = e||event;
		if (e.preventDefault) e.preventDefault(); else e.returnValue = false;
		return false;
	}
	
	this._rInitSizer = function() {
		
		var r = that.conf.resize;
		var w = that.wins.w[that._idd];
		
		r.obj = document.createElement("DIV");
		r.obj.className = "dhxwin_resize";
		r.obj.style.zIndex = w.win.style.zIndex;
		r.obj.style.cursor = r.mode+"-resize";
		that.wins.vp.appendChild(r.obj);
		
		if (that.wins.conf.fr_cover == true) {
			r.objFR = document.createElement("IFRAME");
			r.objFR.className = "dhxwin_resize_fr_cover";
			r.objFR.style.zIndex = r.obj.style.zIndex;
			that.wins.vp.insertBefore(r.objFR, r.obj);
		}
		
		r.rx = w.conf.x;
		r.ry = w.conf.y;
		r.rw = w.conf.w;
		r.rh = w.conf.h;
		r = null;
	}
	
	this._rAdjustSizer = function() {
		var r = that.conf.resize;
		if (!r.obj) this._rInitSizer();
		// dim
		r.obj.style.width = r.rw+"px";
		r.obj.style.height = r.rh+"px";
		
		// pos, optional
		if (r.rx != null) r.obj.style.left = r.rx+"px";
		if (r.ry != null) r.obj.style.top = r.ry+"px";
		
		if (r.objFR != null) {
			r.objFR.style.width = r.obj.style.width;
			r.objFR.style.height = r.obj.style.height;
			if (r.rx != null) r.objFR.style.left = r.obj.style.left;
			if (r.ry != null) r.objFR.style.top = r.obj.style.top;
		}
		
		r = null;
	}
	
	if (typeof(window.addEventListener) == "function") {
		this.wins.w[this._idd].brd.addEventListener("mousemove", this._rOnCellMouseMove, false);
		this.wins.w[this._idd].brd.addEventListener("mousedown", this._rOnCellMouseDown, false);
	} else {
		this.wins.w[this._idd].brd.attachEvent("onmousemove", this._rOnCellMouseMove);
		this.wins.w[this._idd].brd.attachEvent("onmousedown", this._rOnCellMouseDown);
	}
	
	this._unloadResize = function() {
		
		if (typeof(window.addEventListener) == "function") {
			this.wins.w[this._idd].brd.removeEventListener("mousemove", this._rOnCellMouseMove, false);
			this.wins.w[this._idd].brd.removeEventListener("mousedown", this._rOnCellMouseDown, false);
		} else {
			this.wins.w[this._idd].brd.detachEvent("onmousemove", this._rOnCellMouseMove);
			this.wins.w[this._idd].brd.detachEvent("onmousedown", this._rOnCellMouseDown);
		}
		
		this._initResize = null;
		this._rOnCellMouseMove = null;
		this._rOnCellMouseDown = null;
		this._rOnWinMouseMove = null;
		this._rOnWinMouseUp = null;
		this._rOnSelectStart = null;
		this._rInitSizer = null;
		this._rAdjustSizer = null;
		this._unloadResize = null;
		
		this.conf.resize = null;
		that = null;
	};

};


/*
Product Name: dhtmlxSuite 
Version: 4.1.3 
Edition: Professional 
License: content of this file is covered by DHTMLX Commercial or Enterprise license. Usage without proper license is prohibited. To obtain it contact sales@dhtmlx.com
Copyright UAB Dinamenta http://www.dhtmlx.com
*/

// global context menu
dhtmlXWindows.prototype.attachContextMenu = function(conf) {
	return this._renderContextMenu("icon", null, null, conf);
};
dhtmlXWindows.prototype.getContextMenu = function() {
	if (this.cm != null && this.cm.global != null) return this.cm.global;
	return null;
};
dhtmlXWindows.prototype.detachContextMenu = function() {
	this._detachContextMenu("icon", null, null);
};

// custom menu
dhtmlXWindowsCell.prototype.attachContextMenu = function(conf) {
	return this.wins._renderContextMenu("icon", this._idd, null, conf);
};
dhtmlXWindowsCell.prototype.getContextMenu = function() {
	if (this.wins.cm != null && this.wins.cm.icon[this._idd] != null) return this.wins.cm.icon[this._idd];
	return null;
};
dhtmlXWindowsCell.prototype.detachContextMenu = function() {
	this.wins._detachContextMenu("icon", this._idd, null);
};

// menu for button
dhtmlXWindowsButton.prototype.attachContextMenu = function(conf) {
	return this.conf.wins._renderContextMenu("button", this.conf.winId, this.conf.name, conf);
};
dhtmlXWindowsButton.prototype.getContextMenu = function() {
	if (this.conf.wins.cm == null || this.conf.wins.cm.button[this.conf.winId] == null) return null;
	if (this.conf.wins.cm.button[this.conf.winId][this.conf.name] != null) return this.conf.wins.cm.button[this.conf.winId][this.conf.name];
	return null;
};
dhtmlXWindowsButton.prototype.detachContextMenu = function() {
	this.conf.wins._detachContextMenu("button", this.conf.winId, this.conf.name);
};

dhtmlXWindows.prototype._renderContextMenu = function(mode, wId, bId, conf) {
	
	var that = this;
	var firstInit = false;
	
	if (this.cm == null) {
		this.cm = {
			global:	null,	// global context menu for icon
			icon:	{},	// custom for icon, {winId:menuInst, winId2:menuInst2}
			button: {}	// custom foc button, {winId:{buttonId:menuInst, buttonId2:menuInst2}, winId2:{..}}
		};
		firstInit = true;
	}
	
	// check if already attached
	if (wId == null) {
		if (this.cm.global != null) return;
	} else if (mode == "icon") {
		if (this.cm.icon[wId] != null) return;
	} else if (mode == "button") {
		if (this.cm.button[wId] != null && this.cm.button[wId][bId] != null) return;
	}
	
	
	// init
	if (conf == null) conf = {};
	conf.parent = null;
	conf.context = true;
	
	var menu = new dhtmlXMenuObject(conf);
	menu.setAutoHideMode(false);
	
	menu.attachEvent("onShow", function() {
		this.conf.wins_menu_open = true;
	});
	
	menu.attachEvent("onHide", function() {
		this.conf.wins_menu_open = false;
		that.conf.opened_menu = null;
	});
	
	if (wId == null) {
		this.cm.global = menu;
	} else if (mode == "icon") {
		this.cm.icon[wId] = menu;
	} else if (mode == "button") {
		if (this.cm.button[wId] == null) this.cm.button[wId] = {};
		this.cm.button[wId][bId] = menu;
	}
	
	if (firstInit) {
		
		this._showContextMenu = function(e, data) {
			
			if (e.button >= 2) return;
			
			if (data.mode == "icon" && data.id != null && data.press_type == "mousedown") {
				
				var menu = this.cm.icon[data.id]||this.cm.global;
				if (menu == null) return;
				
				e.cancelBubble = true;
				
				var icon = this.w[data.id].hdr.firstChild;
				
				if (menu.conf.wins_menu_open && this.conf.opened_menu == data.id) {
					menu.hideContextMenu();
				} else {
					this._hideContextMenu();
					menu.showContextMenu(window.dhx4.absLeft(icon), window.dhx4.absTop(icon)+icon.offsetHeight);
					this.conf.opened_menu = data.id;
				}
				menu = icon = null;
				
			}
			
			if (data.mode == "button" && data.id != null && data.press_type == "mousedown") {
				
				if (this.cm.button[data.id] == null || this.cm.button[data.id][data.button_name] == null) return;
				
				e.cancelBubble = true;
				
				this.conf.button_last = null; // cancel button click
				
				var menu = this.cm.button[data.id][data.button_name];
				var button = this.w[data.id].b[data.button_name].button;
				
				if (menu.conf.wins_menu_open && this.conf.opened_menu == data.id) {
					menu.hideContextMenu();
				} else {
					this._hideContextMenu();
					menu.showContextMenu(window.dhx4.absLeft(button), window.dhx4.absTop(button)+button.offsetHeight);
					this.conf.opened_menu = data.id;
				}
				menu = button = null;
				
			}
			
		}
		
		this._hideContextMenu = function(e) {
			
			if (e != null) {
				e = e||event;
				if (e.type == "keydown" && e.keyCode != 27) return;
				
				var t = e.target||e.srcElement;
				var m = true;
				while (t != null && m == true) {
					if (t.className != null && t.className.search(/SubLevelArea_Polygon/) >= 0) {
						m = false;
					} else {
						t = t.parentNode;
					}
				}
			}
			
			if (m || e == null) {
				if (that.cm.global != null) that.cm.global.hideContextMenu();
				for (var a in that.cm.icon) {
					if (that.cm.icon[a] != null) that.cm.icon[a].hideContextMenu();
				}
				for (var a in that.cm.button) {
					for (var b in that.cm.button[a]) {
						if (that.cm.button[a][b] != null) that.cm.button[a][b].hideContextMenu();
					}
				}
			}
			
		}
		
		this._detachContextMenu = function(mode, wId, bId) {
			if (this.cm == null) return;
			if (wId == null) {
				if (this.cm.global != null) {
					this.cm.global.unload();
					this.cm.global = null;
				}
			} else if (mode == "icon") {
				if (this.cm.icon[wId] != null) {
					this.cm.icon[wId].unload();
					this.cm.icon[wId] = null;
				}
			} else if (mode == "button") {
				if (this.cm.button[wId] != null && this.cm.button[wId][bId] != null) {
					this.cm.button[wId][bId].unload();
					this.cm.button[wId][bId] = null;
				}
			}
			
		}
		
		this.attachEvent("_winMouseDown", this._showContextMenu);
		
		if (typeof(window.addEventListener) == "function") {
			window.addEventListener("mousedown", this._hideContextMenu, false);
			window.addEventListener("keydown", this._hideContextMenu, false);
		} else {
			document.body.attachEvent("onmousedown", this._hideContextMenu);
			document.body.attachEvent("onkeydown", this._hideContextMenu);
		}
		
		this._unloadContextMenu = function() {
			
			// remove only global menu if any, other will removed from win/button unload
			this._detachContextMenu("icon", null, null);
			this.cm = null;
			
			if (typeof(window.addEventListener) == "function") {
				window.removeEventListener("mousedown", this._hideContextMenu, false);
				window.removeEventListener("keydown", this._hideContextMenu, false);
			} else {
				document.body.detachEvent("onmousedown", this._hideContextMenu);
				document.body.detachEvent("onkeydown", this._hideContextMenu);
			}
			
			that = null;
		}
		
	}
	
	return menu;
};


/*
Product Name: dhtmlxSuite 
Version: 4.1.3 
Edition: Professional 
License: content of this file is covered by DHTMLX Commercial or Enterprise license. Usage without proper license is prohibited. To obtain it contact sales@dhtmlx.com
Copyright UAB Dinamenta http://www.dhtmlx.com
*/

if(!window.dhtmlx)
	window.dhtmlx = {};

(function(){
	var _dhx_msg_cfg = null;
	function callback(config, result){
			var usercall = config.callback;
			modality(false);
			config.box.parentNode.removeChild(config.box);
			_dhx_msg_cfg = config.box = null;
			if (usercall)
				usercall(result);
	}
	function modal_key(e){
		if (_dhx_msg_cfg){
			e = e||event;
			var code = e.which||event.keyCode;
			if (dhtmlx.message.keyboard){
				if (code == 13 || code == 32)
					callback(_dhx_msg_cfg, true);
				if (code == 27)
					callback(_dhx_msg_cfg, false);
			}
			if (e.preventDefault)
				e.preventDefault();
			return !(e.cancelBubble = true);
		}
	}
	if (document.attachEvent)
		document.attachEvent("onkeydown", modal_key);
	else
		document.addEventListener("keydown", modal_key, true);
		
	function modality(mode){
		if(!modality.cover){
			modality.cover = document.createElement("DIV");
			//necessary for IE only
			modality.cover.onkeydown = modal_key;
			modality.cover.className = "dhx_modal_cover";
			document.body.appendChild(modality.cover);
		}
		var height =  document.body.scrollHeight;
		modality.cover.style.display = mode?"inline-block":"none";
	}

	function button(text, result){
		return "<div class='dhtmlx_popup_button' result='"+result+"' ><div>"+text+"</div></div>";
	}

	function info(text){
		if (!t.area){
			t.area = document.createElement("DIV");
			t.area.className = "dhtmlx_message_area";
			t.area.style[t.position]="5px";
			document.body.appendChild(t.area);
		}

		t.hide(text.id);
		var message = document.createElement("DIV");
		message.innerHTML = "<div>"+text.text+"</div>";
		message.className = "dhtmlx-info dhtmlx-" + text.type;
		message.onclick = function(){
			if (text) t.hide(text.id);
			text = null;
		};

		if (t.position == "bottom" && t.area.firstChild)
			t.area.insertBefore(message,t.area.firstChild);
		else
			t.area.appendChild(message);
		
		if (text.expire > 0)
			t.timers[text.id]=window.setTimeout(function(){
				t.hide(text.id);
			}, text.expire);

		t.pull[text.id] = message;
		message = null;

		return text.id;
	}
	function _boxStructure(config, ok, cancel){
		var box = document.createElement("DIV");
		box.className = " dhtmlx_modal_box dhtmlx-"+config.type;
		box.setAttribute("dhxbox", 1);
			
		var inner = '';

		if (config.width)
			box.style.width = config.width;
		if (config.height)
			box.style.height = config.height;
		if (config.title)
			inner+='<div class="dhtmlx_popup_title">'+config.title+'</div>';
		inner+='<div class="dhtmlx_popup_text"><span>'+(config.content?'':config.text)+'</span></div><div  class="dhtmlx_popup_controls">';
		if (ok)
			inner += button(config.ok || "OK", true);
		if (cancel)
			inner += button(config.cancel || "Cancel", false);
		if (config.buttons){
			for (var i=0; i<config.buttons.length; i++)
				inner += button(config.buttons[i],i);
		}
		inner += '</div>';
		box.innerHTML = inner;

		if (config.content){
			var node = config.content;
			if (typeof node == "string") 
				node = document.getElementById(node);
			if (node.style.display == 'none')
				node.style.display = "";
			box.childNodes[config.title?1:0].appendChild(node);
		}

		box.onclick = function(e){
			e = e ||event;
			var source = e.target || e.srcElement;
			if (!source.className) source = source.parentNode;
			if (source.className == "dhtmlx_popup_button"){
				var result = source.getAttribute("result");
				result = (result == "true")||(result == "false"?false:result);
				callback(config, result);
			}
		};
		config.box = box;
		if (ok||cancel)
			_dhx_msg_cfg = config;

		return box;
	}
	function _createBox(config, ok, cancel){
		var box = config.tagName ? config : _boxStructure(config, ok, cancel);
		
		if (!config.hidden)
			modality(true);
		document.body.appendChild(box);
		var x = config.left||Math.abs(Math.floor(((window.innerWidth||document.documentElement.offsetWidth) - box.offsetWidth)/2));
		var y = config.top||Math.abs(Math.floor(((window.innerHeight||document.documentElement.offsetHeight) - box.offsetHeight)/2));
		if (config.position == "top")
			box.style.top = "-3px";
		else
			box.style.top = y+'px';
		box.style.left = x+'px';
		//necessary for IE only
		box.onkeydown = modal_key;

		box.focus();
		if (config.hidden)
			dhtmlx.modalbox.hide(box);

		return box;
	}

	function alertPopup(config){
		return _createBox(config, true, false);
	}
	function confirmPopup(config){
		return _createBox(config, true, true);
	}
	function boxPopup(config){
		return _createBox(config);
	}
	function box_params(text, type, callback){
		if (typeof text != "object"){
			if (typeof type == "function"){
				callback = type;
				type = "";
			}
			text = {text:text, type:type, callback:callback };
		}
		return text;
	}
	function params(text, type, expire, id){
		if (typeof text != "object")
			text = {text:text, type:type, expire:expire, id:id};
		text.id = text.id||t.uid();
		text.expire = text.expire||t.expire;
		return text;
	}
	dhtmlx.alert = function(){
		var text = box_params.apply(this, arguments);
		text.type = text.type || "confirm";
		return alertPopup(text);
	};
	dhtmlx.confirm = function(){
		var text = box_params.apply(this, arguments);
		text.type = text.type || "alert";
		return confirmPopup(text);
	};
	dhtmlx.modalbox = function(){
		var text = box_params.apply(this, arguments);
		text.type = text.type || "alert";
		return boxPopup(text);
	};
	dhtmlx.modalbox.hide = function(node){
		while (node && node.getAttribute && !node.getAttribute("dhxbox"))
			node = node.parentNode;
		if (node){
			node.parentNode.removeChild(node);
			modality(false);
			_dhx_msg_cfg = null;
		}
	};
	var t = dhtmlx.message = function(text, type, expire, id){
		text = params.apply(this, arguments);
		text.type = text.type||"info";

		var subtype = text.type.split("-")[0];
		switch (subtype){
			case "alert":
				return alertPopup(text);
			case "confirm":
				return confirmPopup(text);
			case "modalbox":
				return boxPopup(text);
			default:
				return info(text);
			break;
		}
	};

	t.seed = (new Date()).valueOf();
	t.uid = function(){return t.seed++;};
	t.expire = 4000;
	t.keyboard = true;
	t.position = "top";
	t.pull = {};
	t.timers = {};

	t.hideAll = function(){
		for (var key in t.pull)
			t.hide(key);
	};
	t.hide = function(id){
		var obj = t.pull[id];
		if (obj && obj.parentNode){
			window.setTimeout(function(){
				obj.parentNode.removeChild(obj);
				obj = null;
			},2000);
			obj.className+=" hidden";
			
			if(t.timers[id])
				window.clearTimeout(t.timers[id]);
			delete t.pull[id];
		}
	};
})();

/*
Product Name: dhtmlxVault 
Version: 2.3 
Edition: Standard 
License: content of this file is covered by GPL. Usage outside GPL terms is prohibited. To obtain Commercial or Enterprise license contact sales@dhtmlx.com
Copyright UAB Dinamenta http://www.dhtmlx.com
*/

function dhtmlXVaultObject(conf) {
	
	var that = this;
	
	this.conf = {
		version: "2.3",
		skin: (conf.skin||window.dhx4.skin||(typeof(dhtmlx)!="undefined"?dhtmlx.skin:null)||window.dhx4.skinDetect("dhxvault")||"dhx_skyblue"),
		param_name: (typeof(conf.paramName)!="undefined"?conf.paramName:"file"),
		engine: null,
		list: "list_default",
		url: conf.uploadUrl||"",
		// multiple files, html5/flash only
		multiple_files: (typeof(conf.multiple)!="undefined"?conf.multiple==true:true),
		// swf-file path
		swf_file: conf.swfPath||"",
		swf_url:  conf.swfUrl||"",
		swf_logs: conf.swfLogs||"no",
		// sl-data
		sl_xap:  conf.slXap,
		sl_url:  conf.slUrl,
		sl_logs: conf.slLogs,
		// common
		enabled: true,
		auto_start: (typeof(conf.autoStart)!="undefined"?conf.autoStart==true:true), // true by default
		auto_remove: (typeof(conf.autoRemove)!="undefined"?conf.autoRemove==true:false), // false by default
		files_added: 0,
		uploaded_count: 0,
		files_limit: (typeof(conf.filesLimit)!="undefined"?conf.filesLimit:0), // max files
		max_file_size: 0, // can be truth if > 0
		buttons: { // visible buttons
			upload: (typeof(conf.buttonUpload)!="undefined"?(conf.buttonUpload==true):false),
			clear: (typeof(conf.buttonClear)!="undefined"?(conf.buttonClear==true):true)
		},
		// offsets
		ofs: {
			dhx_skyblue: 5,
			dhx_web: 7,
			dhx_terrace: 10,
			bootstrap: 10
		},
		// data
		uploaded_state: {}, // save state tru/false for uploaded or failed
		uploaded_files: {}, // uploaded files data
		// progress mode
		progress_mode: "percent", // "percent","eta"
		// icons
		icon_def: "",
		icons: {} // generated
	}
	
	this.list = new this[this.conf.list]();
	
	// icons
	this.conf.icon_def = this.icon_def;
	for (var a in this.icons) {
		for (var q=0; q<this.icons[a].length; q++) this.conf.icons[this.icons[a][q]] = a;
	}
	
	// engine detect
	if (typeof(conf.mode) == "string" && typeof(this[conf.mode]) == "function") {
		this.conf.engine = conf.mode;
	} else {
		this.conf.engine = "html4";
		
		var k = null;
		if (typeof(window.FormData) != "undefined" && typeof(window.XMLHttpRequest) != "undefined") {
			k = new XMLHttpRequest();
			if (typeof(k.upload) == "undefined") k = null;
		}
		
		if (k != null) {
			// IE10, IE11, FF, Chrome, Opera
			this.conf.engine = "html5";
		} else if (typeof(window.swfobject) != "undefined" || k === false) {
			var k = swfobject.getFlashPlayerVersion();
			if (k.major >= 10) this.conf.engine = "flash";
		} else {
			// check if silverlight installed
			this.conf.sl_v = this.getSLVersion();
			if (this.conf.sl_v) this.conf.engine = "sl";
		}
		k = null;
	}
	
	var base = (typeof(conf.parent) != "undefined" ? conf.parent : conf.container);
	base = (typeof(base)=="string"?document.getElementById(base):base);
	conf.parent = conf.container = null;
	
	if (base._attach_mode == true) {
		this.base = base;
	} else {
		this.base = document.createElement("DIV");
		base.appendChild(this.base);
	}
	this.base.className += " dhx_vault_"+this.conf.skin;
	if (base._no_border == true) this.base.style.border = "0px solid white";
	
	base = conf = null;
	
	// buttons
	this.p_controls = document.createElement("DIV");
	this.p_controls.className = "dhx_vault_controls";
	this.base.appendChild(this.p_controls);
	this.p_controls.onselectstart = function(e){
		e = e||event;
		if (e.preventDefault) e.preventDefault(); else e.returnValue = false;
		return false;
	}
	
	// files
	this.p_files = document.createElement("DIV");
	this.p_files.className = "dhx_vault_files";
	this.base.appendChild(this.p_files);
	
	this._doOnFilesClick = function(e) {
		e = e||event;
		var t = e.target||e.srcElement;
		var action = null;
		while (t != that.p_files && action == null) {
			if (action == null && t != null && t._action != null) {
				action = t._action;
			} else {
				t = t.parentNode;
			}
		}
		if (action == null) return;
		if (action.data == "delete_file") {
			if (that.conf.enabled)
				that._removeFileFromQueue(action.id);

		}else if (action.data == "show_file") {
			if(that.conf.wnd)
				that.conf.wnd.progressOn();
			$p.ajax.get_and_show_blob(that.actionUrl(action.id, "get"), "", function(){
				if(that.conf.wnd)
					that.conf.wnd.progressOff();
			});
		}
	}
	if (typeof(window.addEventListener) == "function") {
		this.p_files.addEventListener("click", this._doOnFilesClick, false);
	} else {
		this.p_files.attachEvent("onclick", this._doOnFilesClick);
	}
	
	this.file_data = {};
	
	this._initToolbar = function() {
		
		// add
		this.b_opts = {
			browse:	{ str: "btnAdd", onclick: null },
			upload:	{ str: "btnUpload", onclick: function() { if (!that.conf.enabled) return; if (!that.conf.uploading) { that._uploadStart(); } } },
			cancel:	{ str: "btnCancel", onclick: function() { if (!that.conf.enabled) return; that._uploadStop(); that._switchButton(false); } },
			clear:	{ str: "btnClean", onclick: function() { if (!that.conf.enabled) return; that.clear(); }, css: "float:right!important;"}
		};
		
		this.buttons = {};
		
		for (var a in this.b_opts) {
			var k = document.createElement("DIV");
			k.innerHTML = "<div class='dhxvault_button_icon dhx_vault_icon_"+a+"'></div>"+
					"<div class='dhxvault_button_text'>"+this.strings[this.b_opts[a].str]+"</div>";
			
			if (this.b_opts[a].css != null) k.style.cssText += this.b_opts[a].css;
			k.className = "dhx_vault_button";
			k._css = k.className;
			k._onclick = this.b_opts[a].onclick;
			k.onmouseover = function() {
				if (that.conf.enabled != true) return;
				if (this._hover == true) return;
				this._hover = true;
				this.className = this._css+" dhx_vault_button"+this._css_p+"_hover";
			}
			k.onmouseout = function() {
				if (that.conf.enabled != true) return;
				if (this._hover != true) return;
				this._hover = false;
				this.className = this._css;
			}
			k.onmousedown = function() {
				if (that.conf.enabled != true) return;
				if (this._hover != true) return;
				this._pressed = true;
				this.className = this._css+" dhx_vault_button"+this._css_p+"_pressed";
			}
			k.onmouseup = function(e) {
				if (that.conf.enabled != true) return;
				if (this._pressed != true) return;
				this._pressed = false;
				this.className = this._css+(this._hover?" dhx_vault_button"+this._css_p+"_hover":"");
				if (this._onclick != null) this._onclick();
			}
			if (this.b_opts[a].tooltip) k.title = this.b_opts[a].tooltip;
			this.p_controls.appendChild(k);
			this.buttons[a] = k;
			k = null;
			
			// visibile
			if (a == "upload" || a == "clear") this.buttons[a].style.display = (this.conf.buttons[a] == true?"":"none");
			
			this.b_opts[a].onclick = null;
			this.b_opts[a] = null;
			delete this.b_opts[a];
		}
		
		this.b_opts = null;
		delete this.b_opts;
		
		this.buttons.cancel.style.display = "none";
	}
	
	this._readableSize = function(t) {
		var i = false;
		var b = ["b","Kb","Mb","Gb","Tb","Pb","Eb"];
		for (var q=0; q<b.length; q++) if (t > 1024) t = t / 1024; else if (i === false) i = q;
		if (i === false) i = b.length-1;
		return Math.round(t*100)/100+" "+b[i];
	}
	
	this._beforeAddFileToList = function(name, size, lastModifiedDate) {
		return (this.callEvent("onBeforeFileAdd", [{
			id: null,
			name: name,
			size: size,
			lastModifiedDate: lastModifiedDate,
			serverName: null,
			uploaded: false,
			error: false
		}])===true);
	}
	
	this._addFileToList = function(id, name, size, state, progress) {
		
		var ext = this.getFileExtension(name),
			icon = (ext.length>0?(this.conf.icons[ext.toLowerCase()]||this.conf.icon_def):this.conf.icon_def);
		
		// add div for new file
		this.list.addFileItem(id, this.p_files);
		
		// render file in list
		this.list.renderFileRecord(id, {name: name, icon: icon, size: size, readableSize: this._readableSize(size||0), state: state, progress: progress});
		
		this.callEvent("onFileAdd", [{
			id: id,
			name: name,
			size: size,
			lastModifiedDate: this.file_data[id].file.lastModifiedDate||null,
			serverName: null,
			uploaded: false,
			error: false
		}]);
		
	}
	
	this._removeFileFromList = function(id) {
		
		// remove div from list
		this.list.removeFileRecord(id);
		
		if (this.conf.uploaded_files[id] != null) {
			this.conf.uploaded_files[id] = null;
			delete this.conf.uploaded_files[id];
		}
		
		if (this.conf.uploaded_state[id] != null) {
			this.conf.uploaded_state[id] = null;
			delete this.conf.uploaded_state[id];
		}
		
	}
	
	this._updateFileInList = function(id, state, progress) {
		if (this.list.isFileItemExist(id) == false) return;
		if (state == "uploading" && this.conf.progress_mode == "eta" && this._etaStart != null) this._etaStart(id);
		// progress
		this._updateProgress(id, state, progress);
	}
	
	this._updateProgress = function(id, state, progress) {
		if (state == "added") {
			this.list.updateFileState(id, {state: state});
			if (this.conf.progress_mode == "eta" && this._etaEnd != null) this._etaEnd(id);
			return;
		}
		if (state == "fail") {
			this.list.updateFileState(id, {state: state, str_error: this.strings.error});
			if (this.conf.progress_mode == "eta" && this._etaEnd != null) this._etaEnd(id);
			return;
		}
		if (state == "uploaded") {
			if (this.conf.progress_mode == "eta" && this._etaEnd != null) this._etaEnd(id);
			var str_done = this.strings.done;
			var nameSizeData = (this.conf.engine != "html4" ? null : {name: this.file_data[id].name, size: this.file_data[id].size, readableSize: this._readableSize(this.file_data[id].size||0)}); // for html4 mode - update size
			window.setTimeout(function(){
				that.list.updateFileState(id, {state: "uploaded", str_done: str_done});
				if (nameSizeData != null) that.list.updateFileNameSize(id, nameSizeData);
			}, 100); // for very little files or goood internet line
			return;
		}
		if (state == "uploading") {
			if ((progress < 100 && this.conf.progress_type == "loader") || this.file_data[id].custom == true) {
				/* html4 mode or custom record - no progress */
				this.list.updateFileState(id, {state: "uploading_html4"});
			} else if (this.conf.progress_mode == "eta") {
				var eta = (this._etaCheck!=null?this._etaCheck(id,progress):null);
				this.list.updateFileState(id, {state: "uploading", progress: progress, eta: (eta==null?null:"eta: "+eta)});
			} else if (this.conf.progress_mode == "percent") {
				this.list.updateFileState(id, {state: "uploading", progress: progress, eta: progress+"%"});
			}
		}
	}
	
	this._removeFilesByState = function(state) {
		for (var a in this.file_data) {
			if (state === true || this.file_data[a].state == state) {
				this._removeFileFromQueue(a);
			}
		}
	}
	
	this._switchButton = function(state) {
		
		if (state == true) {
			if (this.conf.buttons.upload == true) {
				this.buttons.upload.style.display = "none";
				this.buttons.cancel.style.display = "";
			}
		} else {
			var t = this.conf.uploaded_count;
			var f = [];
			for (var a in this.conf.uploaded_state) {
				f.push({
					id: a,
					name: this._fileName,
					size: (this.file_data[a]!=null?this.file_data[a].size:null),
					lastModifiedDate: (this.file_data[a]!=null?(this.file_data[a].file.lastModifiedDate||null):null),
					serverName: (this.conf.uploaded_files[a]?this.conf.uploaded_files[a].serverName:null),
					uploaded: this.conf.uploaded_state[a],
					error: !this.conf.uploaded_state[a]
				});
			}
			if (this.conf.buttons.upload == true) {
				this.buttons.upload.style.display = "";
				this.buttons.cancel.style.display = "none";
			}
			this.conf.uploaded_count = 0;
			this.conf.uploaded_state = {};
			if (t > 0) this.callEvent("onUploadComplete",[f]);
		}
	}
	
	this._uploadStart = function() {
		
		this._switchButton(true);
		
		// change status for prev fail auploads if any
		if (!this.conf.uploading) {
			for (var a in this.file_data) {
				if (this.file_data[a].state == "fail") {
					this.file_data[a].state = "added";
					this._updateFileInList(a, "added", 0);
				}
			}
		}
		
		this.conf.uploading = true;
		
		var t = false;
		
		for (var a in this.file_data) {
			if (!t && [this.file_data[a].state] == "added") {
				t = true;
				this.file_data[a].state = "uploading";
				this._updateFileInList(a, "uploading", 0);
				this._doUploadFile(a);
			}
		}
		if (!t) {
			this.conf.uploading = false;
			this._switchButton(false);
		}
		
	}
	
	this._onUploadSuccess = function(id, serverName, r, extra) {
		
		// flash mode
		if (typeof(r) != "undefined" && this.conf.engine == "flash") {
			try {eval("dhx4.temp="+r.data);} catch(e){dhx4.temp=null;};
			var t = dhx4.temp;
			dhx4.temp = null;
			if (t != null && t.state == true && t.name != null) {
				serverName = t.name;
				if (t.extra != null) extra = t.extra;
			} else {
				this._onUploadFail(id, (t!=null&&t.extra!=null?t.extra:null));
				return;
			}
		}
		//
		this.conf.uploaded_count++;
		this.conf.uploaded_files[id] = {realName: this.file_data[id].name, serverName: serverName};
		this.file_data[id].state = "uploaded";
		this.conf.uploaded_state[id] = true;
		this._updateFileInList(id, "uploaded", 100);
		this.callEvent("onUploadFile", [{
			id: id,
			name: this.file_data[id].name,
			size: this.file_data[id].size,
			lastModifiedDate: this.file_data[id].file.lastModifiedDate||null,
			serverName: serverName,
			uploaded: true,
			error: false
		}, extra]);
		if (this.conf.auto_remove) this._removeFileFromQueue(id);
		if (this.conf.uploading) this._uploadStart();
	}
	
	this._onUploadFail = function(id, extra) {
		this.file_data[id].state = "fail";
		this._updateFileInList(id, "fail", 0);
		this.conf.uploaded_state[id] = false;
		this.callEvent("onUploadFail", [{
			id: id,
			name: this.file_data[id].name,
			size: this.file_data[id].size,
			lastModifiedDate: this.file_data[id].file.lastModifiedDate||null,
			serverName: null,
			uploaded: false,
			error: true
		}, extra]);
		if (this.conf.uploading) this._uploadStart();
	}
	
	this._onUploadAbort = function(id) {
		this.conf.uploading = false;
		this.file_data[id].state = "added";
		this._updateFileInList(id, "added", 0);
		this.callEvent("onUploadCancel",[{
			id: id,
			name: this.file_data[id].name,
			size: this.file_data[id].size,
			lastModifiedDate: this.file_data[id].file.lastModifiedDate,
			serverName: null,
			uploaded: false,
			error: false
		}]);
	}
	
	this.unload = function() {
		
		this.callEvent = function(){return true;}; // some events while files will removed from list
		
		//
		if (typeof(window.addEventListener) == "function") {
			this.p_files.removeEventListener("click", this._doOnFilesClick, false);
		} else {
			this.p_files.detachEvent("onclick", this._doOnFilesClick);
		}
		
		// remove all files from queue/list
		this._removeFilesByState(true);
		this.conf.uploaded_files = null;
		this.file_data = null;
		
		// custom engine stuff
		this._unloadEngine();
		
		this.list.unload();
		this.list = null;
		this.icons = null;
		
		// buttons
		for (var a in this.buttons) {
			this.buttons[a].onclick = null;
			this.buttons[a].onmouseover = null;
			this.buttons[a].onmouseout = null;
			this.buttons[a].onmousedown = null;
			this.buttons[a].onmouseup = null;
			this.buttons[a]._onclick = null;
			this.buttons[a].parentNode.removeChild(this.buttons[a]);
			this.buttons[a] = null;
			delete this.buttons[a];
		}
		this.buttons = null;
		
		// buttons container
		this.p_controls.onselectstart = null;
		this.p_controls.parentNode.removeChild(this.p_controls);
		this.p_controls = null;
		
		// buttons container
		this.p_files.parentNode.removeChild(this.p_files);
		this.p_files = null;
		
		window.dhx4._eventable(this, "clear");
		this.callEvent = null;
		
		for (var a in this.conf) {
			this.conf[a] = null;
			delete this.conf[a];
		}
		this.conf = null;
		this.strings = null;
		
		for (var a in this) {
			if (typeof(this[a]) == "function") this[a] = null;
		}
		
		// main container
		if (this.base._attach_mode != true) this.base.parentNode.removeChild(this.base);
		this.base = null;
		
		that = a = null;
		
	}
	
	// init engine-relative funcs
	var e = new this[this.conf.engine]();
	for (var a in e) { this[a] = e[a]; e[a] = null; }
	a = e = p = null;
	
	// init app
	this._initToolbar();
	this._initEngine();
	this.setSkin(this.conf.skin);
	
	window.dhx4._eventable(this);
	
	// files limit
	this.attachEvent("onFileAdd", function(){
		this.conf.files_added++;
	});
	this.attachEvent("onBeforeFileAdd", function(){
		if (this.conf.files_limit == 0) return true;
		return (this.conf.files_added < this.conf.files_limit);
	});

	/**
	 * формирует urd для обращения к сервису 1С Builder:files
	 * @param id - идентификатор файла
	 * @param mode - действие "get" или "drop"
	 * @returns {string}
	 */
	this.actionUrl = function(id, mode){
		var name = this.file_data[id].name,
			ext = this.getFileExtension(name),
			url = this.conf.url + (this.conf.url.indexOf("?")<0 ? "?" : "&") + "mode=" +mode+"&name=";
		name = name.replace("." + ext, "");
		url += name + "&extension=" + ext;
		return url;
	};

	// server settings if any + начальный список
	$p.ajax.post_ex(this.conf.url + (this.conf.url.indexOf("?")<0 ? "?" : "&") + "mode=conf", "", true)
		.then(function(req) {
			return JSON.parse(req.responseText)
		}).then(function (t) {
			if (that && t) {
				if (t.maxFileSize != null)
					that.conf.max_file_size = parseInt(t.maxFileSize);
				if(t.hasOwnProperty("list")){
					for(var li in t.list){
						that.file_data[t.list[li].ref] = {
							file: {lastModifiedDate: new Date(t.list[li].lastModifiedDate)},
							size: t.list[li].size,
							name: t.list[li].name,
							state: "uploaded"
						};
						that._addFileToList(t.list[li].ref, t.list[li].name, t.list[li].size);
					}
				}
			}
		}).catch(function (err) {
			console.log(err);
		});

	return this;
	
};

dhtmlXVaultObject.prototype.icon_def = "icon_def";
dhtmlXVaultObject.prototype.icons = {
	// css => list_of_extensions
	icon_image:	["jpg", "jpeg", "gif", "png", "bmp", "tiff", "pcx", "svg", "ico"],
	icon_psd:	["psd"],
	icon_video:	["avi", "mpg", "mpeg", "rm", "move", "mov", "mkv", "flv", "f4v", "mp4", "3gp"],
	icon_audio:	["wav", "aiff", "au", "mp3", "aac", "wma", "ogg", "flac", "ape", "wv", "m4a", "mid", "midi"],
	icon_arch:	["rar", "zip", "tar", "tgz", "arj", "gzip", "bzip2", "7z", "ace", "apk", "deb"],
	icon_text:	["txt", "nfo", "djvu", "xml"],
	icon_html:	["htm", "html"],
	icon_doc:	["doc", "docx", "rtf", "odt"],
	icon_xls:	["xls", "xlsx"],
	icon_pdf:	["pdf", "ps"],
	icon_exe:	["exe"],
	icon_dmg:	["dmg"]
};

dhtmlXVaultObject.prototype.upload = function() {
	if (!this.conf.uploading) this._uploadStart();
};

dhtmlXVaultObject.prototype.setAutoStart = function(state) {
	this.conf.auto_start = (state==true);
};

dhtmlXVaultObject.prototype.setAutoRemove = function(state) {
	this.conf.auto_remove = (state==true);
};

dhtmlXVaultObject.prototype.setURL = function(url) {
	this.conf.url = url;
};

dhtmlXVaultObject.prototype.enable = function() {
	if (this.conf.enabled == true) return;
	this.conf.enabled = true;
	this.base.className = String(this.base.className).replace(/\s{0,}dhx_vault_dis/gi,"");
	//this.p_files.className = "dhx_vault_files";
	//this.p_controls.className = "dhx_vault_controls";
	if (this.conf.engine == "flash") document.getElementById(this.conf.swf_obj_id).style.display = "";
};

dhtmlXVaultObject.prototype.disable = function() {
	if (this.conf.enabled != true) return;
	this.conf.enabled = false;
	this.base.className += " dhx_vault_dis";
	// this.p_files.className = "dhx_vault_files dhx_vault_dis";
	// this.p_controls.className = "dhx_vault_controls dhx_vault_dis";
	if (this.conf.engine == "flash") document.getElementById(this.conf.swf_obj_id).style.display = "none";
};

dhtmlXVaultObject.prototype.setWidth = function(w) { // set width of the control in pixels
	if (this.base._attach_mode == true) return;
	this.base.parentNode.style.width = w+"px";
	this.setSizes();
};

dhtmlXVaultObject.prototype.setHeight = function(h) { // set height of the control in pixels
	if (this.base._attach_mode == true) return;
	this.base.parentNode.style.height = h+"px";
	this.setSizes();
};

dhtmlXVaultObject.prototype.setFilesLimit = function(t) { // control the number of uploaded files
	this.conf.files_added = 0; // reset old settings
	this.conf.files_limit = t;
};

dhtmlXVaultObject.prototype.getStatus = function() {
	// 0 - filelist is empty
	// 1 - all files in filelist uploaded
	//-1 - not all files uploaded
	var t = 0;
	for (var a in this.file_data) {
		if (this.file_data[a].state != "uploaded") return -1;
		t = 1;
	}
	return t;
};

dhtmlXVaultObject.prototype.getData = function() {
	// return struct of uploaded files
	var t = [];
	for (var a in this.conf.uploaded_files) {
		t.push({
			id: a,
			name: this.file_data[a].name,
			size: this.file_data[a].size,
			serverName: this.conf.uploaded_files[a].serverName,
			uploaded: true,
			error: false
		});
	}
	return t;
};

dhtmlXVaultObject.prototype.clear = function() {
	if (this.callEvent("onBeforeClear", []) !== true) return;
	if (this.conf.uploading) this._uploadStop();
	this._switchButton(false);
	this._removeFilesByState(true);
	this.callEvent("onClear",[]);
};

dhtmlXVaultObject.prototype.setSkin = function(skin) {
	if (skin != this.conf.skin) {
		this.base.className = String(this.base.className).replace(new RegExp("\s{0,}dhx_vault_"+this.conf.skin)," dhx_vault_"+skin);
		this.conf.skin = skin;
	}
	
	// update buttons data
	this._updateBttonsSkin();
	
	
	var ofs = this.conf.ofs[this.conf.skin];
	
	this.buttons.browse.style.marginLeft = ofs+"px";
	this.buttons.upload.style.marginLeft = (skin=="dhx_terrace"?"-1px":ofs+"px");
	this.buttons.cancel.style.marginLeft = this.buttons.upload.style.marginLeft;
	this.buttons.clear.style.marginRight = ofs+"px";
	
	// border-radius
	var r = "";
	if (skin == "dhx_terrace") {
		r = (this.conf.buttons.upload == true) ? "0px":"3px";
	}
	
	this.buttons.browse.style.borderTopRightRadius = r;
	this.buttons.browse.style.borderBottomRightRadius = r;
	this.buttons.upload.style.borderTopLeftRadius = r;
	this.buttons.upload.style.borderBottomLeftRadius = r;
	this.buttons.cancel.style.borderTopLeftRadius = this.buttons.upload.style.borderTopLeftRadius;
	this.buttons.cancel.style.borderBottomLeftRadius = this.buttons.upload.style.borderBottomLeftRadius;
	
	this.setSizes();
};

dhtmlXVaultObject.prototype._updateBttonsSkin = function() {
	for (var a in this.buttons) {
		var css = "dhx_vault_button";
		var css_p = "";
		if (this.buttonCss != null && this.buttonCss[this.conf.skin] != null && this.buttonCss[this.conf.skin][a] != null) {
			css_p = this.buttonCss[this.conf.skin][a];
			css += css_p;
		}
		this.buttons[a]._css = this.buttons[a].className = css;
		this.buttons[a]._css_p = css_p;
	}
};

dhtmlXVaultObject.prototype.setSizes = function() {
	
	var w1 = this.base.offsetWidth-(this.base.clientWidth||this.base.scrollWidth);
	var h1 = this.base.offsetHeight-this.base.clientHeight;
	
	this.base.style.width = Math.max(0, this.base.parentNode.clientWidth-w1)+"px";
	this.base.style.height = Math.max(0, this.base.parentNode.clientHeight-h1)+"px";
	
	var ofs = this.conf.ofs[this.conf.skin];
	this.p_files.style.top = this.p_controls.offsetHeight+"px";
	this.p_files.style.left = ofs+"px";
	if (!this.conf.ofs_f) {
		this.p_files.style.width = "100px";
		this.p_files.style.height = "100px";
		this.conf.ofs_f = {
			w: this.p_files.offsetWidth-this.p_files.clientWidth,
			h: this.p_files.offsetHeight-this.p_files.clientHeight
		};
	}
	
	this.p_files.style.width = Math.max(this.base.clientWidth-ofs*2-this.conf.ofs_f.w,0)+"px";
	this.p_files.style.height = Math.max(this.base.clientHeight-this.p_controls.offsetHeight-ofs-this.conf.ofs_f.h,0)+"px";
	
	if (typeof(this.callEvent) == "function") {
		// dataload progress
		this.callEvent("_onSetSizes", []);
	}
	
};

dhtmlXVaultObject.prototype.getFileExtension = function(name) {
	var ext = "";
	var k = String(name).match(/\.([^\.\s]*)$/i); // "filename.jpg" -> [".jpg","jpg"]
	if (k != null) ext = k[1];
	return ext;
};

dhtmlXVaultObject.prototype.strings = {
	// labels
	done: "Готово",
	error: "Ошибка",
	// buttons
	btnAdd: "Добавить файлы",
	btnUpload: "Загрузить",
	btnClean: "Очистить",
	btnCancel: "Отмена"
};

dhtmlXVaultObject.prototype.setStrings = function(data) {
	for (var a in data) this.strings[a] = data[a];
	// update files in list
	for (var a in this.file_data) {
		var state = this.file_data[a].state;
		if (state == "uploaded" || state == "fail") {
			this.list.updateFileState(a, {
				state: state,
				str_error: this.strings.error,
				str_done: this.strings.done
			});
		}
	}
	// update buttons
	var t = {browse: "btnAdd", upload: "btnUpload", clear: "btnClean", cancel: "btnCancel"};
	for (var a in t) this.buttons[a].childNodes[1].innerHTML = this.strings[t[a]];
	
};

dhtmlXVaultObject.prototype.getMaxFileSize = function() {
	return this.conf.max_file_size;
};

/****************************************************************************************************************************************************************************************************************/
//	HTML 5

dhtmlXVaultObject.prototype.html5 = function(){};
dhtmlXVaultObject.prototype.html5.prototype = {
	
	_initEngine: function() {
		
		var that = this;
		this.buttons["browse"].onclick = function(){
			if (that.conf.enabled) that.f.click();
		}
		
		this.conf.progress_type = "percentage";
		this.conf.dnd_enabled = true;
		
		// Safari on Windows sometimes have problem with multiple file selections
		// file length set to zero, do not allow multiple file selecting
		// d-n-d seems works fine
		
		var k = window.navigator.userAgent;
		var mp = true;
		if (k.match(/Windows/gi) != null && k.match(/AppleWebKit/gi) != null && k.match(/Safari/gi) != null) {
			if (k.match(/Version\/5\.1\.5/gi)) this.conf.multiple_files = false;
			if (k.match(/Version\/5\.1[^\.\d{1,}]/gi)) this.conf.dnd_enabled = false;
			if (k.match(/Version\/5\.1\.1/gi)) {
				this.conf.multiple_files = false;
				this.conf.dnd_enabled = false;
			}
			if (k.match(/Version\/5\.1\.2/gi)) this.conf.dnd_enabled = false;
			if (k.match(/Version\/5\.1\.7/gi)) this.conf.multiple_files = false;
		}
		
		// "Mozilla/5.0 (Windows; U; Windows NT 6.1; en-EN) AppleWebKit/533.21.1 (KHTML, like Gecko) Version/5.0.1 Safari/533.17.8"	// ok, no dnd
		// "Mozilla/5.0 (Windows; U; Windows NT 6.1; en-EN) AppleWebKit/533.21.1 (KHTML, like Gecko) Version/5.0.2 Safari/533.18.5"	// ok, no dnd
		// "Mozilla/5.0 (Windows; U; Windows NT 6.1; en-EN) AppleWebKit/533.21.1 (KHTML, like Gecko) Version/5.0.3 Safari/533.19.4"	// ok, no dnd
		// "Mozilla/5.0 (Windows; U; Windows NT 6.1; en-EN) AppleWebKit/533.21.1 (KHTML, like Gecko) Version/5.0.4 Safari/533.20.27"	// ok, no dnd
		// "Mozilla/5.0 (Windows; U; Windows NT 6.1; en-EN) AppleWebKit/533.21.1 (KHTML, like Gecko) Version/5.0.5 Safari/533.21.1"	// ok, no dnd
		// "Mozilla/5.0 (Windows NT 6.1) AppleWebKit/534.50 (KHTML, like Gecko) Version/5.1 Safari/534.50"				// ok, dnd partialy fail, disabled
		// "Mozilla/5.0 (Windows NT 6.1) AppleWebKit/534.52.7 (KHTML, like Gecko) Version/5.1.1 Safari/534.51.22"			// multiple files add - fail, dnd partialy fail, disabled
		// "Mozilla/5.0 (Windows NT 6.1) AppleWebKit/534.52.7 (KHTML, like Gecko) Version/5.1.2 Safari/534.52.7"			// ok, dnd partialy fail, disabled
		// "Mozilla/5.0 (Windows NT 6.1) AppleWebKit/534.54.16 (KHTML, like Gecko) Version/5.1.4 Safari/534.54.16"			// ok
		// "Mozilla/5.0 (Windows NT 6.1) AppleWebKit/534.55.3 (KHTML, like Gecko) Version/5.1.5 Safari/534.55.3"			// multiple files add - fail
		// "Mozilla/5.0 (Windows NT 6.1) AppleWebKit/534.57.2 (KHTML, like Gecko) Version/5.1.7 Safari/534.57.2"			// dnd - ok, multiselect - fail (Windows 8)
		
		// input
		this._addFileInput();
		
		// FF, Opera, Chrome, IE10, IE11
		if (this.conf.dnd_enabled && this._initDND != null) this._initDND();
		
	},
	
	_addFileInput: function() {
		
		// complete input reload, opera needs
		if (this.f != null) {
			this.f.onchange = null;
			this.f.parentNode.removeChild(this.f);
			this.f = null;
		}
		
		var that = this;
		
		this.f = document.createElement("INPUT");
		this.f.type = "file";
		
		if (this.conf.multiple_files) this.f.multiple = "1";
		this.f.className = "dhx_vault_input";
		this.p_controls.appendChild(this.f);
		
		this.f.onchange = function() {
			that._parseFilesInInput(this.files);
			if (window.dhx4.isOpera) that._addFileInput(); else this.value = "";
		}
	},
	
	_doUploadFile: function(id) {
		
		if (this.file_data[id].custom == true) {
			this._cfUploadStart(id);
			return;
		}
		
		var that = this;
		
		if (!this.loader) {
			
			this.loader = new XMLHttpRequest();
			this.loader.upload.onprogress = function(e) {
				if (that.file_data[this._idd].state == "uploading") that._updateFileInList(this._idd, "uploading", Math.round(e.loaded*100/e.total));
			}
			this.loader.onload = function(e) {
				try {eval("dhx4.temp="+this.responseText);} catch(e){};
				var r = dhx4.temp;
				dhx4.temp = null;
				
				if (r != null && typeof(r) == "object" && typeof(r.state) != "undefined" && r.state == true) {
					that._onUploadSuccess(this.upload._idd, r.name, null, r.extra);
				} else {
					that._onUploadFail(this.upload._idd, (r!=null&&r.extra!=null?r.extra:null));
				}
				r = null;
			}
			this.loader.onerror = function(e) {
				that._onUploadFail(this.upload._idd);
			}
			this.loader.onabort = function(e) {
				that._onUploadAbort(this.upload._idd);
			}
		}
		
		this.loader.upload._idd = id;


		this.loader.open("POST", this.conf.url + (this.conf.url.indexOf("?")<0 ? "?" : "&") + "name=" + this.file_data[id].name,
			true, $p.ajax.username, $p.ajax.password);
		this.loader.withCredentials = true;
		this.loader.setRequestHeader("Authorization", "Basic " +
			btoa(unescape(encodeURIComponent($p.ajax.username + ":" + $p.ajax.password))));
		this.loader.setRequestHeader("X-Requested-With", "XMLHttpRequest");
		this.loader.send(this.file_data[id].file);
		
	},
	
	_uploadStop: function() {
		if (!this.conf.uploading) return;
		if (this.cf_loader_id != null) {
			this._cfUploadStop();
		} else if (this.loader != null) {
			this.loader.abort();
		}
	},
	
	_parseFilesInInput: function(f) {
		for (var q=0; q<f.length; q++) this._addFileToQueue(f[q]);
	},
	
	_addFileToQueue: function(f) {
		if (!this._beforeAddFileToList(f.name, f.size, f.lastModifiedDate)) return; // html5 mode, f.lastModifiedDate works in Chrome/Opera/Safari/FF/IE11
		var id = (f._idd||window.dhx4.newId());
		this.file_data[id] = {file: f, name: f.name, size: f.size, state: "added"};
		this._addFileToList(id, f.name, f.size, "added", 0);
		if (this.conf.auto_start && !this.conf.uploading) this._uploadStart(true);
	},
	
	_removeFileFromQueue: function(id) {
		
		if (!this.file_data[id]) return;
		
		var name = this.file_data[id].name;
		var serverName = (this.conf.uploaded_files!=null&&this.conf.uploaded_files[id]!=null?this.conf.uploaded_files[id].serverName:null);
		
		var fileData = {
			id: id,
			name: name,
			size: this.file_data[id].size,
			serverName: serverName,
			uploaded: (this.file_data[id].state == "uploaded"),
			error: (this.file_data[id].state == "fail")
		};
		if (this.callEvent("onBeforeFileRemove",[fileData]) !== true) return;
		
		var k = false;
		if (this.cf_loader_id != null || (this.conf.uploading && this.loader != null && id == this.loader.upload._idd && this.file_data[id].state == "uploading")) {
			this._uploadStop();
			k = true;
		}
		
		this.file_data[id].file = null;
		this.file_data[id].name = null;
		this.file_data[id].size = null;
		this.file_data[id].state = null;
		this.file_data[id] = null;
		delete this.file_data[id];
		
		this._removeFileFromList(id);
		
		this.callEvent("onFileRemove",[fileData]);
		
		if (k) this._uploadStart();

	},
	
	_unloadEngine: function() {
		
		this.buttons["browse"].onclick = null;
		
		if (this.conf.dnd_enabled && this._unloadDND != null) this._unloadDND();
		
		this.f.onchange = null;
		this.f.parentNode.removeChild(this.f);
		this.f = null;
		
		if (this.loader) {
			this.loader.upload.onprogress = null;
			this.loader.onload = null;
			this.loader.onerror = null;
			this.loader.onabort = null;
			this.loader.upload._idd = null;
			this.loader = null;
		}
		
		this._initEngine = null;
		this._doUploadFile = null;
		this._uploadStop = null;
		this._parseFilesInInput = null;
		this._addFileToQueue = null;
		this._removeFileFromQueue = null;
		this._unloadEngine = null;
		
	}
	
};



/****************************************************************************************************************************************************************************************************************/
// DEFAULT FILES VIEW

dhtmlXVaultObject.prototype.list_default = function() {
	
	this.t = {};
	
	this.addFileItem = function(id, fileList) {
		
		var item = document.createElement("DIV");
		item._idd = id;
		fileList.appendChild(item);
		
		this.t[id] = item;
		
		item = fileList = null;
	}
	
	this.isFileItemExist = function(id) {
		return (this.t[id] != null);
	}
	
	this.renderFileRecord = function(id, data) {
		
		var item = this.t[id];
		if (!item == null) return;
		
		item.className = "dhx_vault_file dhx_vault_file_"+data.state;
		item.innerHTML = "<div class='dhx_vault_file_param dhx_vault_file_name'>&nbsp;</div>"+
				"<div class='dhx_vault_file_param dhx_vault_file_progress'>&nbsp;</div>"+
				"<div class='dhx_vault_file_param dhx_vault_file_delete'>&nbsp;</div>"+
				"<div class='dhx_vault_file_icon dhx_vault_"+data.icon+"'><div class='dhx_vault_all_icons'></div></div>";
		
		item.childNodes[2]._action = {id: id, data: "delete_file"};

		item._action = {id: id, data: "show_file"};
		
		this.updateFileNameSize(id, data);
		
		item = null;
	}
	
	this.removeFileRecord = function(id) {
		
		var item = this.t[id];
		if (item == null) return;
		
		item._idd = null;
		item.childNodes[2]._action = null;
		item.parentNode.removeChild(item);
		item = null;
		
		this.t[id] = null;
		delete this.t[id];
		
	}
	
	this.updateFileNameSize = function(id, data) {
		
		var item = this.t[id];
		if (item == null) return;
		
		item.childNodes[0].innerHTML = "<div class='dhx_vault_file_name_text'>"+data.name+(!isNaN(data.size) && data.size !== false ? " ("+data.readableSize+")":"&nbsp;")+"</div>";
		item.childNodes[0].title = data.name+(!isNaN(data.size) && data.size !== false ? " ("+data.readableSize+")" : "");
		
		item = null;
		
	}
	
	this.updateFileState = function(id, data) {
		
		var item = this.t[id];
		if (item == null) return;
		
		var k = false;
		if (this.updateFileStateExtra != null) k = this.updateFileStateExtra(id, data);
		
		if (!k) {
			if (data.state == "added") {
				
				item.className = "dhx_vault_file dhx_vault_file_added";
				item.childNodes[1].className = "dhx_vault_file_param dhx_vault_file_progress";
				item.childNodes[1].innerHTML = "&nbsp;";
			}
			
			if (data.state == "fail") {
				item.className = "dhx_vault_file dhx_vault_file_fail";
				item.childNodes[1].className = "dhx_vault_file_param dhx_vault_file_progress";
				item.childNodes[1].innerHTML = data.str_error;
			}
			
			if (data.state == "uploaded") {
				item.className = "dhx_vault_file dhx_vault_file_uploaded";
				item.childNodes[1].className = "dhx_vault_file_param dhx_vault_file_progress";
				item.childNodes[1].innerHTML = data.str_done;
			}
			
			if (data.state == "uploading_html4" || data.state == "uploading") {
				// gif
				item.className = "dhx_vault_file dhx_vault_file_uploading";
				item.childNodes[1].className = "dhx_vault_file_param dhx_vault_file_uploading";
				item.childNodes[1].innerHTML = "<div class='dhx_vault_progress'><div class='dhx_vault_progress_loader'>&nbsp;</div></div>";
			}
			
		}
		
		item = null;
	}
	
	this.updateStrings = function() {
		
	}
	
	this.unload = function() {
		this.t = null;
	}

	
};

// attach to container
if (typeof(window.dhtmlXCellObject) != "undefined" && typeof(dhtmlXCellObject.prototype.attachVault) == "undefined") {

	dhtmlXCellObject.prototype.attachVault = function(conf) {
		
		var obj = document.createElement("DIV");
		obj.style.position = "relative";
		obj.style.width = "100%";
		obj.style.height = "100%";
		obj.style.overflow = "hidden";
		this._attachObject(obj);
		
		obj._attach_mode = true;
		obj._no_border = true;
		
		// keep borders for windows
		if (typeof(window.dhtmlXWindowsCell) != "undefined" && this instanceof dhtmlXWindowsCell) {
			obj._no_border = false;
		}
		
		if (typeof(conf) != "object" || conf == null) conf = {};
		conf.parent = obj;
		if (typeof(conf.skin) == "undefined") conf.skin = this.conf.skin;
		
		this.dataType = "vault";
		this.dataObj = new dhtmlXVaultObject(conf);
		
		// sometimes layout broke vault's dimension
		if (typeof(window.dhtmlXLayoutCell) != "undefined" && this instanceof dhtmlXLayoutCell) {
			this.layout._getMainInst().attachEvent("onExpand", function(ids){
				for (var q=0; q<ids.length; q++) {
					var cell = this.cells(ids[q]);
					if (cell.dataType == "vault" && cell.dataObj != null) cell.dataObj.setSizes();
					cell = null;
				}
			});
		}
		
		conf.parent = null;
		conf = obj = null;
		
		return this.dataObj;
	};
	
};

// bootstrap skin buttons
dhtmlXVaultObject.prototype.buttonCss = {
	bootstrap: {
		browse: "_browse",
		upload: "_upload",
		cancel: "_cancel",
		clear: "_clear"
	}
};

// attach to popup
if (typeof(window.dhtmlXPopup) != "undefined" && typeof(dhtmlXPopup.prototype.attachVault) == "undefined") {
	dhtmlXPopup.prototype.attachVault = function(width, height, conf) {
		return this._attachNode("vault", {width: width||350, height: height||200, conf:conf||{}});
	};
	dhtmlXPopup.prototype._attach_init_vault = function(data) {
		data.conf.parent = this._nodeId;
		document.getElementById(this._nodeId)._no_border = true;
		if (typeof(data.conf.skin) == "undefined") data.conf.skin = this.conf.skin;
		this._nodeObj = new dhtmlXVaultObject(data.conf);
	};
};



